# 软件设计重构

## 第一章：技术债务
### 1.1 技术财务 --> 技术破产
### 1.2 技术债务组成
- 代码债务
- 设计债务
- 测试债务
- 文档债务

### 1.3 债务影响 Coc (Cost of Change)
- 影响团队士气和积极性  
  例子: 美国骑士资本，因为技术债务导致资产债务极速恶化

### 1.4 引发债务原因
- 时间紧
- 缺乏优秀人才
- 未遵守设计原理 [设计原理链接](https://blog.csdn.net/u010388497/article/details/51809152?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-51809152-blog-123449955.235%5Ev43%5Epc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-2-51809152-blog-123449955.235%5Ev43%5Epc_blog_bottom_relevance_base7&utm_relevant_index=5)
- 不懂设计坏味与重构

### 1.5 管理技术债务
- 增强技术债务意识
- 发现并偿还技术债务
- 防范技术债务积累

## 第二章：设计坏味
> 谚语：从错误中学到的东西要比成功中学到的东西多

### 2.1 坏味的特征
- 可理解性越来越低
- 可修改性和可重用性越来越低
- 可重用性越来越低
- 可靠性和可测试性越来越糟

### 六大质量指标
- 可理解性
- 可修改性
- 可拓展性
- 可重用性
- 可测试性
- 可靠性

### 2.2 导致设计坏味的原因
- 违反设计原则
- 不恰当地使用模式（没有认识到必须平衡的作用力，反设计模式）
- 语言的局限性
- 面向对象的过程思维
- 粘滞性
- 未遵守最佳实践和过程

### 2.5 基于设计原理的坏味分类
- 抽象
- 封装
- 模块化
- 层次结构

## 第三章 抽象型坏味
> 抽象的最大原则：以简单而有效的方式进行交流和解决问题

### 应用抽象原则的实现手法
1. 提供清晰的概念边界和唯一身份
2. 映射域实体：需要建立问题域到解决方案域的词汇映射，即问题域对象需要在解决方案之中使用相应对象的抽象表示它们。
3. 确保内聚性和完整性：抽象必须对其承担的责任提供全面支持，如果只提供方法的一部分，抽象即不内聚也不完整。
4. 赋予单一而重要的职责：确保抽象类的唯一性，如表示图像类中不应该包含提供图像表示格式转化的方法。
5. 避免重复：确保对象在设计中只出现一次。

### 抽象坏味的七大类型
1. **缺失抽象**（基本类型的偏执，数据泥团）
   ##### 使用一系列数据或编码字符串，而不是创建类和接口
   - 理据：创建概念边界清晰，身份唯一实体
   - 原因：未充分分析，未重构，错误地将重点放在细微的性能改善上
   - 重构建议：扩展超类
   - 影响代码质量指标：不可理解性、可修改性、可扩展性、可靠性
   - 现实考虑：避免过度设计、使用构造函数初始化默认值、验证数据值、以漂亮的格式打印数据值、释放已获取的资源

2. **命令式抽象**（操作类）
   ##### 该类只封装了行为没有数据 --> 违反抽象原则
   - 理据：面向对象基本原则识别真实世界中的事物，使用抽象表示它们
   - 原因：以过程型思维进行面向对象编程
   - 重构建议：消除该类坏味，将方法移到映射域的抽象中，封装所需数据，提高内聚性
   - 影响代码质量指标：可理解性、可修改性、可扩展性、可重用性、可测试性

3. **不完整抽象**（类支持行为的不完整，中途半端的操作）
   ##### 抽象未支持互补和相关方法
   - 理据：抽象的实现手法创建内聚而完整的对象
   - 原因：缺乏大局观，未遵守语言和库约定
   - 重构建议：补足互补方法
   - 影响代码质量指标：可理解性、可修改性、可扩展性、可重用性、可靠性

4. **多方面抽象**（发散性变化，概念化滥用，过大的类）
   ##### 抽象被赋予不止一种职责
   - 理据：类的单一且明确职责
   - 原因：通用抽象、演讲过程中未定期重构、麻烦的流程、混合关注点
   - 重构建议：提取类以重构该逻辑族
   - 影响代码质量指标：可理解性、可修改性、可扩展性、可重用性、可靠性、可测试性

5. **不需要抽象**（不相干的类，冗余类）
   ##### 引入实际上不需要的抽象
   - 理据：类的单一且明确职责
   - 原因：使用面向对象语言，思维却是过程型编程思维、贪图方便使用不合适的语言功能、过度设计
   - 重构建议：将类内联化，合并到其他类；如果只是为了存储常量，考虑转化为枚举
   - 影响代码质量指标：可理解性、可重用性

6. **未用的抽象**
   ##### 没用的具体类

7. **重复抽象**

## 第四章 封装坏味
> 例子：开汽车是否需要理解发动机原理，或者防抱死系统 ABS。封装原则倡导隐藏抽象的实现细节，关注点分离和信息隐藏。

### 1. 不充分封装
- 对于抽象的一个或多个成员，声明的访问权限比实际需要的大。
