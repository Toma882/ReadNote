{
    "sourceFile": "Assets/UnityEditor/README_Attributes.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1746867746423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1746868873518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,35 @@\n [SerializeField] // 这是一个特性，使私有字段在Inspector中可见\r\n private int myPrivateVariable;\r\n ```\r\n \r\n+### AttributeUsage\r\n+\r\n+`AttributeUsage` 是 C# 中用于控制特性如何使用的元特性。它可以规定特性可以应用的目标类型、是否允许多次使用以及是否从父类继承。\r\n+\r\n+```csharp\r\n+[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]\r\n+public class MyCustomAttribute : PropertyAttribute\r\n+{\r\n+    // 特性实现\r\n+}\r\n+```\r\n+\r\n+### AttributeTargets\r\n+\r\n+`AttributeTargets` 是一个枚举类型，定义了特性可以应用的目标类型。常见的目标类型包括：\r\n+\r\n+- `AttributeTargets.Class` - 应用于类\r\n+- `AttributeTargets.Field` - 应用于字段\r\n+- `AttributeTargets.Method` - 应用于方法\r\n+- `AttributeTargets.Property` - 应用于属性\r\n+- `AttributeTargets.All` - 应用于所有可能的元素\r\n+\r\n+可以使用按位或运算符 `|` 组合多个目标，例如：\r\n+```csharp\r\n+[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]\r\n+```\r\n+\r\n ## UML类图\r\n \r\n ```\r\n +---------------------------+\r\n@@ -77,8 +104,16 @@\n │   ├── 编辑器初始化\r\n │   │   ├── InitializeOnLoad - 编辑器加载时执行\r\n │   │   ├── InitializeOnLoadMethod - 编辑器加载时执行方法\r\n │   │   └── DidReloadScripts - 脚本重新加载时执行\r\n+│   ├── 设置相关\r\n+│   │   ├── SettingsProvider - 创建设置提供者\r\n+│   │   ├── UserSetting - 用户设置\r\n+│   │   └── SettingsProviderGroup - 设置提供者组\r\n+│   ├── Gizmo相关\r\n+│   │   ├── GizmoDrawer - Gizmo绘制器\r\n+│   │   ├── DrawGizmo - 绘制Gizmo\r\n+│   │   └── GizmoIcon - Gizmo图标\r\n │   └── 自定义编辑器\r\n │       ├── CustomEditor - 自定义检视器\r\n │       ├── CanEditMultipleObjects - 可编辑多对象\r\n │       └── CustomPropertyDrawer - 自定义属性绘制器\r\n@@ -126,8 +161,10 @@\n | **TextAreaAttribute** | 字符串字段 | 显示多行文本区域 | `[TextArea(3, 10)]` |\r\n | **ColorUsageAttribute** | Color字段 | 自定义颜色选择器 | `[ColorUsage(true, true)]` |\r\n | **MultilineAttribute** | 字符串字段 | 显示多行输入框 | `[Multiline(3)]` |\r\n | **DelayedAttribute** | 值类型字段 | 延迟更新值 | `[Delayed]` |\r\n+| **InspectorNameAttribute** | 枚举值/字段 | 自定义Inspector显示名称 | `[InspectorName(\"Friendly Name\")]` |\r\n+| **GradientUsageAttribute** | Gradient字段 | 自定义渐变编辑器 | `[GradientUsage(true)]` |\r\n \r\n ### 序列化特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n@@ -135,8 +172,10 @@\n | **SerializeField** | 私有字段 | 使私有字段可在Inspector中显示 | `[SerializeField]` |\r\n | **NonSerialized** | 公有字段 | 阻止字段序列化 | `[System.NonSerialized]` |\r\n | **SerializeReference** | 引用类型 | 序列化对象引用而非对象本身 | `[SerializeReference]` |\r\n | **Serializable** | 类 | 标记类为可序列化 | `[System.Serializable]` |\r\n+| **FormerlySerializedAs** | 字段 | 重命名字段时保持序列化兼容性 | `[FormerlySerializedAs(\"oldName\")]` |\r\n+| **PreferBinarySerialization** | ScriptableObject | 使用二进制序列化而非YAML | `[PreferBinarySerialization]` |\r\n \r\n ### 菜单特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n@@ -156,8 +195,10 @@\n | **ExecuteAlways** | 类 | 在编辑和运行模式下执行 | `[ExecuteAlways]` |\r\n | **AddComponentMenu** | 类 | 添加到组件菜单 | `[AddComponentMenu(\"Custom/MyComponent\")]` |\r\n | **HideInInspector** | 字段 | 在Inspector中隐藏字段 | `[HideInInspector]` |\r\n | **SelectionBase** | 类 | 设为场景选择基础 | `[SelectionBase]` |\r\n+| **DefaultExecutionOrder** | 类 | 设置脚本执行顺序 | `[DefaultExecutionOrder(-100)]` |\r\n+| **Icon** | 类 | 为组件设置图标 | `[Icon(\"Assets/Icons/MyIcon.png\")]` |\r\n \r\n ### 编辑器定制特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n@@ -168,8 +209,24 @@\n | **InitializeOnLoad** | 类 | 编辑器加载时初始化 | `[InitializeOnLoad]` |\r\n | **InitializeOnLoadMethod** | 静态方法 | 编辑器加载时执行方法 | `[InitializeOnLoadMethod]` |\r\n | **OnOpenAsset** | 静态方法 | 资源打开时执行 | `[OnOpenAsset]` |\r\n \r\n+### Gizmo相关特性\r\n+\r\n+| 特性名称 | 应用目标 | 描述 | 示例 |\r\n+|---------|---------|------|------|\r\n+| **DrawGizmo** | 静态方法 | 绘制场景视图中的Gizmo | `[DrawGizmo(GizmoType.Selected)]` |\r\n+| **GizmoDrawer** | 类 | 定义Gizmo绘制器 | 自定义实现 |\r\n+| **GizmoIcon** | 类 | 为对象添加Gizmo图标 | 自定义实现 |\r\n+\r\n+### 设置相关特性\r\n+\r\n+| 特性名称 | 应用目标 | 描述 | 示例 |\r\n+|---------|---------|------|------|\r\n+| **SettingsProvider** | 类 | 创建设置提供者 | `[SettingsProvider]` |\r\n+| **UserSetting** | 字段 | 标记为用户设置 | `[UserSetting]` |\r\n+| **SettingsProviderGroup** | 类 | 创建设置提供者组 | `[SettingsProviderGroup]` |\r\n+\r\n ## 使用案例\r\n \r\n ### 案例1: 自定义组件检视器\r\n \r\n@@ -335,8 +392,159 @@\n     }\r\n }\r\n ```\r\n \r\n+### 案例4: Gizmo绘制与自定义图标\r\n+\r\n+```csharp\r\n+// 使用DrawGizmo特性的Gizmo绘制\r\n+public class GizmoExample : MonoBehaviour\r\n+{\r\n+    public float radius = 1.0f;\r\n+    public Color gizmoColor = Color.yellow;\r\n+}\r\n+\r\n+// Gizmo绘制器 - 与MonoBehaviour分离\r\n+public class GizmoExampleDrawer\r\n+{\r\n+    [DrawGizmo(GizmoType.Selected | GizmoType.Active)]\r\n+    static void DrawGizmo(GizmoExample example, GizmoType gizmoType)\r\n+    {\r\n+        Gizmos.color = example.gizmoColor;\r\n+        Gizmos.DrawWireSphere(example.transform.position, example.radius);\r\n+        \r\n+        // 只为选中对象绘制额外指示器\r\n+        if (gizmoType == GizmoType.Selected)\r\n+        {\r\n+            Gizmos.color = new Color(example.gizmoColor.r, example.gizmoColor.g, example.gizmoColor.b, 0.3f);\r\n+            Gizmos.DrawSphere(example.transform.position, example.radius);\r\n+        }\r\n+    }\r\n+}\r\n+```\r\n+\r\n+### 案例5: 设置提供者\r\n+\r\n+```csharp\r\n+// 使用SettingsProvider特性创建设置面板\r\n+public class MyCustomSettings\r\n+{\r\n+    private const string SettingsPath = \"Project/MyCustomSettings\";\r\n+    \r\n+    private static SerializedObject settingsObject;\r\n+    private static SerializedProperty exampleProperty;\r\n+    \r\n+    // 创建设置提供者\r\n+    [SettingsProvider]\r\n+    public static SettingsProvider CreateSettingsProvider()\r\n+    {\r\n+        var provider = new SettingsProvider(SettingsPath, SettingsScope.Project)\r\n+        {\r\n+            label = \"My Custom Settings\",\r\n+            guiHandler = (searchContext) =>\r\n+            {\r\n+                // 确保设置对象已初始化\r\n+                if (settingsObject == null)\r\n+                {\r\n+                    var settings = MyCustomSettingsAsset.GetOrCreateSettings();\r\n+                    settingsObject = new SerializedObject(settings);\r\n+                    exampleProperty = settingsObject.FindProperty(\"exampleValue\");\r\n+                }\r\n+                \r\n+                // 开始绘制设置界面\r\n+                EditorGUILayout.PropertyField(exampleProperty, new GUIContent(\"Example Value\"));\r\n+                \r\n+                // 应用修改\r\n+                if (settingsObject.hasModifiedProperties)\r\n+                {\r\n+                    settingsObject.ApplyModifiedProperties();\r\n+                }\r\n+            },\r\n+            keywords = new HashSet<string>(new[] { \"Custom\", \"Example\", \"Settings\" })\r\n+        };\r\n+        \r\n+        return provider;\r\n+    }\r\n+}\r\n+\r\n+// 设置资源类\r\n+[CreateAssetMenu(fileName = \"MyCustomSettings\", menuName = \"Settings/My Custom Settings\")]\r\n+public class MyCustomSettingsAsset : ScriptableObject\r\n+{\r\n+    public float exampleValue = 1.0f;\r\n+    \r\n+    private static MyCustomSettingsAsset instance;\r\n+    \r\n+    public static MyCustomSettingsAsset GetOrCreateSettings()\r\n+    {\r\n+        if (instance != null)\r\n+            return instance;\r\n+            \r\n+        const string settingsPath = \"Assets/Settings/MyCustomSettings.asset\";\r\n+        \r\n+        instance = AssetDatabase.LoadAssetAtPath<MyCustomSettingsAsset>(settingsPath);\r\n+        if (instance != null)\r\n+            return instance;\r\n+            \r\n+        // 创建新设置资源\r\n+        instance = CreateInstance<MyCustomSettingsAsset>();\r\n+        \r\n+        // 确保目录存在\r\n+        if (!AssetDatabase.IsValidFolder(\"Assets/Settings\"))\r\n+            AssetDatabase.CreateFolder(\"Assets\", \"Settings\");\r\n+            \r\n+        AssetDatabase.CreateAsset(instance, settingsPath);\r\n+        AssetDatabase.SaveAssets();\r\n+        \r\n+        return instance;\r\n+    }\r\n+}\r\n+```\r\n+\r\n+## 自定义特性的创建与使用\r\n+\r\n+### 创建自定义特性\r\n+\r\n+要创建自定义特性，需要继承 `PropertyAttribute` 类，并可选择实现相应的 `PropertyDrawer`：\r\n+\r\n+```csharp\r\n+// 定义特性\r\n+[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]\r\n+public class ReadOnlyAttribute : PropertyAttribute\r\n+{\r\n+    // 无需额外实现\r\n+}\r\n+\r\n+// 实现属性绘制器\r\n+[CustomPropertyDrawer(typeof(ReadOnlyAttribute))]\r\n+public class ReadOnlyDrawer : PropertyDrawer\r\n+{\r\n+    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\r\n+    {\r\n+        // 禁用GUI\r\n+        GUI.enabled = false;\r\n+        \r\n+        // 绘制标准字段\r\n+        EditorGUI.PropertyField(position, property, label, true);\r\n+        \r\n+        // 恢复GUI状态\r\n+        GUI.enabled = true;\r\n+    }\r\n+}\r\n+```\r\n+\r\n+### 使用自定义特性\r\n+\r\n+```csharp\r\n+public class ExampleBehaviour : MonoBehaviour\r\n+{\r\n+    [ReadOnly]\r\n+    public string readOnlyText = \"This field cannot be edited\";\r\n+    \r\n+    public string editableText = \"This field can be edited\";\r\n+}\r\n+```\r\n+\r\n ## 特性使用最佳实践\r\n \r\n 1. **组合使用特性**：多个特性可以组合使用，如`[SerializeField]`和`[Range(0,100)]`\r\n \r\n@@ -347,7 +555,15 @@\n 4. **性能考虑**：`ExecuteInEditMode`和`InitializeOnLoad`特性可能影响编辑器性能，应谨慎使用\r\n \r\n 5. **特性继承**：特性不会被继承，需要为每个类单独添加特性\r\n \r\n+6. **特性与类型安全**：在创建自定义特性时，考虑添加类型检查，确保特性只应用于兼容的字段类型\r\n+\r\n+7. **避免特性滥用**：过多使用特性可能导致代码可读性下降，应合理使用\r\n\\ No newline at end of file\n+\r\n+8. **文档化特性行为**：为自定义特性提供清晰的文档，说明其行为和使用方法\r\n+\r\n ## 总结\r\n \r\n-Unity特性系统是扩展编辑器和定制组件行为的强大工具。通过合理使用特性，可以显著提升开发效率、改善编辑器体验并实现复杂的定制功能。特性的组合使用尤其重要，能够创建直观、便于使用的组件检视器和编辑工具。 \n+Unity特性系统是扩展编辑器和定制组件行为的强大工具。通过合理使用特性，可以显著提升开发效率、改善编辑器体验并实现复杂的定制功能。特性的组合使用尤其重要，能够创建直观、便于使用的组件检视器和编辑工具。\r\n+\r\n+无论是使用Unity提供的内置特性，还是创建自定义特性，掌握特性系统都能使你的Unity开发流程更加高效和灵活。通过理解每个特性的用途和应用场景，你可以根据项目需求选择最合适的特性组合，创建出既直观又强大的工具和组件。 \n\\ No newline at end of file\n"
                },
                {
                    "date": 1748161014188,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -151,21 +151,160 @@\n ## 常用特性一览表\r\n \r\n ### 编辑器界面特性\r\n \r\n-| 特性名称 | 应用目标 | 描述 | 示例 |\r\n-|---------|---------|------|------|\r\n-| **HeaderAttribute** | 字段 | 在Inspector中添加标题 | `[Header(\"Player Settings\")]` |\r\n-| **TooltipAttribute** | 字段 | 添加鼠标悬停提示 | `[Tooltip(\"Player's movement speed\")]` |\r\n-| **RangeAttribute** | 数值字段 | 限制数值范围并显示滑动条 | `[Range(0, 100)]` |\r\n-| **SpaceAttribute** | 字段 | 在Inspector中添加空间 | `[Space(10)]` |\r\n-| **TextAreaAttribute** | 字符串字段 | 显示多行文本区域 | `[TextArea(3, 10)]` |\r\n-| **ColorUsageAttribute** | Color字段 | 自定义颜色选择器 | `[ColorUsage(true, true)]` |\r\n-| **MultilineAttribute** | 字符串字段 | 显示多行输入框 | `[Multiline(3)]` |\r\n-| **DelayedAttribute** | 值类型字段 | 延迟更新值 | `[Delayed]` |\r\n-| **InspectorNameAttribute** | 枚举值/字段 | 自定义Inspector显示名称 | `[InspectorName(\"Friendly Name\")]` |\r\n-| **GradientUsageAttribute** | Gradient字段 | 自定义渐变编辑器 | `[GradientUsage(true)]` |\r\n+#### HeaderAttribute - 添加标题分组\r\n+**作用**：在Inspector中为字段组添加标题，用于组织和分类相关字段。\r\n \r\n+```csharp\r\n+public class PlayerController : MonoBehaviour\r\n+{\r\n+    [Header(\"移动设置\")]\r\n+    public float moveSpeed = 5f;\r\n+    public float jumpHeight = 2f;\r\n+    \r\n+    [Header(\"战斗设置\")]\r\n+    public int health = 100;\r\n+    public float attackDamage = 25f;\r\n+}\r\n+```\r\n+\r\n+#### TooltipAttribute - 添加悬停提示\r\n+**作用**：为字段添加鼠标悬停时显示的提示信息，帮助理解字段用途。\r\n+\r\n+```csharp\r\n+public class WeaponSystem : MonoBehaviour\r\n+{\r\n+    [Tooltip(\"每秒发射的子弹数量\")]\r\n+    public float fireRate = 10f;\r\n+    \r\n+    [Tooltip(\"子弹飞行速度，单位：米/秒\")]\r\n+    public float bulletSpeed = 50f;\r\n+}\r\n+```\r\n+\r\n+#### RangeAttribute - 范围滑动条\r\n+**作用**：限制数值字段的取值范围，并在Inspector中显示为滑动条。\r\n+\r\n+```csharp\r\n+public class AudioManager : MonoBehaviour\r\n+{\r\n+    [Range(0f, 1f)]\r\n+    [Tooltip(\"主音量\")]\r\n+    public float masterVolume = 0.8f;\r\n+    \r\n+    [Range(1, 100)]\r\n+    [Tooltip(\"同时播放的最大音效数\")]\r\n+    public int maxSounds = 32;\r\n+}\r\n+```\r\n+\r\n+#### SpaceAttribute - 添加间距\r\n+**作用**：在Inspector中的字段之间添加空白间距，改善视觉布局。\r\n+\r\n+```csharp\r\n+public class GameSettings : MonoBehaviour\r\n+{\r\n+    public string playerName = \"Player\";\r\n+    public int level = 1;\r\n+    \r\n+    [Space(20)]  // 添加20像素间距\r\n+    public bool enableDebug = false;\r\n+    public bool showFPS = true;\r\n+}\r\n+```\r\n+\r\n+#### TextAreaAttribute - 多行文本区域\r\n+**作用**：将字符串字段显示为可调整大小的多行文本区域。\r\n+\r\n+```csharp\r\n+public class DialogueSystem : MonoBehaviour\r\n+{\r\n+    [TextArea(3, 10)]  // 最小3行，最大10行\r\n+    [Tooltip(\"角色对话内容\")]\r\n+    public string dialogueText = \"在这里输入对话内容...\";\r\n+    \r\n+    [TextArea(2, 5)]\r\n+    public string characterDescription;\r\n+}\r\n+```\r\n+\r\n+#### ColorUsageAttribute - 颜色选择器定制\r\n+**作用**：自定义颜色选择器的行为，支持HDR颜色和透明度。\r\n+\r\n+```csharp\r\n+public class LightingController : MonoBehaviour\r\n+{\r\n+    [ColorUsage(false)]  // 禁用透明度\r\n+    public Color ambientColor = Color.white;\r\n+    \r\n+    [ColorUsage(true, true)]  // 启用透明度和HDR\r\n+    public Color emissionColor = Color.red;\r\n+}\r\n+```\r\n+\r\n+#### MultilineAttribute - 多行输入框\r\n+**作用**：将字符串字段显示为固定行数的多行输入框。\r\n+\r\n+```csharp\r\n+public class QuestSystem : MonoBehaviour\r\n+{\r\n+    [Multiline(4)]  // 显示4行输入框\r\n+    public string questDescription = \"任务描述...\";\r\n+    \r\n+    [Multiline(2)]\r\n+    public string questHint = \"提示信息...\";\r\n+}\r\n+```\r\n+\r\n+#### DelayedAttribute - 延迟更新\r\n+**作用**：延迟字段值的更新，直到用户按下Enter键或字段失去焦点。\r\n+\r\n+```csharp\r\n+public class NetworkSettings : MonoBehaviour\r\n+{\r\n+    [Delayed]\r\n+    [Tooltip(\"服务器IP地址\")]\r\n+    public string serverIP = \"127.0.0.1\";\r\n+    \r\n+    [Delayed]\r\n+    public int serverPort = 7777;\r\n+}\r\n+```\r\n+\r\n+#### InspectorNameAttribute - 自定义显示名称\r\n+**作用**：为枚举值或字段在Inspector中显示自定义名称。\r\n+\r\n+```csharp\r\n+public enum WeaponType\r\n+{\r\n+    [InspectorName(\"手枪\")]\r\n+    Pistol,\r\n+    [InspectorName(\"步枪\")]\r\n+    Rifle,\r\n+    [InspectorName(\"霰弹枪\")]\r\n+    Shotgun\r\n+}\r\n+\r\n+public class Weapon : MonoBehaviour\r\n+{\r\n+    public WeaponType weaponType = WeaponType.Pistol;\r\n+}\r\n+```\r\n+\r\n+#### GradientUsageAttribute - 渐变编辑器定制\r\n+**作用**：自定义渐变编辑器的行为，控制是否支持HDR颜色。\r\n+\r\n+```csharp\r\n+public class ParticleController : MonoBehaviour\r\n+{\r\n+    [GradientUsage(false)]  // 标准渐变\r\n+    public Gradient colorOverLifetime;\r\n+    \r\n+    [GradientUsage(true)]   // HDR渐变\r\n+    public Gradient emissionGradient;\r\n+}\r\n+\r\n ### 序列化特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n |---------|---------|------|------|\r\n"
                },
                {
                    "date": 1748161037403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -305,17 +305,128 @@\n }\r\n \r\n ### 序列化特性\r\n \r\n-| 特性名称 | 应用目标 | 描述 | 示例 |\r\n-|---------|---------|------|------|\r\n-| **SerializeField** | 私有字段 | 使私有字段可在Inspector中显示 | `[SerializeField]` |\r\n-| **NonSerialized** | 公有字段 | 阻止字段序列化 | `[System.NonSerialized]` |\r\n-| **SerializeReference** | 引用类型 | 序列化对象引用而非对象本身 | `[SerializeReference]` |\r\n-| **Serializable** | 类 | 标记类为可序列化 | `[System.Serializable]` |\r\n-| **FormerlySerializedAs** | 字段 | 重命名字段时保持序列化兼容性 | `[FormerlySerializedAs(\"oldName\")]` |\r\n-| **PreferBinarySerialization** | ScriptableObject | 使用二进制序列化而非YAML | `[PreferBinarySerialization]` |\r\n+#### SerializeField - 序列化私有字段\r\n+**作用**：使私有字段在Inspector中可见和可编辑，同时保持字段的封装性。\r\n \r\n+```csharp\r\n+public class PlayerData : MonoBehaviour\r\n+{\r\n+    [SerializeField]\r\n+    private int health = 100;  // 私有字段但在Inspector中可见\r\n+    \r\n+    [SerializeField]\r\n+    private string playerName = \"Player\";\r\n+    \r\n+    // 提供公共访问方法\r\n+    public int GetHealth() => health;\r\n+    public void SetHealth(int value) => health = Mathf.Clamp(value, 0, 100);\r\n+}\r\n+```\r\n+\r\n+#### NonSerialized - 阻止序列化\r\n+**作用**：阻止公有字段被序列化，常用于运行时计算的临时数据。\r\n+\r\n+```csharp\r\n+public class GameManager : MonoBehaviour\r\n+{\r\n+    public int score = 0;  // 会被序列化\r\n+    \r\n+    [System.NonSerialized]\r\n+    public float currentTime;  // 不会被序列化，每次运行重新计算\r\n+    \r\n+    [System.NonSerialized]\r\n+    public bool isGamePaused;  // 运行时状态，不需要保存\r\n+}\r\n+```\r\n+\r\n+#### SerializeReference - 引用序列化\r\n+**作用**：序列化接口或抽象类的具体实现，支持多态序列化。\r\n+\r\n+```csharp\r\n+public interface IWeapon\r\n+{\r\n+    void Attack();\r\n+}\r\n+\r\n+[System.Serializable]\r\n+public class Sword : IWeapon\r\n+{\r\n+    public float damage = 50f;\r\n+    public void Attack() => Debug.Log(\"挥剑攻击！\");\r\n+}\r\n+\r\n+[System.Serializable]\r\n+public class Bow : IWeapon\r\n+{\r\n+    public int arrowCount = 30;\r\n+    public void Attack() => Debug.Log(\"射箭攻击！\");\r\n+}\r\n+\r\n+public class Player : MonoBehaviour\r\n+{\r\n+    [SerializeReference]  // 支持多态序列化\r\n+    public IWeapon currentWeapon;\r\n+    \r\n+    [SerializeReference]\r\n+    public List<IWeapon> inventory = new List<IWeapon>();\r\n+}\r\n+```\r\n+\r\n+#### Serializable - 可序列化类\r\n+**作用**：标记类或结构体为可序列化，使其能够在Inspector中显示和保存。\r\n+\r\n+```csharp\r\n+[System.Serializable]\r\n+public class PlayerStats\r\n+{\r\n+    public int level = 1;\r\n+    public float experience = 0f;\r\n+    public int skillPoints = 0;\r\n+    \r\n+    public void LevelUp()\r\n+    {\r\n+        level++;\r\n+        skillPoints += 3;\r\n+        experience = 0f;\r\n+    }\r\n+}\r\n+\r\n+public class RPGCharacter : MonoBehaviour\r\n+{\r\n+    public PlayerStats stats = new PlayerStats();  // 在Inspector中显示为展开的字段组\r\n+}\r\n+```\r\n+\r\n+#### FormerlySerializedAs - 保持序列化兼容性\r\n+**作用**：重命名字段时保持与旧版本的序列化兼容性，避免数据丢失。\r\n+\r\n+```csharp\r\n+public class MovementController : MonoBehaviour\r\n+{\r\n+    [FormerlySerializedAs(\"speed\")]  // 原来叫speed\r\n+    public float movementSpeed = 5f;  // 现在改名为movementSpeed\r\n+    \r\n+    [FormerlySerializedAs(\"jumpPower\")]\r\n+    public float jumpForce = 10f;  // 从jumpPower改名为jumpForce\r\n+}\r\n+```\r\n+\r\n+#### PreferBinarySerialization - 二进制序列化\r\n+**作用**：使ScriptableObject使用二进制序列化而非YAML，提高大数据的序列化性能。\r\n+\r\n+```csharp\r\n+[CreateAssetMenu(fileName = \"LargeDataSet\", menuName = \"Data/Large Data Set\")]\r\n+[PreferBinarySerialization]  // 使用二进制序列化提高性能\r\n+public class LargeDataSet : ScriptableObject\r\n+{\r\n+    public float[] largeArray = new float[10000];  // 大量数据\r\n+    public Texture2D[] textures = new Texture2D[100];\r\n+    \r\n+    // 大量数据时二进制序列化更高效\r\n+}\r\n+\r\n ### 菜单特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n |---------|---------|------|------|\r\n"
                },
                {
                    "date": 1748161062510,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -427,15 +427,147 @@\n }\r\n \r\n ### 菜单特性\r\n \r\n-| 特性名称 | 应用目标 | 描述 | 示例 |\r\n-|---------|---------|------|------|\r\n-| **MenuItem** | 静态方法 | 创建菜单项 | `[MenuItem(\"Tools/Reset Transform\")]` |\r\n-| **ContextMenu** | 方法 | 为组件添加右键菜单项 | `[ContextMenu(\"Reset\")]` |\r\n-| **ContextMenuItem** | 字段 | 为字段添加右键菜单项 | `[ContextMenuItem(\"Reset\", \"ResetValue\")]` |\r\n-| **CreateAssetMenu** | 类 | 在\"Create\"菜单中添加选项 | `[CreateAssetMenu(fileName = \"New Data\", menuName = \"Game/Data\")]` |\r\n+#### MenuItem - 创建编辑器菜单项\r\n+**作用**：在Unity编辑器菜单栏中创建自定义菜单项，用于执行编辑器工具功能。\r\n \r\n+```csharp\r\n+public class EditorTools\r\n+{\r\n+    [MenuItem(\"Tools/重置选中对象位置\")]\r\n+    private static void ResetSelectedTransforms()\r\n+    {\r\n+        foreach (GameObject obj in Selection.gameObjects)\r\n+        {\r\n+            Undo.RecordObject(obj.transform, \"Reset Transform\");\r\n+            obj.transform.position = Vector3.zero;\r\n+            obj.transform.rotation = Quaternion.identity;\r\n+            obj.transform.localScale = Vector3.one;\r\n+        }\r\n+    }\r\n+    \r\n+    // 验证菜单项是否可用\r\n+    [MenuItem(\"Tools/重置选中对象位置\", true)]\r\n+    private static bool ValidateResetSelectedTransforms()\r\n+    {\r\n+        return Selection.gameObjects.Length > 0;\r\n+    }\r\n+    \r\n+    [MenuItem(\"GameObject/创建空的UI容器\", false, 10)]\r\n+    private static void CreateUIContainer()\r\n+    {\r\n+        GameObject container = new GameObject(\"UI Container\");\r\n+        container.AddComponent<RectTransform>();\r\n+        Selection.activeGameObject = container;\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### ContextMenu - 组件右键菜单\r\n+**作用**：为MonoBehaviour组件添加右键菜单项，方便在Inspector中快速执行操作。\r\n+\r\n+```csharp\r\n+public class HealthSystem : MonoBehaviour\r\n+{\r\n+    public int maxHealth = 100;\r\n+    public int currentHealth = 100;\r\n+    \r\n+    [ContextMenu(\"恢复满血\")]\r\n+    private void RestoreFullHealth()\r\n+    {\r\n+        currentHealth = maxHealth;\r\n+        Debug.Log($\"{gameObject.name} 血量已恢复至满血: {currentHealth}\");\r\n+    }\r\n+    \r\n+    [ContextMenu(\"设置为半血\")]\r\n+    private void SetHalfHealth()\r\n+    {\r\n+        currentHealth = maxHealth / 2;\r\n+        Debug.Log($\"{gameObject.name} 血量设置为半血: {currentHealth}\");\r\n+    }\r\n+    \r\n+    [ContextMenu(\"模拟死亡\")]\r\n+    private void SimulateDeath()\r\n+    {\r\n+        currentHealth = 0;\r\n+        Debug.Log($\"{gameObject.name} 已死亡\");\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### ContextMenuItem - 字段右键菜单\r\n+**作用**：为特定字段添加右键菜单项，提供字段相关的快捷操作。\r\n+\r\n+```csharp\r\n+public class WeaponConfig : MonoBehaviour\r\n+{\r\n+    [ContextMenuItem(\"重置为默认值\", \"ResetDamage\")]\r\n+    public float damage = 25f;\r\n+    \r\n+    [ContextMenuItem(\"随机化\", \"RandomizeFireRate\")]\r\n+    public float fireRate = 1f;\r\n+    \r\n+    [ContextMenuItem(\"复制到剪贴板\", \"CopyWeaponName\")]\r\n+    public string weaponName = \"默认武器\";\r\n+    \r\n+    private void ResetDamage()\r\n+    {\r\n+        damage = 25f;\r\n+    }\r\n+    \r\n+    private void RandomizeFireRate()\r\n+    {\r\n+        fireRate = Random.Range(0.5f, 3f);\r\n+    }\r\n+    \r\n+    private void CopyWeaponName()\r\n+    {\r\n+        GUIUtility.systemCopyBuffer = weaponName;\r\n+        Debug.Log($\"武器名称已复制: {weaponName}\");\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### CreateAssetMenu - 创建资源菜单\r\n+**作用**：在Project窗口的\"Create\"菜单中添加创建ScriptableObject资源的选项。\r\n+\r\n+```csharp\r\n+[CreateAssetMenu(\r\n+    fileName = \"新的武器数据\", \r\n+    menuName = \"游戏数据/武器配置\", \r\n+    order = 1\r\n+)]\r\n+public class WeaponData : ScriptableObject\r\n+{\r\n+    [Header(\"基础属性\")]\r\n+    public string weaponName = \"新武器\";\r\n+    public float damage = 50f;\r\n+    public float fireRate = 1f;\r\n+    \r\n+    [Header(\"视觉效果\")]\r\n+    public Sprite weaponIcon;\r\n+    public GameObject weaponPrefab;\r\n+    \r\n+    [Header(\"音效\")]\r\n+    public AudioClip fireSound;\r\n+    public AudioClip reloadSound;\r\n+}\r\n+\r\n+[CreateAssetMenu(\r\n+    fileName = \"新的关卡数据\", \r\n+    menuName = \"游戏数据/关卡配置\", \r\n+    order = 2\r\n+)]\r\n+public class LevelData : ScriptableObject\r\n+{\r\n+    public string levelName = \"新关卡\";\r\n+    public int levelIndex = 1;\r\n+    public float timeLimit = 300f;\r\n+    public GameObject[] enemyPrefabs;\r\n+    public Vector3[] spawnPoints;\r\n+}\r\n+\r\n ### 组件相关特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n |---------|---------|------|------|\r\n"
                },
                {
                    "date": 1748161097380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -568,20 +568,251 @@\n }\r\n \r\n ### 组件相关特性\r\n \r\n-| 特性名称 | 应用目标 | 描述 | 示例 |\r\n-|---------|---------|------|------|\r\n-| **RequireComponent** | 类 | 添加依赖组件 | `[RequireComponent(typeof(Rigidbody))]` |\r\n-| **DisallowMultipleComponent** | 类 | 禁止多个相同组件 | `[DisallowMultipleComponent]` |\r\n-| **ExecuteInEditMode** | 类 | 在编辑模式下执行 | `[ExecuteInEditMode]` |\r\n-| **ExecuteAlways** | 类 | 在编辑和运行模式下执行 | `[ExecuteAlways]` |\r\n-| **AddComponentMenu** | 类 | 添加到组件菜单 | `[AddComponentMenu(\"Custom/MyComponent\")]` |\r\n-| **HideInInspector** | 字段 | 在Inspector中隐藏字段 | `[HideInInspector]` |\r\n-| **SelectionBase** | 类 | 设为场景选择基础 | `[SelectionBase]` |\r\n-| **DefaultExecutionOrder** | 类 | 设置脚本执行顺序 | `[DefaultExecutionOrder(-100)]` |\r\n-| **Icon** | 类 | 为组件设置图标 | `[Icon(\"Assets/Icons/MyIcon.png\")]` |\r\n+#### RequireComponent - 依赖组件\r\n+**作用**：自动添加依赖的组件，确保组件正常工作所需的其他组件存在。\r\n \r\n+```csharp\r\n+[RequireComponent(typeof(Rigidbody))]\r\n+[RequireComponent(typeof(Collider))]\r\n+public class PlayerMovement : MonoBehaviour\r\n+{\r\n+    private Rigidbody rb;\r\n+    private Collider col;\r\n+    \r\n+    void Start()\r\n+    {\r\n+        // 这些组件会被自动添加，所以可以安全获取\r\n+        rb = GetComponent<Rigidbody>();\r\n+        col = GetComponent<Collider>();\r\n+    }\r\n+    \r\n+    void Update()\r\n+    {\r\n+        // 使用Rigidbody进行移动\r\n+        Vector3 movement = new Vector3(Input.GetAxis(\"Horizontal\"), 0, Input.GetAxis(\"Vertical\"));\r\n+        rb.AddForce(movement * 10f);\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### DisallowMultipleComponent - 禁止多组件\r\n+**作用**：防止在同一个GameObject上添加多个相同类型的组件。\r\n+\r\n+```csharp\r\n+[DisallowMultipleComponent]\r\n+public class GameManager : MonoBehaviour\r\n+{\r\n+    public static GameManager Instance { get; private set; }\r\n+    \r\n+    void Awake()\r\n+    {\r\n+        // 单例模式，确保只有一个GameManager\r\n+        if (Instance == null)\r\n+        {\r\n+            Instance = this;\r\n+            DontDestroyOnLoad(gameObject);\r\n+        }\r\n+        else\r\n+        {\r\n+            Destroy(gameObject);\r\n+        }\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### ExecuteInEditMode - 编辑模式执行\r\n+**作用**：使脚本在编辑模式下也能执行，常用于编辑器工具和预览功能。\r\n+\r\n+```csharp\r\n+[ExecuteInEditMode]\r\n+public class GridGenerator : MonoBehaviour\r\n+{\r\n+    public int gridWidth = 10;\r\n+    public int gridHeight = 10;\r\n+    public float cellSize = 1f;\r\n+    public GameObject tilePrefab;\r\n+    \r\n+    void Update()\r\n+    {\r\n+        // 在编辑模式下实时更新网格预览\r\n+        if (!Application.isPlaying)\r\n+        {\r\n+            UpdateGridPreview();\r\n+        }\r\n+    }\r\n+    \r\n+    void UpdateGridPreview()\r\n+    {\r\n+        // 清除旧的子对象\r\n+        for (int i = transform.childCount - 1; i >= 0; i--)\r\n+        {\r\n+            DestroyImmediate(transform.GetChild(i).gameObject);\r\n+        }\r\n+        \r\n+        // 生成新的网格\r\n+        for (int x = 0; x < gridWidth; x++)\r\n+        {\r\n+            for (int y = 0; y < gridHeight; y++)\r\n+            {\r\n+                Vector3 position = new Vector3(x * cellSize, 0, y * cellSize);\r\n+                GameObject tile = Instantiate(tilePrefab, position, Quaternion.identity, transform);\r\n+                tile.name = $\"Tile_{x}_{y}\";\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### ExecuteAlways - 总是执行\r\n+**作用**：在编辑模式和运行模式下都执行脚本，是ExecuteInEditMode的增强版本。\r\n+\r\n+```csharp\r\n+[ExecuteAlways]\r\n+public class LightController : MonoBehaviour\r\n+{\r\n+    public Color lightColor = Color.white;\r\n+    public float intensity = 1f;\r\n+    \r\n+    private Light lightComponent;\r\n+    \r\n+    void OnEnable()\r\n+    {\r\n+        lightComponent = GetComponent<Light>();\r\n+    }\r\n+    \r\n+    void Update()\r\n+    {\r\n+        if (lightComponent != null)\r\n+        {\r\n+            lightComponent.color = lightColor;\r\n+            lightComponent.intensity = intensity;\r\n+        }\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### AddComponentMenu - 组件菜单\r\n+**作用**：将组件添加到\"Add Component\"菜单的指定分类中，方便查找和使用。\r\n+\r\n+```csharp\r\n+[AddComponentMenu(\"游戏系统/库存管理器\")]\r\n+public class InventoryManager : MonoBehaviour\r\n+{\r\n+    public int maxSlots = 20;\r\n+    public List<Item> items = new List<Item>();\r\n+    \r\n+    public bool AddItem(Item item)\r\n+    {\r\n+        if (items.Count < maxSlots)\r\n+        {\r\n+            items.Add(item);\r\n+            return true;\r\n+        }\r\n+        return false;\r\n+    }\r\n+}\r\n+\r\n+[AddComponentMenu(\"AI/敌人AI控制器\")]\r\n+public class EnemyAI : MonoBehaviour\r\n+{\r\n+    public float detectionRange = 10f;\r\n+    public float attackRange = 2f;\r\n+    public Transform target;\r\n+    \r\n+    void Update()\r\n+    {\r\n+        // AI逻辑\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### HideInInspector - 隐藏字段\r\n+**作用**：在Inspector中隐藏公有字段，常用于不希望在编辑器中修改的字段。\r\n+\r\n+```csharp\r\n+public class ScoreManager : MonoBehaviour\r\n+{\r\n+    public int baseScore = 100;  // 在Inspector中显示\r\n+    \r\n+    [HideInInspector]\r\n+    public int currentScore;     // 在Inspector中隐藏\r\n+    \r\n+    [HideInInspector]\r\n+    public float multiplier = 1f; // 运行时计算，不需要在Inspector中显示\r\n+    \r\n+    void Start()\r\n+    {\r\n+        currentScore = baseScore;\r\n+    }\r\n+    \r\n+    public void AddScore(int points)\r\n+    {\r\n+        currentScore += Mathf.RoundToInt(points * multiplier);\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### SelectionBase - 选择基础\r\n+**作用**：在场景视图中点击子对象时，选择标记了SelectionBase的父对象。\r\n+\r\n+```csharp\r\n+[SelectionBase]\r\n+public class Vehicle : MonoBehaviour\r\n+{\r\n+    public Transform[] wheels;\r\n+    public Transform body;\r\n+    public Transform engine;\r\n+    \r\n+    // 当点击车轮、车身或引擎时，会选择整个Vehicle对象\r\n+    // 这样便于整体操作车辆而不是单独的部件\r\n+}\r\n+```\r\n+\r\n+#### DefaultExecutionOrder - 执行顺序\r\n+**作用**：设置脚本的执行顺序，确保某些脚本在其他脚本之前或之后执行。\r\n+\r\n+```csharp\r\n+[DefaultExecutionOrder(-100)]  // 优先执行\r\n+public class GameInitializer : MonoBehaviour\r\n+{\r\n+    void Awake()\r\n+    {\r\n+        // 初始化游戏系统，需要在其他脚本之前执行\r\n+        Debug.Log(\"游戏系统初始化\");\r\n+    }\r\n+}\r\n+\r\n+[DefaultExecutionOrder(100)]   // 延后执行\r\n+public class GameFinalizer : MonoBehaviour\r\n+{\r\n+    void Start()\r\n+    {\r\n+        // 在所有其他脚本Start之后执行\r\n+        Debug.Log(\"游戏启动完成\");\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### Icon - 组件图标\r\n+**作用**：为组件在Hierarchy窗口中设置自定义图标，便于识别。\r\n+\r\n+```csharp\r\n+[Icon(\"Assets/Icons/manager_icon.png\")]\r\n+public class AudioManager : MonoBehaviour\r\n+{\r\n+    public AudioSource musicSource;\r\n+    public AudioSource sfxSource;\r\n+    \r\n+    public void PlayMusic(AudioClip clip)\r\n+    {\r\n+        musicSource.clip = clip;\r\n+        musicSource.Play();\r\n+    }\r\n+}\r\n+```\r\n+\r\n ### 编辑器定制特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n |---------|---------|------|------|\r\n"
                },
                {
                    "date": 1748161140107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -813,17 +813,296 @@\n ```\r\n \r\n ### 编辑器定制特性\r\n \r\n-| 特性名称 | 应用目标 | 描述 | 示例 |\r\n-|---------|---------|------|------|\r\n-| **CustomEditor** | 编辑器类 | 自定义Inspector | `[CustomEditor(typeof(MyComponent))]` |\r\n-| **CustomPropertyDrawer** | 属性绘制类 | 自定义属性绘制 | `[CustomPropertyDrawer(typeof(MyClass))]` |\r\n-| **CanEditMultipleObjects** | 编辑器类 | 支持多对象编辑 | `[CanEditMultipleObjects]` |\r\n-| **InitializeOnLoad** | 类 | 编辑器加载时初始化 | `[InitializeOnLoad]` |\r\n-| **InitializeOnLoadMethod** | 静态方法 | 编辑器加载时执行方法 | `[InitializeOnLoadMethod]` |\r\n-| **OnOpenAsset** | 静态方法 | 资源打开时执行 | `[OnOpenAsset]` |\r\n+#### CustomEditor - 自定义检视器\r\n+**作用**：为特定组件创建自定义的Inspector界面，提供更好的编辑体验。\r\n \r\n+```csharp\r\n+// 目标组件\r\n+public class WaveGenerator : MonoBehaviour\r\n+{\r\n+    public float amplitude = 1f;\r\n+    public float frequency = 1f;\r\n+    public float speed = 1f;\r\n+    public AnimationCurve waveCurve = AnimationCurve.Linear(0, 0, 1, 1);\r\n+}\r\n+\r\n+// 自定义编辑器\r\n+[CustomEditor(typeof(WaveGenerator))]\r\n+public class WaveGeneratorEditor : Editor\r\n+{\r\n+    private WaveGenerator waveGen;\r\n+    \r\n+    void OnEnable()\r\n+    {\r\n+        waveGen = (WaveGenerator)target;\r\n+    }\r\n+    \r\n+    public override void OnInspectorGUI()\r\n+    {\r\n+        EditorGUILayout.LabelField(\"波形生成器设置\", EditorStyles.boldLabel);\r\n+        \r\n+        // 绘制默认属性\r\n+        DrawDefaultInspector();\r\n+        \r\n+        EditorGUILayout.Space();\r\n+        \r\n+        // 添加自定义按钮\r\n+        if (GUILayout.Button(\"生成预览波形\"))\r\n+        {\r\n+            GeneratePreview();\r\n+        }\r\n+        \r\n+        if (GUILayout.Button(\"重置为默认值\"))\r\n+        {\r\n+            ResetToDefaults();\r\n+        }\r\n+        \r\n+        // 显示实时信息\r\n+        EditorGUILayout.HelpBox($\"当前波长: {2 * Mathf.PI / waveGen.frequency:F2}\", MessageType.Info);\r\n+    }\r\n+    \r\n+    private void GeneratePreview()\r\n+    {\r\n+        Debug.Log(\"生成波形预览\");\r\n+    }\r\n+    \r\n+    private void ResetToDefaults()\r\n+    {\r\n+        Undo.RecordObject(waveGen, \"Reset Wave Generator\");\r\n+        waveGen.amplitude = 1f;\r\n+        waveGen.frequency = 1f;\r\n+        waveGen.speed = 1f;\r\n+        waveGen.waveCurve = AnimationCurve.Linear(0, 0, 1, 1);\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### CustomPropertyDrawer - 自定义属性绘制器\r\n+**作用**：为特定类型或特性创建自定义的属性绘制器，控制字段在Inspector中的显示方式。\r\n+\r\n+```csharp\r\n+// 自定义数据类型\r\n+[System.Serializable]\r\n+public class MinMaxRange\r\n+{\r\n+    public float min = 0f;\r\n+    public float max = 1f;\r\n+    \r\n+    public float GetRandomValue()\r\n+    {\r\n+        return Random.Range(min, max);\r\n+    }\r\n+}\r\n+\r\n+// 自定义属性绘制器\r\n+[CustomPropertyDrawer(typeof(MinMaxRange))]\r\n+public class MinMaxRangeDrawer : PropertyDrawer\r\n+{\r\n+    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\r\n+    {\r\n+        EditorGUI.BeginProperty(position, label, property);\r\n+        \r\n+        // 绘制标签\r\n+        position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);\r\n+        \r\n+        // 获取属性\r\n+        var minProp = property.FindPropertyRelative(\"min\");\r\n+        var maxProp = property.FindPropertyRelative(\"max\");\r\n+        \r\n+        // 计算布局\r\n+        var minRect = new Rect(position.x, position.y, 50, position.height);\r\n+        var sliderRect = new Rect(position.x + 55, position.y, position.width - 115, position.height);\r\n+        var maxRect = new Rect(position.x + position.width - 55, position.y, 50, position.height);\r\n+        \r\n+        // 绘制控件\r\n+        float minValue = EditorGUI.FloatField(minRect, minProp.floatValue);\r\n+        float maxValue = EditorGUI.FloatField(maxRect, maxProp.floatValue);\r\n+        \r\n+        EditorGUI.MinMaxSlider(sliderRect, ref minValue, ref maxValue, 0f, 10f);\r\n+        \r\n+        // 应用值\r\n+        minProp.floatValue = minValue;\r\n+        maxProp.floatValue = maxValue;\r\n+        \r\n+        EditorGUI.EndProperty();\r\n+    }\r\n+}\r\n+\r\n+// 使用示例\r\n+public class SpawnController : MonoBehaviour\r\n+{\r\n+    public MinMaxRange spawnDelay = new MinMaxRange();\r\n+    public MinMaxRange spawnCount = new MinMaxRange();\r\n+}\r\n+```\r\n+\r\n+#### CanEditMultipleObjects - 多对象编辑\r\n+**作用**：允许自定义编辑器同时编辑多个选中的对象。\r\n+\r\n+```csharp\r\n+[CustomEditor(typeof(LightController))]\r\n+[CanEditMultipleObjects]  // 支持多选编辑\r\n+public class LightControllerEditor : Editor\r\n+{\r\n+    public override void OnInspectorGUI()\r\n+    {\r\n+        // 绘制默认Inspector\r\n+        DrawDefaultInspector();\r\n+        \r\n+        EditorGUILayout.Space();\r\n+        \r\n+        // 批量操作按钮\r\n+        if (GUILayout.Button(\"批量开启所有灯光\"))\r\n+        {\r\n+            foreach (LightController light in targets)\r\n+            {\r\n+                Undo.RecordObject(light, \"Turn On Lights\");\r\n+                light.GetComponent<Light>().enabled = true;\r\n+            }\r\n+        }\r\n+        \r\n+        if (GUILayout.Button(\"批量关闭所有灯光\"))\r\n+        {\r\n+            foreach (LightController light in targets)\r\n+            {\r\n+                Undo.RecordObject(light, \"Turn Off Lights\");\r\n+                light.GetComponent<Light>().enabled = false;\r\n+            }\r\n+        }\r\n+        \r\n+        // 显示选中数量\r\n+        EditorGUILayout.HelpBox($\"已选中 {targets.Length} 个灯光控制器\", MessageType.Info);\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### InitializeOnLoad - 编辑器加载时初始化\r\n+**作用**：在编辑器加载时自动初始化类，常用于编辑器工具的设置。\r\n+\r\n+```csharp\r\n+[InitializeOnLoad]\r\n+public class EditorInitializer\r\n+{\r\n+    static EditorInitializer()\r\n+    {\r\n+        Debug.Log(\"编辑器初始化完成\");\r\n+        \r\n+        // 订阅编辑器事件\r\n+        EditorApplication.hierarchyChanged += OnHierarchyChanged;\r\n+        EditorApplication.projectChanged += OnProjectChanged;\r\n+        \r\n+        // 设置编辑器偏好\r\n+        EditorPrefs.SetBool(\"AutoSave\", true);\r\n+    }\r\n+    \r\n+    private static void OnHierarchyChanged()\r\n+    {\r\n+        Debug.Log(\"层级视图发生变化\");\r\n+    }\r\n+    \r\n+    private static void OnProjectChanged()\r\n+    {\r\n+        Debug.Log(\"项目发生变化\");\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### InitializeOnLoadMethod - 编辑器加载时执行方法\r\n+**作用**：标记静态方法在编辑器加载时执行，比InitializeOnLoad更精确。\r\n+\r\n+```csharp\r\n+public class EditorUtilities\r\n+{\r\n+    [InitializeOnLoadMethod]\r\n+    private static void InitializeEditor()\r\n+    {\r\n+        Debug.Log(\"编辑器工具初始化\");\r\n+        \r\n+        // 检查项目设置\r\n+        CheckProjectSettings();\r\n+        \r\n+        // 设置默认场景\r\n+        SetupDefaultScene();\r\n+    }\r\n+    \r\n+    [InitializeOnLoadMethod]\r\n+    private static void SetupCustomShortcuts()\r\n+    {\r\n+        Debug.Log(\"设置自定义快捷键\");\r\n+        // 注册自定义快捷键\r\n+    }\r\n+    \r\n+    private static void CheckProjectSettings()\r\n+    {\r\n+        // 检查项目配置\r\n+        if (PlayerSettings.companyName == \"DefaultCompany\")\r\n+        {\r\n+            Debug.LogWarning(\"请设置公司名称\");\r\n+        }\r\n+    }\r\n+    \r\n+    private static void SetupDefaultScene()\r\n+    {\r\n+        // 设置默认场景配置\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### OnOpenAsset - 资源打开时执行\r\n+**作用**：在特定类型的资源被打开时执行自定义逻辑。\r\n+\r\n+```csharp\r\n+public class AssetOpener\r\n+{\r\n+    [OnOpenAsset(1)]  // 优先级为1\r\n+    public static bool OnOpenAsset(int instanceID, int line)\r\n+    {\r\n+        Object obj = EditorUtility.InstanceIDToObject(instanceID);\r\n+        \r\n+        // 处理特定类型的资源\r\n+        if (obj is TextAsset textAsset)\r\n+        {\r\n+            if (textAsset.name.EndsWith(\"_config\"))\r\n+            {\r\n+                // 用自定义编辑器打开配置文件\r\n+                ConfigEditorWindow.OpenConfig(textAsset);\r\n+                return true;  // 返回true表示已处理，阻止默认行为\r\n+            }\r\n+        }\r\n+        \r\n+        // 处理ScriptableObject\r\n+        if (obj is WeaponData weaponData)\r\n+        {\r\n+            WeaponEditorWindow.OpenWeapon(weaponData);\r\n+            return true;\r\n+        }\r\n+        \r\n+        return false;  // 返回false使用默认处理方式\r\n+    }\r\n+    \r\n+    [OnOpenAsset(2)]  // 优先级为2，较低\r\n+    public static bool LogAssetOpen(int instanceID, int line)\r\n+    {\r\n+        Object obj = EditorUtility.InstanceIDToObject(instanceID);\r\n+        Debug.Log($\"打开资源: {obj.name} (类型: {obj.GetType().Name})\");\r\n+        return false;  // 不阻止默认行为\r\n+    }\r\n+}\r\n+\r\n+// 自定义编辑器窗口示例\r\n+public class ConfigEditorWindow : EditorWindow\r\n+{\r\n+    public static void OpenConfig(TextAsset config)\r\n+    {\r\n+        var window = GetWindow<ConfigEditorWindow>();\r\n+        window.titleContent = new GUIContent($\"配置编辑器 - {config.name}\");\r\n+        window.Show();\r\n+    }\r\n+}\r\n+```\r\n+\r\n ### Gizmo相关特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n |---------|---------|------|------|\r\n"
                },
                {
                    "date": 1748161174404,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1103,14 +1103,183 @@\n ```\r\n \r\n ### Gizmo相关特性\r\n \r\n-| 特性名称 | 应用目标 | 描述 | 示例 |\r\n-|---------|---------|------|------|\r\n-| **DrawGizmo** | 静态方法 | 绘制场景视图中的Gizmo | `[DrawGizmo(GizmoType.Selected)]` |\r\n-| **GizmoDrawer** | 类 | 定义Gizmo绘制器 | 自定义实现 |\r\n-| **GizmoIcon** | 类 | 为对象添加Gizmo图标 | 自定义实现 |\r\n+#### DrawGizmo - 绘制场景Gizmo\r\n+**作用**：在场景视图中为特定组件绘制自定义Gizmo，提供可视化调试信息。\r\n \r\n+```csharp\r\n+// 目标组件\r\n+public class DetectionZone : MonoBehaviour\r\n+{\r\n+    public float detectionRadius = 5f;\r\n+    public Color gizmoColor = Color.red;\r\n+    public bool showDetectionCone = true;\r\n+    public float coneAngle = 60f;\r\n+}\r\n+\r\n+// Gizmo绘制器\r\n+public class DetectionZoneGizmos\r\n+{\r\n+    [DrawGizmo(GizmoType.Selected | GizmoType.Active)]\r\n+    static void DrawDetectionZoneGizmo(DetectionZone zone, GizmoType gizmoType)\r\n+    {\r\n+        // 设置Gizmo颜色\r\n+        Gizmos.color = zone.gizmoColor;\r\n+        \r\n+        // 绘制检测范围圆圈\r\n+        Gizmos.DrawWireSphere(zone.transform.position, zone.detectionRadius);\r\n+        \r\n+        // 只为选中对象绘制额外细节\r\n+        if ((gizmoType & GizmoType.Selected) != 0)\r\n+        {\r\n+            // 绘制半透明填充\r\n+            Color fillColor = zone.gizmoColor;\r\n+            fillColor.a = 0.1f;\r\n+            Gizmos.color = fillColor;\r\n+            Gizmos.DrawSphere(zone.transform.position, zone.detectionRadius);\r\n+            \r\n+            // 绘制检测锥形\r\n+            if (zone.showDetectionCone)\r\n+            {\r\n+                DrawDetectionCone(zone);\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    [DrawGizmo(GizmoType.NonSelected)]\r\n+    static void DrawSimpleGizmo(DetectionZone zone, GizmoType gizmoType)\r\n+    {\r\n+        // 为未选中对象绘制简单指示器\r\n+        Gizmos.color = Color.yellow;\r\n+        Gizmos.DrawWireCube(zone.transform.position, Vector3.one * 0.5f);\r\n+    }\r\n+    \r\n+    private static void DrawDetectionCone(DetectionZone zone)\r\n+    {\r\n+        Vector3 forward = zone.transform.forward;\r\n+        Vector3 position = zone.transform.position;\r\n+        \r\n+        // 计算锥形边界\r\n+        float halfAngle = zone.coneAngle * 0.5f * Mathf.Deg2Rad;\r\n+        Vector3 left = Quaternion.AngleAxis(-zone.coneAngle * 0.5f, zone.transform.up) * forward;\r\n+        Vector3 right = Quaternion.AngleAxis(zone.coneAngle * 0.5f, zone.transform.up) * forward;\r\n+        \r\n+        // 绘制锥形线条\r\n+        Gizmos.color = Color.blue;\r\n+        Gizmos.DrawRay(position, left * zone.detectionRadius);\r\n+        Gizmos.DrawRay(position, right * zone.detectionRadius);\r\n+        Gizmos.DrawRay(position, forward * zone.detectionRadius);\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### 自定义Gizmo图标\r\n+**作用**：为GameObject在场景视图中显示自定义图标，便于识别特殊对象。\r\n+\r\n+```csharp\r\n+// 在组件的OnDrawGizmos方法中绘制图标\r\n+public class SpawnPoint : MonoBehaviour\r\n+{\r\n+    public Texture2D spawnIcon;  // 在Inspector中分配图标\r\n+    \r\n+    void OnDrawGizmos()\r\n+    {\r\n+        // 绘制图标\r\n+        if (spawnIcon != null)\r\n+        {\r\n+            Gizmos.DrawIcon(transform.position, spawnIcon.name, true);\r\n+        }\r\n+        \r\n+        // 绘制额外的Gizmo元素\r\n+        Gizmos.color = Color.green;\r\n+        Gizmos.DrawWireCube(transform.position, Vector3.one);\r\n+    }\r\n+    \r\n+    void OnDrawGizmosSelected()\r\n+    {\r\n+        // 选中时绘制更多细节\r\n+        Gizmos.color = Color.cyan;\r\n+        Gizmos.DrawWireSphere(transform.position, 2f);\r\n+        \r\n+        // 绘制方向指示器\r\n+        Gizmos.color = Color.red;\r\n+        Gizmos.DrawRay(transform.position, transform.forward * 3f);\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### 高级Gizmo绘制示例\r\n+**作用**：展示复杂的Gizmo绘制技术，包括条件绘制和交互式Gizmo。\r\n+\r\n+```csharp\r\n+public class PathWaypoint : MonoBehaviour\r\n+{\r\n+    public PathWaypoint nextWaypoint;\r\n+    public float waypointRadius = 1f;\r\n+    public Color waypointColor = Color.yellow;\r\n+    \r\n+    [Header(\"调试选项\")]\r\n+    public bool showConnections = true;\r\n+    public bool showDirection = true;\r\n+    public bool showIndex = true;\r\n+}\r\n+\r\n+public class PathWaypointGizmos\r\n+{\r\n+    [DrawGizmo(GizmoType.Selected | GizmoType.NonSelected)]\r\n+    static void DrawWaypointGizmo(PathWaypoint waypoint, GizmoType gizmoType)\r\n+    {\r\n+        bool isSelected = (gizmoType & GizmoType.Selected) != 0;\r\n+        \r\n+        // 绘制路径点\r\n+        Gizmos.color = isSelected ? Color.white : waypoint.waypointColor;\r\n+        Gizmos.DrawWireSphere(waypoint.transform.position, waypoint.waypointRadius);\r\n+        \r\n+        if (isSelected)\r\n+        {\r\n+            // 选中时绘制填充球体\r\n+            Color fillColor = waypoint.waypointColor;\r\n+            fillColor.a = 0.3f;\r\n+            Gizmos.color = fillColor;\r\n+            Gizmos.DrawSphere(waypoint.transform.position, waypoint.waypointRadius);\r\n+        }\r\n+        \r\n+        // 绘制连接线\r\n+        if (waypoint.showConnections && waypoint.nextWaypoint != null)\r\n+        {\r\n+            Gizmos.color = Color.blue;\r\n+            Gizmos.DrawLine(waypoint.transform.position, waypoint.nextWaypoint.transform.position);\r\n+            \r\n+            // 绘制方向箭头\r\n+            if (waypoint.showDirection)\r\n+            {\r\n+                DrawArrow(waypoint.transform.position, waypoint.nextWaypoint.transform.position);\r\n+            }\r\n+        }\r\n+        \r\n+        // 绘制索引标签（仅在选中时）\r\n+        if (isSelected && waypoint.showIndex)\r\n+        {\r\n+            UnityEditor.Handles.Label(\r\n+                waypoint.transform.position + Vector3.up * 2f,\r\n+                $\"路径点 {waypoint.transform.GetSiblingIndex()}\"\r\n+            );\r\n+        }\r\n+    }\r\n+    \r\n+    private static void DrawArrow(Vector3 from, Vector3 to)\r\n+    {\r\n+        Vector3 direction = (to - from).normalized;\r\n+        Vector3 right = Vector3.Cross(direction, Vector3.up).normalized;\r\n+        Vector3 arrowHead = to - direction * 0.5f;\r\n+        \r\n+        // 绘制箭头\r\n+        Gizmos.DrawLine(arrowHead, arrowHead + (-direction + right) * 0.3f);\r\n+        Gizmos.DrawLine(arrowHead, arrowHead + (-direction - right) * 0.3f);\r\n+    }\r\n+}\r\n+\r\n ### 设置相关特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n |---------|---------|------|------|\r\n"
                },
                {
                    "date": 1748161215602,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1280,14 +1280,278 @@\n }\r\n \r\n ### 设置相关特性\r\n \r\n-| 特性名称 | 应用目标 | 描述 | 示例 |\r\n-|---------|---------|------|------|\r\n-| **SettingsProvider** | 类 | 创建设置提供者 | `[SettingsProvider]` |\r\n-| **UserSetting** | 字段 | 标记为用户设置 | `[UserSetting]` |\r\n-| **SettingsProviderGroup** | 类 | 创建设置提供者组 | `[SettingsProviderGroup]` |\r\n+#### SettingsProvider - 创建设置提供者\r\n+**作用**：在Unity的Project Settings或Preferences窗口中创建自定义设置面板。\r\n \r\n+```csharp\r\n+// 设置数据类\r\n+[System.Serializable]\r\n+public class MyProjectSettings\r\n+{\r\n+    public string apiKey = \"\";\r\n+    public bool enableDebugMode = false;\r\n+    public float networkTimeout = 30f;\r\n+    public LogLevel logLevel = LogLevel.Info;\r\n+}\r\n+\r\n+public enum LogLevel\r\n+{\r\n+    Debug, Info, Warning, Error\r\n+}\r\n+\r\n+// 设置提供者\r\n+public class MyProjectSettingsProvider\r\n+{\r\n+    private static MyProjectSettings settings;\r\n+    private static SerializedObject serializedSettings;\r\n+    \r\n+    [SettingsProvider]\r\n+    public static SettingsProvider CreateMyProjectSettingsProvider()\r\n+    {\r\n+        var provider = new SettingsProvider(\"Project/My Game Settings\", SettingsScope.Project)\r\n+        {\r\n+            label = \"我的游戏设置\",\r\n+            guiHandler = (searchContext) =>\r\n+            {\r\n+                // 确保设置已加载\r\n+                if (settings == null)\r\n+                {\r\n+                    LoadSettings();\r\n+                }\r\n+                \r\n+                if (serializedSettings == null || serializedSettings.targetObject == null)\r\n+                {\r\n+                    serializedSettings = new SerializedObject(ScriptableObject.CreateInstance<MyProjectSettingsAsset>());\r\n+                }\r\n+                \r\n+                EditorGUILayout.LabelField(\"API设置\", EditorStyles.boldLabel);\r\n+                settings.apiKey = EditorGUILayout.TextField(\"API密钥\", settings.apiKey);\r\n+                \r\n+                EditorGUILayout.Space();\r\n+                EditorGUILayout.LabelField(\"调试设置\", EditorStyles.boldLabel);\r\n+                settings.enableDebugMode = EditorGUILayout.Toggle(\"启用调试模式\", settings.enableDebugMode);\r\n+                settings.logLevel = (LogLevel)EditorGUILayout.EnumPopup(\"日志级别\", settings.logLevel);\r\n+                \r\n+                EditorGUILayout.Space();\r\n+                EditorGUILayout.LabelField(\"网络设置\", EditorStyles.boldLabel);\r\n+                settings.networkTimeout = EditorGUILayout.FloatField(\"网络超时(秒)\", settings.networkTimeout);\r\n+                \r\n+                // 保存按钮\r\n+                EditorGUILayout.Space();\r\n+                if (GUILayout.Button(\"保存设置\"))\r\n+                {\r\n+                    SaveSettings();\r\n+                }\r\n+                \r\n+                if (GUILayout.Button(\"重置为默认值\"))\r\n+                {\r\n+                    ResetToDefaults();\r\n+                }\r\n+            },\r\n+            \r\n+            // 搜索关键词\r\n+            keywords = new HashSet<string>(new[] { \"API\", \"Debug\", \"Network\", \"Log\" })\r\n+        };\r\n+        \r\n+        return provider;\r\n+    }\r\n+    \r\n+    private static void LoadSettings()\r\n+    {\r\n+        string json = EditorPrefs.GetString(\"MyProjectSettings\", \"{}\");\r\n+        settings = JsonUtility.FromJson<MyProjectSettings>(json);\r\n+        if (settings == null)\r\n+        {\r\n+            settings = new MyProjectSettings();\r\n+        }\r\n+    }\r\n+    \r\n+    private static void SaveSettings()\r\n+    {\r\n+        string json = JsonUtility.ToJson(settings, true);\r\n+        EditorPrefs.SetString(\"MyProjectSettings\", json);\r\n+        Debug.Log(\"设置已保存\");\r\n+    }\r\n+    \r\n+    private static void ResetToDefaults()\r\n+    {\r\n+        settings = new MyProjectSettings();\r\n+        SaveSettings();\r\n+    }\r\n+}\r\n+\r\n+// 用于序列化的ScriptableObject\r\n+public class MyProjectSettingsAsset : ScriptableObject\r\n+{\r\n+    public MyProjectSettings settings = new MyProjectSettings();\r\n+}\r\n+```\r\n+\r\n+#### UserSetting - 用户设置\r\n+**作用**：标记字段为用户特定的设置，这些设置会保存在用户的偏好设置中。\r\n+\r\n+```csharp\r\n+public class EditorPreferences\r\n+{\r\n+    // 用户设置会自动保存到EditorPrefs\r\n+    [UserSetting(\"Editor/Auto Save\")]\r\n+    public static bool autoSave = true;\r\n+    \r\n+    [UserSetting(\"Editor/Show Grid\")]\r\n+    public static bool showGrid = false;\r\n+    \r\n+    [UserSetting(\"Editor/Grid Size\")]\r\n+    public static float gridSize = 1f;\r\n+    \r\n+    [UserSetting(\"Editor/Theme\")]\r\n+    public static string editorTheme = \"Dark\";\r\n+    \r\n+    // 创建偏好设置界面\r\n+    [SettingsProvider]\r\n+    public static SettingsProvider CreateUserPreferencesProvider()\r\n+    {\r\n+        var provider = new SettingsProvider(\"Preferences/My Editor\", SettingsScope.User)\r\n+        {\r\n+            label = \"我的编辑器偏好\",\r\n+            guiHandler = (searchContext) =>\r\n+            {\r\n+                EditorGUILayout.LabelField(\"编辑器设置\", EditorStyles.boldLabel);\r\n+                \r\n+                autoSave = EditorGUILayout.Toggle(\"自动保存\", autoSave);\r\n+                showGrid = EditorGUILayout.Toggle(\"显示网格\", showGrid);\r\n+                \r\n+                if (showGrid)\r\n+                {\r\n+                    EditorGUI.indentLevel++;\r\n+                    gridSize = EditorGUILayout.FloatField(\"网格大小\", gridSize);\r\n+                    EditorGUI.indentLevel--;\r\n+                }\r\n+                \r\n+                EditorGUILayout.Space();\r\n+                EditorGUILayout.LabelField(\"外观设置\", EditorStyles.boldLabel);\r\n+                \r\n+                string[] themes = { \"Light\", \"Dark\", \"Custom\" };\r\n+                int themeIndex = System.Array.IndexOf(themes, editorTheme);\r\n+                themeIndex = EditorGUILayout.Popup(\"编辑器主题\", themeIndex, themes);\r\n+                editorTheme = themes[themeIndex];\r\n+                \r\n+                // 应用设置\r\n+                if (GUI.changed)\r\n+                {\r\n+                    ApplySettings();\r\n+                }\r\n+            },\r\n+            keywords = new HashSet<string>(new[] { \"Auto\", \"Save\", \"Grid\", \"Theme\" })\r\n+        };\r\n+        \r\n+        return provider;\r\n+    }\r\n+    \r\n+    private static void ApplySettings()\r\n+    {\r\n+        // 应用设置到编辑器\r\n+        EditorPrefs.SetBool(\"MyEditor_AutoSave\", autoSave);\r\n+        EditorPrefs.SetBool(\"MyEditor_ShowGrid\", showGrid);\r\n+        EditorPrefs.SetFloat(\"MyEditor_GridSize\", gridSize);\r\n+        EditorPrefs.SetString(\"MyEditor_Theme\", editorTheme);\r\n+    }\r\n+}\r\n+```\r\n+\r\n+#### SettingsProviderGroup - 设置提供者组\r\n+**作用**：将多个相关的设置提供者组织在一起，创建设置分组。\r\n+\r\n+```csharp\r\n+// 游戏设置组\r\n+public class GameSettingsGroup\r\n+{\r\n+    [SettingsProviderGroup]\r\n+    public static SettingsProvider[] CreateGameSettingsGroup()\r\n+    {\r\n+        return new SettingsProvider[]\r\n+        {\r\n+            CreatePlayerSettingsProvider(),\r\n+            CreateAudioSettingsProvider(),\r\n+            CreateGraphicsSettingsProvider()\r\n+        };\r\n+    }\r\n+    \r\n+    private static SettingsProvider CreatePlayerSettingsProvider()\r\n+    {\r\n+        return new SettingsProvider(\"Project/Game Settings/Player\", SettingsScope.Project)\r\n+        {\r\n+            label = \"玩家设置\",\r\n+            guiHandler = (searchContext) =>\r\n+            {\r\n+                EditorGUILayout.LabelField(\"玩家配置\", EditorStyles.boldLabel);\r\n+                \r\n+                PlayerSettings.defaultInterfaceOrientation = (UIOrientation)EditorGUILayout.EnumPopup(\r\n+                    \"默认界面方向\", PlayerSettings.defaultInterfaceOrientation);\r\n+                \r\n+                PlayerSettings.allowedAutorotateToPortrait = EditorGUILayout.Toggle(\r\n+                    \"允许竖屏旋转\", PlayerSettings.allowedAutorotateToPortrait);\r\n+                \r\n+                PlayerSettings.allowedAutorotateToLandscapeLeft = EditorGUILayout.Toggle(\r\n+                    \"允许左横屏\", PlayerSettings.allowedAutorotateToLandscapeLeft);\r\n+                \r\n+                PlayerSettings.allowedAutorotateToLandscapeRight = EditorGUILayout.Toggle(\r\n+                    \"允许右横屏\", PlayerSettings.allowedAutorotateToLandscapeRight);\r\n+            }\r\n+        };\r\n+    }\r\n+    \r\n+    private static SettingsProvider CreateAudioSettingsProvider()\r\n+    {\r\n+        return new SettingsProvider(\"Project/Game Settings/Audio\", SettingsScope.Project)\r\n+        {\r\n+            label = \"音频设置\",\r\n+            guiHandler = (searchContext) =>\r\n+            {\r\n+                EditorGUILayout.LabelField(\"音频配置\", EditorStyles.boldLabel);\r\n+                \r\n+                AudioSettings.GetConfiguration(out var config);\r\n+                \r\n+                EditorGUILayout.LabelField($\"采样率: {config.sampleRate} Hz\");\r\n+                EditorGUILayout.LabelField($\"缓冲区大小: {config.bufferSize}\");\r\n+                EditorGUILayout.LabelField($\"扬声器模式: {config.speakerMode}\");\r\n+                \r\n+                if (GUILayout.Button(\"重置音频设置\"))\r\n+                {\r\n+                    AudioSettings.Reset();\r\n+                }\r\n+            }\r\n+        };\r\n+    }\r\n+    \r\n+    private static SettingsProvider CreateGraphicsSettingsProvider()\r\n+    {\r\n+        return new SettingsProvider(\"Project/Game Settings/Graphics\", SettingsScope.Project)\r\n+        {\r\n+            label = \"图形设置\",\r\n+            guiHandler = (searchContext) =>\r\n+            {\r\n+                EditorGUILayout.LabelField(\"图形配置\", EditorStyles.boldLabel);\r\n+                \r\n+                QualitySettings.pixelLightCount = EditorGUILayout.IntField(\r\n+                    \"像素光源数量\", QualitySettings.pixelLightCount);\r\n+                \r\n+                QualitySettings.shadows = (ShadowQuality)EditorGUILayout.EnumPopup(\r\n+                    \"阴影质量\", QualitySettings.shadows);\r\n+                \r\n+                QualitySettings.shadowResolution = (ShadowResolution)EditorGUILayout.EnumPopup(\r\n+                    \"阴影分辨率\", QualitySettings.shadowResolution);\r\n+                \r\n+                QualitySettings.antiAliasing = EditorGUILayout.IntPopup(\r\n+                    \"抗锯齿\", QualitySettings.antiAliasing, \r\n+                    new string[] { \"禁用\", \"2x\", \"4x\", \"8x\" },\r\n+                    new int[] { 0, 2, 4, 8 });\r\n+            }\r\n+        };\r\n+    }\r\n+}\r\n+\r\n ## 使用案例\r\n \r\n ### 案例1: 自定义组件检视器\r\n \r\n"
                },
                {
                    "date": 1748161268556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1886,9 +1886,318 @@\n 7. **避免特性滥用**：过多使用特性可能导致代码可读性下降，应合理使用\r\n \r\n 8. **文档化特性行为**：为自定义特性提供清晰的文档，说明其行为和使用方法\r\n \r\n+## 运行时特性详解\r\n+\r\n+### RuntimeInitializeOnLoadMethod - 运行时初始化\r\n+**作用**：在游戏运行时自动执行初始化方法，支持不同的加载时机。\r\n+\r\n+```csharp\r\n+public class GameInitializer\r\n+{\r\n+    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]\r\n+    private static void InitializeBeforeScene()\r\n+    {\r\n+        Debug.Log(\"在场景加载前初始化\");\r\n+        // 初始化核心系统，如数据管理器\r\n+        DataManager.Initialize();\r\n+    }\r\n+    \r\n+    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]\r\n+    private static void InitializeAfterScene()\r\n+    {\r\n+        Debug.Log(\"在场景加载后初始化\");\r\n+        // 初始化依赖场景对象的系统\r\n+        UIManager.Initialize();\r\n+    }\r\n+    \r\n+    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterAssembliesLoaded)]\r\n+    private static void InitializeAfterAssemblies()\r\n+    {\r\n+        Debug.Log(\"程序集加载后初始化\");\r\n+        // 注册事件监听器\r\n+        EventManager.RegisterGlobalListeners();\r\n+    }\r\n+    \r\n+    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSplashScreen)]\r\n+    private static void InitializeBeforeSplash()\r\n+    {\r\n+        Debug.Log(\"启动画面前初始化\");\r\n+        // 设置应用程序配置\r\n+        Application.targetFrameRate = 60;\r\n+    }\r\n+    \r\n+    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]\r\n+    private static void RegisterSubsystems()\r\n+    {\r\n+        Debug.Log(\"注册子系统\");\r\n+        // 注册自定义子系统\r\n+    }\r\n+}\r\n+```\r\n+\r\n+### HelpURL - 帮助文档链接\r\n+**作用**：为组件添加帮助文档链接，在Inspector中显示帮助按钮。\r\n+\r\n+```csharp\r\n+[HelpURL(\"https://docs.unity3d.com/Manual/class-AudioSource.html\")]\r\n+public class CustomAudioController : MonoBehaviour\r\n+{\r\n+    [Header(\"音频设置\")]\r\n+    public AudioClip backgroundMusic;\r\n+    public AudioClip[] soundEffects;\r\n+    \r\n+    [Range(0f, 1f)]\r\n+    public float masterVolume = 1f;\r\n+    \r\n+    private AudioSource audioSource;\r\n+    \r\n+    void Start()\r\n+    {\r\n+        audioSource = GetComponent<AudioSource>();\r\n+        if (backgroundMusic != null)\r\n+        {\r\n+            audioSource.clip = backgroundMusic;\r\n+            audioSource.loop = true;\r\n+            audioSource.volume = masterVolume;\r\n+            audioSource.Play();\r\n+        }\r\n+    }\r\n+    \r\n+    public void PlaySoundEffect(int index)\r\n+    {\r\n+        if (index >= 0 && index < soundEffects.Length && soundEffects[index] != null)\r\n+        {\r\n+            audioSource.PlayOneShot(soundEffects[index], masterVolume);\r\n+        }\r\n+    }\r\n+}\r\n+```\r\n+\r\n+### Obsolete - 标记过时API\r\n+**作用**：标记方法、类或字段为过时，提供升级指导。\r\n+\r\n+```csharp\r\n+public class PlayerController : MonoBehaviour\r\n+{\r\n+    public float moveSpeed = 5f;\r\n+    \r\n+    // 新的移动方法\r\n+    public void Move(Vector3 direction)\r\n+    {\r\n+        transform.Translate(direction * moveSpeed * Time.deltaTime);\r\n+    }\r\n+    \r\n+    // 标记为过时的方法\r\n+    [System.Obsolete(\"使用 Move(Vector3 direction) 方法替代\")]\r\n+    public void MovePlayer(float x, float z)\r\n+    {\r\n+        Move(new Vector3(x, 0, z));\r\n+    }\r\n+    \r\n+    // 带有错误级别的过时标记\r\n+    [System.Obsolete(\"此方法已被移除，请使用新的移动系统\", true)]\r\n+    public void OldMoveMethod()\r\n+    {\r\n+        // 这个方法会产生编译错误\r\n+    }\r\n+    \r\n+    // 提供升级路径的过时标记\r\n+    [System.Obsolete(\"请使用 SetSpeed(float speed) 方法。这个属性将在下个版本中移除。\")]\r\n+    public float Speed\r\n+    {\r\n+        get => moveSpeed;\r\n+        set => SetSpeed(value);\r\n+    }\r\n+    \r\n+    public void SetSpeed(float speed)\r\n+    {\r\n+        moveSpeed = Mathf.Clamp(speed, 0f, 20f);\r\n+    }\r\n+}\r\n+```\r\n+\r\n+## 特性组合使用示例\r\n+\r\n+### 完整的组件示例\r\n+**展示多个特性的组合使用，创建功能完整且用户友好的组件。**\r\n+\r\n+```csharp\r\n+[AddComponentMenu(\"游戏系统/高级玩家控制器\")]\r\n+[RequireComponent(typeof(Rigidbody))]\r\n+[RequireComponent(typeof(CapsuleCollider))]\r\n+[DisallowMultipleComponent]\r\n+[HelpURL(\"https://mygame.com/docs/player-controller\")]\r\n+public class AdvancedPlayerController : MonoBehaviour\r\n+{\r\n+    [Header(\"移动设置\")]\r\n+    [Tooltip(\"玩家移动速度\")]\r\n+    [Range(1f, 20f)]\r\n+    public float moveSpeed = 8f;\r\n+    \r\n+    [Tooltip(\"跳跃力度\")]\r\n+    [Range(5f, 30f)]\r\n+    public float jumpForce = 15f;\r\n+    \r\n+    [Space(10)]\r\n+    [Header(\"高级设置\")]\r\n+    [Tooltip(\"空中控制力度，0表示无法在空中控制\")]\r\n+    [Range(0f, 1f)]\r\n+    public float airControl = 0.3f;\r\n+    \r\n+    [SerializeField]\r\n+    [Tooltip(\"地面检测层级\")]\r\n+    private LayerMask groundLayer = 1;\r\n+    \r\n+    [Space(10)]\r\n+    [Header(\"音效设置\")]\r\n+    [Tooltip(\"脚步声音效\")]\r\n+    public AudioClip[] footstepSounds;\r\n+    \r\n+    [Tooltip(\"跳跃音效\")]\r\n+    public AudioClip jumpSound;\r\n+    \r\n+    [Tooltip(\"着陆音效\")]\r\n+    public AudioClip landSound;\r\n+    \r\n+    [Space(10)]\r\n+    [Header(\"调试信息\")]\r\n+    [SerializeField]\r\n+    [Tooltip(\"显示调试信息\")]\r\n+    private bool showDebugInfo = false;\r\n+    \r\n+    [HideInInspector]\r\n+    public bool isGrounded;\r\n+    \r\n+    [HideInInspector]\r\n+    public Vector3 velocity;\r\n+    \r\n+    // 私有字段\r\n+    private Rigidbody rb;\r\n+    private CapsuleCollider col;\r\n+    private AudioSource audioSource;\r\n+    \r\n+    [SerializeField]\r\n+    private float groundCheckDistance = 0.1f;\r\n+    \r\n+    void Start()\r\n+    {\r\n+        rb = GetComponent<Rigidbody>();\r\n+        col = GetComponent<CapsuleCollider>();\r\n+        audioSource = GetComponent<AudioSource>();\r\n+        \r\n+        if (audioSource == null)\r\n+        {\r\n+            audioSource = gameObject.AddComponent<AudioSource>();\r\n+        }\r\n+    }\r\n+    \r\n+    void Update()\r\n+    {\r\n+        CheckGrounded();\r\n+        HandleMovement();\r\n+        HandleJump();\r\n+        \r\n+        if (showDebugInfo)\r\n+        {\r\n+            DisplayDebugInfo();\r\n+        }\r\n+    }\r\n+    \r\n+    private void CheckGrounded()\r\n+    {\r\n+        Vector3 origin = transform.position + Vector3.up * 0.1f;\r\n+        isGrounded = Physics.Raycast(origin, Vector3.down, \r\n+            col.height * 0.5f + groundCheckDistance, groundLayer);\r\n+    }\r\n+    \r\n+    private void HandleMovement()\r\n+    {\r\n+        float horizontal = Input.GetAxis(\"Horizontal\");\r\n+        float vertical = Input.GetAxis(\"Vertical\");\r\n+        \r\n+        Vector3 movement = new Vector3(horizontal, 0, vertical).normalized;\r\n+        \r\n+        if (isGrounded)\r\n+        {\r\n+            rb.velocity = new Vector3(movement.x * moveSpeed, rb.velocity.y, movement.z * moveSpeed);\r\n+            \r\n+            // 播放脚步声\r\n+            if (movement.magnitude > 0.1f && footstepSounds.Length > 0)\r\n+            {\r\n+                PlayFootstepSound();\r\n+            }\r\n+        }\r\n+        else\r\n+        {\r\n+            // 空中控制\r\n+            Vector3 airMovement = movement * moveSpeed * airControl;\r\n+            rb.velocity = new Vector3(airMovement.x, rb.velocity.y, airMovement.z);\r\n+        }\r\n+        \r\n+        velocity = rb.velocity;\r\n+    }\r\n+    \r\n+    private void HandleJump()\r\n+    {\r\n+        if (Input.GetButtonDown(\"Jump\") && isGrounded)\r\n+        {\r\n+            rb.velocity = new Vector3(rb.velocity.x, jumpForce, rb.velocity.z);\r\n+            \r\n+            if (jumpSound != null)\r\n+            {\r\n+                audioSource.PlayOneShot(jumpSound);\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    private void PlayFootstepSound()\r\n+    {\r\n+        if (footstepSounds.Length > 0)\r\n+        {\r\n+            AudioClip clip = footstepSounds[Random.Range(0, footstepSounds.Length)];\r\n+            audioSource.PlayOneShot(clip, 0.5f);\r\n+        }\r\n+    }\r\n+    \r\n+    private void DisplayDebugInfo()\r\n+    {\r\n+        Debug.DrawRay(transform.position + Vector3.up * 0.1f, Vector3.down * \r\n+            (col.height * 0.5f + groundCheckDistance), isGrounded ? Color.green : Color.red);\r\n+    }\r\n+    \r\n+    [ContextMenu(\"重置为默认值\")]\r\n+    private void ResetToDefaults()\r\n+    {\r\n+        moveSpeed = 8f;\r\n+        jumpForce = 15f;\r\n+        airControl = 0.3f;\r\n+        groundLayer = 1;\r\n+        showDebugInfo = false;\r\n+    }\r\n+    \r\n+    [ContextMenu(\"测试跳跃\")]\r\n+    private void TestJump()\r\n+    {\r\n+        if (Application.isPlaying && isGrounded)\r\n+        {\r\n+            rb.velocity = new Vector3(rb.velocity.x, jumpForce, rb.velocity.z);\r\n+        }\r\n+    }\r\n+}\r\n+```\r\n+\r\n ## 总结\r\n \r\n Unity特性系统是扩展编辑器和定制组件行为的强大工具。通过合理使用特性，可以显著提升开发效率、改善编辑器体验并实现复杂的定制功能。特性的组合使用尤其重要，能够创建直观、便于使用的组件检视器和编辑工具。\r\n \r\n+### 关键要点：\r\n+\r\n+1. **界面优化**：使用`Header`、`Tooltip`、`Space`等特性改善Inspector布局\r\n+2. **数据控制**：通过`Range`、`SerializeField`、`HideInInspector`控制数据显示和编辑\r\n+3. **功能扩展**：利用`ContextMenu`、`MenuItem`添加便捷操作\r\n+4. **编辑器定制**：使用`CustomEditor`、`CustomPropertyDrawer`创建专业的编辑界面\r\n+5. **系统集成**：通过`RequireComponent`、`ExecuteInEditMode`等确保组件正确工作\r\n+6. **调试支持**：使用`DrawGizmo`、Gizmo方法提供可视化调试信息\r\n+\r\n 无论是使用Unity提供的内置特性，还是创建自定义特性，掌握特性系统都能使你的Unity开发流程更加高效和灵活。通过理解每个特性的用途和应用场景，你可以根据项目需求选择最合适的特性组合，创建出既直观又强大的工具和组件。 \n\\ No newline at end of file\n"
                },
                {
                    "date": 1748161398979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,81 @@\n # Unity特性(Attributes)详解\r\n \r\n+## 目录\r\n+\r\n+- [概述](#概述)\r\n+- [特性基础](#特性基础)\r\n+  - [AttributeUsage](#attributeusage)\r\n+  - [AttributeTargets](#attributetargets)\r\n+- [UML类图](#uml类图)\r\n+- [思维导图](#思维导图)\r\n+- [常用特性一览表](#常用特性一览表)\r\n+  - [编辑器界面特性](#编辑器界面特性)\r\n+    - [HeaderAttribute - 添加标题分组](#headerattribute---添加标题分组)\r\n+    - [TooltipAttribute - 添加悬停提示](#tooltipattribute---添加悬停提示)\r\n+    - [RangeAttribute - 范围滑动条](#rangeattribute---范围滑动条)\r\n+    - [SpaceAttribute - 添加间距](#spaceattribute---添加间距)\r\n+    - [TextAreaAttribute - 多行文本区域](#textareaattribute---多行文本区域)\r\n+    - [ColorUsageAttribute - 颜色选择器定制](#colorusageattribute---颜色选择器定制)\r\n+    - [MultilineAttribute - 多行输入框](#multilineattribute---多行输入框)\r\n+    - [DelayedAttribute - 延迟更新](#delayedattribute---延迟更新)\r\n+    - [InspectorNameAttribute - 自定义显示名称](#inspectornameattribute---自定义显示名称)\r\n+    - [GradientUsageAttribute - 渐变编辑器定制](#gradientusageattribute---渐变编辑器定制)\r\n+  - [序列化特性](#序列化特性)\r\n+    - [SerializeField - 序列化私有字段](#serializefield---序列化私有字段)\r\n+    - [NonSerialized - 阻止序列化](#nonserialized---阻止序列化)\r\n+    - [SerializeReference - 引用序列化](#serializereference---引用序列化)\r\n+    - [Serializable - 可序列化类](#serializable---可序列化类)\r\n+    - [FormerlySerializedAs - 保持序列化兼容性](#formerlyserializedas---保持序列化兼容性)\r\n+    - [PreferBinarySerialization - 二进制序列化](#preferbinaryserialization---二进制序列化)\r\n+  - [菜单特性](#菜单特性)\r\n+    - [MenuItem - 创建编辑器菜单项](#menuitem---创建编辑器菜单项)\r\n+    - [ContextMenu - 组件右键菜单](#contextmenu---组件右键菜单)\r\n+    - [ContextMenuItem - 字段右键菜单](#contextmenuitem---字段右键菜单)\r\n+    - [CreateAssetMenu - 创建资源菜单](#createassetmenu---创建资源菜单)\r\n+  - [组件相关特性](#组件相关特性)\r\n+    - [RequireComponent - 依赖组件](#requirecomponent---依赖组件)\r\n+    - [DisallowMultipleComponent - 禁止多组件](#disallowmultiplecomponent---禁止多组件)\r\n+    - [ExecuteInEditMode - 编辑模式执行](#executeineditmode---编辑模式执行)\r\n+    - [ExecuteAlways - 总是执行](#executealways---总是执行)\r\n+    - [AddComponentMenu - 组件菜单](#addcomponentmenu---组件菜单)\r\n+    - [HideInInspector - 隐藏字段](#hideininspector---隐藏字段)\r\n+    - [SelectionBase - 选择基础](#selectionbase---选择基础)\r\n+    - [DefaultExecutionOrder - 执行顺序](#defaultexecutionorder---执行顺序)\r\n+    - [Icon - 组件图标](#icon---组件图标)\r\n+  - [编辑器定制特性](#编辑器定制特性)\r\n+    - [CustomEditor - 自定义检视器](#customeditor---自定义检视器)\r\n+    - [CustomPropertyDrawer - 自定义属性绘制器](#custompropertydrawer---自定义属性绘制器)\r\n+    - [CanEditMultipleObjects - 多对象编辑](#caneditmultipleobjects---多对象编辑)\r\n+    - [InitializeOnLoad - 编辑器加载时初始化](#initializeonload---编辑器加载时初始化)\r\n+    - [InitializeOnLoadMethod - 编辑器加载时执行方法](#initializeonloadmethod---编辑器加载时执行方法)\r\n+    - [OnOpenAsset - 资源打开时执行](#onopenasset---资源打开时执行)\r\n+  - [Gizmo相关特性](#gizmo相关特性)\r\n+    - [DrawGizmo - 绘制场景Gizmo](#drawgizmo---绘制场景gizmo)\r\n+    - [自定义Gizmo图标](#自定义gizmo图标)\r\n+    - [高级Gizmo绘制示例](#高级gizmo绘制示例)\r\n+  - [设置相关特性](#设置相关特性)\r\n+    - [SettingsProvider - 创建设置提供者](#settingsprovider---创建设置提供者)\r\n+    - [UserSetting - 用户设置](#usersetting---用户设置)\r\n+    - [SettingsProviderGroup - 设置提供者组](#settingsprovidergroup---设置提供者组)\r\n+- [使用案例](#使用案例)\r\n+  - [案例1: 自定义组件检视器](#案例1-自定义组件检视器)\r\n+  - [案例2: 菜单扩展与编辑器工具](#案例2-菜单扩展与编辑器工具)\r\n+  - [案例3: 自定义属性绘制器](#案例3-自定义属性绘制器)\r\n+  - [案例4: Gizmo绘制与自定义图标](#案例4-gizmo绘制与自定义图标)\r\n+  - [案例5: 设置提供者](#案例5-设置提供者)\r\n+- [自定义特性的创建与使用](#自定义特性的创建与使用)\r\n+  - [创建自定义特性](#创建自定义特性)\r\n+  - [使用自定义特性](#使用自定义特性)\r\n+- [运行时特性详解](#运行时特性详解)\r\n+  - [RuntimeInitializeOnLoadMethod - 运行时初始化](#runtimeinitializeonloadmethod---运行时初始化)\r\n+  - [HelpURL - 帮助文档链接](#helpurl---帮助文档链接)\r\n+  - [Obsolete - 标记过时API](#obsolete---标记过时api)\r\n+- [特性组合使用示例](#特性组合使用示例)\r\n+  - [完整的组件示例](#完整的组件示例)\r\n+- [特性使用最佳实践](#特性使用最佳实践)\r\n+- [总结](#总结)\r\n+\r\n ## 概述\r\n \r\n Unity的特性(Attributes)系统是扩展编辑器和控制组件行为的强大工具。通过特性，开发者可以自定义Inspector界面、控制序列化行为、定义菜单项和调整编译设置等。本文档详细介绍Unity特性系统的架构、常用特性及其应用场景。\r\n \r\n"
                }
            ],
            "date": 1746867746423,
            "name": "Commit-0",
            "content": "# Unity特性(Attributes)详解\r\n\r\n## 概述\r\n\r\nUnity的特性(Attributes)系统是扩展编辑器和控制组件行为的强大工具。通过特性，开发者可以自定义Inspector界面、控制序列化行为、定义菜单项和调整编译设置等。本文档详细介绍Unity特性系统的架构、常用特性及其应用场景。\r\n\r\n## 特性基础\r\n\r\n特性(Attributes)是一种向代码添加元数据的机制，通过方括号`[]`标记。Unity使用这些元数据来修改编辑器行为或运行时行为，无需开发者编写额外的功能代码。\r\n\r\n```csharp\r\n[SerializeField] // 这是一个特性，使私有字段在Inspector中可见\r\nprivate int myPrivateVariable;\r\n```\r\n\r\n## UML类图\r\n\r\n```\r\n+---------------------------+\r\n|        Attribute          | <-- C#基类\r\n+---------------------------+\r\n| + AttributeTargets        |\r\n| + AllowMultiple           |\r\n+---------------------------+\r\n             ^\r\n             |\r\n+---------------------------+       +----------------------------+\r\n|    PropertyAttribute      | <---- |       CustomEditor         |\r\n+---------------------------+       +----------------------------+\r\n| + order                   |       | + inspectedType            |\r\n+--------------^------------+       | + editorForChildClasses    |\r\n               |                    +----------------------------+\r\n               |                    | + OnInspectorGUI()         |\r\n     +---------+----------+         +----------------------------+\r\n     |                    |\r\n+----------------+  +------------------+\r\n|    RangeAttribute |  | HeaderAttribute |\r\n+----------------+  +------------------+\r\n| + min          |  | + header         |\r\n| + max          |  +------------------+\r\n+----------------+\r\n     \r\n+---------------------------+       +---------------------------+\r\n|      ContextMenuItem      |       |      InitializeOnLoad     |\r\n+---------------------------+       +---------------------------+\r\n| + name                    |       |                           |\r\n| + function                |       |                           |\r\n+---------------------------+       +---------------------------+\r\n\r\n+---------------------------+       +---------------------------+\r\n|        MenuItem           |       |    ExecuteInEditMode      |\r\n+---------------------------+       +---------------------------+\r\n| + itemName                |       |                           |\r\n| + validate                |       |                           |\r\n+---------------------------+       +---------------------------+\r\n```\r\n\r\n## 思维导图\r\n\r\n```\r\nUnity特性系统\r\n├── 编辑器特性\r\n│   ├── 界面相关\r\n│   │   ├── HeaderAttribute - 添加标题\r\n│   │   ├── SpaceAttribute - 添加空间\r\n│   │   ├── TooltipAttribute - 添加提示\r\n│   │   ├── TextAreaAttribute - 多行文本\r\n│   │   ├── ColorUsageAttribute - 颜色选择器\r\n│   │   ├── RangeAttribute - 范围滑动条\r\n│   │   ├── MultilineAttribute - 多行输入\r\n│   │   └── DelayedAttribute - 延迟输入\r\n│   ├── 菜单相关\r\n│   │   ├── MenuItem - 创建菜单项\r\n│   │   ├── ContextMenu - 右键菜单\r\n│   │   ├── ContextMenuItem - 右键菜单项\r\n│   │   └── CreateAssetMenu - 创建资源菜单\r\n│   ├── 编辑器初始化\r\n│   │   ├── InitializeOnLoad - 编辑器加载时执行\r\n│   │   ├── InitializeOnLoadMethod - 编辑器加载时执行方法\r\n│   │   └── DidReloadScripts - 脚本重新加载时执行\r\n│   └── 自定义编辑器\r\n│       ├── CustomEditor - 自定义检视器\r\n│       ├── CanEditMultipleObjects - 可编辑多对象\r\n│       └── CustomPropertyDrawer - 自定义属性绘制器\r\n├── 运行时特性\r\n│   ├── 序列化相关\r\n│   │   ├── SerializeField - 序列化私有字段\r\n│   │   ├── NonSerialized - 不序列化\r\n│   │   ├── SerializeReference - 引用序列化\r\n│   │   └── Serializable - 可序列化类\r\n│   ├── 组件相关\r\n│   │   ├── RequireComponent - 需要组件\r\n│   │   ├── DisallowMultipleComponent - 禁止多组件\r\n│   │   ├── AddComponentMenu - 添加组件菜单\r\n│   │   └── HideInInspector - 在检视器中隐藏\r\n│   ├── 执行相关\r\n│   │   ├── ExecuteInEditMode - 编辑模式执行\r\n│   │   ├── ExecuteAlways - 总是执行\r\n│   │   └── RuntimeInitializeOnLoadMethod - 运行时初始化\r\n│   └── 场景相关\r\n│       ├── SelectionBase - 选择基础\r\n│       └── PreferBinarySerialization - 偏好二进制序列化\r\n└── API相关特性\r\n    ├── 可见性控制\r\n    │   ├── HideInInspector - 隐藏\r\n    │   ├── FormerlySerializedAs - 曾序列化为\r\n    │   └── ShowInInspector - 在检视器中显示\r\n    ├── 弃用与兼容性\r\n    │   ├── Obsolete - 过时\r\n    │   └── HelpURL - 帮助URL\r\n    └── 其他\r\n        ├── AssemblyIsEditorAssembly - 编辑器程序集\r\n        └── GUITarget - GUI目标\r\n```\r\n\r\n## 常用特性一览表\r\n\r\n### 编辑器界面特性\r\n\r\n| 特性名称 | 应用目标 | 描述 | 示例 |\r\n|---------|---------|------|------|\r\n| **HeaderAttribute** | 字段 | 在Inspector中添加标题 | `[Header(\"Player Settings\")]` |\r\n| **TooltipAttribute** | 字段 | 添加鼠标悬停提示 | `[Tooltip(\"Player's movement speed\")]` |\r\n| **RangeAttribute** | 数值字段 | 限制数值范围并显示滑动条 | `[Range(0, 100)]` |\r\n| **SpaceAttribute** | 字段 | 在Inspector中添加空间 | `[Space(10)]` |\r\n| **TextAreaAttribute** | 字符串字段 | 显示多行文本区域 | `[TextArea(3, 10)]` |\r\n| **ColorUsageAttribute** | Color字段 | 自定义颜色选择器 | `[ColorUsage(true, true)]` |\r\n| **MultilineAttribute** | 字符串字段 | 显示多行输入框 | `[Multiline(3)]` |\r\n| **DelayedAttribute** | 值类型字段 | 延迟更新值 | `[Delayed]` |\r\n\r\n### 序列化特性\r\n\r\n| 特性名称 | 应用目标 | 描述 | 示例 |\r\n|---------|---------|------|------|\r\n| **SerializeField** | 私有字段 | 使私有字段可在Inspector中显示 | `[SerializeField]` |\r\n| **NonSerialized** | 公有字段 | 阻止字段序列化 | `[System.NonSerialized]` |\r\n| **SerializeReference** | 引用类型 | 序列化对象引用而非对象本身 | `[SerializeReference]` |\r\n| **Serializable** | 类 | 标记类为可序列化 | `[System.Serializable]` |\r\n\r\n### 菜单特性\r\n\r\n| 特性名称 | 应用目标 | 描述 | 示例 |\r\n|---------|---------|------|------|\r\n| **MenuItem** | 静态方法 | 创建菜单项 | `[MenuItem(\"Tools/Reset Transform\")]` |\r\n| **ContextMenu** | 方法 | 为组件添加右键菜单项 | `[ContextMenu(\"Reset\")]` |\r\n| **ContextMenuItem** | 字段 | 为字段添加右键菜单项 | `[ContextMenuItem(\"Reset\", \"ResetValue\")]` |\r\n| **CreateAssetMenu** | 类 | 在\"Create\"菜单中添加选项 | `[CreateAssetMenu(fileName = \"New Data\", menuName = \"Game/Data\")]` |\r\n\r\n### 组件相关特性\r\n\r\n| 特性名称 | 应用目标 | 描述 | 示例 |\r\n|---------|---------|------|------|\r\n| **RequireComponent** | 类 | 添加依赖组件 | `[RequireComponent(typeof(Rigidbody))]` |\r\n| **DisallowMultipleComponent** | 类 | 禁止多个相同组件 | `[DisallowMultipleComponent]` |\r\n| **ExecuteInEditMode** | 类 | 在编辑模式下执行 | `[ExecuteInEditMode]` |\r\n| **ExecuteAlways** | 类 | 在编辑和运行模式下执行 | `[ExecuteAlways]` |\r\n| **AddComponentMenu** | 类 | 添加到组件菜单 | `[AddComponentMenu(\"Custom/MyComponent\")]` |\r\n| **HideInInspector** | 字段 | 在Inspector中隐藏字段 | `[HideInInspector]` |\r\n| **SelectionBase** | 类 | 设为场景选择基础 | `[SelectionBase]` |\r\n\r\n### 编辑器定制特性\r\n\r\n| 特性名称 | 应用目标 | 描述 | 示例 |\r\n|---------|---------|------|------|\r\n| **CustomEditor** | 编辑器类 | 自定义Inspector | `[CustomEditor(typeof(MyComponent))]` |\r\n| **CustomPropertyDrawer** | 属性绘制类 | 自定义属性绘制 | `[CustomPropertyDrawer(typeof(MyClass))]` |\r\n| **CanEditMultipleObjects** | 编辑器类 | 支持多对象编辑 | `[CanEditMultipleObjects]` |\r\n| **InitializeOnLoad** | 类 | 编辑器加载时初始化 | `[InitializeOnLoad]` |\r\n| **InitializeOnLoadMethod** | 静态方法 | 编辑器加载时执行方法 | `[InitializeOnLoadMethod]` |\r\n| **OnOpenAsset** | 静态方法 | 资源打开时执行 | `[OnOpenAsset]` |\r\n\r\n## 使用案例\r\n\r\n### 案例1: 自定义组件检视器\r\n\r\n```csharp\r\n// 组件定义\r\npublic class PlayerController : MonoBehaviour\r\n{\r\n    [Header(\"Movement Settings\")]\r\n    [Tooltip(\"Player movement speed in units per second\")]\r\n    [Range(1, 20)]\r\n    public float moveSpeed = 5f;\r\n    \r\n    [Header(\"Jump Settings\")]\r\n    [Tooltip(\"Jump force applied to the player\")]\r\n    public float jumpForce = 10f;\r\n    \r\n    [Space(10)]\r\n    [Header(\"Advanced Settings\")]\r\n    [SerializeField]\r\n    private bool useGravity = true;\r\n    \r\n    [TextArea(3, 5)]\r\n    public string playerDescription = \"Default player character\";\r\n    \r\n    [ContextMenu(\"Reset Values\")]\r\n    void ResetValues()\r\n    {\r\n        moveSpeed = 5f;\r\n        jumpForce = 10f;\r\n        useGravity = true;\r\n    }\r\n}\r\n\r\n// 自定义检视器\r\n[CustomEditor(typeof(PlayerController))]\r\n[CanEditMultipleObjects]\r\npublic class PlayerControllerEditor : Editor\r\n{\r\n    public override void OnInspectorGUI()\r\n    {\r\n        PlayerController player = (PlayerController)target;\r\n        \r\n        EditorGUILayout.LabelField(\"Player Stats Overview\", EditorStyles.boldLabel);\r\n        \r\n        EditorGUI.BeginChangeCheck();\r\n        // 绘制默认检视器\r\n        DrawDefaultInspector();\r\n        \r\n        // 添加自定义按钮\r\n        if(GUILayout.Button(\"Test Jump\"))\r\n        {\r\n            // 执行测试跳跃逻辑\r\n        }\r\n        \r\n        if(EditorGUI.EndChangeCheck())\r\n        {\r\n            Undo.RecordObject(player, \"Changed Player Settings\");\r\n            // 处理更改\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 案例2: 菜单扩展与编辑器工具\r\n\r\n```csharp\r\npublic static class EditorTools\r\n{\r\n    [MenuItem(\"Tools/Reset Scene Objects\")]\r\n    private static void ResetSceneObjects()\r\n    {\r\n        GameObject[] objects = Selection.gameObjects;\r\n        foreach(GameObject obj in objects)\r\n        {\r\n            Undo.RecordObject(obj.transform, \"Reset Transform\");\r\n            obj.transform.position = Vector3.zero;\r\n            obj.transform.rotation = Quaternion.identity;\r\n            obj.transform.localScale = Vector3.one;\r\n        }\r\n    }\r\n    \r\n    [MenuItem(\"Tools/Reset Scene Objects\", true)]\r\n    private static bool ValidateResetSceneObjects()\r\n    {\r\n        return Selection.gameObjects.Length > 0;\r\n    }\r\n    \r\n    [InitializeOnLoadMethod]\r\n    private static void OnProjectLoaded()\r\n    {\r\n        Debug.Log(\"Project loaded in editor\");\r\n        EditorApplication.hierarchyChanged += OnHierarchyChanged;\r\n    }\r\n    \r\n    private static void OnHierarchyChanged()\r\n    {\r\n        // 响应层级视图变化\r\n    }\r\n}\r\n```\r\n\r\n### 案例3: 自定义属性绘制器\r\n\r\n```csharp\r\n// 自定义序列化字段\r\n[System.Serializable]\r\npublic class FloatRange\r\n{\r\n    public float min = 0;\r\n    public float max = 1;\r\n    \r\n    public FloatRange(float min, float max)\r\n    {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    \r\n    public float GetRandomValue()\r\n    {\r\n        return Random.Range(min, max);\r\n    }\r\n}\r\n\r\n// 自定义属性绘制器\r\n[CustomPropertyDrawer(typeof(FloatRange))]\r\npublic class FloatRangeDrawer : PropertyDrawer\r\n{\r\n    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\r\n    {\r\n        EditorGUI.BeginProperty(position, label, property);\r\n        \r\n        position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);\r\n        \r\n        var minProp = property.FindPropertyRelative(\"min\");\r\n        var maxProp = property.FindPropertyRelative(\"max\");\r\n        \r\n        var minValue = minProp.floatValue;\r\n        var maxValue = maxProp.floatValue;\r\n        \r\n        float rangeMin = 0;\r\n        float rangeMax = 10;\r\n        \r\n        var rangeBounds = new Rect(position);\r\n        rangeBounds.width = position.width;\r\n        \r\n        EditorGUI.MinMaxSlider(rangeBounds, ref minValue, ref maxValue, rangeMin, rangeMax);\r\n        \r\n        var minRect = new Rect(position);\r\n        minRect.width = 50;\r\n        position.xMin += 55;\r\n        \r\n        var maxRect = new Rect(position);\r\n        maxRect.width = 50;\r\n        position.xMin += 55;\r\n        \r\n        minValue = EditorGUI.FloatField(minRect, minValue);\r\n        maxValue = EditorGUI.FloatField(maxRect, maxValue);\r\n        \r\n        minProp.floatValue = minValue;\r\n        maxProp.floatValue = maxValue;\r\n        \r\n        EditorGUI.EndProperty();\r\n    }\r\n}\r\n```\r\n\r\n## 特性使用最佳实践\r\n\r\n1. **组合使用特性**：多个特性可以组合使用，如`[SerializeField]`和`[Range(0,100)]`\r\n\r\n2. **顺序与分组**：使用`Header`和`Space`特性合理组织Inspector界面，提高可读性\r\n\r\n3. **编写自定义特性**：继承`PropertyAttribute`和`PropertyDrawer`可创建自定义特性\r\n\r\n4. **性能考虑**：`ExecuteInEditMode`和`InitializeOnLoad`特性可能影响编辑器性能，应谨慎使用\r\n\r\n5. **特性继承**：特性不会被继承，需要为每个类单独添加特性\r\n\r\n## 总结\r\n\r\nUnity特性系统是扩展编辑器和定制组件行为的强大工具。通过合理使用特性，可以显著提升开发效率、改善编辑器体验并实现复杂的定制功能。特性的组合使用尤其重要，能够创建直观、便于使用的组件检视器和编辑工具。 "
        }
    ]
}