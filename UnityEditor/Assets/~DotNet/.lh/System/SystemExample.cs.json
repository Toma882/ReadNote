{
    "sourceFile": "System/SystemExample.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1761989152019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761989168473,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,8 +321,174 @@\n                 Debug.LogError($\"Convert示例出错: {ex.Message}\");\n             }\n         }\n \n+        // ================= Span 内存切片 =================\n+        /// <summary>\n+        /// Span内存切片常用API演示\n+        /// 包含数组切片、字符串切片、栈分配、零拷贝操作等\n+        /// 注意：Span<T> 是 ref struct，只能在栈上使用，不能作为泛型类型参数\n+        /// </summary>\n+        private void SpanExample()\n+        {\n+            Debug.Log(\"--- Span 内存切片示例 ---\");\n+            \n+            try\n+            {\n+                // ========== 数组切片 ==========\n+                int[] array = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+                Debug.Log($\"原始数组: [{string.Join(\", \", array)}]\");\n+                \n+                // 创建 Span（零拷贝，直接引用原数组）\n+                Span<int> span = array.AsSpan();\n+                Debug.Log($\"完整 Span: [{string.Join(\", \", span.ToArray())}]\");\n+                \n+                // 切片操作（不复制数据，只是改变视图）\n+                Span<int> slice1 = span.Slice(2, 5);  // 从索引2开始，长度5\n+                Debug.Log($\"切片 [2:7]: [{string.Join(\", \", slice1.ToArray())}]\");\n+                \n+                // 修改 Span 会影响原数组\n+                slice1[0] = 100;\n+                Debug.Log($\"修改切片后原数组: [{string.Join(\", \", array)}]\");\n+                \n+                // ========== 字符串切片 ==========\n+                string text = \"Hello, World!\";\n+                ReadOnlySpan<char> textSpan = text.AsSpan();\n+                Debug.Log($\"原始字符串: {text}\");\n+                Debug.Log($\"Span 长度: {textSpan.Length}\");\n+                \n+                // 字符串切片（ReadOnlySpan，因为字符串不可变）\n+                ReadOnlySpan<char> hello = textSpan.Slice(0, 5);\n+                ReadOnlySpan<char> world = textSpan.Slice(7, 5);\n+                \n+                Debug.Log($\"'Hello' 切片: {hello.ToString()}\");\n+                Debug.Log($\"'World' 切片: {world.ToString()}\");\n+                \n+                // ========== 栈分配 Span（Stackalloc） ==========\n+                // 在栈上分配内存，避免堆分配\n+                Span<int> stackAllocSpan = stackalloc int[10];\n+                for (int i = 0; i < stackAllocSpan.Length; i++)\n+                {\n+                    stackAllocSpan[i] = i * 2;\n+                }\n+                Debug.Log($\"栈分配 Span: [{string.Join(\", \", stackAllocSpan.ToArray())}]\");\n+                \n+                // ========== Span 和 ReadOnlySpan 区别 ==========\n+                int[] readOnlyArray = { 10, 20, 30, 40, 50 };\n+                ReadOnlySpan<int> readOnlySpan = readOnlyArray;\n+                \n+                Debug.Log($\"ReadOnlySpan 值: [{string.Join(\", \", readOnlySpan.ToArray())}]\");\n+                // readOnlySpan[0] = 100;  // 编译错误：ReadOnlySpan 是只读的\n+                \n+                // ========== 性能优势：零拷贝操作 ==========\n+                byte[] largeArray = new byte[1000];\n+                for (int i = 0; i < largeArray.Length; i++)\n+                {\n+                    largeArray[i] = (byte)(i % 256);\n+                }\n+                \n+                // 使用 Span 切片（不复制）\n+                Span<byte> largeSpan = largeArray.AsSpan();\n+                Span<byte> middleSlice = largeSpan.Slice(100, 200);\n+                Debug.Log($\"大数组中间切片长度: {middleSlice.Length} (零拷贝)\");\n+                \n+                // ========== Span 边界检查 ==========\n+                try\n+                {\n+                    Span<int> testSpan = array.AsSpan();\n+                    Debug.Log(\"Span 具有边界检查，访问越界会抛出异常\");\n+                    Debug.Log($\"Span 有效长度: {testSpan.Length}\");\n+                    // testSpan[100] = 999;  // 会抛出 IndexOutOfRangeException\n+                }\n+                catch (IndexOutOfRangeException ex)\n+                {\n+                    Debug.LogError($\"Span 边界检查异常: {ex.Message}\");\n+                }\n+                \n+                // ========== Span 作为方法参数 ==========\n+                int sum = CalculateSum(span);\n+                Debug.Log($\"Span 求和结果: {sum}\");\n+                \n+                bool contains = ContainsValue(readOnlySpan, 30);\n+                Debug.Log($\"ReadOnlySpan 是否包含30: {contains}\");\n+                \n+                // ========== Span 转换 ==========\n+                // Span 转数组（会复制）\n+                int[] spanToArray = span.ToArray();\n+                Debug.Log($\"Span 转数组: [{string.Join(\", \", spanToArray)}]\");\n+                \n+                // ========== 字符串解析示例 ==========\n+                string numbers = \"1,2,3,4,5,6,7,8,9,10\";\n+                ReadOnlySpan<char> numbersSpan = numbers.AsSpan();\n+                \n+                List<int> parsedNumbers = new List<int>();\n+                int start = 0;\n+                for (int i = 0; i < numbersSpan.Length; i++)\n+                {\n+                    if (numbersSpan[i] == ',' || i == numbersSpan.Length - 1)\n+                    {\n+                        int end = i == numbersSpan.Length - 1 ? numbersSpan.Length : i;\n+                        ReadOnlySpan<char> numberSpan = numbersSpan.Slice(start, end - start);\n+                        if (int.TryParse(numberSpan, out int number))\n+                        {\n+                            parsedNumbers.Add(number);\n+                        }\n+                        start = i + 1;\n+                    }\n+                }\n+                Debug.Log($\"解析字符串: [{string.Join(\", \", parsedNumbers)}]\");\n+                \n+                // ========== Span 比较操作 ==========\n+                int[] array1 = { 1, 2, 3, 4, 5 };\n+                int[] array2 = { 1, 2, 3, 4, 5 };\n+                Span<int> span1 = array1.AsSpan();\n+                Span<int> span2 = array2.AsSpan();\n+                \n+                bool sequenceEqual = span1.SequenceEqual(span2);\n+                Debug.Log($\"两个 Span 序列是否相等: {sequenceEqual}\");\n+                \n+                // ========== Span 查找操作 ==========\n+                int[] searchArray = { 10, 20, 30, 40, 50, 30, 60 };\n+                Span<int> searchSpan = searchArray.AsSpan();\n+                \n+                int index = searchSpan.IndexOf(30);\n+                Debug.Log($\"查找值30的索引: {index}\");\n+                \n+                int lastIndex = searchSpan.LastIndexOf(30);\n+                Debug.Log($\"查找值30的最后索引: {lastIndex}\");\n+                \n+                bool containsValue = searchSpan.Contains(40);\n+                Debug.Log($\"Span 是否包含40: {containsValue}\");\n+                \n+                // ========== Span 填充和复制 ==========\n+                Span<int> fillSpan = array.AsSpan();\n+                fillSpan.Fill(999);\n+                Debug.Log($\"填充后的数组: [{string.Join(\", \", array)}]\");\n+                \n+                // 恢复原值\n+                int[] original = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+                original.CopyTo(array);\n+                \n+                // Span 复制\n+                int[] source = { 100, 200, 300 };\n+                int[] destination = new int[5];\n+                source.AsSpan().CopyTo(destination.AsSpan());\n+                Debug.Log($\"复制后的目标数组: [{string.Join(\", \", destination)}]\");\n+                \n+                // ========== 注意事项 ==========\n+                Debug.LogWarning(\"⚠️ Span 使用注意事项：\");\n+                Debug.LogWarning(\"1. Span<T> 是 ref struct，只能在栈上使用\");\n+                Debug.LogWarning(\"2. 不能作为类的字段、数组元素、泛型类型参数\");\n+                Debug.LogWarning(\"3. 不能在异步方法中使用\");\n+                Debug.LogWarning(\"4. 不能装箱\");\n+                Debug.LogWarning(\"5. Unity 2022 中 Transform/GameObject 等类新增了 Span 重载，但 ToLua# 无法绑定\");\n+            }\n+            catch (Exception ex)\n+            {\n+                Debug.LogError($\"Span示例出错: {ex.Message}\");\n+            }\n+        }\n+        \n         // ================= GC 垃圾回收 =================\n         /// <summary>\n         /// GC垃圾回收常用API演示\n         /// 包含内存监控、垃圾回收控制、弱引用等操作\n"
                },
                {
                    "date": 1761989173753,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1072,8 +1072,36 @@\n         {\n             Debug.Log($\"属性 {e.PropertyName} 发生变化\");\n         }\n         \n+        // ================= Span 辅助方法 =================\n+        \n+        /// <summary>\n+        /// Span 作为方法参数的示例：计算 Span 中所有元素的和\n+        /// </summary>\n+        private int CalculateSum(Span<int> span)\n+        {\n+            int sum = 0;\n+            foreach (int value in span)\n+            {\n+                sum += value;\n+            }\n+            return sum;\n+        }\n+        \n+        /// <summary>\n+        /// ReadOnlySpan 作为方法参数的示例：检查是否包含指定值\n+        /// </summary>\n+        private bool ContainsValue(ReadOnlySpan<int> span, int value)\n+        {\n+            foreach (int item in span)\n+            {\n+                if (item == value)\n+                    return true;\n+            }\n+            return false;\n+        }\n+        \n         // 自定义颜色转换器\n         private class ColorConverter : TypeConverter\n         {\n             public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)\n"
                },
                {
                    "date": 1762517028203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,8 +52,9 @@\n             DiagnosticsExample();\n             SecurityExample();\n             GlobalizationExample();\n             ComponentModelExample();\n+            AppDomainExample();\n             Debug.Log(\"=== .NET System API示例结束 ===\");\n         }\n \n         // ================= Math 数学运算 =================\n"
                },
                {
                    "date": 1762517065145,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1067,8 +1067,273 @@\n                 Debug.LogError($\"ComponentModel示例出错: {ex.Message}\");\n             }\n         }\n         \n+        // ================= AppDomain 应用程序域 =================\n+        /// <summary>\n+        /// AppDomain应用程序域常用API演示\n+        /// 包含程序集查询、类型查找、反射操作等\n+        /// AppDomain 是 .NET 中应用程序的隔离边界，用于加载和执行程序集\n+        /// </summary>\n+        private void AppDomainExample()\n+        {\n+            Debug.Log(\"--- AppDomain 应用程序域示例 ---\");\n+            \n+            try\n+            {\n+                // ========== 获取当前应用程序域 ==========\n+                AppDomain currentDomain = AppDomain.CurrentDomain;\n+                Debug.Log($\"当前应用程序域名称: {currentDomain.FriendlyName}\");\n+                Debug.Log($\"应用程序域ID: {currentDomain.Id}\");\n+                Debug.Log($\"基础目录: {currentDomain.BaseDirectory}\");\n+                Debug.Log($\"相对搜索路径: {currentDomain.RelativeSearchPath}\");\n+                \n+                // ========== 获取所有已加载的程序集 ==========\n+                // GetAssemblies() 返回当前应用程序域中所有已加载的程序集\n+                // 这是反射操作中最常用的方法之一，用于查找类型、方法等\n+                Assembly[] assemblies = currentDomain.GetAssemblies();\n+                Debug.Log($\"已加载的程序集总数: {assemblies.Length}\");\n+                \n+                // 显示前10个程序集信息\n+                Debug.Log(\"--- 前10个程序集信息 ---\");\n+                for (int i = 0; i < Math.Min(10, assemblies.Length); i++)\n+                {\n+                    Assembly assembly = assemblies[i];\n+                    Debug.Log($\"程序集 {i + 1}: {assembly.GetName().Name}\");\n+                    Debug.Log($\"  完整名称: {assembly.FullName}\");\n+                    Debug.Log($\"  位置: {assembly.Location}\");\n+                    Debug.Log($\"  是否动态: {assembly.IsDynamic}\");\n+                }\n+                \n+                // ========== 按名称查找程序集 ==========\n+                // 查找特定程序集\n+                Assembly[] unityAssemblies = assemblies.Where(a => \n+                    a.GetName().Name.Contains(\"UnityEngine\") || \n+                    a.GetName().Name.Contains(\"Unity\")).ToArray();\n+                Debug.Log($\"Unity相关程序集数量: {unityAssemblies.Length}\");\n+                \n+                foreach (var unityAssembly in unityAssemblies.Take(5))\n+                {\n+                    Debug.Log($\"  - {unityAssembly.GetName().Name}\");\n+                }\n+                \n+                // ========== 从程序集中查找类型 ==========\n+                Debug.Log(\"--- 类型查找示例 ---\");\n+                \n+                // 方法1: 遍历所有程序集查找类型\n+                string targetTypeName = \"System.String\";\n+                Type foundType = null;\n+                \n+                foreach (Assembly assembly in assemblies)\n+                {\n+                    try\n+                    {\n+                        foundType = assembly.GetType(targetTypeName);\n+                        if (foundType != null)\n+                        {\n+                            Debug.Log($\"找到类型 {targetTypeName} 在程序集: {assembly.GetName().Name}\");\n+                            break;\n+                        }\n+                    }\n+                    catch\n+                    {\n+                        // 忽略无法加载的程序集\n+                    }\n+                }\n+                \n+                // 方法2: 使用 Type.GetType (更常用)\n+                Type stringType = Type.GetType(targetTypeName);\n+                if (stringType != null)\n+                {\n+                    Debug.Log($\"Type.GetType 找到类型: {stringType.Name}\");\n+                }\n+                \n+                // ========== 查找命名空间下的所有类型 ==========\n+                Debug.Log(\"--- 查找命名空间下的类型 ---\");\n+                string targetNamespace = \"UnityEngine\";\n+                int typeCount = 0;\n+                \n+                foreach (Assembly assembly in assemblies)\n+                {\n+                    try\n+                    {\n+                        Type[] types = assembly.GetTypes();\n+                        var namespaceTypes = types.Where(t => \n+                            t.Namespace == targetNamespace && \n+                            t.IsPublic && \n+                            !t.IsAbstract).Take(10);\n+                        \n+                        foreach (var type in namespaceTypes)\n+                        {\n+                            Debug.Log($\"  {targetNamespace}.{type.Name}\");\n+                            typeCount++;\n+                        }\n+                    }\n+                    catch (ReflectionTypeLoadException ex)\n+                    {\n+                        // 某些程序集可能无法完全加载，只加载可用的类型\n+                        if (ex.Types != null)\n+                        {\n+                            foreach (var type in ex.Types.Where(t => t != null && t.Namespace == targetNamespace).Take(10))\n+                            {\n+                                Debug.Log($\"  {targetNamespace}.{type.Name}\");\n+                                typeCount++;\n+                            }\n+                        }\n+                    }\n+                    catch\n+                    {\n+                        // 忽略其他错误\n+                    }\n+                }\n+                Debug.Log($\"找到 {targetNamespace} 命名空间下的类型数量: {typeCount}\");\n+                \n+                // ========== 查找实现特定接口或继承特定基类的类型 ==========\n+                Debug.Log(\"--- 查找继承特定基类的类型 ---\");\n+                Type componentBaseType = typeof(Component);\n+                int componentTypeCount = 0;\n+                \n+                foreach (Assembly assembly in assemblies)\n+                {\n+                    try\n+                    {\n+                        Type[] types = assembly.GetTypes();\n+                        var componentTypes = types.Where(t => \n+                            componentBaseType.IsAssignableFrom(t) && \n+                            !t.IsAbstract && \n+                            t.IsClass).Take(5);\n+                        \n+                        foreach (var type in componentTypes)\n+                        {\n+                            Debug.Log($\"  继承Component的类型: {type.Name}\");\n+                            componentTypeCount++;\n+                        }\n+                    }\n+                    catch\n+                    {\n+                        // 忽略错误\n+                    }\n+                }\n+                Debug.Log($\"找到继承Component的类型总数: {componentTypeCount}\");\n+                \n+                // ========== 程序集信息查询 ==========\n+                Debug.Log(\"--- 程序集详细信息 ---\");\n+                Assembly mscorlib = assemblies.FirstOrDefault(a => a.GetName().Name == \"mscorlib\");\n+                if (mscorlib != null)\n+                {\n+                    AssemblyName assemblyName = mscorlib.GetName();\n+                    Debug.Log($\"程序集名称: {assemblyName.Name}\");\n+                    Debug.Log($\"版本: {assemblyName.Version}\");\n+                    Debug.Log($\"公钥标记: {BitConverter.ToString(assemblyName.GetPublicKeyToken())}\");\n+                    Debug.Log($\"文化信息: {assemblyName.CultureInfo?.Name ?? \"中性\"}\");\n+                }\n+                \n+                // ========== 查找特定方法 ==========\n+                Debug.Log(\"--- 查找特定方法 ---\");\n+                Type mathType = typeof(Math);\n+                MethodInfo[] mathMethods = mathType.GetMethods(BindingFlags.Public | BindingFlags.Static);\n+                Debug.Log($\"Math类的公共静态方法数量: {mathMethods.Length}\");\n+                \n+                // 查找包含特定名称的方法\n+                var sqrtMethods = mathMethods.Where(m => m.Name.Contains(\"Sqrt\")).Take(3);\n+                foreach (var method in sqrtMethods)\n+                {\n+                    Debug.Log($\"  Math.{method.Name}({string.Join(\", \", method.GetParameters().Select(p => p.ParameterType.Name))})\");\n+                }\n+                \n+                // ========== 程序集加载事件 ==========\n+                Debug.Log(\"--- 程序集加载事件 ---\");\n+                // 注意：在 Unity 中，程序集加载事件可能不会按预期触发\n+                // 因为 Unity 使用自己的程序集加载机制\n+                currentDomain.AssemblyLoad += OnAssemblyLoad;\n+                Debug.Log(\"已注册程序集加载事件处理器\");\n+                \n+                // ========== 动态加载程序集（示例） ==========\n+                Debug.Log(\"--- 动态加载程序集 ---\");\n+                // 注意：在 Unity 中，动态加载程序集需要使用 Assembly.LoadFrom 或 Assembly.LoadFile\n+                // 但通常 Unity 会自动加载所有程序集，所以很少需要手动加载\n+                \n+                // 查找当前程序集\n+                Assembly currentAssembly = Assembly.GetExecutingAssembly();\n+                Debug.Log($\"当前执行程序集: {currentAssembly.GetName().Name}\");\n+                Debug.Log($\"当前程序集位置: {currentAssembly.Location}\");\n+                \n+                // ========== 程序集依赖关系 ==========\n+                Debug.Log(\"--- 程序集引用关系 ---\");\n+                AssemblyName[] referencedAssemblies = currentAssembly.GetReferencedAssemblies();\n+                Debug.Log($\"当前程序集引用的程序集数量: {referencedAssemblies.Length}\");\n+                \n+                foreach (var refAssembly in referencedAssemblies.Take(5))\n+                {\n+                    Debug.Log($\"  引用: {refAssembly.Name} v{refAssembly.Version}\");\n+                }\n+                \n+                // ========== 查找自定义特性 ==========\n+                Debug.Log(\"--- 查找程序集特性 ---\");\n+                object[] attributes = currentAssembly.GetCustomAttributes(false);\n+                Debug.Log($\"当前程序集的自定义特性数量: {attributes.Length}\");\n+                \n+                foreach (var attr in attributes.Take(5))\n+                {\n+                    Debug.Log($\"  特性: {attr.GetType().Name}\");\n+                }\n+                \n+                // ========== 性能考虑 ==========\n+                Debug.LogWarning(\"⚠️ AppDomain.GetAssemblies() 使用注意事项：\");\n+                Debug.LogWarning(\"1. GetAssemblies() 返回所有已加载的程序集，数量可能很大\");\n+                Debug.LogWarning(\"2. 遍历所有程序集和类型可能很耗时，建议缓存结果\");\n+                Debug.LogWarning(\"3. 某些程序集可能无法完全加载，需要处理 ReflectionTypeLoadException\");\n+                Debug.LogWarning(\"4. 在 Unity 中，程序集加载时机可能与 .NET 标准不同\");\n+                Debug.LogWarning(\"5. 使用 Type.GetType() 通常比遍历程序集更高效\");\n+                \n+                // ========== 实用示例：查找所有 MonoBehaviour 子类 ==========\n+                Debug.Log(\"--- 实用示例：查找 MonoBehaviour 子类 ---\");\n+                Type monoBehaviourType = typeof(MonoBehaviour);\n+                List<string> monoBehaviourTypes = new List<string>();\n+                \n+                foreach (Assembly assembly in assemblies)\n+                {\n+                    try\n+                    {\n+                        Type[] types = assembly.GetTypes();\n+                        var mbTypes = types.Where(t => \n+                            monoBehaviourType.IsAssignableFrom(t) && \n+                            t.IsClass && \n+                            !t.IsAbstract &&\n+                            t != monoBehaviourType);\n+                        \n+                        foreach (var type in mbTypes.Take(5))\n+                        {\n+                            monoBehaviourTypes.Add($\"{type.Namespace}.{type.Name}\");\n+                        }\n+                    }\n+                    catch\n+                    {\n+                        // 忽略错误\n+                    }\n+                }\n+                \n+                Debug.Log($\"找到 MonoBehaviour 子类数量: {monoBehaviourTypes.Count}\");\n+                foreach (var typeName in monoBehaviourTypes.Take(10))\n+                {\n+                    Debug.Log($\"  - {typeName}\");\n+                }\n+            }\n+            catch (Exception ex)\n+            {\n+                Debug.LogError($\"AppDomain示例出错: {ex.Message}\");\n+                Debug.LogError($\"堆栈跟踪: {ex.StackTrace}\");\n+            }\n+        }\n+        \n+        /// <summary>\n+        /// 程序集加载事件处理器\n+        /// </summary>\n+        private void OnAssemblyLoad(object sender, AssemblyLoadEventArgs args)\n+        {\n+            Debug.Log($\"程序集已加载: {args.LoadedAssembly.GetName().Name}\");\n+        }\n+        \n         // 属性变化事件处理\n         private void OnPropertyChanged(object sender, PropertyChangedEventArgs e)\n         {\n             Debug.Log($\"属性 {e.PropertyName} 发生变化\");\n"
                },
                {
                    "date": 1762517077101,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,8 +11,10 @@\n using System.ComponentModel;\n using System.Security.Cryptography;\n using System.Text;\n using System.Threading;\n+using System.Reflection;\n+using System.Linq;\n using UnityEngine;\n using Debug = UnityEngine.Debug;\n using System.Runtime;\n using Sirenix.OdinInspector.Editor.Validation;\n"
                }
            ],
            "date": 1761989152019,
            "name": "Commit-0",
            "content": "// SystemExample.cs\n// .NET System API使用详解示例\n// 包含Math、DateTime、Convert、GC、Diagnostics、Security、Globalization、ComponentModel、Configuration等常用功能\n// 每个方法、关键步骤、枚举值均有详细中文注释\n// 适合.NET初学者学习和查阅\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.ComponentModel;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading;\nusing UnityEngine;\nusing Debug = UnityEngine.Debug;\nusing System.Runtime;\nusing Sirenix.OdinInspector.Editor.Validation;\nusing Sirenix.OdinInspector;\n\nnamespace DotNet.SystemNS\n{\n    /// <summary>\n    /// .NET System API使用详解示例\n    /// 演示Math、DateTime、Convert、GC、Diagnostics、Security、Globalization、ComponentModel、Configuration等常用操作\n    /// </summary>\n    public class SystemExample : MonoBehaviour\n    {\n        [Header(\"System示例\")]\n        [Tooltip(\"是否自动运行所有示例代码\")]\n        [SerializeField] private bool runExamples = true;\n\n        private void Start()\n        {\n            if (runExamples)\n            {\n                RunAllExamples();\n            }\n        }\n\n        /// <summary>\n        /// 运行所有System相关示例\n        /// </summary>\n        private void RunAllExamples()\n        {\n            Debug.Log(\"=== .NET System API示例开始 ===\");\n            MathExample();\n            DateTimeExample();\n            ConvertExample();\n            SpanExample();\n            GCExample();\n            DiagnosticsExample();\n            SecurityExample();\n            GlobalizationExample();\n            ComponentModelExample();\n            Debug.Log(\"=== .NET System API示例结束 ===\");\n        }\n\n        // ================= Math 数学运算 =================\n        /// <summary>\n        /// Math类常用API演示\n        /// 包含数学常量、基本运算、三角函数、对数函数等\n        /// </summary>\n        private void MathExample()\n        {\n            Debug.Log(\"--- Math 数学运算示例 ---\");\n            \n            try\n            {\n                // ========== 数学常量 ==========\n                Debug.Log($\"PI: {Math.PI}\");\n                Debug.Log($\"E: {Math.E}\");\n                Debug.Log($\"Tau: {Math.Atanh(1)}\");\n                \n                // ========== 基本运算 ==========\n                double sqrt = Math.Sqrt(16);\n                double pow = Math.Pow(2, 8);\n                double abs = Math.Abs(-123.45);\n                double max = Math.Max(10, 20);\n                double min = Math.Min(10, 20);\n                double floor = Math.Floor(3.7);\n                double ceiling = Math.Ceiling(3.2);\n                double round = Math.Round(3.14159, 2);\n                \n                Debug.Log($\"Sqrt(16): {sqrt}\");\n                Debug.Log($\"Pow(2,8): {pow}\");\n                Debug.Log($\"Abs(-123.45): {abs}\");\n                Debug.Log($\"Max(10,20): {max}\");\n                Debug.Log($\"Min(10,20): {min}\");\n                Debug.Log($\"Floor(3.7): {floor}\");\n                Debug.Log($\"Ceiling(3.2): {ceiling}\");\n                Debug.Log($\"Round(3.14159,2): {round}\");\n                \n                // ========== 三角函数 ==========\n                double sin = Math.Sin(Math.PI / 2);\n                double cos = Math.Cos(0);\n                double tan = Math.Tan(Math.PI / 4);\n                double asin = Math.Asin(1);\n                double acos = Math.Acos(0);\n                double atan = Math.Atan(1);\n                \n                Debug.Log($\"Sin(π/2): {sin}\");\n                Debug.Log($\"Cos(0): {cos}\");\n                Debug.Log($\"Tan(π/4): {tan}\");\n                Debug.Log($\"Asin(1): {asin}\");\n                Debug.Log($\"Acos(0): {acos}\");\n                Debug.Log($\"Atan(1): {atan}\");\n                \n                // ========== 对数函数 ==========\n                double log = Math.Log(100);\n                double log10 = Math.Log10(100);\n                double exp = Math.Exp(1);\n                \n                Debug.Log($\"Log(100): {log}\");\n                Debug.Log($\"Log10(100): {log10}\");\n                Debug.Log($\"Exp(1): {exp}\");\n                \n                // ========== 其他数学函数 ==========\n                double sign = Math.Sign(-5);\n                double truncate = Math.Truncate(3.7);\n                double remainder = Math.IEEERemainder(10, 3);\n                \n                Debug.Log($\"Sign(-5): {sign}\");\n                Debug.Log($\"Truncate(3.7): {truncate}\");\n                Debug.Log($\"IEEERemainder(10,3): {remainder}\");\n            }\n            catch (Exception ex)\n            {\n                Debug.LogError($\"Math示例出错: {ex.Message}\");\n            }\n        }\n\n        // ================= DateTime 日期时间 =================\n        /// <summary>\n        /// DateTime和TimeSpan常用API演示\n        /// 包含日期时间创建、格式化、计算、时区等操作\n        /// </summary>\n        private void DateTimeExample()\n        {\n            Debug.Log(\"--- DateTime 日期时间示例 ---\");\n            \n            try\n            {\n                // ========== DateTime创建和获取 ==========\n                DateTime now = DateTime.Now;\n                DateTime utcNow = DateTime.UtcNow;\n                DateTime today = DateTime.Today;\n                DateTime minValue = DateTime.MinValue;\n                DateTime maxValue = DateTime.MaxValue;\n                \n                Debug.Log($\"当前时间: {now}\");\n                Debug.Log($\"UTC时间: {utcNow}\");\n                Debug.Log($\"今天: {today}\");\n                Debug.Log($\"最小时间: {minValue}\");\n                Debug.Log($\"最大时间: {maxValue}\");\n                \n                // ========== 日期时间计算 ==========\n                DateTime tomorrow = now.AddDays(1);\n                DateTime yesterday = now.AddDays(-1);\n                DateTime nextWeek = now.AddDays(7);\n                DateTime nextMonth = now.AddMonths(1);\n                DateTime nextYear = now.AddYears(1);\n                \n                Debug.Log($\"明天: {tomorrow}\");\n                Debug.Log($\"昨天: {yesterday}\");\n                Debug.Log($\"下周: {nextWeek}\");\n                Debug.Log($\"下月: {nextMonth}\");\n                Debug.Log($\"明年: {nextYear}\");\n                \n                // ========== 时间间隔计算 ==========\n                TimeSpan diff = tomorrow - now;\n                TimeSpan oneHour = TimeSpan.FromHours(1);\n                TimeSpan oneDay = TimeSpan.FromDays(1);\n                TimeSpan oneWeek = TimeSpan.FromDays(7);\n                \n                Debug.Log($\"到明天的时间间隔: {diff}\");\n                Debug.Log($\"一小时: {oneHour}\");\n                Debug.Log($\"一天: {oneDay}\");\n                Debug.Log($\"一周: {oneWeek}\");\n                \n                // ========== 日期时间格式化 ==========\n                string shortDate = now.ToString(\"yyyy-MM-dd\");\n                string longDate = now.ToString(\"yyyy年MM月dd日\");\n                string timeOnly = now.ToString(\"HH:mm:ss\");\n                string fullDateTime = now.ToString(\"yyyy-MM-dd HH:mm:ss\");\n                string customFormat = now.ToString(\"MM/dd/yyyy HH:mm\");\n                \n                Debug.Log($\"短日期: {shortDate}\");\n                Debug.Log($\"长日期: {longDate}\");\n                Debug.Log($\"时间: {timeOnly}\");\n                Debug.Log($\"完整日期时间: {fullDateTime}\");\n                Debug.Log($\"自定义格式: {customFormat}\");\n                \n                // ========== 日期时间解析 ==========\n                string dateStr = \"2023-12-25 14:30:00\";\n                DateTime parsedDate = DateTime.Parse(dateStr);\n                DateTime.TryParse(\"2023-12-25\", out DateTime tryParsedDate);\n                \n                Debug.Log($\"解析的日期: {parsedDate}\");\n                Debug.Log($\"TryParse结果: {tryParsedDate}\");\n                \n                // ========== 日期时间属性 ==========\n                Debug.Log($\"年: {now.Year}\");\n                Debug.Log($\"月: {now.Month}\");\n                Debug.Log($\"日: {now.Day}\");\n                Debug.Log($\"时: {now.Hour}\");\n                Debug.Log($\"分: {now.Minute}\");\n                Debug.Log($\"秒: {now.Second}\");\n                Debug.Log($\"毫秒: {now.Millisecond}\");\n                Debug.Log($\"星期: {now.DayOfWeek}\");\n                Debug.Log($\"一年中的第几天: {now.DayOfYear}\");\n                \n                // ========== 时间戳转换 ==========\n                long ticks = now.Ticks;\n                DateTime fromTicks = new DateTime(ticks);\n                \n                Debug.Log($\"Ticks: {ticks}\");\n                Debug.Log($\"从Ticks创建: {fromTicks}\");\n            }\n            catch (Exception ex)\n            {\n                Debug.LogError($\"DateTime示例出错: {ex.Message}\");\n            }\n        }\n\n        // ================= Convert 类型转换 =================\n        /// <summary>\n        /// Convert和BitConverter常用API演示\n        /// 包含各种类型之间的转换、字节转换等操作\n        /// </summary>\n        private void ConvertExample()\n        {\n            Debug.Log(\"--- Convert 类型转换示例 ---\");\n            \n            try\n            {\n                // ========== Convert类转换 ==========\n                // 字符串转数值类型\n                int intValue = Convert.ToInt32(\"123\");\n                double doubleValue = Convert.ToDouble(\"3.14\");\n                decimal decimalValue = Convert.ToDecimal(\"123.456\");\n                bool boolValue = Convert.ToBoolean(\"true\");\n                char charValue = Convert.ToChar(\"A\");\n                \n                Debug.Log($\"字符串转int: {intValue}\");\n                Debug.Log($\"字符串转double: {doubleValue}\");\n                Debug.Log($\"字符串转decimal: {decimalValue}\");\n                Debug.Log($\"字符串转bool: {boolValue}\");\n                Debug.Log($\"字符串转char: {charValue}\");\n                \n                // 数值类型转换\n                int intFromDouble = Convert.ToInt32(3.7);\n                double doubleFromInt = Convert.ToDouble(42);\n                long longFromInt = Convert.ToInt64(123);\n                \n                Debug.Log($\"double转int: {intFromDouble}\");\n                Debug.Log($\"int转double: {doubleFromInt}\");\n                Debug.Log($\"int转long: {longFromInt}\");\n                \n                // 特殊转换\n                string hexString = Convert.ToString(255, 16);\n                int fromHex = Convert.ToInt32(\"FF\", 16);\n                string binaryString = Convert.ToString(42, 2);\n                \n                Debug.Log($\"255转十六进制: {hexString}\");\n                Debug.Log($\"FF转十进制: {fromHex}\");\n                Debug.Log($\"42转二进制: {binaryString}\");\n                \n                // ========== BitConverter字节转换 ==========\n                // 基本类型转字节数组\n                byte[] intBytes = BitConverter.GetBytes(123456);\n                byte[] doubleBytes = BitConverter.GetBytes(3.14159);\n                byte[] longBytes = BitConverter.GetBytes(123456789L);\n                byte[] boolBytes = BitConverter.GetBytes(true);\n                \n                Debug.Log($\"int转字节: {BitConverter.ToString(intBytes)}\");\n                Debug.Log($\"double转字节: {BitConverter.ToString(doubleBytes)}\");\n                Debug.Log($\"long转字节: {BitConverter.ToString(longBytes)}\");\n                Debug.Log($\"bool转字节: {BitConverter.ToString(boolBytes)}\");\n                \n                // 字节数组转基本类型\n                int fromIntBytes = BitConverter.ToInt32(intBytes, 0);\n                double fromDoubleBytes = BitConverter.ToDouble(doubleBytes, 0);\n                long fromLongBytes = BitConverter.ToInt64(longBytes, 0);\n                bool fromBoolBytes = BitConverter.ToBoolean(boolBytes, 0);\n                \n                Debug.Log($\"字节转int: {fromIntBytes}\");\n                Debug.Log($\"字节转double: {fromDoubleBytes}\");\n                Debug.Log($\"字节转long: {fromLongBytes}\");\n                Debug.Log($\"字节转bool: {fromBoolBytes}\");\n                \n                // ========== 字节序处理 ==========\n                bool isLittleEndian = BitConverter.IsLittleEndian;\n                Debug.Log($\"系统是否为小端序: {isLittleEndian}\");\n                \n                // 如果需要大端序，可以反转字节数组\n                if (BitConverter.IsLittleEndian)\n                {\n                    Array.Reverse(intBytes);\n                    Debug.Log($\"反转后字节: {BitConverter.ToString(intBytes)}\");\n                }\n                \n                // ========== 特殊转换 ==========\n                // 字符串编码转换\n                string text = \"Hello, 世界!\";\n                byte[] utf8Bytes = Encoding.UTF8.GetBytes(text);\n                byte[] asciiBytes = Encoding.ASCII.GetBytes(\"Hello\");\n                \n                Debug.Log($\"UTF8字节: {BitConverter.ToString(utf8Bytes)}\");\n                Debug.Log($\"ASCII字节: {BitConverter.ToString(asciiBytes)}\");\n                \n                // 字节数组转字符串\n                string fromUtf8 = Encoding.UTF8.GetString(utf8Bytes);\n                string fromAscii = Encoding.ASCII.GetString(asciiBytes);\n                \n                Debug.Log($\"UTF8转字符串: {fromUtf8}\");\n                Debug.Log($\"ASCII转字符串: {fromAscii}\");\n            }\n            catch (Exception ex)\n            {\n                Debug.LogError($\"Convert示例出错: {ex.Message}\");\n            }\n        }\n\n        // ================= GC 垃圾回收 =================\n        /// <summary>\n        /// GC垃圾回收常用API演示\n        /// 包含内存监控、垃圾回收控制、弱引用等操作\n        /// </summary>\n        private void GCExample()\n        {\n            Debug.Log(\"--- GC 垃圾回收示例 ---\");\n            \n            try\n            {\n                // ========== 内存监控 ==========\n                long memBefore = GC.GetTotalMemory(false);\n                Debug.Log($\"初始内存: {memBefore} 字节 ({memBefore / 1024.0 / 1024.0:F2} MB)\");\n                \n                // 分配大量内存\n                var arrays = new List<byte[]>();\n                for (int i = 0; i < 10; i++)\n                {\n                    arrays.Add(new byte[1024 * 1024]); // 每个1MB\n                }\n                \n                long memAfter = GC.GetTotalMemory(false);\n                Debug.Log($\"分配后内存: {memAfter} 字节 ({memAfter / 1024.0 / 1024.0:F2} MB)\");\n                Debug.Log($\"内存增长: {memAfter - memBefore} 字节\");\n                \n                // 强制垃圾回收\n                GC.Collect();\n                GC.WaitForPendingFinalizers();\n                GC.Collect();\n                \n                long memCollected = GC.GetTotalMemory(true);\n                Debug.Log($\"GC后内存: {memCollected} 字节 ({memCollected / 1024.0 / 1024.0:F2} MB)\");\n                \n                // ========== 代际信息 ==========\n                int maxGeneration = GC.MaxGeneration;\n                Debug.Log($\"最大代际: {maxGeneration}\");\n                \n                for (int i = 0; i <= maxGeneration; i++)\n                {\n                    long genMemory = GC.GetTotalMemory(false);\n                    Debug.Log($\"代际 {i} 内存: {genMemory} 字节\");\n                }\n                \n                // ========== 垃圾回收统计 ==========\n                int collectionCount0 = GC.CollectionCount(0);\n                int collectionCount1 = GC.CollectionCount(1);\n                int collectionCount2 = GC.CollectionCount(2);\n                \n                Debug.Log($\"代际0回收次数: {collectionCount0}\");\n                Debug.Log($\"代际1回收次数: {collectionCount1}\");\n                Debug.Log($\"代际2回收次数: {collectionCount2}\");\n                \n                // ========== 弱引用示例 ==========\n                var strongRef = new byte[1024 * 1024]; // 强引用\n                var weakRef = new WeakReference(strongRef); // 弱引用\n                \n                Debug.Log($\"弱引用目标是否存活: {weakRef.IsAlive}\");\n                Debug.Log($\"弱引用目标: {weakRef.Target}\");\n                \n                // 释放强引用\n                strongRef = null;\n                GC.Collect();\n                GC.WaitForPendingFinalizers();\n                \n                Debug.Log($\"释放强引用后，弱引用目标是否存活: {weakRef.IsAlive}\");\n                Debug.Log($\"弱引用目标: {weakRef.Target}\");\n                \n                // ========== 内存压力 ==========\n                GC.AddMemoryPressure(1024 * 1024); // 添加1MB内存压力\n                Debug.Log(\"已添加内存压力\");\n                \n                // ========== 垃圾回收模式 ==========\n                GCLatencyMode currentMode = GCSettings.LatencyMode;\n                Debug.Log($\"当前GC延迟模式: {currentMode}\");\n                \n                // 设置垃圾回收模式（仅在服务器模式下有效）\n                if (Application.isEditor)\n                {\n                    GCSettings.LatencyMode = GCLatencyMode.LowLatency;\n                    Debug.Log(\"已设置为低延迟模式\");\n                }\n                \n                // ========== 大对象堆信息 ==========\n                bool isServerGC = GCSettings.IsServerGC;\n                Debug.Log($\"是否使用服务器GC: {isServerGC}\");\n                \n                // 清理测试数据\n                arrays.Clear();\n                GC.Collect();\n            }\n            catch (Exception ex)\n            {\n                Debug.LogError($\"GC示例出错: {ex.Message}\");\n            }\n        }\n\n        // ================= Diagnostics 诊断 =================\n        /// <summary>\n        /// Diagnostics诊断常用API演示\n        /// 包含性能计时、进程管理、调试工具等操作\n        /// </summary>\n        private void DiagnosticsExample()\n        {\n            Debug.Log(\"--- Diagnostics 诊断示例 ---\");\n            \n            try\n            {\n                // ========== Stopwatch性能计时 ==========\n                Stopwatch sw = new Stopwatch();\n                \n                // 基本计时\n                sw.Start();\n                for (int i = 0; i < 100000; i++)\n                {\n                    var x = Math.Sqrt(i);\n                }\n                sw.Stop();\n                \n                Debug.Log($\"循环耗时: {sw.ElapsedMilliseconds}ms\");\n                Debug.Log($\"循环耗时: {sw.ElapsedTicks} ticks\");\n                Debug.Log($\"循环耗时: {sw.Elapsed.TotalSeconds:F4} 秒\");\n                \n                // 重置和重新计时\n                sw.Reset();\n                sw.Start();\n                Thread.Sleep(100);\n                sw.Stop();\n                Debug.Log($\"睡眠100ms实际耗时: {sw.ElapsedMilliseconds}ms\");\n                \n                // ========== 进程信息 ==========\n                Process currentProcess = Process.GetCurrentProcess();\n                Debug.Log($\"当前进程ID: {currentProcess.Id}\");\n                Debug.Log($\"当前进程名称: {currentProcess.ProcessName}\");\n                Debug.Log($\"当前进程启动时间: {currentProcess.StartTime}\");\n                Debug.Log($\"当前进程工作集内存: {currentProcess.WorkingSet64 / 1024 / 1024} MB\");\n                Debug.Log($\"当前进程虚拟内存: {currentProcess.VirtualMemorySize64 / 1024 / 1024} MB\");\n                Debug.Log($\"当前进程CPU时间: {currentProcess.TotalProcessorTime}\");\n                \n                // ========== 系统进程列表 ==========\n                Process[] processes = Process.GetProcesses();\n                Debug.Log($\"系统进程总数: {processes.Length}\");\n                \n                // 查找特定进程\n                Process[] unityProcesses = Process.GetProcessesByName(\"Unity\");\n                Debug.Log($\"Unity相关进程数: {unityProcesses.Length}\");\n                \n                // ========== 性能计数器 ==========\n                // 注意：在Unity中某些性能计数器可能不可用\n                // 确保引入必要的命名空间\n                //using System.Diagnostics;\n\n                // 使用 PerformanceCounter 之前检查是否可用\n                // if (PerformanceCounterCategory.Exists(\"Processor\"))\n                // {\n                //     try\n                //     {\n                //         using (PerformanceCounter cpuCounter = new PerformanceCounter(\"Processor\", \"% Processor Time\", \"_Total\"))\n                //         {\n                //             float cpuUsage = cpuCounter.NextValue();\n                //             Debug.Log($\"CPU使用率: {cpuUsage:F2}%\");\n                //         }\n                //     }\n                //     catch (Exception ex)\n                //     {\n                //         Debug.LogWarning($\"性能计数器不可用: {ex.Message}\");\n                //     }\n                // }\n                // else\n                // {\n                //     Debug.LogWarning(\"性能计数器类别 'Processor' 不存在。\");\n                // }\n                {\n                  //  Debug.LogWarning($\"性能计数器不可用: {ex.Message}\");\n                }\n                \n                // ========== 调试断言 ==========\n                int value = 42;\n                Debug.Assert(value > 0, \"值必须大于0\");\n                Debug.Assert(value < 100, \"值必须小于100\");\n                \n                // ========== 条件编译 ==========\n                #if DEBUG\n                Debug.Log(\"这是调试版本\");\n                #else\n                Debug.Log(\"这是发布版本\");\n                #endif\n                \n                // ========== 堆栈跟踪 ==========\n                StackTrace stackTrace = new StackTrace();\n                Debug.Log($\"当前调用堆栈深度: {stackTrace.FrameCount}\");\n                \n                // 获取调用方法信息\n                StackFrame frame = stackTrace.GetFrame(0);\n                if (frame != null)\n                {\n                    Debug.Log($\"调用方法: {frame.GetMethod()?.Name}\");\n                    Debug.Log($\"调用文件: {frame.GetFileName()}\");\n                    Debug.Log($\"调用行号: {frame.GetFileLineNumber()}\");\n                }\n                \n                // ========== 内存诊断 ==========\n                long managedMemory = GC.GetTotalMemory(false);\n                Debug.Log($\"托管内存: {managedMemory / 1024 / 1024} MB\");\n                \n                // ========== 异常诊断 ==========\n                try\n                {\n                    throw new InvalidOperationException(\"测试异常\");\n                }\n                catch (Exception ex)\n                {\n                    Debug.LogError($\"捕获异常: {ex.Message}\");\n                    Debug.LogError($\"异常堆栈: {ex.StackTrace}\");\n                }\n            }\n            catch (Exception ex)\n            {\n                Debug.LogError($\"Diagnostics示例出错: {ex.Message}\");\n            }\n        }\n\n        // ================= Security 加密解密 =================\n        /// <summary>\n        /// Security加密解密常用API演示\n        /// 包含哈希算法、对称加密、非对称加密等操作\n        /// </summary>\n        private void SecurityExample()\n        {\n            Debug.Log(\"--- Security 加密解密示例 ---\");\n            \n            try\n            {\n                string originalText = \"Hello, 世界! 这是一个测试文本。\";\n                byte[] originalBytes = Encoding.UTF8.GetBytes(originalText);\n                \n                // ========== 哈希算法 ==========\n                // SHA256哈希\n                using (SHA256 sha256 = SHA256.Create())\n                {\n                    byte[] hash256 = sha256.ComputeHash(originalBytes);\n                    string hash256Str = BitConverter.ToString(hash256).Replace(\"-\", \"\");\n                    Debug.Log($\"SHA256哈希: {hash256Str}\");\n                }\n                \n                // SHA1哈希（不推荐用于安全场景）\n                using (SHA1 sha1 = SHA1.Create())\n                {\n                    byte[] hash1 = sha1.ComputeHash(originalBytes);\n                    string hash1Str = BitConverter.ToString(hash1).Replace(\"-\", \"\");\n                    Debug.Log($\"SHA1哈希: {hash1Str}\");\n                }\n                \n                // MD5哈希（不推荐用于安全场景）\n                using (MD5 md5 = MD5.Create())\n                {\n                    byte[] hashMD5 = md5.ComputeHash(originalBytes);\n                    string hashMD5Str = BitConverter.ToString(hashMD5).Replace(\"-\", \"\");\n                    Debug.Log($\"MD5哈希: {hashMD5Str}\");\n                }\n                \n                // ========== 对称加密 ==========\n                // AES加密\n                using (Aes aes = Aes.Create())\n                {\n                    aes.GenerateKey();\n                    aes.GenerateIV();\n                    \n                    // 加密\n                    using (ICryptoTransform encryptor = aes.CreateEncryptor())\n                    {\n                        byte[] encrypted = encryptor.TransformFinalBlock(originalBytes, 0, originalBytes.Length);\n                        string encryptedStr = Convert.ToBase64String(encrypted);\n                        Debug.Log($\"AES加密结果: {encryptedStr}\");\n                        \n                        // 解密\n                        using (ICryptoTransform decryptor = aes.CreateDecryptor())\n                        {\n                            byte[] decrypted = decryptor.TransformFinalBlock(encrypted, 0, encrypted.Length);\n                            string decryptedText = Encoding.UTF8.GetString(decrypted);\n                            Debug.Log($\"AES解密结果: {decryptedText}\");\n                        }\n                    }\n                }\n                \n                // ========== 随机数生成 ==========\n                using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())\n                {\n                    byte[] randomBytes = new byte[32];\n                    rng.GetBytes(randomBytes);\n                    string randomStr = BitConverter.ToString(randomBytes).Replace(\"-\", \"\");\n                    Debug.Log($\"加密随机数: {randomStr}\");\n                }\n                \n                // ========== 密码哈希 ==========\n                string password = \"MyPassword123\";\n                byte[] salt = new byte[16];\n                using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())\n                {\n                    rng.GetBytes(salt);\n                }\n                \n                using (Rfc2898DeriveBytes pbkdf2 = new Rfc2898DeriveBytes(password, salt, 10000))\n                {\n                    byte[] hash = pbkdf2.GetBytes(32);\n                    string passwordHash = Convert.ToBase64String(hash);\n                    string saltStr = Convert.ToBase64String(salt);\n                    Debug.Log($\"密码哈希: {passwordHash}\");\n                    Debug.Log($\"盐值: {saltStr}\");\n                }\n                \n                // ========== 数字签名 ==========\n                // 注意：在Unity中某些加密算法可能不可用\n                try\n                {\n                    using (RSA rsa = RSA.Create())\n                    {\n                        byte[] signature = rsa.SignData(originalBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);\n                        string signatureStr = Convert.ToBase64String(signature);\n                        Debug.Log($\"RSA签名: {signatureStr}\");\n                        \n                        bool isValid = rsa.VerifyData(originalBytes, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);\n                        Debug.Log($\"签名验证: {isValid}\");\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Debug.LogWarning($\"RSA签名不可用: {ex.Message}\");\n                }\n                \n                // ========== 安全字符串 ==========\n                // 注意：System.Security.SecureString在某些平台可能不可用\n                try\n                {\n                    var secureString = new System.Security.SecureString();\n                    foreach (char c in \"SecretPassword\")\n                    {\n                        secureString.AppendChar(c);\n                    }\n                    Debug.Log($\"安全字符串长度: {secureString.Length}\");\n                    secureString.Dispose();\n                }\n                catch (Exception ex)\n                {\n                    Debug.LogWarning($\"SecureString不可用: {ex.Message}\");\n                }\n            }\n            catch (Exception ex)\n            {\n                Debug.LogError($\"Security示例出错: {ex.Message}\");\n            }\n        }\n\n        // ================= Globalization 全球化 =================\n        /// <summary>\n        /// Globalization全球化常用API演示\n        /// 包含文化信息、日期格式、数字格式、货币格式等操作\n        /// </summary>\n        private void GlobalizationExample()\n        {\n            Debug.Log(\"--- Globalization 全球化示例 ---\");\n            \n            try\n            {\n                // ========== 文化信息 ==========\n                CultureInfo currentCulture = CultureInfo.CurrentCulture;\n                CultureInfo currentUICulture = CultureInfo.CurrentUICulture;\n                CultureInfo invariantCulture = CultureInfo.InvariantCulture;\n                \n                Debug.Log($\"当前文化: {currentCulture.Name} ({currentCulture.DisplayName})\");\n                Debug.Log($\"当前UI文化: {currentUICulture.Name} ({currentUICulture.DisplayName})\");\n                Debug.Log($\"不变文化: {invariantCulture.Name}\");\n                \n                // ========== 不同文化的日期格式 ==========\n                DateTime now = DateTime.Now;\n                \n                CultureInfo[] cultures = {\n                    new CultureInfo(\"zh-CN\"), // 中文简体\n                    new CultureInfo(\"en-US\"), // 英文美国\n                    new CultureInfo(\"fr-FR\"), // 法文法国\n                    new CultureInfo(\"de-DE\"), // 德文德国\n                    new CultureInfo(\"ja-JP\"), // 日文日本\n                    new CultureInfo(\"ko-KR\")  // 韩文韩国\n                };\n                \n                foreach (var culture in cultures)\n                {\n                    string dateStr = now.ToString(culture);\n                    string shortDate = now.ToString(\"d\", culture);\n                    string longDate = now.ToString(\"D\", culture);\n                    \n                    Debug.Log($\"{culture.DisplayName}: {dateStr}\");\n                    Debug.Log($\"{culture.DisplayName} 短日期: {shortDate}\");\n                    Debug.Log($\"{culture.DisplayName} 长日期: {longDate}\");\n                }\n                \n                // ========== 数字格式 ==========\n                double number = 12345.67;\n                \n                foreach (var culture in cultures)\n                {\n                    string numberStr = number.ToString(\"N\", culture);\n                    string currencyStr = number.ToString(\"C\", culture);\n                    string percentStr = (number / 100000).ToString(\"P\", culture);\n                    \n                    Debug.Log($\"{culture.DisplayName} 数字: {numberStr}\");\n                    Debug.Log($\"{culture.DisplayName} 货币: {currencyStr}\");\n                    Debug.Log($\"{culture.DisplayName} 百分比: {percentStr}\");\n                }\n                \n                // ========== 日期时间格式信息 ==========\n                CultureInfo zhCN = new CultureInfo(\"zh-CN\");\n                DateTimeFormatInfo dateFormat = zhCN.DateTimeFormat;\n                \n                Debug.Log($\"中文月份名称: {string.Join(\", \", dateFormat.MonthNames)}\");\n                Debug.Log($\"中文星期名称: {string.Join(\", \", dateFormat.DayNames)}\");\n                Debug.Log($\"中文短星期名称: {string.Join(\", \", dateFormat.AbbreviatedDayNames)}\");\n                Debug.Log($\"中文AM/PM: {dateFormat.AMDesignator}, {dateFormat.PMDesignator}\");\n                \n                // ========== 数字格式信息 ==========\n                NumberFormatInfo numberFormat = zhCN.NumberFormat;\n                \n                Debug.Log($\"数字分隔符: {numberFormat.NumberDecimalSeparator}\");\n                Debug.Log($\"千位分隔符: {numberFormat.NumberGroupSeparator}\");\n                Debug.Log($\"货币符号: {numberFormat.CurrencySymbol}\");\n                Debug.Log($\"货币分隔符: {numberFormat.CurrencyDecimalSeparator}\");\n                \n                // ========== 自定义格式 ==========\n                CultureInfo customCulture = new CultureInfo(\"en-US\");\n                customCulture.NumberFormat.NumberDecimalDigits = 3;\n                customCulture.NumberFormat.NumberGroupSeparator = \"_\";\n                \n                string customNumber = number.ToString(\"N\", customCulture);\n                Debug.Log($\"自定义格式数字: {customNumber}\");\n                \n                // ========== 文化比较 ==========\n                string text1 = \"café\";\n                string text2 = \"CAFE\";\n                \n                int comparison1 = string.Compare(text1, text2, StringComparison.Ordinal);\n                int comparison2 = string.Compare(text1, text2, StringComparison.OrdinalIgnoreCase);\n                int comparison3 = string.Compare(text1, text2, StringComparison.CurrentCulture);\n                \n                Debug.Log($\"Ordinal比较: {comparison1}\");\n                Debug.Log($\"OrdinalIgnoreCase比较: {comparison2}\");\n                Debug.Log($\"CurrentCulture比较: {comparison3}\");\n                \n                // ========== 时区信息 ==========\n                TimeZoneInfo localZone = TimeZoneInfo.Local;\n                Debug.Log($\"本地时区: {localZone.DisplayName}\");\n                Debug.Log($\"时区ID: {localZone.Id}\");\n                Debug.Log($\"标准时间名称: {localZone.StandardName}\");\n                Debug.Log($\"夏令时名称: {localZone.DaylightName}\");\n                Debug.Log($\"当前偏移: {localZone.GetUtcOffset(DateTime.Now)}\");\n                \n                // ========== 可用文化列表 ==========\n                CultureInfo[] allCultures = CultureInfo.GetCultures(CultureTypes.AllCultures);\n                Debug.Log($\"系统支持的文化总数: {allCultures.Length}\");\n                \n                // 显示前10个文化\n                for (int i = 0; i < Math.Min(10, allCultures.Length); i++)\n                {\n                    Debug.Log($\"文化{i + 1}: {allCultures[i].Name} - {allCultures[i].DisplayName}\");\n                }\n            }\n            catch (Exception ex)\n            {\n                Debug.LogError($\"Globalization示例出错: {ex.Message}\");\n            }\n        }\n\n        // ================= ComponentModel 组件模型 =================\n        /// <summary>\n        /// ComponentModel组件模型常用API演示\n        /// 包含属性描述、类型转换、数据验证、属性变化通知等操作\n        /// </summary>\n        private void ComponentModelExample()\n        {\n            Debug.Log(\"--- ComponentModel 组件模型示例 ---\");\n            \n            try\n            {\n                // ========== 属性描述器 ==========\n                var person = new Person { Name = \"张三\", Age = 28, Email = \"zhangsan@example.com\" };\n                PropertyDescriptorCollection props = TypeDescriptor.GetProperties(person);\n                \n                Debug.Log($\"Person类的属性数量: {props.Count}\");\n                foreach (PropertyDescriptor prop in props)\n                {\n                    Debug.Log($\"属性: {prop.Name}, 类型: {prop.PropertyType.Name}, 值: {prop.GetValue(person)}\");\n                }\n                \n                // ========== 类型转换器 ==========\n                TypeConverter stringConverter = TypeDescriptor.GetConverter(typeof(string));\n                TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));\n                TypeConverter boolConverter = TypeDescriptor.GetConverter(typeof(bool));\n                \n                Debug.Log($\"字符串转换器: {stringConverter.GetType().Name}\");\n                Debug.Log($\"整数转换器: {intConverter.GetType().Name}\");\n                Debug.Log($\"布尔转换器: {boolConverter.GetType().Name}\");\n                \n                // 测试转换\n                if (intConverter.CanConvertFrom(typeof(string)))\n                {\n                    int convertedValue = (int)intConverter.ConvertFrom(\"123\");\n                    Debug.Log($\"字符串'123'转换为int: {convertedValue}\");\n                }\n                \n                // ========== 数据验证 ==========\n                var user = new User { Name = \"李四\", Age = 25, Email = \"invalid-email\" };\n                var validationResults = new List<ValidationResult>();\n                \n                // // 确保引入必要的命名空间\n                // var validationContext = new ValidationContext(user);\n                \n                // // 使用早期返回提高可读性\n                // if (!Validator.TryValidateObject(user, validationContext, validationResults, true))\n                // {\n                //     Debug.Log($\"用户数据验证结果: false\");\n                //     foreach (var result in validationResults)\n                //     {\n                //         Debug.LogWarning($\"验证错误: {result.ErrorMessage}\");\n                //     }\n                //     return; // 早期返回\n                // }\n                \n                // Debug.Log($\"用户数据验证结果: true\");\n                // if (!isValid)\n                // {\n                //     foreach (var result in validationResults)\n                //     {\n                //         Debug.LogWarning($\"验证错误: {result.ErrorMessage}\");\n                //     }\n                // }\n                \n                // ========== 属性变化通知 ==========\n                var observablePerson = new ObservablePerson { Name = \"王五\", Age = 30 };\n                observablePerson.PropertyChanged += OnPropertyChanged;\n                \n                observablePerson.Name = \"王六\";\n                observablePerson.Age = 31;\n                \n                // ========== 自定义类型转换器 ==========\n                var colorConverter = new ColorConverter();\n                if (colorConverter.CanConvertFrom(typeof(string)))\n                {\n                    var color = (Color)colorConverter.ConvertFrom(\"Red\");\n                    Debug.Log($\"字符串'Red'转换为Color: {color}\");\n                }\n                \n                // ========== 事件描述器 ==========\n                EventDescriptorCollection events = TypeDescriptor.GetEvents(typeof(ObservablePerson));\n                Debug.Log($\"ObservablePerson类的事件数量: {events.Count}\");\n                foreach (EventDescriptor evt in events)\n                {\n                    Debug.Log($\"事件: {evt.Name}, 类型: {evt.EventType.Name}\");\n                }\n                \n                // ========== 属性网格支持 ==========\n                var complexPerson = new ComplexPerson\n                {\n                    Name = \"赵六\",\n                    Age = 35,\n                    Address = new Address { City = \"北京\", Street = \"长安街\" }\n                };\n                \n                PropertyDescriptorCollection complexProps = TypeDescriptor.GetProperties(complexPerson);\n                Debug.Log($\"ComplexPerson类的属性数量: {complexProps.Count}\");\n                foreach (PropertyDescriptor prop in complexProps)\n                {\n                    Debug.Log($\"属性: {prop.Name}, 类型: {prop.PropertyType.Name}\");\n                }\n            }\n            catch (Exception ex)\n            {\n                Debug.LogError($\"ComponentModel示例出错: {ex.Message}\");\n            }\n        }\n        \n        // 属性变化事件处理\n        private void OnPropertyChanged(object sender, PropertyChangedEventArgs e)\n        {\n            Debug.Log($\"属性 {e.PropertyName} 发生变化\");\n        }\n        \n        // 自定义颜色转换器\n        private class ColorConverter : TypeConverter\n        {\n            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)\n            {\n                return sourceType == typeof(string);\n            }\n            \n            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)\n            {\n                if (value is string colorName)\n                {\n                    switch (colorName.ToLower())\n                    {\n                        case \"red\": return Color.red;\n                        case \"green\": return Color.green;\n                        case \"blue\": return Color.blue;\n                        default: return Color.white;\n                    }\n                }\n                return base.ConvertFrom(context, culture, value);\n            }\n        }\n        \n        // 数据验证示例类\n        private class User\n        {\n            [Required(ErrorMessage = \"姓名不能为空\")]\n            //[StringLength(50, MinimumLength = 2, ErrorMessage = \"姓名长度必须在2-50个字符之间\")]\n            public string Name { get; set; }\n            \n            //[Range(0, 150, ErrorMessage = \"年龄必须在0-150之间\")]\n            public int Age { get; set; }\n            \n            //[EmailAddress(ErrorMessage = \"邮箱格式不正确\")]\n            public string Email { get; set; }\n        }\n        \n        // 属性变化通知示例类\n        private class ObservablePerson : INotifyPropertyChanged\n        {\n            private string name;\n            private int age;\n            \n            public string Name\n            {\n                get => name;\n                set\n                {\n                    if (name != value)\n                    {\n                        name = value;\n                        OnPropertyChanged(nameof(Name));\n                    }\n                }\n            }\n            \n            public int Age\n            {\n                get => age;\n                set\n                {\n                    if (age != value)\n                    {\n                        age = value;\n                        OnPropertyChanged(nameof(Age));\n                    }\n                }\n            }\n            \n            public event PropertyChangedEventHandler PropertyChanged;\n            \n            protected virtual void OnPropertyChanged(string propertyName)\n            {\n                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));\n            }\n        }\n        \n        // 复杂对象示例类\n        private class ComplexPerson\n        {\n            public string Name { get; set; }\n            public int Age { get; set; }\n            public Address Address { get; set; }\n        }\n        \n        private class Address\n        {\n            public string City { get; set; }\n            public string Street { get; set; }\n        }\n\n        // 内部测试类\n        private class Person\n        {\n            public string Name { get; set; }\n            public int Age { get; set; }\n            public string Email { get; set; }\n        }\n    }\n} "
        }
    ]
}