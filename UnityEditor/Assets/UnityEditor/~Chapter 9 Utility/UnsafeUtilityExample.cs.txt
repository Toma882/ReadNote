using UnityEngine;
using UnityEditor;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using System;

namespace UnityEditor.Examples
{
    /// <summary>
    /// UnsafeUtility 工具类示例
    /// 提供不安全内存操作相关的实用工具功能
    /// </summary>
    public static class UnsafeUtilityExample
    {
        #region 内存分配示例

        /// <summary>
        /// 分配内存
        /// </summary>
        public static void MallocExample()
        {
            int size = 1024; // 1KB
            Allocator allocator = Allocator.Temp;
            
            // 分配内存
            unsafe
            {
                void* ptr = UnsafeUtility.Malloc(size, 16, allocator);
                
                if (ptr != null)
                {
                    Debug.Log($"内存分配成功:");
                    Debug.Log($"- 大小: {size} 字节");
                    Debug.Log($"- 对齐: 16 字节");
                    Debug.Log($"- 分配器: {allocator}");
                    
                    // 释放内存
                    UnsafeUtility.Free(ptr, allocator);
                    Debug.Log("内存已释放");
                }
            }
        }

        /// <summary>
        /// 释放内存
        /// </summary>
        public static void FreeExample()
        {
            unsafe
            {
                // 分配内存
                void* ptr = UnsafeUtility.Malloc(512, 4, Allocator.Temp);
                
                Debug.Log("内存已分配: 512字节");
                
                // 释放内存
                UnsafeUtility.Free(ptr, Allocator.Temp);
                
                Debug.Log("内存已释放");
            }
        }

        #endregion

        #region 内存复制示例

        /// <summary>
        /// 内存复制
        /// </summary>
        public static void MemCpyExample()
        {
            unsafe
            {
                // 源数据
                int[] sourceArray = { 1, 2, 3, 4, 5 };
                int[] destArray = new int[5];
                
                fixed (int* srcPtr = sourceArray)
                fixed (int* dstPtr = destArray)
                {
                    // 复制内存
                    UnsafeUtility.MemCpy(dstPtr, srcPtr, sourceArray.Length * sizeof(int));
                }
                
                Debug.Log("内存复制完成:");
                Debug.Log($"- 源数组: [{string.Join(", ", sourceArray)}]");
                Debug.Log($"- 目标数组: [{string.Join(", ", destArray)}]");
            }
        }

        /// <summary>
        /// 内存移动
        /// </summary>
        public static void MemMoveExample()
        {
            unsafe
            {
                int[] array = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
                
                fixed (int* ptr = array)
                {
                    // 移动内存（支持重叠区域）
                    UnsafeUtility.MemMove(ptr + 2, ptr, 5 * sizeof(int));
                }
                
                Debug.Log($"内存移动完成: [{string.Join(", ", array)}]");
            }
        }

        /// <summary>
        /// 内存清零
        /// </summary>
        public static void MemClearExample()
        {
            unsafe
            {
                int[] array = { 1, 2, 3, 4, 5 };
                
                Debug.Log($"清零前: [{string.Join(", ", array)}]");
                
                fixed (int* ptr = array)
                {
                    // 清零内存
                    UnsafeUtility.MemClear(ptr, array.Length * sizeof(int));
                }
                
                Debug.Log($"清零后: [{string.Join(", ", array)}]");
            }
        }

        #endregion

        #region 内存比较示例

        /// <summary>
        /// 内存比较
        /// </summary>
        public static void MemCmpExample()
        {
            unsafe
            {
                int[] array1 = { 1, 2, 3, 4, 5 };
                int[] array2 = { 1, 2, 3, 4, 5 };
                int[] array3 = { 1, 2, 3, 4, 6 };
                
                fixed (int* ptr1 = array1)
                fixed (int* ptr2 = array2)
                fixed (int* ptr3 = array3)
                {
                    int result1 = UnsafeUtility.MemCmp(ptr1, ptr2, array1.Length * sizeof(int));
                    int result2 = UnsafeUtility.MemCmp(ptr1, ptr3, array1.Length * sizeof(int));
                    
                    Debug.Log("内存比较结果:");
                    Debug.Log($"- array1 vs array2: {(result1 == 0 ? "相同" : "不同")}");
                    Debug.Log($"- array1 vs array3: {(result2 == 0 ? "相同" : "不同")}");
                }
            }
        }

        #endregion

        #region 类型大小和对齐示例

        /// <summary>
        /// 获取类型大小
        /// </summary>
        public static void SizeOfExample()
        {
            int intSize = UnsafeUtility.SizeOf<int>();
            int floatSize = UnsafeUtility.SizeOf<float>();
            int vector3Size = UnsafeUtility.SizeOf<Vector3>();
            int quaternionSize = UnsafeUtility.SizeOf<Quaternion>();
            
            Debug.Log("类型大小:");
            Debug.Log($"- int: {intSize} 字节");
            Debug.Log($"- float: {floatSize} 字节");
            Debug.Log($"- Vector3: {vector3Size} 字节");
            Debug.Log($"- Quaternion: {quaternionSize} 字节");
        }

        /// <summary>
        /// 获取类型对齐
        /// </summary>
        public static void AlignOfExample()
        {
            int intAlign = UnsafeUtility.AlignOf<int>();
            int floatAlign = UnsafeUtility.AlignOf<float>();
            int vector3Align = UnsafeUtility.AlignOf<Vector3>();
            
            Debug.Log("类型对齐:");
            Debug.Log($"- int: {intAlign} 字节");
            Debug.Log($"- float: {floatAlign} 字节");
            Debug.Log($"- Vector3: {vector3Align} 字节");
        }

        #endregion

        #region 指针操作示例

        /// <summary>
        /// 地址转换
        /// </summary>
        public static void AddressOfExample()
        {
            unsafe
            {
                int value = 42;
                void* ptr = UnsafeUtility.AddressOf(ref value);
                
                Debug.Log($"变量地址: 0x{((IntPtr)ptr).ToString("X")}");
                Debug.Log($"变量值: {value}");
            }
        }

        /// <summary>
        /// 读取数据
        /// </summary>
        public static void ReadArrayElementExample()
        {
            unsafe
            {
                int[] array = { 10, 20, 30, 40, 50 };
                
                fixed (int* ptr = array)
                {
                    for (int i = 0; i < array.Length; i++)
                    {
                        int value = UnsafeUtility.ReadArrayElement<int>(ptr, i);
                        Debug.Log($"数组[{i}] = {value}");
                    }
                }
            }
        }

        /// <summary>
        /// 写入数据
        /// </summary>
        public static void WriteArrayElementExample()
        {
            unsafe
            {
                int[] array = new int[5];
                
                fixed (int* ptr = array)
                {
                    for (int i = 0; i < array.Length; i++)
                    {
                        UnsafeUtility.WriteArrayElement(ptr, i, i * 10);
                    }
                }
                
                Debug.Log($"写入后的数组: [{string.Join(", ", array)}]");
            }
        }

        #endregion

        #region NativeArray操作示例

        /// <summary>
        /// NativeArray内存操作
        /// </summary>
        public static void NativeArrayMemoryExample()
        {
            NativeArray<int> nativeArray = new NativeArray<int>(10, Allocator.Temp);
            
            // 填充数据
            for (int i = 0; i < nativeArray.Length; i++)
            {
                nativeArray[i] = i * 2;
            }
            
            unsafe
            {
                void* ptr = nativeArray.GetUnsafePtr();
                int size = UnsafeUtility.SizeOf<int>() * nativeArray.Length;
                
                Debug.Log($"NativeArray内存信息:");
                Debug.Log($"- 长度: {nativeArray.Length}");
                Debug.Log($"- 总大小: {size} 字节");
                Debug.Log($"- 指针地址: 0x{((IntPtr)ptr).ToString("X")}");
            }
            
            nativeArray.Dispose();
        }

        /// <summary>
        /// NativeArray复制
        /// </summary>
        public static void NativeArrayCopyExample()
        {
            NativeArray<float> source = new NativeArray<float>(5, Allocator.Temp);
            NativeArray<float> dest = new NativeArray<float>(5, Allocator.Temp);
            
            // 填充源数组
            for (int i = 0; i < source.Length; i++)
            {
                source[i] = i * 1.5f;
            }
            
            unsafe
            {
                void* srcPtr = source.GetUnsafePtr();
                void* dstPtr = dest.GetUnsafePtr();
                
                // 复制内存
                UnsafeUtility.MemCpy(dstPtr, srcPtr, source.Length * UnsafeUtility.SizeOf<float>());
            }
            
            Debug.Log("NativeArray复制完成:");
            Debug.Log($"- 源数组: [{string.Join(", ", source.ToArray())}]");
            Debug.Log($"- 目标数组: [{string.Join(", ", dest.ToArray())}]");
            
            source.Dispose();
            dest.Dispose();
        }

        #endregion

        #region 性能测试示例

        /// <summary>
        /// 内存操作性能测试
        /// </summary>
        public static void MemoryPerformanceTestExample()
        {
            int size = 1024 * 1024; // 1MB
            int iterations = 100;
            
            unsafe
            {
                void* ptr1 = UnsafeUtility.Malloc(size, 16, Allocator.Temp);
                void* ptr2 = UnsafeUtility.Malloc(size, 16, Allocator.Temp);
                
                // 测试MemCpy性能
                var stopwatch = System.Diagnostics.Stopwatch.StartNew();
                for (int i = 0; i < iterations; i++)
                {
                    UnsafeUtility.MemCpy(ptr2, ptr1, size);
                }
                stopwatch.Stop();
                
                Debug.Log($"内存复制性能测试 ({iterations}次, {size}字节):");
                Debug.Log($"- 总耗时: {stopwatch.ElapsedMilliseconds}ms");
                Debug.Log($"- 平均耗时: {stopwatch.ElapsedMilliseconds / (float)iterations}ms");
                
                UnsafeUtility.Free(ptr1, Allocator.Temp);
                UnsafeUtility.Free(ptr2, Allocator.Temp);
            }
        }

        #endregion

        #region 综合示例

        /// <summary>
        /// 自定义内存池
        /// </summary>
        public static void CustomMemoryPoolExample()
        {
            unsafe
            {
                int poolSize = 1024;
                void* memoryPool = UnsafeUtility.Malloc(poolSize, 16, Allocator.Persistent);
                
                Debug.Log($"内存池已创建: {poolSize}字节");
                
                // 使用内存池
                int* intPtr = (int*)memoryPool;
                for (int i = 0; i < 10; i++)
                {
                    intPtr[i] = i * 10;
                }
                
                Debug.Log("内存池数据:");
                for (int i = 0; i < 10; i++)
                {
                    Debug.Log($"  - [{i}] = {intPtr[i]}");
                }
                
                // 清理内存池
                UnsafeUtility.Free(memoryPool, Allocator.Persistent);
                Debug.Log("内存池已释放");
            }
        }

        /// <summary>
        /// 批量数据处理
        /// </summary>
        public static void BatchDataProcessingExample()
        {
            int count = 1000;
            NativeArray<Vector3> positions = new NativeArray<Vector3>(count, Allocator.Temp);
            
            // 初始化数据
            for (int i = 0; i < count; i++)
            {
                positions[i] = new Vector3(i, i * 2, i * 3);
            }
            
            unsafe
            {
                Vector3* ptr = (Vector3*)positions.GetUnsafePtr();
                
                // 批量处理
                for (int i = 0; i < count; i++)
                {
                    ptr[i] *= 2.0f;
                }
            }
            
            Debug.Log($"批量处理完成: {count}个Vector3");
            Debug.Log($"第一个元素: {positions[0]}");
            Debug.Log($"最后一个元素: {positions[count - 1]}");
            
            positions.Dispose();
        }

        #endregion

        #region 高级内存操作示例

        /// <summary>
        /// 内存对齐操作
        /// </summary>
        public static void MemoryAlignmentExample()
        {
            Debug.Log("=== 内存对齐操作 ===");
            
            unsafe
            {
                // 检查内存对齐
                int size = 64;
                int alignment = 16;
                
                void* ptr = UnsafeUtility.Malloc(size, alignment, Allocator.Temp);
                if (ptr != null)
                {
                    // 检查指针是否对齐
                    bool isAligned = UnsafeUtility.IsAligned(ptr, alignment);
                    Debug.Log($"指针是否对齐: {isAligned}");
                    
                    // 获取对齐后的指针
                    void* alignedPtr = UnsafeUtility.Align(ptr, alignment);
                    Debug.Log($"对齐后指针: {alignedPtr}");
                    
                    UnsafeUtility.Free(ptr, Allocator.Temp);
                }
            }
        }

        /// <summary>
        /// 内存比较操作
        /// </summary>
        public static void MemoryComparisonExample()
        {
            Debug.Log("=== 内存比较操作 ===");
            
            unsafe
            {
                int size = 16;
                void* ptr1 = UnsafeUtility.Malloc(size, 4, Allocator.Temp);
                void* ptr2 = UnsafeUtility.Malloc(size, 4, Allocator.Temp);
                
                if (ptr1 != null && ptr2 != null)
                {
                    // 初始化内存
                    UnsafeUtility.MemSet(ptr1, 0xAA, size);
                    UnsafeUtility.MemSet(ptr2, 0xAA, size);
                    
                    // 比较内存
                    int result = UnsafeUtility.MemCmp(ptr1, ptr2, size);
                    Debug.Log($"内存比较结果: {result}");
                    
                    // 修改第二个内存块
                    UnsafeUtility.MemSet(ptr2, 0xBB, size);
                    
                    // 再次比较
                    result = UnsafeUtility.MemCmp(ptr1, ptr2, size);
                    Debug.Log($"修改后内存比较结果: {result}");
                    
                    UnsafeUtility.Free(ptr1, Allocator.Temp);
                    UnsafeUtility.Free(ptr2, Allocator.Temp);
                }
            }
        }

        /// <summary>
        /// 内存移动操作
        /// </summary>
        public static void MemoryMoveExample()
        {
            Debug.Log("=== 内存移动操作 ===");
            
            unsafe
            {
                int size = 32;
                void* src = UnsafeUtility.Malloc(size, 4, Allocator.Temp);
                void* dst = UnsafeUtility.Malloc(size, 4, Allocator.Temp);
                
                if (src != null && dst != null)
                {
                    // 初始化源内存
                    UnsafeUtility.MemSet(src, 0xCC, size);
                    
                    // 移动内存
                    UnsafeUtility.MemMove(dst, src, size);
                    Debug.Log("内存移动完成");
                    
                    // 验证移动结果
                    int result = UnsafeUtility.MemCmp(src, dst, size);
                    Debug.Log($"移动后内存比较结果: {result}");
                    
                    UnsafeUtility.Free(src, Allocator.Temp);
                    UnsafeUtility.Free(dst, Allocator.Temp);
                }
            }
        }

        /// <summary>
        /// 内存交换操作
        /// </summary>
        public static void MemorySwapExample()
        {
            Debug.Log("=== 内存交换操作 ===");
            
            unsafe
            {
                int size = 16;
                void* ptr1 = UnsafeUtility.Malloc(size, 4, Allocator.Temp);
                void* ptr2 = UnsafeUtility.Malloc(size, 4, Allocator.Temp);
                
                if (ptr1 != null && ptr2 != null)
                {
                    // 初始化内存
                    UnsafeUtility.MemSet(ptr1, 0x11, size);
                    UnsafeUtility.MemSet(ptr2, 0x22, size);
                    
                    Debug.Log("交换前:");
                    Debug.Log($"ptr1: {((byte*)ptr1)[0]:X2}");
                    Debug.Log($"ptr2: {((byte*)ptr2)[0]:X2}");
                    
                    // 交换内存
                    UnsafeUtility.MemSwap(ptr1, ptr2, size);
                    Debug.Log("内存交换完成");
                    
                    Debug.Log("交换后:");
                    Debug.Log($"ptr1: {((byte*)ptr1)[0]:X2}");
                    Debug.Log($"ptr2: {((byte*)ptr2)[0]:X2}");
                    
                    UnsafeUtility.Free(ptr1, Allocator.Temp);
                    UnsafeUtility.Free(ptr2, Allocator.Temp);
                }
            }
        }

        #endregion

        #region 类型操作示例

        /// <summary>
        /// 类型大小操作
        /// </summary>
        public static void TypeSizeExample()
        {
            Debug.Log("=== 类型大小操作 ===");
            
            // 获取基本类型大小
            int intSize = UnsafeUtility.SizeOf<int>();
            Debug.Log($"int 大小: {intSize} 字节");
            
            int floatSize = UnsafeUtility.SizeOf<float>();
            Debug.Log($"float 大小: {floatSize} 字节");
            
            int vector3Size = UnsafeUtility.SizeOf<Vector3>();
            Debug.Log($"Vector3 大小: {vector3Size} 字节");
            
            // 获取类型对齐
            int intAlign = UnsafeUtility.AlignOf<int>();
            Debug.Log($"int 对齐: {intAlign} 字节");
            
            int floatAlign = UnsafeUtility.AlignOf<float>();
            Debug.Log($"float 对齐: {floatAlign} 字节");
            
            int vector3Align = UnsafeUtility.AlignOf<Vector3>();
            Debug.Log($"Vector3 对齐: {vector3Align} 字节");
        }

        /// <summary>
        /// 类型转换操作
        /// </summary>
        public static void TypeConversionExample()
        {
            Debug.Log("=== 类型转换操作 ===");
            
            unsafe
            {
                // 分配内存
                int size = UnsafeUtility.SizeOf<Vector3>();
                void* ptr = UnsafeUtility.Malloc(size, UnsafeUtility.AlignOf<Vector3>(), Allocator.Temp);
                
                if (ptr != null)
                {
                    // 写入Vector3
                    Vector3 original = new Vector3(1.0f, 2.0f, 3.0f);
                    UnsafeUtility.WriteArrayElement(ptr, 0, original);
                    
                    // 读取Vector3
                    Vector3 read = UnsafeUtility.ReadArrayElement<Vector3>(ptr, 0);
                    Debug.Log($"原始值: {original}");
                    Debug.Log($"读取值: {read}");
                    
                    // 类型转换
                    float* floatPtr = (float*)ptr;
                    Debug.Log($"转换为float指针: {floatPtr[0]}, {floatPtr[1]}, {floatPtr[2]}");
                    
                    UnsafeUtility.Free(ptr, Allocator.Temp);
                }
            }
        }

        #endregion

        #region 数组操作示例

        /// <summary>
        /// 数组操作
        /// </summary>
        public static void ArrayOperationsExample()
        {
            Debug.Log("=== 数组操作 ===");
            
            unsafe
            {
                int count = 10;
                int size = UnsafeUtility.SizeOf<int>() * count;
                void* ptr = UnsafeUtility.Malloc(size, UnsafeUtility.AlignOf<int>(), Allocator.Temp);
                
                if (ptr != null)
                {
                    // 初始化数组
                    for (int i = 0; i < count; i++)
                    {
                        UnsafeUtility.WriteArrayElement(ptr, i, i * i);
                    }
                    
                    // 读取数组
                    Debug.Log("数组内容:");
                    for (int i = 0; i < count; i++)
                    {
                        int value = UnsafeUtility.ReadArrayElement<int>(ptr, i);
                        Debug.Log($"  [{i}] = {value}");
                    }
                    
                    // 数组复制
                    void* copyPtr = UnsafeUtility.Malloc(size, UnsafeUtility.AlignOf<int>(), Allocator.Temp);
                    if (copyPtr != null)
                    {
                        UnsafeUtility.MemCpy(copyPtr, ptr, size);
                        Debug.Log("数组复制完成");
                        
                        // 验证复制
                        bool isEqual = UnsafeUtility.MemCmp(ptr, copyPtr, size) == 0;
                        Debug.Log($"复制验证: {isEqual}");
                        
                        UnsafeUtility.Free(copyPtr, Allocator.Temp);
                    }
                    
                    UnsafeUtility.Free(ptr, Allocator.Temp);
                }
            }
        }

        /// <summary>
        /// 数组排序
        /// </summary>
        public static void ArraySortingExample()
        {
            Debug.Log("=== 数组排序 ===");
            
            unsafe
            {
                int count = 5;
                int size = UnsafeUtility.SizeOf<int>() * count;
                void* ptr = UnsafeUtility.Malloc(size, UnsafeUtility.AlignOf<int>(), Allocator.Temp);
                
                if (ptr != null)
                {
                    // 初始化数组（逆序）
                    for (int i = 0; i < count; i++)
                    {
                        UnsafeUtility.WriteArrayElement(ptr, i, count - i);
                    }
                    
                    Debug.Log("排序前:");
                    for (int i = 0; i < count; i++)
                    {
                        int value = UnsafeUtility.ReadArrayElement<int>(ptr, i);
                        Debug.Log($"  [{i}] = {value}");
                    }
                    
                    // 简单冒泡排序
                    for (int i = 0; i < count - 1; i++)
                    {
                        for (int j = 0; j < count - i - 1; j++)
                        {
                            int val1 = UnsafeUtility.ReadArrayElement<int>(ptr, j);
                            int val2 = UnsafeUtility.ReadArrayElement<int>(ptr, j + 1);
                            
                            if (val1 > val2)
                            {
                                UnsafeUtility.WriteArrayElement(ptr, j, val2);
                                UnsafeUtility.WriteArrayElement(ptr, j + 1, val1);
                            }
                        }
                    }
                    
                    Debug.Log("排序后:");
                    for (int i = 0; i < count; i++)
                    {
                        int value = UnsafeUtility.ReadArrayElement<int>(ptr, i);
                        Debug.Log($"  [{i}] = {value}");
                    }
                    
                    UnsafeUtility.Free(ptr, Allocator.Temp);
                }
            }
        }

        #endregion

        #region 性能测试示例

        /// <summary>
        /// 性能测试
        /// </summary>
        public static void PerformanceTestExample()
        {
            Debug.Log("=== 性能测试 ===");
            
            unsafe
            {
                int size = 1024 * 1024; // 1MB
                int iterations = 1000;
                
                // 分配内存
                void* ptr1 = UnsafeUtility.Malloc(size, 4, Allocator.Temp);
                void* ptr2 = UnsafeUtility.Malloc(size, 4, Allocator.Temp);
                
                if (ptr1 != null && ptr2 != null)
                {
                    // 初始化内存
                    UnsafeUtility.MemSet(ptr1, 0xAA, size);
                    UnsafeUtility.MemSet(ptr2, 0xBB, size);
                    
                    // 测试内存复制性能
                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();
                    
                    for (int i = 0; i < iterations; i++)
                    {
                        UnsafeUtility.MemCpy(ptr2, ptr1, size);
                    }
                    
                    stopwatch.Stop();
                    
                    Debug.Log($"内存复制性能测试:");
                    Debug.Log($"- 大小: {size / 1024} KB");
                    Debug.Log($"- 迭代次数: {iterations}");
                    Debug.Log($"- 总时间: {stopwatch.ElapsedMilliseconds} ms");
                    Debug.Log($"- 平均时间: {stopwatch.ElapsedMilliseconds / (float)iterations} ms");
                    Debug.Log($"- 吞吐量: {size * iterations / (stopwatch.ElapsedMilliseconds / 1000.0f) / 1024 / 1024} MB/s");
                    
                    UnsafeUtility.Free(ptr1, Allocator.Temp);
                    UnsafeUtility.Free(ptr2, Allocator.Temp);
                }
            }
        }
    }
}
        #endregion
