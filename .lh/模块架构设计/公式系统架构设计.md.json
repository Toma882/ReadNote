{
    "sourceFile": "模块架构设计/公式系统架构设计.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1767203458660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767203523888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-﻿# 公式系统架构设计\r\n+# 公式系统架构设计\r\n \r\n ## 设计目标\r\n \r\n 设计一套完整的公式解析系统，支持三级公式架构（一级基础函数、二级派生计算、三级综合效果），实现职责分离、策划友好、类型安全，提供数据驱动的配置化公式系统。\r\n"
                },
                {
                    "date": 1767203548548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-﻿# 公式系统架构设计\r\n+# 公式系统架构设计\r\n \r\n ## 设计目标\r\n \r\n 设计一套完整的公式解析系统，支持三级公式架构（一级基础函数、二级派生计算、三级综合效果），实现职责分离、策划友好、类型安全，提供数据驱动的配置化公式系统。\r\n"
                }
            ],
            "date": 1767203458660,
            "name": "Commit-0",
            "content": "# 公式系统架构设计\r\n\r\n## 设计目标\r\n\r\n设计一套完整的公式解析系统，支持三级公式架构（一级基础函数、二级派生计算、三级综合效果），实现职责分离、策划友好、类型安全，提供数据驱动的配置化公式系统。\r\n\r\n---\r\n\r\n## 核心设计理念\r\n\r\n### 1. 三级公式架构为核心\r\n\r\n**本质**：公式系统的核心是三级公式的分层架构\r\n- 一级公式 = 基础获取函数（程序员提供，不运算，只传参）\r\n- 二级公式 = 派生计算（策划编写，基于一级公式）\r\n- 三级公式 = 综合效果计算（策划编写，基于一级和二级公式）\r\n- 职责分离 = 程序员提供基础设施，策划负责公式设计和测试\r\n\r\n### 2. 字符匹配规则 + 类型安全\r\n\r\n**本质**：通过严格的字符匹配规则实现类型安全和职责分离\r\n- 字符匹配规则 = 三级公式以`#`开头，二级公式以`@`开头且包含下划线\r\n- 类型安全 = 通过预定义参数类型避免运行时错误\r\n- 策划友好 = 策划只需严格按照字符匹配规则编写公式\r\n- 即时反馈 = 策划可以独立测试和调整公式，无需程序员参与\r\n\r\n### 3. 数据驱动架构\r\n\r\n**本质**：公式特性通过配置数据实现，无需修改代码\r\n- 公式注册、公式计算 → 通过配置数据定义\r\n- 函数注册、参数传递 → 通过配置数据调整\r\n- 新增公式 → 扩展配置数据即可\r\n- 公式平衡 → 调整配置数值即可\r\n\r\n---\r\n\r\n## 整体架构设计\r\n\r\n### 三级公式架构 + 职责分离\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph ProgrammerLayer[\"程序员层<br/>基础设施提供\"]\r\n        FunctionRegistry[\"函数注册表<br/>RegisterFunction<br/>一级公式函数\"]\r\n        ParserEngine[\"解析引擎<br/>FormulaParserBase<br/>公式解析和编译\"]\r\n        CacheSystem[\"缓存系统<br/>FormulaCache<br/>编译结果缓存\"]\r\n    end\r\n    \r\n    subgraph DesignerLayer[\"策划层<br/>公式设计\"]\r\n        Level1Formula[\"一级公式<br/>ATTR/EQUIPMENT_BONUS<br/>基础获取函数\"]\r\n        Level2Formula[\"二级公式<br/>@Category_Name<br/>派生计算\"]\r\n        Level3Formula[\"三级公式<br/>#FinalResult<br/>综合效果计算\"]\r\n    end\r\n    \r\n    subgraph RuntimeLayer[\"运行时层<br/>公式计算\"]\r\n        ParamContainer[\"参数容器<br/>Param.Create<br/>链式参数传递\"]\r\n        FormulaCalculator[\"公式计算器<br/>CalculateFormula<br/>执行公式计算\"]\r\n        ResultCache[\"结果缓存<br/>计算结果缓存\"]\r\n    end\r\n    \r\n    ProgrammerLayer -->|提供基础设施| DesignerLayer\r\n    DesignerLayer -->|注册公式| RuntimeLayer\r\n    RuntimeLayer -->|计算公式| ResultCache\r\n    \r\n    style ProgrammerLayer fill:#e1f5ff\r\n    style DesignerLayer fill:#fff4e1\r\n    style RuntimeLayer fill:#c8e6c9\r\n```\r\n\r\n### 三级公式数据流\r\n\r\n```mermaid\r\ngraph LR\r\n    Start[计算公式请求<br/>#TotalDamage] -->|1. 解析三级公式| ParseLv3[解析引擎<br/>识别#TotalDamage]\r\n    ParseLv3 -->|2. 查找二级公式| FindLv2[查找二级公式<br/>@Combat_AttackPower]\r\n    FindLv2 -->|3. 解析二级公式| ParseLv2[解析二级公式<br/>识别@Category_Name]\r\n    ParseLv2 -->|4. 查找一级公式| FindLv1[查找一级公式<br/>ATTR/EQUIPMENT_BONUS]\r\n    FindLv1 -->|5. 执行一级函数| ExecuteLv1[执行一级函数<br/>获取基础数据]\r\n    ExecuteLv1 -->|6. 计算二级公式| CalcLv2[计算二级公式<br/>派生计算]\r\n    CalcLv2 -->|7. 计算三级公式| CalcLv3[计算三级公式<br/>综合效果]\r\n    CalcLv3 -->|8. 返回结果| End[最终结果]\r\n    \r\n    style ParseLv3 fill:#e1f5ff\r\n    style FindLv2 fill:#fff4e1\r\n    style ExecuteLv1 fill:#c8e6c9\r\n    style CalcLv3 fill:#c8e6c9\r\n```\r\n\r\n**数据流特性**：\r\n- ✅ **三级分层**：一级 → 二级 → 三级，逐层计算\r\n- ✅ **职责分离**：程序员提供一级函数，策划编写二级和三级公式\r\n- ✅ **字符匹配**：通过字符匹配规则识别公式级别\r\n- ✅ **自动缓存**：编译结果自动缓存，提升性能\r\n- ✅ **类型安全**：通过预定义参数类型避免运行时错误\r\n\r\n---\r\n\r\n## 三级公式架构设计\r\n\r\n### 核心职责\r\n\r\n一级基础函数 + 二级派生计算 + 三级综合效果\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph Level1[\"一级公式层<br/>基础获取函数\"]\r\n        AttrFunc[\"ATTR函数<br/>获取角色属性\"]\r\n        EquipFunc[\"EQUIPMENT_BONUS函数<br/>获取装备加成\"]\r\n        SkillFunc[\"SKILL_BONUS函数<br/>获取技能加成\"]\r\n        OtherFunc[\"其他函数<br/>...\"]\r\n    end\r\n    \r\n    subgraph Level2[\"二级公式层<br/>派生计算\"]\r\n        CombatFormula[\"@Combat_AttackPower<br/>战斗攻击力计算\"]\r\n        SoulFormula[\"@SoulAttribute_Mod<br/>灵魂属性修正\"]\r\n        WuXingFormula[\"@WuXing_Metal<br/>五行属性计算\"]\r\n        OtherFormula[\"其他二级公式<br/>...\"]\r\n    end\r\n    \r\n    subgraph Level3[\"三级公式层<br/>综合效果计算\"]\r\n        TotalDamage[\"#TotalDamage<br/>总伤害计算\"]\r\n        FinalHealing[\"#FinalHealing<br/>最终治疗量\"]\r\n        SkillEffect[\"#SkillEffect<br/>技能效果计算\"]\r\n        OtherFinal[\"其他三级公式<br/>...\"]\r\n    end\r\n    \r\n    Level1 -->|组成| Level2\r\n    Level1 -->|组成| Level3\r\n    Level2 -->|组成| Level3\r\n    \r\n    style Level1 fill:#e1f5ff\r\n    style Level2 fill:#fff4e1\r\n    style Level3 fill:#c8e6c9\r\n```\r\n\r\n### 字符匹配规则\r\n\r\n**三级公式识别规则**：\r\n```lua\r\n-- 三级公式：以 # 开头\r\nlocal lv3Pattern = \"%#[%w_]+\"  -- #TotalDamage\r\n```\r\n\r\n**二级公式识别规则**：\r\n```lua\r\n-- 二级公式：以 @ 开头，包含下划线\r\nlocal lv2Pattern = \"%@[%w_]+%_[%w_]+\"  -- @Combat_AttackPower\r\n```\r\n\r\n**一级公式识别规则**：\r\n```lua\r\n-- 一级公式：三种模式\r\nlocal lv1_1Pattern = \"([A-Z_]+%([^%)]*%))\"  -- FUNC(args)\r\nlocal lv1_2Pattern = \"([A-Z_]+%[[^%]]*%]\"   -- FUNC[index]\r\nlocal lv1_3Pattern = \"\\\\b([A-Z_]+)\\\\b\"      -- FUNC\r\n```\r\n\r\n### 公式依赖关系\r\n\r\n```mermaid\r\ngraph TD\r\n    L3[三级公式<br/>#TotalDamage] -->|依赖| L2A[二级公式<br/>@Combat_AttackPower]\r\n    L3 -->|依赖| L2B[二级公式<br/>@Combat_CriticalMultiplier]\r\n    \r\n    L2A -->|依赖| L1A[一级公式<br/>ATTR]\r\n    L2A -->|依赖| L1B[一级公式<br/>EQUIPMENT_BONUS]\r\n    L2B -->|依赖| L1C[一级公式<br/>SKILL_BONUS]\r\n    \r\n    style L3 fill:#c8e6c9\r\n    style L2A fill:#fff4e1\r\n    style L2B fill:#fff4e1\r\n    style L1A fill:#e1f5ff\r\n    style L1B fill:#e1f5ff\r\n    style L1C fill:#e1f5ff\r\n```\r\n\r\n---\r\n\r\n## 解析引擎架构设计\r\n\r\n### 核心职责\r\n\r\n公式解析 + 公式编译 + 结果缓存\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph ParserEngine[\"解析引擎<br/>FormulaParserBase\"]\r\n        FormulaParser[\"公式解析器<br/>ParseFormula<br/>识别公式级别\"]\r\n        FormulaCompiler[\"公式编译器<br/>CompileFormula<br/>编译为Lua函数\"]\r\n        FormulaCache[\"公式缓存<br/>FormulaCache<br/>缓存编译结果\"]\r\n    end\r\n    \r\n    subgraph PatternMatcher[\"模式匹配器\"]\r\n        Lv3Matcher[\"三级公式匹配器<br/>#Pattern\"]\r\n        Lv2Matcher[\"二级公式匹配器<br/>@Pattern\"]\r\n        Lv1Matcher[\"一级公式匹配器<br/>FUNCPattern\"]\r\n    end\r\n    \r\n    subgraph FunctionResolver[\"函数解析器\"]\r\n        Lv3Resolver[\"三级公式解析器<br/>解析#Formula\"]\r\n        Lv2Resolver[\"二级公式解析器<br/>解析@Formula\"]\r\n        Lv1Resolver[\"一级公式解析器<br/>解析FUNC调用\"]\r\n    end\r\n    \r\n    FormulaParser --> PatternMatcher\r\n    PatternMatcher --> FunctionResolver\r\n    FunctionResolver --> FormulaCompiler\r\n    FormulaCompiler --> FormulaCache\r\n    \r\n    style ParserEngine fill:#e1f5ff\r\n    style PatternMatcher fill:#fff4e1\r\n    style FunctionResolver fill:#c8e6c9\r\n```\r\n\r\n### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[计算公式请求<br/>CalculateFormula] --> CheckCache{检查缓存<br/>FormulaCache}\r\n    CheckCache -->|缓存命中| ReturnCache[返回缓存结果]\r\n    CheckCache -->|缓存未命中| ParseFormula[解析公式<br/>识别公式级别]\r\n    \r\n    ParseFormula --> IdentifyLevel{识别公式级别<br/>#/@/FUNC}\r\n    IdentifyLevel -->|三级公式| ParseLv3[解析三级公式<br/>查找依赖的二级公式]\r\n    IdentifyLevel -->|二级公式| ParseLv2[解析二级公式<br/>查找依赖的一级公式]\r\n    IdentifyLevel -->|一级公式| ParseLv1[解析一级公式<br/>查找函数定义]\r\n    \r\n    ParseLv3 --> ResolveDeps[解析依赖<br/>递归解析二级和一级公式]\r\n    ParseLv2 --> ResolveDeps\r\n    ParseLv1 --> ResolveDeps\r\n    \r\n    ResolveDeps --> Compile[编译公式<br/>生成Lua函数]\r\n    Compile --> CacheResult[缓存编译结果<br/>FormulaCache]\r\n    CacheResult --> Execute[执行函数<br/>传入参数]\r\n    Execute --> ReturnResult[返回计算结果]\r\n    \r\n    style CheckCache fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style IdentifyLevel fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style Compile fill:#c8e6c9\r\n    style ReturnResult fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 参数传递系统架构设计\r\n\r\n### 核心职责\r\n\r\n链式参数传递 + 类型安全 + 参数验证\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph ParamContainer[\"参数容器<br/>Param.Create\"]\r\n        ParamBuilder[\"参数构建器<br/>链式调用\"]\r\n        ParamValidator[\"参数验证器<br/>类型检查\"]\r\n        ParamStorage[\"参数存储<br/>paramDict\"]\r\n    end\r\n    \r\n    subgraph ParamTypes[\"参数类型定义\"]\r\n        ActorType[\"Actor类型<br/>角色对象\"]\r\n        TargetType[\"Target类型<br/>目标对象\"]\r\n        SkillType[\"Skill类型<br/>技能数据\"]\r\n        ItemType[\"Item类型<br/>道具数据\"]\r\n    end\r\n    \r\n    subgraph FunctionCall[\"函数调用\"]\r\n        GetParam[\"获取参数<br/>GetParam(type)\"]\r\n        TypeCheck[\"类型检查<br/>验证参数类型\"]\r\n        PassParam[\"传递参数<br/>传递给函数\"]\r\n    end\r\n    \r\n    ParamContainer -->|定义参数类型| ParamTypes\r\n    ParamTypes -->|验证参数| ParamValidator\r\n    ParamValidator -->|存储参数| ParamStorage\r\n    FunctionCall -->|读取参数| ParamStorage\r\n    FunctionCall -->|类型检查| TypeCheck\r\n    TypeCheck -->|传递参数| PassParam\r\n    \r\n    style ParamContainer fill:#e1f5ff\r\n    style ParamTypes fill:#fff4e1\r\n    style FunctionCall fill:#c8e6c9\r\n```\r\n\r\n### 链式调用设计\r\n\r\n```mermaid\r\ngraph LR\r\n    Create[Param.Create] -->|:Actor| Actor[设置Actor参数]\r\n    Actor -->|:Target| Target[设置Target参数]\r\n    Target -->|:Skill| Skill[设置Skill参数]\r\n    Skill -->|:Item| Item[设置Item参数]\r\n    Item -->|完成| End[参数容器就绪]\r\n    \r\n    style Create fill:#e1f5ff\r\n    style End fill:#c8e6c9\r\n```\r\n\r\n**设计优势**：\r\n- ✅ **链式调用**：流畅的API设计，易于使用\r\n- ✅ **类型安全**：参数类型预定义，避免运行时错误\r\n- ✅ **参数验证**：自动验证参数类型和完整性\r\n- ✅ **灵活扩展**：可以轻松添加新的参数类型\r\n\r\n---\r\n\r\n## 架构模式分析\r\n\r\n### 职责分离模式（Separation of Concerns）\r\n\r\n**核心思想**：程序员和策划职责分离\r\n\r\n```mermaid\r\ngraph TB\r\n    Programmer[程序员<br/>提供基础设施]\r\n    Designer[策划<br/>设计公式]\r\n    \r\n    Programmer -->|提供| Infrastructure[基础设施<br/>函数注册/解析引擎]\r\n    Designer -->|使用| Infrastructure\r\n    Designer -->|编写| Formulas[公式<br/>二级/三级公式]\r\n    \r\n    style Programmer fill:#e1f5ff\r\n    style Designer fill:#fff4e1\r\n    style Infrastructure fill:#c8e6c9\r\n```\r\n\r\n**优势**：\r\n- ✅ **职责清晰**：程序员负责基础设施，策划负责公式设计\r\n- ✅ **独立工作**：策划可以独立测试和调整公式\r\n- ✅ **减少沟通**：减少程序员和策划之间的沟通成本\r\n\r\n### 模板方法模式（Template Method Pattern）\r\n\r\n**核心思想**：定义公式解析的标准流程\r\n\r\n```mermaid\r\ngraph TB\r\n    TemplateMethod[模板方法<br/>CalculateFormula<br/>定义标准流程]\r\n    \r\n    Step1[步骤1：检查缓存<br/>抽象步骤]\r\n    Step2[步骤2：解析公式<br/>抽象步骤]\r\n    Step3[步骤3：编译公式<br/>具体步骤]\r\n    Step4[步骤4：执行计算<br/>具体步骤]\r\n    \r\n    ConcreteStep1[具体实现1<br/>FormulaCache查找]\r\n    ConcreteStep2[具体实现2<br/>ParseFormula解析]\r\n    \r\n    TemplateMethod --> Step1\r\n    TemplateMethod --> Step2\r\n    TemplateMethod --> Step3\r\n    TemplateMethod --> Step4\r\n    \r\n    Step1 --> ConcreteStep1\r\n    Step2 --> ConcreteStep2\r\n    \r\n    style TemplateMethod fill:#f3e5f5\r\n    style Step1 fill:#e1f5ff\r\n    style Step2 fill:#e1f5ff\r\n    style Step3 fill:#fff4e1\r\n    style Step4 fill:#fff4e1\r\n```\r\n\r\n---\r\n\r\n## 数据流设计\r\n\r\n### 公式计算数据流\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Client as 客户端\r\n    participant Parser as FormulaParserBase\r\n    participant Cache as FormulaCache\r\n    participant Compiler as FormulaCompiler\r\n    participant Func as 一级函数\r\n    \r\n    Client->>Parser: CalculateFormula(\"#TotalDamage\", params)\r\n    Parser->>Cache: 检查缓存\r\n    Cache-->>Parser: 缓存未命中\r\n    Parser->>Parser: 解析三级公式\r\n    Parser->>Parser: 查找二级公式 @Combat_AttackPower\r\n    Parser->>Parser: 解析二级公式\r\n    Parser->>Parser: 查找一级公式 ATTR\r\n    Parser->>Func: 调用 ATTR('strength', Actor)\r\n    Func-->>Parser: 返回属性值\r\n    Parser->>Compiler: 编译公式为函数\r\n    Compiler-->>Parser: 返回编译后的函数\r\n    Parser->>Cache: 缓存编译结果\r\n    Parser->>Parser: 执行编译后的函数\r\n    Parser-->>Client: 返回计算结果\r\n```\r\n\r\n---\r\n\r\n## 架构验证\r\n\r\n### 流程合理性验证\r\n\r\n从架构可验证：\r\n- ✅ **数据流完整**：公式请求 → 解析 → 编译 → 执行 → 返回（完整流程）\r\n- ✅ **职责清晰**：程序员层、策划层、运行时层职责明确，无重叠\r\n- ✅ **解耦设计**：通过三级公式架构实现职责分离\r\n- ✅ **类型安全**：通过字符匹配规则和参数类型定义实现类型安全\r\n\r\n### 扩展性验证\r\n\r\n从架构可验证：\r\n- ✅ **三级架构**：新增公式只需在对应级别注册\r\n- ✅ **函数扩展**：新增一级函数只需注册到FunctionRegistry\r\n- ✅ **参数扩展**：新增参数类型只需扩展ParamTypes\r\n- ✅ **配置驱动**：公式通过配置数据扩展，无需修改代码\r\n\r\n### 易用性验证\r\n\r\n从架构可验证：\r\n- ✅ **策划友好**：策划只需按照字符匹配规则编写公式\r\n- ✅ **即时反馈**：策划可以独立测试和调整公式\r\n- ✅ **类型安全**：通过预定义参数类型避免运行时错误\r\n- ✅ **自动缓存**：编译结果自动缓存，提升性能\r\n\r\n---\r\n\r\n## 开发指导原则\r\n\r\n### 一、开发约束（什么能做，什么不能做）\r\n\r\n#### ✅ 应该做的\r\n\r\n1. **一级函数必须注册**\r\n   ```\r\n   ✅ 正确：\r\n   formulaParser:RegisterFunction(\"ATTR\", function(...) end, ...)\r\n   \r\n   ❌ 错误：\r\n   直接调用未注册的函数\r\n   ```\r\n\r\n2. **公式必须遵循字符匹配规则**\r\n   ```\r\n   ✅ 正确：\r\n   三级公式：#TotalDamage\r\n   二级公式：@Combat_AttackPower\r\n   一级公式：ATTR('strength', Actor)\r\n   \r\n   ❌ 错误：\r\n   不遵循字符匹配规则（如：TotalDamage、@CombatPower）\r\n   ```\r\n\r\n3. **参数必须使用Param容器**\r\n   ```\r\n   ✅ 正确：\r\n   local params = Param.Create():Actor(player):Target(enemy)\r\n   \r\n   ❌ 错误：\r\n   直接传递复杂对象\r\n   ```\r\n\r\n#### ❌ 不应该做的\r\n\r\n1. **禁止绕过字符匹配规则**\r\n   - 公式必须严格按照字符匹配规则编写\r\n   - 不能使用不符合规则的公式格式\r\n\r\n2. **禁止直接调用未注册函数**\r\n   - 所有一级函数必须注册\r\n   - 不能直接调用未注册的函数\r\n\r\n3. **禁止硬编码公式逻辑**\r\n   - 公式逻辑应该在配置中定义\r\n   - 不能硬编码公式计算逻辑\r\n\r\n### 二、开发流程（标准化开发步骤）\r\n\r\n#### 程序员开发一级函数的流程\r\n\r\n```\r\n1. 定义函数签名\r\n   ↓\r\n   确定函数名、参数类型、返回值类型\r\n   \r\n2. 实现函数逻辑\r\n   ↓\r\n   实现函数的具体计算逻辑\r\n   \r\n3. 注册函数\r\n   ↓\r\n   formulaParser:RegisterFunction(\"FUNC_NAME\", func, ...)\r\n   \r\n4. 测试函数\r\n   ↓\r\n   使用TestNestedFormula测试函数\r\n```\r\n\r\n#### 策划编写公式的流程\r\n\r\n```\r\n1. 确定公式级别\r\n   ↓\r\n   一级/二级/三级公式\r\n   \r\n2. 遵循字符匹配规则\r\n   ↓\r\n   三级：#开头，二级：@开头+下划线，一级：FUNC格式\r\n   \r\n3. 编写公式\r\n   ↓\r\n   使用已注册的一级函数和二级公式\r\n   \r\n4. 测试公式\r\n   ↓\r\n   使用CalculateFormula测试公式\r\n```\r\n\r\n---\r\n\r\n## 总结\r\n\r\n### 架构设计价值\r\n\r\n该架构设计文档的价值在于：\r\n- ✅ **思路解构**：完整解构公式系统的搭建思路\r\n- ✅ **流程验证**：从架构层面验证流程合理性\r\n- ✅ **模式分析**：分析职责分离、模板方法模式的应用\r\n- ✅ **开发指导**：为后续详细设计和实现提供清晰指导\r\n\r\n### 设计原则\r\n\r\n- ✅ **三级公式架构为核心**：一级基础函数、二级派生计算、三级综合效果\r\n- ✅ **字符匹配规则 + 类型安全**：通过严格的字符匹配规则实现类型安全\r\n- ✅ **数据驱动架构**：公式特性通过配置数据实现\r\n- ✅ **职责分离**：程序员提供基础设施，策划负责公式设计\r\n\r\n### 架构特点\r\n\r\n- ✅ **策划友好**：策划只需按照字符匹配规则编写公式\r\n- ✅ **类型安全**：通过预定义参数类型避免运行时错误\r\n- ✅ **自动缓存**：编译结果自动缓存，提升性能\r\n- ✅ **灵活扩展**：新增公式只需在对应级别注册\r\n\r\n细节实现是后续开发阶段的工作，当前架构设计已足够指导整个公式系统的开发。\r\n"
        }
    ]
}