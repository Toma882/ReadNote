{
    "sourceFile": "模块架构设计/设计模式库架构设计.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 42,
            "patches": [
                {
                    "date": 1767208727919,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767208753328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n │   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n │   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n │   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n │   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n-│   ├── Mediator (中介者模式) - \r\n+│   ├── Mediator (中介者模式) - 微内核架构思维，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Memento (备忘录模式)\r\n │   ├── Observer (观察者模式)\r\n │   ├── State (状态模式)\r\n │   ├── Strategy (策略模式)\r\n"
                },
                {
                    "date": 1767208760465,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n │   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n │   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n │   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n │   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n-│   ├── Mediator (中介者模式) - 微内核架构思维，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n+│   ├── Mediator (中介者模式) - 微内核架构思维，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n │   ├── Memento (备忘录模式)\r\n │   ├── Observer (观察者模式)\r\n │   ├── State (状态模式)\r\n │   ├── Strategy (策略模式)\r\n"
                },
                {
                    "date": 1767208784948,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n │   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n │   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n │   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Mediator (中介者模式) - 微内核架构思维，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n-│   ├── Memento (备忘录模式)\r\n+│   ├── Memento (备忘录模式) - \r\n │   ├── Observer (观察者模式)\r\n │   ├── State (状态模式)\r\n │   ├── Strategy (策略模式)\r\n │   ├── TemplateMethod (模板方法模式)\r\n"
                },
                {
                    "date": 1767208815756,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n │   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n │   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n │   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n │   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n-│   ├── Mediator (中介者模式) - 微内核架构思维，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n+│   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n │   ├── Memento (备忘录模式) - \r\n │   ├── Observer (观察者模式)\r\n │   ├── State (状态模式)\r\n │   ├── Strategy (策略模式)\r\n"
                },
                {
                    "date": 1767209264561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n │   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n │   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n │   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n-│   ├── Memento (备忘录模式) - \r\n+│   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n │   ├── Observer (观察者模式)\r\n │   ├── State (状态模式)\r\n │   ├── Strategy (策略模式)\r\n │   ├── TemplateMethod (模板方法模式)\r\n"
                },
                {
                    "date": 1767209335241,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n │   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n │   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n │   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n-│   ├── Observer (观察者模式)\r\n+│   ├── Observer (观察者模式) - 实现事件分发系统\r\n │   ├── State (状态模式)\r\n │   ├── Strategy (策略模式)\r\n │   ├── TemplateMethod (模板方法模式)\r\n │   └── Visitor (访问者模式)\r\n"
                },
                {
                    "date": 1767209367730,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n │   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n │   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n │   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n-│   ├── Observer (观察者模式) - 实现事件分发系统\r\n+│   ├── Observer (观察者模式) - 事件分发系统的运用\r\n │   ├── State (状态模式)\r\n │   ├── Strategy (策略模式)\r\n │   ├── TemplateMethod (模板方法模式)\r\n │   └── Visitor (访问者模式)\r\n"
                },
                {
                    "date": 1767209375116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,847 @@\n+# 🎯 Lua设计模式库 - 完整指南\r\n+\r\n+## 📋 概述\r\n+\r\n+这是一个功能完整的Lua设计模式库，涵盖了从基础到高级的各种设计模式实现。每个模式都经过精心设计，确保易用性、可扩展性和高性能。\r\n+\r\n+**🎯 设计理念：** 将复杂的设计模式封装成简单易用的工具，让开发者专注于业务逻辑，而不是架构细节。\r\n+\r\n+---\r\n+\r\n+## 🏗️ 架构分类\r\n+\r\n+### 核心模式分类\r\n+```\r\n+Pattern Library (设计模式库)\r\n+├── Creational (创建型模式) - 对象创建的艺术\r\n+│   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n+│   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)\r\n+│   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容\r\n+│   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n+│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n+├── Structural (结构型模式) - 对象组合的艺术\r\n+│   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n+│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果\r\n+│   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n+│   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n+│   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n+│   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n+│   └── Proxy (代理模式) - 可用钩子方法+策略模式替代，避免代理模式滥用\r\n+├── Behavioral (行为型模式) - 对象交互的艺术\r\n+│   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n+│   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n+│   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n+│   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n+│   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n+│   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n+│   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n+│   ├── State (状态模式)\r\n+│   ├── Strategy (策略模式)\r\n+│   ├── TemplateMethod (模板方法模式)\r\n+│   └── Visitor (访问者模式)\r\n+└── Advanced (高级模式) - 游戏开发专用模式\r\n+    ├── Component (组件模式)\r\n+    ├── EventDriven (事件驱动模式)\r\n+    ├── StateMachine (状态机模式)\r\n+    ├── ServiceLocator (服务定位器模式)\r\n+    ├── ObjectPool (对象池模式)\r\n+    ├── DataDriven (数据驱动模式)\r\n+    ├── ReactiveProgramming (响应式编程模式)\r\n+    ├── DependencyInjection (依赖注入模式)\r\n+    ├── DirtyFlag (脏标记模式)\r\n+    ├── DoubleBuffer (双缓冲模式)\r\n+    ├── DataLocality (数据局部性模式)\r\n+    └── Bytecode (字节码模式)\r\n+```\r\n+\r\n+---\r\n+\r\n+## 🏭 创建型模式 (Creational Patterns)\r\n+\r\n+### 🔒 **单例模式 (Singleton)**\r\n+**用途：** 确保一个类只有一个实例，并提供全局访问点\r\n+**作用：** \r\n+- 游戏管理器\r\n+- 配置管理器\r\n+- 资源管理器\r\n+- 日志系统\r\n+\r\n+**适用场景：**\r\n+- 需要全局唯一实例\r\n+- 资源管理\r\n+- 配置管理\r\n+\r\n+```lua\r\n+local singleton = SingletonPattern.New()\r\n+local instance1 = singleton:GetInstance()\r\n+local instance2 = singleton:GetInstance()\r\n+print(instance1 == instance2)  -- true，同一个实例\r\n+```\r\n+\r\n+### 🏭 **工厂模式 (Factory)**\r\n+**用途：** 根据条件创建不同类型的对象\r\n+**作用：**\r\n+- 游戏对象创建\r\n+- 武器系统\r\n+- 敌人生成\r\n+- 道具创建\r\n+\r\n+**适用场景：**\r\n+- 需要根据条件创建对象\r\n+- 对象创建逻辑复杂\r\n+- 支持扩展新类型\r\n+\r\n+```lua\r\n+local factory = FactoryPattern.New()\r\n+local weapon = factory:CreateWeapon(\"sword\")\r\n+local enemy = factory:CreateEnemy(\"goblin\")\r\n+```\r\n+\r\n+### 🏭🏭 **抽象工厂模式 (AbstractFactory)**\r\n+**用途：** 创建一系列相关对象，确保它们相互兼容\r\n+**作用：**\r\n+- 游戏主题系统\r\n+- UI风格系统\r\n+- 关卡风格\r\n+- 种族系统\r\n+\r\n+**适用场景：**\r\n+- 需要创建相关对象族\r\n+- 确保对象兼容性\r\n+- 支持多种风格\r\n+\r\n+```lua\r\n+local factory = AbstractFactoryPattern.New()\r\n+local medievalFactory = factory:CreateFactory(\"medieval\")\r\n+local sword = medievalFactory:CreateWeapon()\r\n+local armor = medievalFactory:CreateArmor()\r\n+```\r\n+\r\n+### 🏗️ **建造者模式 (Builder)**\r\n+**用途：** 分步骤构建复杂对象\r\n+**作用：**\r\n+- 角色创建\r\n+- 关卡构建\r\n+- 配置构建\r\n+- 复杂对象组装\r\n+\r\n+**适用场景：**\r\n+- 对象构建过程复杂\r\n+- 需要分步骤构建\r\n+- 支持不同构建方式\r\n+\r\n+```lua\r\n+local builder = BuilderPattern.New()\r\n+local character = builder:SetName(\"英雄\")\r\n+    :SetClass(\"战士\")\r\n+    :SetLevel(10)\r\n+    :SetEquipment(\"铁剑\")\r\n+    :Build()\r\n+```\r\n+\r\n+### 🧬 **原型模式 (Prototype)**\r\n+**用途：** 通过克隆现有对象来创建新对象\r\n+**作用：**\r\n+- 对象复制\r\n+- 模板系统\r\n+- 快速创建\r\n+- 减少初始化开销\r\n+\r\n+**适用场景：**\r\n+- 对象创建开销大\r\n+- 需要对象副本\r\n+- 模板系统\r\n+\r\n+```lua\r\n+local prototype = PrototypePattern.New()\r\n+local original = prototype:Create(\"template\")\r\n+local clone = original:Clone()\r\n+```\r\n+\r\n+---\r\n+\r\n+## 🏗️ 结构型模式 (Structural Patterns)\r\n+\r\n+### 🔌 **适配器模式 (Adapter)**\r\n+**用途：** 让不兼容的接口能够协同工作\r\n+**作用：**\r\n+- 第三方库集成\r\n+- 旧系统适配\r\n+- 接口统一\r\n+- 兼容性处理\r\n+\r\n+**适用场景：**\r\n+- 集成第三方库\r\n+- 系统升级兼容\r\n+- 接口不匹配\r\n+\r\n+```lua\r\n+local adapter = AdapterPattern.New()\r\n+local newInterface = adapter:Adapt(oldSystem)\r\n+newInterface:NewMethod()\r\n+```\r\n+\r\n+### 🌉 **桥接模式 (Bridge)**\r\n+**用途：** 将抽象与实现分离，使它们可以独立变化\r\n+**作用：**\r\n+- 平台抽象\r\n+- 渲染器抽象\r\n+- 数据库抽象\r\n+- 网络抽象\r\n+\r\n+**适用场景：**\r\n+- 需要支持多平台\r\n+- 抽象与实现分离\r\n+- 避免继承爆炸\r\n+\r\n+```lua\r\n+local bridge = BridgePattern.New()\r\n+local renderer = bridge:CreateRenderer(\"OpenGL\")\r\n+local shape = bridge:CreateShape(\"Circle\", renderer)\r\n+```\r\n+\r\n+### 🧩 **组合模式 (Composite)**\r\n+**用途：** 将对象组合成树形结构，统一处理单个对象和组合对象\r\n+**作用：**\r\n+- 场景图系统\r\n+- UI组件树\r\n+- 文件系统\r\n+- 游戏对象层次\r\n+\r\n+**适用场景：**\r\n+- 树形结构\r\n+- 部分-整体关系\r\n+- 统一处理接口\r\n+\r\n+```lua\r\n+local composite = CompositePattern.New()\r\n+local root = composite:CreateComponent(\"root\")\r\n+local child1 = composite:CreateComponent(\"child1\")\r\n+root:Add(child1)\r\n+root:Operation()  -- 递归调用所有子组件\r\n+```\r\n+\r\n+### 🎨 **装饰器模式 (Decorator)**\r\n+**用途：** 动态地给对象添加新功能\r\n+**作用：**\r\n+- 装备系统\r\n+- 技能增强\r\n+- 状态效果\r\n+- 功能扩展\r\n+\r\n+**适用场景：**\r\n+- 需要动态添加功能\r\n+- 避免继承爆炸\r\n+- 功能组合\r\n+\r\n+```lua\r\n+local decorator = DecoratorPattern.New()\r\n+local baseWeapon = decorator:CreateWeapon(\"剑\")\r\n+local fireWeapon = decorator:AddFireEffect(baseWeapon)\r\n+local iceWeapon = decorator:AddIceEffect(fireWeapon)\r\n+```\r\n+\r\n+### 🏛️ **外观模式 (Facade)**\r\n+**用途：** 为复杂子系统提供简单接口\r\n+**作用：**\r\n+- 系统封装\r\n+- 简化接口\r\n+- 降低耦合\r\n+- 统一入口\r\n+\r\n+**适用场景：**\r\n+- 复杂系统封装\r\n+- 简化客户端使用\r\n+- 降低系统耦合\r\n+\r\n+```lua\r\n+local facade = FacadePattern.New()\r\n+-- 复杂的子系统操作被封装成简单接口\r\n+facade:StartGame()\r\n+facade:SaveGame()\r\n+facade:LoadGame()\r\n+```\r\n+\r\n+### 🦋 **享元模式 (Flyweight)**\r\n+**用途：** 通过共享减少内存使用\r\n+**作用：**\r\n+- 纹理共享\r\n+- 模型共享\r\n+- 配置共享\r\n+- 资源优化\r\n+\r\n+**适用场景：**\r\n+- 大量相似对象\r\n+- 内存优化\r\n+- 资源共享\r\n+\r\n+```lua\r\n+local flyweight = FlyweightPattern.New()\r\n+local texture1 = flyweight:GetTexture(\"grass\")\r\n+local texture2 = flyweight:GetTexture(\"grass\")  -- 共享同一个纹理\r\n+```\r\n+\r\n+### 🎭 **代理模式 (Proxy)**\r\n+**用途：** 控制对其他对象的访问\r\n+**作用：**\r\n+- 权限控制\r\n+- 延迟加载\r\n+- 缓存代理\r\n+- 安全控制\r\n+\r\n+**适用场景：**\r\n+- 访问控制\r\n+- 延迟加载\r\n+- 缓存优化\r\n+\r\n+```lua\r\n+local proxy = ProxyPattern.New()\r\n+local realObject = proxy:GetObject()  -- 可能延迟加载\r\n+proxy:CheckPermission(\"read\")  -- 权限检查\r\n+```\r\n+\r\n+---\r\n+\r\n+## 🎭 行为型模式 (Behavioral Patterns)\r\n+\r\n+### 🔗 **责任链模式 (ChainOfResponsibility)**\r\n+**用途：** 将请求沿着处理者链进行传递，直到被处理\r\n+**作用：**\r\n+- 事件处理\r\n+- 权限验证\r\n+- 异常处理\r\n+- 请求过滤\r\n+\r\n+**适用场景：**\r\n+- 多个对象处理请求\r\n+- 请求处理顺序不确定\r\n+- 动态处理链\r\n+\r\n+```lua\r\n+local chain = ChainOfResponsibilityPattern.New()\r\n+chain:AddHandler(handler1)\r\n+chain:AddHandler(handler2)\r\n+chain:HandleRequest(request)\r\n+```\r\n+\r\n+### 📝 **命令模式 (Command)**\r\n+**用途：** 将请求封装成对象，支持请求排队、记录日志、撤销等操作\r\n+**作用：**\r\n+- 撤销/重做系统\r\n+- 宏命令\r\n+- 队列处理\r\n+- 日志记录\r\n+\r\n+**适用场景：**\r\n+- 需要撤销功能\r\n+- 命令排队\r\n+- 宏操作\r\n+\r\n+```lua\r\n+local command = CommandPattern.New()\r\n+local moveCommand = command:CreateMoveCommand(unit, target)\r\n+command:Execute(moveCommand)\r\n+command:Undo()  -- 撤销操作\r\n+```\r\n+\r\n+### 🔤 **解释器模式 (Interpreter)**\r\n+**用途：** 为语言创建解释器\r\n+**作用：**\r\n+- 脚本系统\r\n+- 配置解析\r\n+- 规则引擎\r\n+- 表达式求值\r\n+\r\n+**适用场景：**\r\n+- 简单语言解析\r\n+- 规则引擎\r\n+- 表达式计算\r\n+\r\n+```lua\r\n+local interpreter = InterpreterPattern.New()\r\n+local result = interpreter:Interpret(\"1 + 2 * 3\")\r\n+```\r\n+\r\n+### 🔄 **迭代器模式 (Iterator)**\r\n+**用途：** 提供一种方法顺序访问集合中的元素，而不暴露其内部表示\r\n+**作用：**\r\n+- 集合遍历\r\n+- 自定义遍历\r\n+- 遍历算法\r\n+- 集合封装\r\n+\r\n+**适用场景：**\r\n+- 集合遍历\r\n+- 自定义遍历逻辑\r\n+- 集合封装\r\n+\r\n+```lua\r\n+local iterator = IteratorPattern.New()\r\n+local collection = iterator:CreateCollection()\r\n+for item in collection:Iterator() do\r\n+    print(item)\r\n+end\r\n+```\r\n+\r\n+### 🤝 **中介者模式 (Mediator)**\r\n+**用途：** 封装对象间的交互，降低它们之间的耦合度\r\n+**作用：**\r\n+- 聊天系统\r\n+- 游戏系统协调\r\n+- UI组件协调\r\n+- 模块间通信\r\n+\r\n+**适用场景：**\r\n+- 对象间复杂交互\r\n+- 降低耦合\r\n+- 集中控制\r\n+\r\n+```lua\r\n+local mediator = MediatorPattern.New()\r\n+mediator:RegisterComponent(component1)\r\n+mediator:RegisterComponent(component2)\r\n+component1:SendMessage(\"hello\", mediator)\r\n+```\r\n+\r\n+### 💾 **备忘录模式 (Memento)**\r\n+**用途：** 在不破坏封装的前提下，捕获并外部化对象的内部状态\r\n+**作用：**\r\n+- 游戏存档\r\n+- 撤销系统\r\n+- 状态恢复\r\n+- 快照系统\r\n+\r\n+**适用场景：**\r\n+- 状态保存\r\n+- 撤销功能\r\n+- 快照系统\r\n+\r\n+```lua\r\n+local memento = MementoPattern.New()\r\n+local originator = memento:CreateOriginator()\r\n+local savedState = originator:SaveState()\r\n+originator:RestoreState(savedState)\r\n+```\r\n+\r\n+### 👀 **观察者模式 (Observer)**\r\n+**用途：** 定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会得到通知\r\n+**作用：**\r\n+- 事件系统\r\n+- 数据绑定\r\n+- 消息通知\r\n+- 状态同步\r\n+\r\n+**适用场景：**\r\n+- 事件通知\r\n+- 数据同步\r\n+- 松耦合通信\r\n+\r\n+```lua\r\n+local observer = ObserverPattern.New()\r\n+observer:Subscribe(subscriber1)\r\n+observer:Subscribe(subscriber2)\r\n+observer:Notify(\"event occurred\")\r\n+```\r\n+\r\n+### 🔄 **状态模式 (State)**\r\n+**用途：** 让对象在其内部状态改变时改变其行为\r\n+**作用：**\r\n+- 游戏状态管理\r\n+- 角色状态\r\n+- 系统状态\r\n+- 工作流状态\r\n+\r\n+**适用场景：**\r\n+- 对象状态变化\r\n+- 状态相关行为\r\n+- 状态机实现\r\n+\r\n+```lua\r\n+local state = StatePattern.New()\r\n+local context = state:CreateContext()\r\n+context:SetState(state:CreateState(\"idle\"))\r\n+context:Request()  -- 根据当前状态执行不同行为\r\n+```\r\n+\r\n+### 🎯 **策略模式 (Strategy)**\r\n+**用途：** 定义一系列算法，使它们可以互相替换，算法的变化不会影响使用算法的客户\r\n+**作用：**\r\n+- AI行为选择\r\n+- 算法选择\r\n+- 支付方式\r\n+- 排序算法\r\n+\r\n+**适用场景：**\r\n+- 算法选择\r\n+- 行为选择\r\n+- 避免条件判断\r\n+\r\n+```lua\r\n+local strategy = StrategyPattern.New()\r\n+local context = strategy:CreateContext()\r\n+context:SetStrategy(strategy:CreateStrategy(\"aggressive\"))\r\n+context:ExecuteStrategy()\r\n+```\r\n+\r\n+### 📋 **模板方法模式 (TemplateMethod)**\r\n+**用途：** 在父类中定义算法骨架，让子类重写特定步骤\r\n+**作用：**\r\n+- 算法框架\r\n+- 流程控制\r\n+- 代码复用\r\n+- 扩展点定义\r\n+\r\n+**适用场景：**\r\n+- 算法框架\r\n+- 流程模板\r\n+- 代码复用\r\n+\r\n+```lua\r\n+local template = TemplateMethodPattern.New()\r\n+local concreteClass = template:CreateConcreteClass()\r\n+concreteClass:TemplateMethod()  -- 调用模板方法\r\n+```\r\n+\r\n+### 👥 **访问者模式 (Visitor)**\r\n+**用途：** 在不改变数据结构的前提下，定义作用于其元素的新操作\r\n+**作用：**\r\n+- 数据操作\r\n+- 统计功能\r\n+- 导出功能\r\n+- 功能扩展\r\n+\r\n+**适用场景：**\r\n+- 数据结构稳定\r\n+- 操作经常变化\r\n+- 功能扩展\r\n+\r\n+```lua\r\n+local visitor = VisitorPattern.New()\r\n+local element = visitor:CreateElement()\r\n+local concreteVisitor = visitor:CreateVisitor()\r\n+element:Accept(concreteVisitor)\r\n+```\r\n+\r\n+---\r\n+\r\n+## 🚀 高级模式 (Advanced Patterns)\r\n+\r\n+### 🧩 **组件模式 (Component)**\r\n+**用途：** 将游戏对象分解为可重用的组件\r\n+**作用：**\r\n+- 游戏对象系统\r\n+- 模块化设计\r\n+- 功能组合\r\n+- 系统解耦\r\n+\r\n+**适用场景：**\r\n+- 复杂游戏对象\r\n+- 功能模块化\r\n+- 系统解耦\r\n+\r\n+```lua\r\n+local component = ComponentPattern.New()\r\n+local gameObject = component:CreateGameObject()\r\n+gameObject:AddComponent(\"Transform\")\r\n+gameObject:AddComponent(\"Renderer\")\r\n+gameObject:AddComponent(\"Collider\")\r\n+```\r\n+\r\n+### 📡 **事件驱动模式 (EventDriven)**\r\n+**用途：** 通过事件进行松耦合的通信\r\n+**作用：**\r\n+- 系统解耦\r\n+- 异步通信\r\n+- 消息传递\r\n+- 响应式系统\r\n+\r\n+**适用场景：**\r\n+- 系统解耦\r\n+- 异步处理\r\n+- 消息系统\r\n+\r\n+```lua\r\n+local eventSystem = EventDrivenPattern.New()\r\n+eventSystem:Subscribe(\"playerMove\", handler)\r\n+eventSystem:Publish(\"playerMove\", {x = 100, y = 200})\r\n+```\r\n+\r\n+### 🎮 **状态机模式 (StateMachine)**\r\n+**用途：** 管理复杂的状态转换逻辑\r\n+**作用：**\r\n+- 角色状态管理\r\n+- 游戏流程控制\r\n+- AI状态管理\r\n+- 系统状态控制\r\n+\r\n+**适用场景：**\r\n+- 复杂状态管理\r\n+- 状态转换逻辑\r\n+- 流程控制\r\n+\r\n+```lua\r\n+local stateMachine = StateMachinePattern.New()\r\n+stateMachine:AddState(\"idle\")\r\n+stateMachine:AddState(\"walking\")\r\n+stateMachine:AddTransition(\"idle\", \"walking\", \"startWalking\")\r\n+stateMachine:ChangeState(\"idle\")\r\n+```\r\n+\r\n+### 🏢 **服务定位器模式 (ServiceLocator)**\r\n+**用途：** 提供全局的服务访问点\r\n+**作用：**\r\n+- 服务管理\r\n+- 依赖管理\r\n+- 全局访问\r\n+- 服务注册\r\n+\r\n+**适用场景：**\r\n+- 全局服务访问\r\n+- 服务管理\r\n+- 依赖注入\r\n+\r\n+```lua\r\n+local serviceLocator = ServiceLocatorPattern.New()\r\n+serviceLocator:Register(\"audioService\", audioService)\r\n+local audio = serviceLocator:GetService(\"audioService\")\r\n+```\r\n+\r\n+### 🏊 **对象池模式 (ObjectPool)**\r\n+**用途：** 重用对象以减少创建和销毁的开销\r\n+**作用：**\r\n+- 性能优化\r\n+- 内存管理\r\n+- 对象复用\r\n+- 垃圾回收优化\r\n+\r\n+**适用场景：**\r\n+- 频繁创建销毁\r\n+- 性能优化\r\n+- 内存管理\r\n+\r\n+```lua\r\n+local objectPool = ObjectPoolPattern.New()\r\n+local bullet = objectPool:GetObject(\"bullet\")\r\n+-- 使用子弹\r\n+objectPool:ReturnObject(bullet)\r\n+```\r\n+\r\n+### 📊 **数据驱动模式 (DataDriven)**\r\n+**用途：** 通过数据配置驱动系统行为\r\n+**作用：**\r\n+- 配置管理\r\n+- 数据驱动\r\n+- 系统配置\r\n+- 行为配置\r\n+\r\n+**适用场景：**\r\n+- 配置驱动\r\n+- 数据驱动\r\n+- 系统配置\r\n+\r\n+```lua\r\n+local dataDriven = DataDrivenPattern.New()\r\n+dataDriven:LoadConfig(\"weapon_config.json\")\r\n+local weapon = dataDriven:CreateWeapon(\"sword\")\r\n+```\r\n+\r\n+### ⚡ **响应式编程模式 (ReactiveProgramming)**\r\n+**用途：** 通过数据流和变化传播来简化编程\r\n+**作用：**\r\n+- 数据流处理\r\n+- 变化传播\r\n+- 异步处理\r\n+- 事件流\r\n+\r\n+**适用场景：**\r\n+- 数据流处理\r\n+- 变化响应\r\n+- 异步编程\r\n+\r\n+```lua\r\n+local reactive = ReactiveProgrammingPattern.New()\r\n+local stream = reactive:CreateStream()\r\n+stream:Subscribe(function(value) print(\"Value changed:\", value) end)\r\n+stream:Next(100)\r\n+```\r\n+\r\n+### 💉 **依赖注入模式 (DependencyInjection)**\r\n+**用途：** 通过外部注入依赖，降低组件间的耦合\r\n+**作用：**\r\n+- 依赖管理\r\n+- 解耦设计\r\n+- 测试友好\r\n+- 配置灵活\r\n+\r\n+**适用场景：**\r\n+- 依赖管理\r\n+- 系统解耦\r\n+- 测试友好\r\n+\r\n+```lua\r\n+local di = DependencyInjectionPattern.New()\r\n+di:Register(\"database\", databaseService)\r\n+di:Register(\"logger\", loggerService)\r\n+local service = di:CreateService(MyService)\r\n+```\r\n+\r\n+### 🚩 **脏标记模式 (DirtyFlag)**\r\n+**用途：** 通过标记避免不必要的计算\r\n+**作用：**\r\n+- 性能优化\r\n+- 缓存管理\r\n+- 计算优化\r\n+- 更新控制\r\n+\r\n+**适用场景：**\r\n+- 性能优化\r\n+- 缓存管理\r\n+- 计算优化\r\n+\r\n+```lua\r\n+local dirtyFlag = DirtyFlagPattern.New()\r\n+local object = dirtyFlag:CreateObject()\r\n+object:MarkDirty()\r\n+if object:IsDirty() then\r\n+    object:Update()\r\n+    object:ClearDirty()\r\n+end\r\n+```\r\n+\r\n+### 🔄 **双缓冲模式 (DoubleBuffer)**\r\n+**用途：** 使用两个缓冲区避免渲染冲突\r\n+**作用：**\r\n+- 渲染优化\r\n+- 动画平滑\r\n+- 避免闪烁\r\n+- 性能提升\r\n+\r\n+**适用场景：**\r\n+- 渲染系统\r\n+- 动画系统\r\n+- 避免闪烁\r\n+\r\n+```lua\r\n+local doubleBuffer = DoubleBufferPattern.New()\r\n+local buffer = doubleBuffer:CreateBuffer()\r\n+buffer:SwapBuffers()\r\n+buffer:DrawToBackBuffer()\r\n+```\r\n+\r\n+### 📍 **数据局部性模式 (DataLocality)**\r\n+**用途：** 通过组织数据布局提高缓存效率\r\n+**作用：**\r\n+- 性能优化\r\n+- 缓存优化\r\n+- 内存访问优化\r\n+- 系统性能\r\n+\r\n+**适用场景：**\r\n+- 性能优化\r\n+- 缓存优化\r\n+- 内存访问优化\r\n+\r\n+```lua\r\n+local dataLocality = DataLocalityPattern.New()\r\n+local optimizedArray = dataLocality:CreateOptimizedArray()\r\n+-- 数据按访问模式组织，提高缓存命中率\r\n+```\r\n+\r\n+### 💻 **字节码模式 (Bytecode)**\r\n+**用途：** 通过字节码实现脚本系统\r\n+**作用：**\r\n+- 脚本系统\r\n+- 虚拟机\r\n+- 性能优化\r\n+- 跨平台\r\n+\r\n+**适用场景：**\r\n+- 脚本系统\r\n+- 性能优化\r\n+- 跨平台\r\n+\r\n+```lua\r\n+local bytecode = BytecodePattern.New()\r\n+local script = bytecode:Compile(\"print('Hello World')\")\r\n+bytecode:Execute(script)\r\n+```\r\n+\r\n+---\r\n+\r\n+## 🚀 使用指南\r\n+\r\n+### 快速开始\r\n+```lua\r\n+-- 1. 选择合适的设计模式\r\n+local pattern = PatternFactory.Create(PatternTypes.SINGLETON)\r\n+\r\n+-- 2. 创建模式实例\r\n+local instance = pattern:Create()\r\n+\r\n+-- 3. 使用模式功能\r\n+instance:DoSomething()\r\n+```\r\n+\r\n+### 模式选择建议\r\n+- **对象创建**: 使用创建型模式\r\n+- **对象组合**: 使用结构型模式\r\n+- **对象交互**: 使用行为型模式\r\n+- **游戏开发**: 使用高级模式\r\n+\r\n+### 最佳实践\r\n+- **单一职责**: 每个模式只负责一个方面\r\n+- **开闭原则**: 对扩展开放，对修改关闭\r\n+- **依赖倒置**: 依赖抽象而非具体实现\r\n+- **接口隔离**: 客户端不应该依赖不需要的接口\r\n+\r\n+---\r\n+\r\n+## 📈 模式对比\r\n+\r\n+| 模式类型 | 主要用途 | 复杂度 | 适用场景 | 性能影响 |\r\n+|----------|----------|--------|----------|----------|\r\n+| **创建型** | 对象创建 | 低-中 | 对象创建逻辑 | 低 |\r\n+| **结构型** | 对象组合 | 中 | 对象关系 | 低-中 |\r\n+| **行为型** | 对象交互 | 中-高 | 对象通信 | 中 |\r\n+| **高级** | 游戏开发 | 高 | 复杂系统 | 中-高 |\r\n+\r\n+---\r\n+\r\n+## 🔧 扩展开发\r\n+\r\n+### 添加新的设计模式\r\n+1. 继承基础模式接口\r\n+2. 实现必要的方法\r\n+3. 在工厂中注册\r\n+4. 添加使用示例\r\n+\r\n+### 自定义模式实现\r\n+```lua\r\n+local CustomPattern = BaseClass(IPattern)\r\n+\r\n+function CustomPattern:ctor()\r\n+    -- 初始化代码\r\n+end\r\n+\r\n+function CustomPattern:Execute()\r\n+    -- 模式执行逻辑\r\n+end\r\n+```\r\n+\r\n+---\r\n+\r\n+## 📚 总结\r\n+\r\n+这个设计模式库提供了：\r\n+\r\n+✅ **完整的模式覆盖** - 从基础到高级的完整覆盖  \r\n+✅ **游戏开发优化** - 针对游戏开发的专用模式  \r\n+✅ **易用性设计** - 统一的接口和工厂创建  \r\n+✅ **扩展性架构** - 易于添加新的设计模式  \r\n+✅ **实用性强** - 实际项目中的应用场景  \r\n+\r\n+**🎯 核心价值：** 让开发者专注于业务逻辑，而不是架构设计的复杂细节。\r\n+\r\n+---\r\n+\r\n+*支持Lua 5.1+ | 完整设计模式 | 游戏开发优化 | 易于扩展 | 🚀 架构设计最佳实践*\r\n"
                },
                {
                    "date": 1767209615075,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,10 +34,10 @@\n │   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n │   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n │   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n-│   ├── State (状态模式)\r\n-│   ├── Strategy (策略模式)\r\n+│   ├── State (状态模式) - 状态机就是其最好的理解了\r\n+│   ├── Strategy (策略模式) - \r\n │   ├── TemplateMethod (模板方法模式)\r\n │   └── Visitor (访问者模式)\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)\r\n@@ -844,851 +844,4 @@\n \r\n ---\r\n \r\n *支持Lua 5.1+ | 完整设计模式 | 游戏开发优化 | 易于扩展 | 🚀 架构设计最佳实践*\r\n-# 🎯 Lua设计模式库 - 完整指南\r\n-\r\n-## 📋 概述\r\n-\r\n-这是一个功能完整的Lua设计模式库，涵盖了从基础到高级的各种设计模式实现。每个模式都经过精心设计，确保易用性、可扩展性和高性能。\r\n-\r\n-**🎯 设计理念：** 将复杂的设计模式封装成简单易用的工具，让开发者专注于业务逻辑，而不是架构细节。\r\n-\r\n----\r\n-\r\n-## 🏗️ 架构分类\r\n-\r\n-### 核心模式分类\r\n-```\r\n-Pattern Library (设计模式库)\r\n-├── Creational (创建型模式) - 对象创建的艺术\r\n-│   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n-│   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)\r\n-│   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容\r\n-│   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n-│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n-├── Structural (结构型模式) - 对象组合的艺术\r\n-│   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n-│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果\r\n-│   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n-│   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n-│   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n-│   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n-│   └── Proxy (代理模式) - 可用钩子方法+策略模式替代，避免代理模式滥用\r\n-├── Behavioral (行为型模式) - 对象交互的艺术\r\n-│   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n-│   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n-│   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n-│   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n-│   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n-│   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n-│   ├── Observer (观察者模式) - 事件分发系统的运用\r\n-│   ├── State (状态模式)\r\n-│   ├── Strategy (策略模式)\r\n-│   ├── TemplateMethod (模板方法模式)\r\n-│   └── Visitor (访问者模式)\r\n-└── Advanced (高级模式) - 游戏开发专用模式\r\n-    ├── Component (组件模式)\r\n-    ├── EventDriven (事件驱动模式)\r\n-    ├── StateMachine (状态机模式)\r\n-    ├── ServiceLocator (服务定位器模式)\r\n-    ├── ObjectPool (对象池模式)\r\n-    ├── DataDriven (数据驱动模式)\r\n-    ├── ReactiveProgramming (响应式编程模式)\r\n-    ├── DependencyInjection (依赖注入模式)\r\n-    ├── DirtyFlag (脏标记模式)\r\n-    ├── DoubleBuffer (双缓冲模式)\r\n-    ├── DataLocality (数据局部性模式)\r\n-    └── Bytecode (字节码模式)\r\n-```\r\n-\r\n----\r\n-\r\n-## 🏭 创建型模式 (Creational Patterns)\r\n-\r\n-### 🔒 **单例模式 (Singleton)**\r\n-**用途：** 确保一个类只有一个实例，并提供全局访问点\r\n-**作用：** \r\n-- 游戏管理器\r\n-- 配置管理器\r\n-- 资源管理器\r\n-- 日志系统\r\n-\r\n-**适用场景：**\r\n-- 需要全局唯一实例\r\n-- 资源管理\r\n-- 配置管理\r\n-\r\n-```lua\r\n-local singleton = SingletonPattern.New()\r\n-local instance1 = singleton:GetInstance()\r\n-local instance2 = singleton:GetInstance()\r\n-print(instance1 == instance2)  -- true，同一个实例\r\n-```\r\n-\r\n-### 🏭 **工厂模式 (Factory)**\r\n-**用途：** 根据条件创建不同类型的对象\r\n-**作用：**\r\n-- 游戏对象创建\r\n-- 武器系统\r\n-- 敌人生成\r\n-- 道具创建\r\n-\r\n-**适用场景：**\r\n-- 需要根据条件创建对象\r\n-- 对象创建逻辑复杂\r\n-- 支持扩展新类型\r\n-\r\n-```lua\r\n-local factory = FactoryPattern.New()\r\n-local weapon = factory:CreateWeapon(\"sword\")\r\n-local enemy = factory:CreateEnemy(\"goblin\")\r\n-```\r\n-\r\n-### 🏭🏭 **抽象工厂模式 (AbstractFactory)**\r\n-**用途：** 创建一系列相关对象，确保它们相互兼容\r\n-**作用：**\r\n-- 游戏主题系统\r\n-- UI风格系统\r\n-- 关卡风格\r\n-- 种族系统\r\n-\r\n-**适用场景：**\r\n-- 需要创建相关对象族\r\n-- 确保对象兼容性\r\n-- 支持多种风格\r\n-\r\n-```lua\r\n-local factory = AbstractFactoryPattern.New()\r\n-local medievalFactory = factory:CreateFactory(\"medieval\")\r\n-local sword = medievalFactory:CreateWeapon()\r\n-local armor = medievalFactory:CreateArmor()\r\n-```\r\n-\r\n-### 🏗️ **建造者模式 (Builder)**\r\n-**用途：** 分步骤构建复杂对象\r\n-**作用：**\r\n-- 角色创建\r\n-- 关卡构建\r\n-- 配置构建\r\n-- 复杂对象组装\r\n-\r\n-**适用场景：**\r\n-- 对象构建过程复杂\r\n-- 需要分步骤构建\r\n-- 支持不同构建方式\r\n-\r\n-```lua\r\n-local builder = BuilderPattern.New()\r\n-local character = builder:SetName(\"英雄\")\r\n-    :SetClass(\"战士\")\r\n-    :SetLevel(10)\r\n-    :SetEquipment(\"铁剑\")\r\n-    :Build()\r\n-```\r\n-\r\n-### 🧬 **原型模式 (Prototype)**\r\n-**用途：** 通过克隆现有对象来创建新对象\r\n-**作用：**\r\n-- 对象复制\r\n-- 模板系统\r\n-- 快速创建\r\n-- 减少初始化开销\r\n-\r\n-**适用场景：**\r\n-- 对象创建开销大\r\n-- 需要对象副本\r\n-- 模板系统\r\n-\r\n-```lua\r\n-local prototype = PrototypePattern.New()\r\n-local original = prototype:Create(\"template\")\r\n-local clone = original:Clone()\r\n-```\r\n-\r\n----\r\n-\r\n-## 🏗️ 结构型模式 (Structural Patterns)\r\n-\r\n-### 🔌 **适配器模式 (Adapter)**\r\n-**用途：** 让不兼容的接口能够协同工作\r\n-**作用：**\r\n-- 第三方库集成\r\n-- 旧系统适配\r\n-- 接口统一\r\n-- 兼容性处理\r\n-\r\n-**适用场景：**\r\n-- 集成第三方库\r\n-- 系统升级兼容\r\n-- 接口不匹配\r\n-\r\n-```lua\r\n-local adapter = AdapterPattern.New()\r\n-local newInterface = adapter:Adapt(oldSystem)\r\n-newInterface:NewMethod()\r\n-```\r\n-\r\n-### 🌉 **桥接模式 (Bridge)**\r\n-**用途：** 将抽象与实现分离，使它们可以独立变化\r\n-**作用：**\r\n-- 平台抽象\r\n-- 渲染器抽象\r\n-- 数据库抽象\r\n-- 网络抽象\r\n-\r\n-**适用场景：**\r\n-- 需要支持多平台\r\n-- 抽象与实现分离\r\n-- 避免继承爆炸\r\n-\r\n-```lua\r\n-local bridge = BridgePattern.New()\r\n-local renderer = bridge:CreateRenderer(\"OpenGL\")\r\n-local shape = bridge:CreateShape(\"Circle\", renderer)\r\n-```\r\n-\r\n-### 🧩 **组合模式 (Composite)**\r\n-**用途：** 将对象组合成树形结构，统一处理单个对象和组合对象\r\n-**作用：**\r\n-- 场景图系统\r\n-- UI组件树\r\n-- 文件系统\r\n-- 游戏对象层次\r\n-\r\n-**适用场景：**\r\n-- 树形结构\r\n-- 部分-整体关系\r\n-- 统一处理接口\r\n-\r\n-```lua\r\n-local composite = CompositePattern.New()\r\n-local root = composite:CreateComponent(\"root\")\r\n-local child1 = composite:CreateComponent(\"child1\")\r\n-root:Add(child1)\r\n-root:Operation()  -- 递归调用所有子组件\r\n-```\r\n-\r\n-### 🎨 **装饰器模式 (Decorator)**\r\n-**用途：** 动态地给对象添加新功能\r\n-**作用：**\r\n-- 装备系统\r\n-- 技能增强\r\n-- 状态效果\r\n-- 功能扩展\r\n-\r\n-**适用场景：**\r\n-- 需要动态添加功能\r\n-- 避免继承爆炸\r\n-- 功能组合\r\n-\r\n-```lua\r\n-local decorator = DecoratorPattern.New()\r\n-local baseWeapon = decorator:CreateWeapon(\"剑\")\r\n-local fireWeapon = decorator:AddFireEffect(baseWeapon)\r\n-local iceWeapon = decorator:AddIceEffect(fireWeapon)\r\n-```\r\n-\r\n-### 🏛️ **外观模式 (Facade)**\r\n-**用途：** 为复杂子系统提供简单接口\r\n-**作用：**\r\n-- 系统封装\r\n-- 简化接口\r\n-- 降低耦合\r\n-- 统一入口\r\n-\r\n-**适用场景：**\r\n-- 复杂系统封装\r\n-- 简化客户端使用\r\n-- 降低系统耦合\r\n-\r\n-```lua\r\n-local facade = FacadePattern.New()\r\n--- 复杂的子系统操作被封装成简单接口\r\n-facade:StartGame()\r\n-facade:SaveGame()\r\n-facade:LoadGame()\r\n-```\r\n-\r\n-### 🦋 **享元模式 (Flyweight)**\r\n-**用途：** 通过共享减少内存使用\r\n-**作用：**\r\n-- 纹理共享\r\n-- 模型共享\r\n-- 配置共享\r\n-- 资源优化\r\n-\r\n-**适用场景：**\r\n-- 大量相似对象\r\n-- 内存优化\r\n-- 资源共享\r\n-\r\n-```lua\r\n-local flyweight = FlyweightPattern.New()\r\n-local texture1 = flyweight:GetTexture(\"grass\")\r\n-local texture2 = flyweight:GetTexture(\"grass\")  -- 共享同一个纹理\r\n-```\r\n-\r\n-### 🎭 **代理模式 (Proxy)**\r\n-**用途：** 控制对其他对象的访问\r\n-**作用：**\r\n-- 权限控制\r\n-- 延迟加载\r\n-- 缓存代理\r\n-- 安全控制\r\n-\r\n-**适用场景：**\r\n-- 访问控制\r\n-- 延迟加载\r\n-- 缓存优化\r\n-\r\n-```lua\r\n-local proxy = ProxyPattern.New()\r\n-local realObject = proxy:GetObject()  -- 可能延迟加载\r\n-proxy:CheckPermission(\"read\")  -- 权限检查\r\n-```\r\n-\r\n----\r\n-\r\n-## 🎭 行为型模式 (Behavioral Patterns)\r\n-\r\n-### 🔗 **责任链模式 (ChainOfResponsibility)**\r\n-**用途：** 将请求沿着处理者链进行传递，直到被处理\r\n-**作用：**\r\n-- 事件处理\r\n-- 权限验证\r\n-- 异常处理\r\n-- 请求过滤\r\n-\r\n-**适用场景：**\r\n-- 多个对象处理请求\r\n-- 请求处理顺序不确定\r\n-- 动态处理链\r\n-\r\n-```lua\r\n-local chain = ChainOfResponsibilityPattern.New()\r\n-chain:AddHandler(handler1)\r\n-chain:AddHandler(handler2)\r\n-chain:HandleRequest(request)\r\n-```\r\n-\r\n-### 📝 **命令模式 (Command)**\r\n-**用途：** 将请求封装成对象，支持请求排队、记录日志、撤销等操作\r\n-**作用：**\r\n-- 撤销/重做系统\r\n-- 宏命令\r\n-- 队列处理\r\n-- 日志记录\r\n-\r\n-**适用场景：**\r\n-- 需要撤销功能\r\n-- 命令排队\r\n-- 宏操作\r\n-\r\n-```lua\r\n-local command = CommandPattern.New()\r\n-local moveCommand = command:CreateMoveCommand(unit, target)\r\n-command:Execute(moveCommand)\r\n-command:Undo()  -- 撤销操作\r\n-```\r\n-\r\n-### 🔤 **解释器模式 (Interpreter)**\r\n-**用途：** 为语言创建解释器\r\n-**作用：**\r\n-- 脚本系统\r\n-- 配置解析\r\n-- 规则引擎\r\n-- 表达式求值\r\n-\r\n-**适用场景：**\r\n-- 简单语言解析\r\n-- 规则引擎\r\n-- 表达式计算\r\n-\r\n-```lua\r\n-local interpreter = InterpreterPattern.New()\r\n-local result = interpreter:Interpret(\"1 + 2 * 3\")\r\n-```\r\n-\r\n-### 🔄 **迭代器模式 (Iterator)**\r\n-**用途：** 提供一种方法顺序访问集合中的元素，而不暴露其内部表示\r\n-**作用：**\r\n-- 集合遍历\r\n-- 自定义遍历\r\n-- 遍历算法\r\n-- 集合封装\r\n-\r\n-**适用场景：**\r\n-- 集合遍历\r\n-- 自定义遍历逻辑\r\n-- 集合封装\r\n-\r\n-```lua\r\n-local iterator = IteratorPattern.New()\r\n-local collection = iterator:CreateCollection()\r\n-for item in collection:Iterator() do\r\n-    print(item)\r\n-end\r\n-```\r\n-\r\n-### 🤝 **中介者模式 (Mediator)**\r\n-**用途：** 封装对象间的交互，降低它们之间的耦合度\r\n-**作用：**\r\n-- 聊天系统\r\n-- 游戏系统协调\r\n-- UI组件协调\r\n-- 模块间通信\r\n-\r\n-**适用场景：**\r\n-- 对象间复杂交互\r\n-- 降低耦合\r\n-- 集中控制\r\n-\r\n-```lua\r\n-local mediator = MediatorPattern.New()\r\n-mediator:RegisterComponent(component1)\r\n-mediator:RegisterComponent(component2)\r\n-component1:SendMessage(\"hello\", mediator)\r\n-```\r\n-\r\n-### 💾 **备忘录模式 (Memento)**\r\n-**用途：** 在不破坏封装的前提下，捕获并外部化对象的内部状态\r\n-**作用：**\r\n-- 游戏存档\r\n-- 撤销系统\r\n-- 状态恢复\r\n-- 快照系统\r\n-\r\n-**适用场景：**\r\n-- 状态保存\r\n-- 撤销功能\r\n-- 快照系统\r\n-\r\n-```lua\r\n-local memento = MementoPattern.New()\r\n-local originator = memento:CreateOriginator()\r\n-local savedState = originator:SaveState()\r\n-originator:RestoreState(savedState)\r\n-```\r\n-\r\n-### 👀 **观察者模式 (Observer)**\r\n-**用途：** 定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会得到通知\r\n-**作用：**\r\n-- 事件系统\r\n-- 数据绑定\r\n-- 消息通知\r\n-- 状态同步\r\n-\r\n-**适用场景：**\r\n-- 事件通知\r\n-- 数据同步\r\n-- 松耦合通信\r\n-\r\n-```lua\r\n-local observer = ObserverPattern.New()\r\n-observer:Subscribe(subscriber1)\r\n-observer:Subscribe(subscriber2)\r\n-observer:Notify(\"event occurred\")\r\n-```\r\n-\r\n-### 🔄 **状态模式 (State)**\r\n-**用途：** 让对象在其内部状态改变时改变其行为\r\n-**作用：**\r\n-- 游戏状态管理\r\n-- 角色状态\r\n-- 系统状态\r\n-- 工作流状态\r\n-\r\n-**适用场景：**\r\n-- 对象状态变化\r\n-- 状态相关行为\r\n-- 状态机实现\r\n-\r\n-```lua\r\n-local state = StatePattern.New()\r\n-local context = state:CreateContext()\r\n-context:SetState(state:CreateState(\"idle\"))\r\n-context:Request()  -- 根据当前状态执行不同行为\r\n-```\r\n-\r\n-### 🎯 **策略模式 (Strategy)**\r\n-**用途：** 定义一系列算法，使它们可以互相替换，算法的变化不会影响使用算法的客户\r\n-**作用：**\r\n-- AI行为选择\r\n-- 算法选择\r\n-- 支付方式\r\n-- 排序算法\r\n-\r\n-**适用场景：**\r\n-- 算法选择\r\n-- 行为选择\r\n-- 避免条件判断\r\n-\r\n-```lua\r\n-local strategy = StrategyPattern.New()\r\n-local context = strategy:CreateContext()\r\n-context:SetStrategy(strategy:CreateStrategy(\"aggressive\"))\r\n-context:ExecuteStrategy()\r\n-```\r\n-\r\n-### 📋 **模板方法模式 (TemplateMethod)**\r\n-**用途：** 在父类中定义算法骨架，让子类重写特定步骤\r\n-**作用：**\r\n-- 算法框架\r\n-- 流程控制\r\n-- 代码复用\r\n-- 扩展点定义\r\n-\r\n-**适用场景：**\r\n-- 算法框架\r\n-- 流程模板\r\n-- 代码复用\r\n-\r\n-```lua\r\n-local template = TemplateMethodPattern.New()\r\n-local concreteClass = template:CreateConcreteClass()\r\n-concreteClass:TemplateMethod()  -- 调用模板方法\r\n-```\r\n-\r\n-### 👥 **访问者模式 (Visitor)**\r\n-**用途：** 在不改变数据结构的前提下，定义作用于其元素的新操作\r\n-**作用：**\r\n-- 数据操作\r\n-- 统计功能\r\n-- 导出功能\r\n-- 功能扩展\r\n-\r\n-**适用场景：**\r\n-- 数据结构稳定\r\n-- 操作经常变化\r\n-- 功能扩展\r\n-\r\n-```lua\r\n-local visitor = VisitorPattern.New()\r\n-local element = visitor:CreateElement()\r\n-local concreteVisitor = visitor:CreateVisitor()\r\n-element:Accept(concreteVisitor)\r\n-```\r\n-\r\n----\r\n-\r\n-## 🚀 高级模式 (Advanced Patterns)\r\n-\r\n-### 🧩 **组件模式 (Component)**\r\n-**用途：** 将游戏对象分解为可重用的组件\r\n-**作用：**\r\n-- 游戏对象系统\r\n-- 模块化设计\r\n-- 功能组合\r\n-- 系统解耦\r\n-\r\n-**适用场景：**\r\n-- 复杂游戏对象\r\n-- 功能模块化\r\n-- 系统解耦\r\n-\r\n-```lua\r\n-local component = ComponentPattern.New()\r\n-local gameObject = component:CreateGameObject()\r\n-gameObject:AddComponent(\"Transform\")\r\n-gameObject:AddComponent(\"Renderer\")\r\n-gameObject:AddComponent(\"Collider\")\r\n-```\r\n-\r\n-### 📡 **事件驱动模式 (EventDriven)**\r\n-**用途：** 通过事件进行松耦合的通信\r\n-**作用：**\r\n-- 系统解耦\r\n-- 异步通信\r\n-- 消息传递\r\n-- 响应式系统\r\n-\r\n-**适用场景：**\r\n-- 系统解耦\r\n-- 异步处理\r\n-- 消息系统\r\n-\r\n-```lua\r\n-local eventSystem = EventDrivenPattern.New()\r\n-eventSystem:Subscribe(\"playerMove\", handler)\r\n-eventSystem:Publish(\"playerMove\", {x = 100, y = 200})\r\n-```\r\n-\r\n-### 🎮 **状态机模式 (StateMachine)**\r\n-**用途：** 管理复杂的状态转换逻辑\r\n-**作用：**\r\n-- 角色状态管理\r\n-- 游戏流程控制\r\n-- AI状态管理\r\n-- 系统状态控制\r\n-\r\n-**适用场景：**\r\n-- 复杂状态管理\r\n-- 状态转换逻辑\r\n-- 流程控制\r\n-\r\n-```lua\r\n-local stateMachine = StateMachinePattern.New()\r\n-stateMachine:AddState(\"idle\")\r\n-stateMachine:AddState(\"walking\")\r\n-stateMachine:AddTransition(\"idle\", \"walking\", \"startWalking\")\r\n-stateMachine:ChangeState(\"idle\")\r\n-```\r\n-\r\n-### 🏢 **服务定位器模式 (ServiceLocator)**\r\n-**用途：** 提供全局的服务访问点\r\n-**作用：**\r\n-- 服务管理\r\n-- 依赖管理\r\n-- 全局访问\r\n-- 服务注册\r\n-\r\n-**适用场景：**\r\n-- 全局服务访问\r\n-- 服务管理\r\n-- 依赖注入\r\n-\r\n-```lua\r\n-local serviceLocator = ServiceLocatorPattern.New()\r\n-serviceLocator:Register(\"audioService\", audioService)\r\n-local audio = serviceLocator:GetService(\"audioService\")\r\n-```\r\n-\r\n-### 🏊 **对象池模式 (ObjectPool)**\r\n-**用途：** 重用对象以减少创建和销毁的开销\r\n-**作用：**\r\n-- 性能优化\r\n-- 内存管理\r\n-- 对象复用\r\n-- 垃圾回收优化\r\n-\r\n-**适用场景：**\r\n-- 频繁创建销毁\r\n-- 性能优化\r\n-- 内存管理\r\n-\r\n-```lua\r\n-local objectPool = ObjectPoolPattern.New()\r\n-local bullet = objectPool:GetObject(\"bullet\")\r\n--- 使用子弹\r\n-objectPool:ReturnObject(bullet)\r\n-```\r\n-\r\n-### 📊 **数据驱动模式 (DataDriven)**\r\n-**用途：** 通过数据配置驱动系统行为\r\n-**作用：**\r\n-- 配置管理\r\n-- 数据驱动\r\n-- 系统配置\r\n-- 行为配置\r\n-\r\n-**适用场景：**\r\n-- 配置驱动\r\n-- 数据驱动\r\n-- 系统配置\r\n-\r\n-```lua\r\n-local dataDriven = DataDrivenPattern.New()\r\n-dataDriven:LoadConfig(\"weapon_config.json\")\r\n-local weapon = dataDriven:CreateWeapon(\"sword\")\r\n-```\r\n-\r\n-### ⚡ **响应式编程模式 (ReactiveProgramming)**\r\n-**用途：** 通过数据流和变化传播来简化编程\r\n-**作用：**\r\n-- 数据流处理\r\n-- 变化传播\r\n-- 异步处理\r\n-- 事件流\r\n-\r\n-**适用场景：**\r\n-- 数据流处理\r\n-- 变化响应\r\n-- 异步编程\r\n-\r\n-```lua\r\n-local reactive = ReactiveProgrammingPattern.New()\r\n-local stream = reactive:CreateStream()\r\n-stream:Subscribe(function(value) print(\"Value changed:\", value) end)\r\n-stream:Next(100)\r\n-```\r\n-\r\n-### 💉 **依赖注入模式 (DependencyInjection)**\r\n-**用途：** 通过外部注入依赖，降低组件间的耦合\r\n-**作用：**\r\n-- 依赖管理\r\n-- 解耦设计\r\n-- 测试友好\r\n-- 配置灵活\r\n-\r\n-**适用场景：**\r\n-- 依赖管理\r\n-- 系统解耦\r\n-- 测试友好\r\n-\r\n-```lua\r\n-local di = DependencyInjectionPattern.New()\r\n-di:Register(\"database\", databaseService)\r\n-di:Register(\"logger\", loggerService)\r\n-local service = di:CreateService(MyService)\r\n-```\r\n-\r\n-### 🚩 **脏标记模式 (DirtyFlag)**\r\n-**用途：** 通过标记避免不必要的计算\r\n-**作用：**\r\n-- 性能优化\r\n-- 缓存管理\r\n-- 计算优化\r\n-- 更新控制\r\n-\r\n-**适用场景：**\r\n-- 性能优化\r\n-- 缓存管理\r\n-- 计算优化\r\n-\r\n-```lua\r\n-local dirtyFlag = DirtyFlagPattern.New()\r\n-local object = dirtyFlag:CreateObject()\r\n-object:MarkDirty()\r\n-if object:IsDirty() then\r\n-    object:Update()\r\n-    object:ClearDirty()\r\n-end\r\n-```\r\n-\r\n-### 🔄 **双缓冲模式 (DoubleBuffer)**\r\n-**用途：** 使用两个缓冲区避免渲染冲突\r\n-**作用：**\r\n-- 渲染优化\r\n-- 动画平滑\r\n-- 避免闪烁\r\n-- 性能提升\r\n-\r\n-**适用场景：**\r\n-- 渲染系统\r\n-- 动画系统\r\n-- 避免闪烁\r\n-\r\n-```lua\r\n-local doubleBuffer = DoubleBufferPattern.New()\r\n-local buffer = doubleBuffer:CreateBuffer()\r\n-buffer:SwapBuffers()\r\n-buffer:DrawToBackBuffer()\r\n-```\r\n-\r\n-### 📍 **数据局部性模式 (DataLocality)**\r\n-**用途：** 通过组织数据布局提高缓存效率\r\n-**作用：**\r\n-- 性能优化\r\n-- 缓存优化\r\n-- 内存访问优化\r\n-- 系统性能\r\n-\r\n-**适用场景：**\r\n-- 性能优化\r\n-- 缓存优化\r\n-- 内存访问优化\r\n-\r\n-```lua\r\n-local dataLocality = DataLocalityPattern.New()\r\n-local optimizedArray = dataLocality:CreateOptimizedArray()\r\n--- 数据按访问模式组织，提高缓存命中率\r\n-```\r\n-\r\n-### 💻 **字节码模式 (Bytecode)**\r\n-**用途：** 通过字节码实现脚本系统\r\n-**作用：**\r\n-- 脚本系统\r\n-- 虚拟机\r\n-- 性能优化\r\n-- 跨平台\r\n-\r\n-**适用场景：**\r\n-- 脚本系统\r\n-- 性能优化\r\n-- 跨平台\r\n-\r\n-```lua\r\n-local bytecode = BytecodePattern.New()\r\n-local script = bytecode:Compile(\"print('Hello World')\")\r\n-bytecode:Execute(script)\r\n-```\r\n-\r\n----\r\n-\r\n-## 🚀 使用指南\r\n-\r\n-### 快速开始\r\n-```lua\r\n--- 1. 选择合适的设计模式\r\n-local pattern = PatternFactory.Create(PatternTypes.SINGLETON)\r\n-\r\n--- 2. 创建模式实例\r\n-local instance = pattern:Create()\r\n-\r\n--- 3. 使用模式功能\r\n-instance:DoSomething()\r\n-```\r\n-\r\n-### 模式选择建议\r\n-- **对象创建**: 使用创建型模式\r\n-- **对象组合**: 使用结构型模式\r\n-- **对象交互**: 使用行为型模式\r\n-- **游戏开发**: 使用高级模式\r\n-\r\n-### 最佳实践\r\n-- **单一职责**: 每个模式只负责一个方面\r\n-- **开闭原则**: 对扩展开放，对修改关闭\r\n-- **依赖倒置**: 依赖抽象而非具体实现\r\n-- **接口隔离**: 客户端不应该依赖不需要的接口\r\n-\r\n----\r\n-\r\n-## 📈 模式对比\r\n-\r\n-| 模式类型 | 主要用途 | 复杂度 | 适用场景 | 性能影响 |\r\n-|----------|----------|--------|----------|----------|\r\n-| **创建型** | 对象创建 | 低-中 | 对象创建逻辑 | 低 |\r\n-| **结构型** | 对象组合 | 中 | 对象关系 | 低-中 |\r\n-| **行为型** | 对象交互 | 中-高 | 对象通信 | 中 |\r\n-| **高级** | 游戏开发 | 高 | 复杂系统 | 中-高 |\r\n-\r\n----\r\n-\r\n-## 🔧 扩展开发\r\n-\r\n-### 添加新的设计模式\r\n-1. 继承基础模式接口\r\n-2. 实现必要的方法\r\n-3. 在工厂中注册\r\n-4. 添加使用示例\r\n-\r\n-### 自定义模式实现\r\n-```lua\r\n-local CustomPattern = BaseClass(IPattern)\r\n-\r\n-function CustomPattern:ctor()\r\n-    -- 初始化代码\r\n-end\r\n-\r\n-function CustomPattern:Execute()\r\n-    -- 模式执行逻辑\r\n-end\r\n-```\r\n-\r\n----\r\n-\r\n-## 📚 总结\r\n-\r\n-这个设计模式库提供了：\r\n-\r\n-✅ **完整的模式覆盖** - 从基础到高级的完整覆盖  \r\n-✅ **游戏开发优化** - 针对游戏开发的专用模式  \r\n-✅ **易用性设计** - 统一的接口和工厂创建  \r\n-✅ **扩展性架构** - 易于添加新的设计模式  \r\n-✅ **实用性强** - 实际项目中的应用场景  \r\n-\r\n-**🎯 核心价值：** 让开发者专注于业务逻辑，而不是架构设计的复杂细节。\r\n-\r\n----\r\n-\r\n-*支持Lua 5.1+ | 完整设计模式 | 游戏开发优化 | 易于扩展 | 🚀 架构设计最佳实践*\r\n"
                },
                {
                    "date": 1767209703710,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n │   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n │   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n │   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n │   ├── State (状态模式) - 状态机就是其最好的理解了\r\n-│   ├── Strategy (策略模式) - \r\n+│   ├── Strategy (策略模式) - 解决一类问题的不同解决方案\r\n │   ├── TemplateMethod (模板方法模式)\r\n │   └── Visitor (访问者模式)\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)\r\n"
                },
                {
                    "date": 1767209719821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n │   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n │   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n │   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n │   ├── State (状态模式) - 状态机就是其最好的理解了\r\n-│   ├── Strategy (策略模式) - 解决一类问题的不同解决方案\r\n+│   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n │   ├── TemplateMethod (模板方法模式)\r\n │   └── Visitor (访问者模式)\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)\r\n"
                },
                {
                    "date": 1767209752727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,9 @@\n │   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n │   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n │   ├── State (状态模式) - 状态机就是其最好的理解了\r\n │   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n-│   ├── TemplateMethod (模板方法模式)\r\n+│   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n │   └── Visitor (访问者模式)\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)\r\n     ├── EventDriven (事件驱动模式)\r\n"
                },
                {
                    "date": 1767209758724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,847 @@\n+# 🎯 Lua设计模式库 - 完整指南\r\n+\r\n+## 📋 概述\r\n+\r\n+这是一个功能完整的Lua设计模式库，涵盖了从基础到高级的各种设计模式实现。每个模式都经过精心设计，确保易用性、可扩展性和高性能。\r\n+\r\n+**🎯 设计理念：** 将复杂的设计模式封装成简单易用的工具，让开发者专注于业务逻辑，而不是架构细节。\r\n+\r\n+---\r\n+\r\n+## 🏗️ 架构分类\r\n+\r\n+### 核心模式分类\r\n+```\r\n+Pattern Library (设计模式库)\r\n+├── Creational (创建型模式) - 对象创建的艺术\r\n+│   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n+│   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)\r\n+│   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容\r\n+│   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n+│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n+├── Structural (结构型模式) - 对象组合的艺术\r\n+│   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n+│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果\r\n+│   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n+│   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n+│   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n+│   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n+│   └── Proxy (代理模式) - 可用钩子方法+策略模式替代，避免代理模式滥用\r\n+├── Behavioral (行为型模式) - 对象交互的艺术\r\n+│   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n+│   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n+│   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n+│   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n+│   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n+│   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n+│   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n+│   ├── State (状态模式) - 状态机就是其最好的理解了\r\n+│   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n+│   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n+│   └── Visitor (访问者模式) \r\n+└── Advanced (高级模式) - 游戏开发专用模式\r\n+    ├── Component (组件模式)\r\n+    ├── EventDriven (事件驱动模式)\r\n+    ├── StateMachine (状态机模式)\r\n+    ├── ServiceLocator (服务定位器模式)\r\n+    ├── ObjectPool (对象池模式)\r\n+    ├── DataDriven (数据驱动模式)\r\n+    ├── ReactiveProgramming (响应式编程模式)\r\n+    ├── DependencyInjection (依赖注入模式)\r\n+    ├── DirtyFlag (脏标记模式)\r\n+    ├── DoubleBuffer (双缓冲模式)\r\n+    ├── DataLocality (数据局部性模式)\r\n+    └── Bytecode (字节码模式)\r\n+```\r\n+\r\n+---\r\n+\r\n+## 🏭 创建型模式 (Creational Patterns)\r\n+\r\n+### 🔒 **单例模式 (Singleton)**\r\n+**用途：** 确保一个类只有一个实例，并提供全局访问点\r\n+**作用：** \r\n+- 游戏管理器\r\n+- 配置管理器\r\n+- 资源管理器\r\n+- 日志系统\r\n+\r\n+**适用场景：**\r\n+- 需要全局唯一实例\r\n+- 资源管理\r\n+- 配置管理\r\n+\r\n+```lua\r\n+local singleton = SingletonPattern.New()\r\n+local instance1 = singleton:GetInstance()\r\n+local instance2 = singleton:GetInstance()\r\n+print(instance1 == instance2)  -- true，同一个实例\r\n+```\r\n+\r\n+### 🏭 **工厂模式 (Factory)**\r\n+**用途：** 根据条件创建不同类型的对象\r\n+**作用：**\r\n+- 游戏对象创建\r\n+- 武器系统\r\n+- 敌人生成\r\n+- 道具创建\r\n+\r\n+**适用场景：**\r\n+- 需要根据条件创建对象\r\n+- 对象创建逻辑复杂\r\n+- 支持扩展新类型\r\n+\r\n+```lua\r\n+local factory = FactoryPattern.New()\r\n+local weapon = factory:CreateWeapon(\"sword\")\r\n+local enemy = factory:CreateEnemy(\"goblin\")\r\n+```\r\n+\r\n+### 🏭🏭 **抽象工厂模式 (AbstractFactory)**\r\n+**用途：** 创建一系列相关对象，确保它们相互兼容\r\n+**作用：**\r\n+- 游戏主题系统\r\n+- UI风格系统\r\n+- 关卡风格\r\n+- 种族系统\r\n+\r\n+**适用场景：**\r\n+- 需要创建相关对象族\r\n+- 确保对象兼容性\r\n+- 支持多种风格\r\n+\r\n+```lua\r\n+local factory = AbstractFactoryPattern.New()\r\n+local medievalFactory = factory:CreateFactory(\"medieval\")\r\n+local sword = medievalFactory:CreateWeapon()\r\n+local armor = medievalFactory:CreateArmor()\r\n+```\r\n+\r\n+### 🏗️ **建造者模式 (Builder)**\r\n+**用途：** 分步骤构建复杂对象\r\n+**作用：**\r\n+- 角色创建\r\n+- 关卡构建\r\n+- 配置构建\r\n+- 复杂对象组装\r\n+\r\n+**适用场景：**\r\n+- 对象构建过程复杂\r\n+- 需要分步骤构建\r\n+- 支持不同构建方式\r\n+\r\n+```lua\r\n+local builder = BuilderPattern.New()\r\n+local character = builder:SetName(\"英雄\")\r\n+    :SetClass(\"战士\")\r\n+    :SetLevel(10)\r\n+    :SetEquipment(\"铁剑\")\r\n+    :Build()\r\n+```\r\n+\r\n+### 🧬 **原型模式 (Prototype)**\r\n+**用途：** 通过克隆现有对象来创建新对象\r\n+**作用：**\r\n+- 对象复制\r\n+- 模板系统\r\n+- 快速创建\r\n+- 减少初始化开销\r\n+\r\n+**适用场景：**\r\n+- 对象创建开销大\r\n+- 需要对象副本\r\n+- 模板系统\r\n+\r\n+```lua\r\n+local prototype = PrototypePattern.New()\r\n+local original = prototype:Create(\"template\")\r\n+local clone = original:Clone()\r\n+```\r\n+\r\n+---\r\n+\r\n+## 🏗️ 结构型模式 (Structural Patterns)\r\n+\r\n+### 🔌 **适配器模式 (Adapter)**\r\n+**用途：** 让不兼容的接口能够协同工作\r\n+**作用：**\r\n+- 第三方库集成\r\n+- 旧系统适配\r\n+- 接口统一\r\n+- 兼容性处理\r\n+\r\n+**适用场景：**\r\n+- 集成第三方库\r\n+- 系统升级兼容\r\n+- 接口不匹配\r\n+\r\n+```lua\r\n+local adapter = AdapterPattern.New()\r\n+local newInterface = adapter:Adapt(oldSystem)\r\n+newInterface:NewMethod()\r\n+```\r\n+\r\n+### 🌉 **桥接模式 (Bridge)**\r\n+**用途：** 将抽象与实现分离，使它们可以独立变化\r\n+**作用：**\r\n+- 平台抽象\r\n+- 渲染器抽象\r\n+- 数据库抽象\r\n+- 网络抽象\r\n+\r\n+**适用场景：**\r\n+- 需要支持多平台\r\n+- 抽象与实现分离\r\n+- 避免继承爆炸\r\n+\r\n+```lua\r\n+local bridge = BridgePattern.New()\r\n+local renderer = bridge:CreateRenderer(\"OpenGL\")\r\n+local shape = bridge:CreateShape(\"Circle\", renderer)\r\n+```\r\n+\r\n+### 🧩 **组合模式 (Composite)**\r\n+**用途：** 将对象组合成树形结构，统一处理单个对象和组合对象\r\n+**作用：**\r\n+- 场景图系统\r\n+- UI组件树\r\n+- 文件系统\r\n+- 游戏对象层次\r\n+\r\n+**适用场景：**\r\n+- 树形结构\r\n+- 部分-整体关系\r\n+- 统一处理接口\r\n+\r\n+```lua\r\n+local composite = CompositePattern.New()\r\n+local root = composite:CreateComponent(\"root\")\r\n+local child1 = composite:CreateComponent(\"child1\")\r\n+root:Add(child1)\r\n+root:Operation()  -- 递归调用所有子组件\r\n+```\r\n+\r\n+### 🎨 **装饰器模式 (Decorator)**\r\n+**用途：** 动态地给对象添加新功能\r\n+**作用：**\r\n+- 装备系统\r\n+- 技能增强\r\n+- 状态效果\r\n+- 功能扩展\r\n+\r\n+**适用场景：**\r\n+- 需要动态添加功能\r\n+- 避免继承爆炸\r\n+- 功能组合\r\n+\r\n+```lua\r\n+local decorator = DecoratorPattern.New()\r\n+local baseWeapon = decorator:CreateWeapon(\"剑\")\r\n+local fireWeapon = decorator:AddFireEffect(baseWeapon)\r\n+local iceWeapon = decorator:AddIceEffect(fireWeapon)\r\n+```\r\n+\r\n+### 🏛️ **外观模式 (Facade)**\r\n+**用途：** 为复杂子系统提供简单接口\r\n+**作用：**\r\n+- 系统封装\r\n+- 简化接口\r\n+- 降低耦合\r\n+- 统一入口\r\n+\r\n+**适用场景：**\r\n+- 复杂系统封装\r\n+- 简化客户端使用\r\n+- 降低系统耦合\r\n+\r\n+```lua\r\n+local facade = FacadePattern.New()\r\n+-- 复杂的子系统操作被封装成简单接口\r\n+facade:StartGame()\r\n+facade:SaveGame()\r\n+facade:LoadGame()\r\n+```\r\n+\r\n+### 🦋 **享元模式 (Flyweight)**\r\n+**用途：** 通过共享减少内存使用\r\n+**作用：**\r\n+- 纹理共享\r\n+- 模型共享\r\n+- 配置共享\r\n+- 资源优化\r\n+\r\n+**适用场景：**\r\n+- 大量相似对象\r\n+- 内存优化\r\n+- 资源共享\r\n+\r\n+```lua\r\n+local flyweight = FlyweightPattern.New()\r\n+local texture1 = flyweight:GetTexture(\"grass\")\r\n+local texture2 = flyweight:GetTexture(\"grass\")  -- 共享同一个纹理\r\n+```\r\n+\r\n+### 🎭 **代理模式 (Proxy)**\r\n+**用途：** 控制对其他对象的访问\r\n+**作用：**\r\n+- 权限控制\r\n+- 延迟加载\r\n+- 缓存代理\r\n+- 安全控制\r\n+\r\n+**适用场景：**\r\n+- 访问控制\r\n+- 延迟加载\r\n+- 缓存优化\r\n+\r\n+```lua\r\n+local proxy = ProxyPattern.New()\r\n+local realObject = proxy:GetObject()  -- 可能延迟加载\r\n+proxy:CheckPermission(\"read\")  -- 权限检查\r\n+```\r\n+\r\n+---\r\n+\r\n+## 🎭 行为型模式 (Behavioral Patterns)\r\n+\r\n+### 🔗 **责任链模式 (ChainOfResponsibility)**\r\n+**用途：** 将请求沿着处理者链进行传递，直到被处理\r\n+**作用：**\r\n+- 事件处理\r\n+- 权限验证\r\n+- 异常处理\r\n+- 请求过滤\r\n+\r\n+**适用场景：**\r\n+- 多个对象处理请求\r\n+- 请求处理顺序不确定\r\n+- 动态处理链\r\n+\r\n+```lua\r\n+local chain = ChainOfResponsibilityPattern.New()\r\n+chain:AddHandler(handler1)\r\n+chain:AddHandler(handler2)\r\n+chain:HandleRequest(request)\r\n+```\r\n+\r\n+### 📝 **命令模式 (Command)**\r\n+**用途：** 将请求封装成对象，支持请求排队、记录日志、撤销等操作\r\n+**作用：**\r\n+- 撤销/重做系统\r\n+- 宏命令\r\n+- 队列处理\r\n+- 日志记录\r\n+\r\n+**适用场景：**\r\n+- 需要撤销功能\r\n+- 命令排队\r\n+- 宏操作\r\n+\r\n+```lua\r\n+local command = CommandPattern.New()\r\n+local moveCommand = command:CreateMoveCommand(unit, target)\r\n+command:Execute(moveCommand)\r\n+command:Undo()  -- 撤销操作\r\n+```\r\n+\r\n+### 🔤 **解释器模式 (Interpreter)**\r\n+**用途：** 为语言创建解释器\r\n+**作用：**\r\n+- 脚本系统\r\n+- 配置解析\r\n+- 规则引擎\r\n+- 表达式求值\r\n+\r\n+**适用场景：**\r\n+- 简单语言解析\r\n+- 规则引擎\r\n+- 表达式计算\r\n+\r\n+```lua\r\n+local interpreter = InterpreterPattern.New()\r\n+local result = interpreter:Interpret(\"1 + 2 * 3\")\r\n+```\r\n+\r\n+### 🔄 **迭代器模式 (Iterator)**\r\n+**用途：** 提供一种方法顺序访问集合中的元素，而不暴露其内部表示\r\n+**作用：**\r\n+- 集合遍历\r\n+- 自定义遍历\r\n+- 遍历算法\r\n+- 集合封装\r\n+\r\n+**适用场景：**\r\n+- 集合遍历\r\n+- 自定义遍历逻辑\r\n+- 集合封装\r\n+\r\n+```lua\r\n+local iterator = IteratorPattern.New()\r\n+local collection = iterator:CreateCollection()\r\n+for item in collection:Iterator() do\r\n+    print(item)\r\n+end\r\n+```\r\n+\r\n+### 🤝 **中介者模式 (Mediator)**\r\n+**用途：** 封装对象间的交互，降低它们之间的耦合度\r\n+**作用：**\r\n+- 聊天系统\r\n+- 游戏系统协调\r\n+- UI组件协调\r\n+- 模块间通信\r\n+\r\n+**适用场景：**\r\n+- 对象间复杂交互\r\n+- 降低耦合\r\n+- 集中控制\r\n+\r\n+```lua\r\n+local mediator = MediatorPattern.New()\r\n+mediator:RegisterComponent(component1)\r\n+mediator:RegisterComponent(component2)\r\n+component1:SendMessage(\"hello\", mediator)\r\n+```\r\n+\r\n+### 💾 **备忘录模式 (Memento)**\r\n+**用途：** 在不破坏封装的前提下，捕获并外部化对象的内部状态\r\n+**作用：**\r\n+- 游戏存档\r\n+- 撤销系统\r\n+- 状态恢复\r\n+- 快照系统\r\n+\r\n+**适用场景：**\r\n+- 状态保存\r\n+- 撤销功能\r\n+- 快照系统\r\n+\r\n+```lua\r\n+local memento = MementoPattern.New()\r\n+local originator = memento:CreateOriginator()\r\n+local savedState = originator:SaveState()\r\n+originator:RestoreState(savedState)\r\n+```\r\n+\r\n+### 👀 **观察者模式 (Observer)**\r\n+**用途：** 定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会得到通知\r\n+**作用：**\r\n+- 事件系统\r\n+- 数据绑定\r\n+- 消息通知\r\n+- 状态同步\r\n+\r\n+**适用场景：**\r\n+- 事件通知\r\n+- 数据同步\r\n+- 松耦合通信\r\n+\r\n+```lua\r\n+local observer = ObserverPattern.New()\r\n+observer:Subscribe(subscriber1)\r\n+observer:Subscribe(subscriber2)\r\n+observer:Notify(\"event occurred\")\r\n+```\r\n+\r\n+### 🔄 **状态模式 (State)**\r\n+**用途：** 让对象在其内部状态改变时改变其行为\r\n+**作用：**\r\n+- 游戏状态管理\r\n+- 角色状态\r\n+- 系统状态\r\n+- 工作流状态\r\n+\r\n+**适用场景：**\r\n+- 对象状态变化\r\n+- 状态相关行为\r\n+- 状态机实现\r\n+\r\n+```lua\r\n+local state = StatePattern.New()\r\n+local context = state:CreateContext()\r\n+context:SetState(state:CreateState(\"idle\"))\r\n+context:Request()  -- 根据当前状态执行不同行为\r\n+```\r\n+\r\n+### 🎯 **策略模式 (Strategy)**\r\n+**用途：** 定义一系列算法，使它们可以互相替换，算法的变化不会影响使用算法的客户\r\n+**作用：**\r\n+- AI行为选择\r\n+- 算法选择\r\n+- 支付方式\r\n+- 排序算法\r\n+\r\n+**适用场景：**\r\n+- 算法选择\r\n+- 行为选择\r\n+- 避免条件判断\r\n+\r\n+```lua\r\n+local strategy = StrategyPattern.New()\r\n+local context = strategy:CreateContext()\r\n+context:SetStrategy(strategy:CreateStrategy(\"aggressive\"))\r\n+context:ExecuteStrategy()\r\n+```\r\n+\r\n+### 📋 **模板方法模式 (TemplateMethod)**\r\n+**用途：** 在父类中定义算法骨架，让子类重写特定步骤\r\n+**作用：**\r\n+- 算法框架\r\n+- 流程控制\r\n+- 代码复用\r\n+- 扩展点定义\r\n+\r\n+**适用场景：**\r\n+- 算法框架\r\n+- 流程模板\r\n+- 代码复用\r\n+\r\n+```lua\r\n+local template = TemplateMethodPattern.New()\r\n+local concreteClass = template:CreateConcreteClass()\r\n+concreteClass:TemplateMethod()  -- 调用模板方法\r\n+```\r\n+\r\n+### 👥 **访问者模式 (Visitor)**\r\n+**用途：** 在不改变数据结构的前提下，定义作用于其元素的新操作\r\n+**作用：**\r\n+- 数据操作\r\n+- 统计功能\r\n+- 导出功能\r\n+- 功能扩展\r\n+\r\n+**适用场景：**\r\n+- 数据结构稳定\r\n+- 操作经常变化\r\n+- 功能扩展\r\n+\r\n+```lua\r\n+local visitor = VisitorPattern.New()\r\n+local element = visitor:CreateElement()\r\n+local concreteVisitor = visitor:CreateVisitor()\r\n+element:Accept(concreteVisitor)\r\n+```\r\n+\r\n+---\r\n+\r\n+## 🚀 高级模式 (Advanced Patterns)\r\n+\r\n+### 🧩 **组件模式 (Component)**\r\n+**用途：** 将游戏对象分解为可重用的组件\r\n+**作用：**\r\n+- 游戏对象系统\r\n+- 模块化设计\r\n+- 功能组合\r\n+- 系统解耦\r\n+\r\n+**适用场景：**\r\n+- 复杂游戏对象\r\n+- 功能模块化\r\n+- 系统解耦\r\n+\r\n+```lua\r\n+local component = ComponentPattern.New()\r\n+local gameObject = component:CreateGameObject()\r\n+gameObject:AddComponent(\"Transform\")\r\n+gameObject:AddComponent(\"Renderer\")\r\n+gameObject:AddComponent(\"Collider\")\r\n+```\r\n+\r\n+### 📡 **事件驱动模式 (EventDriven)**\r\n+**用途：** 通过事件进行松耦合的通信\r\n+**作用：**\r\n+- 系统解耦\r\n+- 异步通信\r\n+- 消息传递\r\n+- 响应式系统\r\n+\r\n+**适用场景：**\r\n+- 系统解耦\r\n+- 异步处理\r\n+- 消息系统\r\n+\r\n+```lua\r\n+local eventSystem = EventDrivenPattern.New()\r\n+eventSystem:Subscribe(\"playerMove\", handler)\r\n+eventSystem:Publish(\"playerMove\", {x = 100, y = 200})\r\n+```\r\n+\r\n+### 🎮 **状态机模式 (StateMachine)**\r\n+**用途：** 管理复杂的状态转换逻辑\r\n+**作用：**\r\n+- 角色状态管理\r\n+- 游戏流程控制\r\n+- AI状态管理\r\n+- 系统状态控制\r\n+\r\n+**适用场景：**\r\n+- 复杂状态管理\r\n+- 状态转换逻辑\r\n+- 流程控制\r\n+\r\n+```lua\r\n+local stateMachine = StateMachinePattern.New()\r\n+stateMachine:AddState(\"idle\")\r\n+stateMachine:AddState(\"walking\")\r\n+stateMachine:AddTransition(\"idle\", \"walking\", \"startWalking\")\r\n+stateMachine:ChangeState(\"idle\")\r\n+```\r\n+\r\n+### 🏢 **服务定位器模式 (ServiceLocator)**\r\n+**用途：** 提供全局的服务访问点\r\n+**作用：**\r\n+- 服务管理\r\n+- 依赖管理\r\n+- 全局访问\r\n+- 服务注册\r\n+\r\n+**适用场景：**\r\n+- 全局服务访问\r\n+- 服务管理\r\n+- 依赖注入\r\n+\r\n+```lua\r\n+local serviceLocator = ServiceLocatorPattern.New()\r\n+serviceLocator:Register(\"audioService\", audioService)\r\n+local audio = serviceLocator:GetService(\"audioService\")\r\n+```\r\n+\r\n+### 🏊 **对象池模式 (ObjectPool)**\r\n+**用途：** 重用对象以减少创建和销毁的开销\r\n+**作用：**\r\n+- 性能优化\r\n+- 内存管理\r\n+- 对象复用\r\n+- 垃圾回收优化\r\n+\r\n+**适用场景：**\r\n+- 频繁创建销毁\r\n+- 性能优化\r\n+- 内存管理\r\n+\r\n+```lua\r\n+local objectPool = ObjectPoolPattern.New()\r\n+local bullet = objectPool:GetObject(\"bullet\")\r\n+-- 使用子弹\r\n+objectPool:ReturnObject(bullet)\r\n+```\r\n+\r\n+### 📊 **数据驱动模式 (DataDriven)**\r\n+**用途：** 通过数据配置驱动系统行为\r\n+**作用：**\r\n+- 配置管理\r\n+- 数据驱动\r\n+- 系统配置\r\n+- 行为配置\r\n+\r\n+**适用场景：**\r\n+- 配置驱动\r\n+- 数据驱动\r\n+- 系统配置\r\n+\r\n+```lua\r\n+local dataDriven = DataDrivenPattern.New()\r\n+dataDriven:LoadConfig(\"weapon_config.json\")\r\n+local weapon = dataDriven:CreateWeapon(\"sword\")\r\n+```\r\n+\r\n+### ⚡ **响应式编程模式 (ReactiveProgramming)**\r\n+**用途：** 通过数据流和变化传播来简化编程\r\n+**作用：**\r\n+- 数据流处理\r\n+- 变化传播\r\n+- 异步处理\r\n+- 事件流\r\n+\r\n+**适用场景：**\r\n+- 数据流处理\r\n+- 变化响应\r\n+- 异步编程\r\n+\r\n+```lua\r\n+local reactive = ReactiveProgrammingPattern.New()\r\n+local stream = reactive:CreateStream()\r\n+stream:Subscribe(function(value) print(\"Value changed:\", value) end)\r\n+stream:Next(100)\r\n+```\r\n+\r\n+### 💉 **依赖注入模式 (DependencyInjection)**\r\n+**用途：** 通过外部注入依赖，降低组件间的耦合\r\n+**作用：**\r\n+- 依赖管理\r\n+- 解耦设计\r\n+- 测试友好\r\n+- 配置灵活\r\n+\r\n+**适用场景：**\r\n+- 依赖管理\r\n+- 系统解耦\r\n+- 测试友好\r\n+\r\n+```lua\r\n+local di = DependencyInjectionPattern.New()\r\n+di:Register(\"database\", databaseService)\r\n+di:Register(\"logger\", loggerService)\r\n+local service = di:CreateService(MyService)\r\n+```\r\n+\r\n+### 🚩 **脏标记模式 (DirtyFlag)**\r\n+**用途：** 通过标记避免不必要的计算\r\n+**作用：**\r\n+- 性能优化\r\n+- 缓存管理\r\n+- 计算优化\r\n+- 更新控制\r\n+\r\n+**适用场景：**\r\n+- 性能优化\r\n+- 缓存管理\r\n+- 计算优化\r\n+\r\n+```lua\r\n+local dirtyFlag = DirtyFlagPattern.New()\r\n+local object = dirtyFlag:CreateObject()\r\n+object:MarkDirty()\r\n+if object:IsDirty() then\r\n+    object:Update()\r\n+    object:ClearDirty()\r\n+end\r\n+```\r\n+\r\n+### 🔄 **双缓冲模式 (DoubleBuffer)**\r\n+**用途：** 使用两个缓冲区避免渲染冲突\r\n+**作用：**\r\n+- 渲染优化\r\n+- 动画平滑\r\n+- 避免闪烁\r\n+- 性能提升\r\n+\r\n+**适用场景：**\r\n+- 渲染系统\r\n+- 动画系统\r\n+- 避免闪烁\r\n+\r\n+```lua\r\n+local doubleBuffer = DoubleBufferPattern.New()\r\n+local buffer = doubleBuffer:CreateBuffer()\r\n+buffer:SwapBuffers()\r\n+buffer:DrawToBackBuffer()\r\n+```\r\n+\r\n+### 📍 **数据局部性模式 (DataLocality)**\r\n+**用途：** 通过组织数据布局提高缓存效率\r\n+**作用：**\r\n+- 性能优化\r\n+- 缓存优化\r\n+- 内存访问优化\r\n+- 系统性能\r\n+\r\n+**适用场景：**\r\n+- 性能优化\r\n+- 缓存优化\r\n+- 内存访问优化\r\n+\r\n+```lua\r\n+local dataLocality = DataLocalityPattern.New()\r\n+local optimizedArray = dataLocality:CreateOptimizedArray()\r\n+-- 数据按访问模式组织，提高缓存命中率\r\n+```\r\n+\r\n+### 💻 **字节码模式 (Bytecode)**\r\n+**用途：** 通过字节码实现脚本系统\r\n+**作用：**\r\n+- 脚本系统\r\n+- 虚拟机\r\n+- 性能优化\r\n+- 跨平台\r\n+\r\n+**适用场景：**\r\n+- 脚本系统\r\n+- 性能优化\r\n+- 跨平台\r\n+\r\n+```lua\r\n+local bytecode = BytecodePattern.New()\r\n+local script = bytecode:Compile(\"print('Hello World')\")\r\n+bytecode:Execute(script)\r\n+```\r\n+\r\n+---\r\n+\r\n+## 🚀 使用指南\r\n+\r\n+### 快速开始\r\n+```lua\r\n+-- 1. 选择合适的设计模式\r\n+local pattern = PatternFactory.Create(PatternTypes.SINGLETON)\r\n+\r\n+-- 2. 创建模式实例\r\n+local instance = pattern:Create()\r\n+\r\n+-- 3. 使用模式功能\r\n+instance:DoSomething()\r\n+```\r\n+\r\n+### 模式选择建议\r\n+- **对象创建**: 使用创建型模式\r\n+- **对象组合**: 使用结构型模式\r\n+- **对象交互**: 使用行为型模式\r\n+- **游戏开发**: 使用高级模式\r\n+\r\n+### 最佳实践\r\n+- **单一职责**: 每个模式只负责一个方面\r\n+- **开闭原则**: 对扩展开放，对修改关闭\r\n+- **依赖倒置**: 依赖抽象而非具体实现\r\n+- **接口隔离**: 客户端不应该依赖不需要的接口\r\n+\r\n+---\r\n+\r\n+## 📈 模式对比\r\n+\r\n+| 模式类型 | 主要用途 | 复杂度 | 适用场景 | 性能影响 |\r\n+|----------|----------|--------|----------|----------|\r\n+| **创建型** | 对象创建 | 低-中 | 对象创建逻辑 | 低 |\r\n+| **结构型** | 对象组合 | 中 | 对象关系 | 低-中 |\r\n+| **行为型** | 对象交互 | 中-高 | 对象通信 | 中 |\r\n+| **高级** | 游戏开发 | 高 | 复杂系统 | 中-高 |\r\n+\r\n+---\r\n+\r\n+## 🔧 扩展开发\r\n+\r\n+### 添加新的设计模式\r\n+1. 继承基础模式接口\r\n+2. 实现必要的方法\r\n+3. 在工厂中注册\r\n+4. 添加使用示例\r\n+\r\n+### 自定义模式实现\r\n+```lua\r\n+local CustomPattern = BaseClass(IPattern)\r\n+\r\n+function CustomPattern:ctor()\r\n+    -- 初始化代码\r\n+end\r\n+\r\n+function CustomPattern:Execute()\r\n+    -- 模式执行逻辑\r\n+end\r\n+```\r\n+\r\n+---\r\n+\r\n+## 📚 总结\r\n+\r\n+这个设计模式库提供了：\r\n+\r\n+✅ **完整的模式覆盖** - 从基础到高级的完整覆盖  \r\n+✅ **游戏开发优化** - 针对游戏开发的专用模式  \r\n+✅ **易用性设计** - 统一的接口和工厂创建  \r\n+✅ **扩展性架构** - 易于添加新的设计模式  \r\n+✅ **实用性强** - 实际项目中的应用场景  \r\n+\r\n+**🎯 核心价值：** 让开发者专注于业务逻辑，而不是架构设计的复杂细节。\r\n+\r\n+---\r\n+\r\n+*支持Lua 5.1+ | 完整设计模式 | 游戏开发优化 | 易于扩展 | 🚀 架构设计最佳实践*\r\n"
                },
                {
                    "date": 1767210826728,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n │   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n │   ├── State (状态模式) - 状态机就是其最好的理解了\r\n │   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n │   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n-│   └── Visitor (访问者模式) \r\n+│   └── Visitor (访问者模式) - 策略模式+表驱动模式，通过表驱动模式实现不同元素类型的不同处理逻辑。\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)\r\n     ├── EventDriven (事件驱动模式)\r\n     ├── StateMachine (状态机模式)\r\n@@ -844,851 +844,4 @@\n \r\n ---\r\n \r\n *支持Lua 5.1+ | 完整设计模式 | 游戏开发优化 | 易于扩展 | 🚀 架构设计最佳实践*\r\n-# 🎯 Lua设计模式库 - 完整指南\r\n-\r\n-## 📋 概述\r\n-\r\n-这是一个功能完整的Lua设计模式库，涵盖了从基础到高级的各种设计模式实现。每个模式都经过精心设计，确保易用性、可扩展性和高性能。\r\n-\r\n-**🎯 设计理念：** 将复杂的设计模式封装成简单易用的工具，让开发者专注于业务逻辑，而不是架构细节。\r\n-\r\n----\r\n-\r\n-## 🏗️ 架构分类\r\n-\r\n-### 核心模式分类\r\n-```\r\n-Pattern Library (设计模式库)\r\n-├── Creational (创建型模式) - 对象创建的艺术\r\n-│   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n-│   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)\r\n-│   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容\r\n-│   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n-│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n-├── Structural (结构型模式) - 对象组合的艺术\r\n-│   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n-│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果\r\n-│   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n-│   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n-│   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n-│   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n-│   └── Proxy (代理模式) - 可用钩子方法+策略模式替代，避免代理模式滥用\r\n-├── Behavioral (行为型模式) - 对象交互的艺术\r\n-│   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n-│   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n-│   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n-│   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n-│   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n-│   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n-│   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n-│   ├── State (状态模式) - 状态机就是其最好的理解了\r\n-│   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n-│   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n-│   └── Visitor (访问者模式)\r\n-└── Advanced (高级模式) - 游戏开发专用模式\r\n-    ├── Component (组件模式)\r\n-    ├── EventDriven (事件驱动模式)\r\n-    ├── StateMachine (状态机模式)\r\n-    ├── ServiceLocator (服务定位器模式)\r\n-    ├── ObjectPool (对象池模式)\r\n-    ├── DataDriven (数据驱动模式)\r\n-    ├── ReactiveProgramming (响应式编程模式)\r\n-    ├── DependencyInjection (依赖注入模式)\r\n-    ├── DirtyFlag (脏标记模式)\r\n-    ├── DoubleBuffer (双缓冲模式)\r\n-    ├── DataLocality (数据局部性模式)\r\n-    └── Bytecode (字节码模式)\r\n-```\r\n-\r\n----\r\n-\r\n-## 🏭 创建型模式 (Creational Patterns)\r\n-\r\n-### 🔒 **单例模式 (Singleton)**\r\n-**用途：** 确保一个类只有一个实例，并提供全局访问点\r\n-**作用：** \r\n-- 游戏管理器\r\n-- 配置管理器\r\n-- 资源管理器\r\n-- 日志系统\r\n-\r\n-**适用场景：**\r\n-- 需要全局唯一实例\r\n-- 资源管理\r\n-- 配置管理\r\n-\r\n-```lua\r\n-local singleton = SingletonPattern.New()\r\n-local instance1 = singleton:GetInstance()\r\n-local instance2 = singleton:GetInstance()\r\n-print(instance1 == instance2)  -- true，同一个实例\r\n-```\r\n-\r\n-### 🏭 **工厂模式 (Factory)**\r\n-**用途：** 根据条件创建不同类型的对象\r\n-**作用：**\r\n-- 游戏对象创建\r\n-- 武器系统\r\n-- 敌人生成\r\n-- 道具创建\r\n-\r\n-**适用场景：**\r\n-- 需要根据条件创建对象\r\n-- 对象创建逻辑复杂\r\n-- 支持扩展新类型\r\n-\r\n-```lua\r\n-local factory = FactoryPattern.New()\r\n-local weapon = factory:CreateWeapon(\"sword\")\r\n-local enemy = factory:CreateEnemy(\"goblin\")\r\n-```\r\n-\r\n-### 🏭🏭 **抽象工厂模式 (AbstractFactory)**\r\n-**用途：** 创建一系列相关对象，确保它们相互兼容\r\n-**作用：**\r\n-- 游戏主题系统\r\n-- UI风格系统\r\n-- 关卡风格\r\n-- 种族系统\r\n-\r\n-**适用场景：**\r\n-- 需要创建相关对象族\r\n-- 确保对象兼容性\r\n-- 支持多种风格\r\n-\r\n-```lua\r\n-local factory = AbstractFactoryPattern.New()\r\n-local medievalFactory = factory:CreateFactory(\"medieval\")\r\n-local sword = medievalFactory:CreateWeapon()\r\n-local armor = medievalFactory:CreateArmor()\r\n-```\r\n-\r\n-### 🏗️ **建造者模式 (Builder)**\r\n-**用途：** 分步骤构建复杂对象\r\n-**作用：**\r\n-- 角色创建\r\n-- 关卡构建\r\n-- 配置构建\r\n-- 复杂对象组装\r\n-\r\n-**适用场景：**\r\n-- 对象构建过程复杂\r\n-- 需要分步骤构建\r\n-- 支持不同构建方式\r\n-\r\n-```lua\r\n-local builder = BuilderPattern.New()\r\n-local character = builder:SetName(\"英雄\")\r\n-    :SetClass(\"战士\")\r\n-    :SetLevel(10)\r\n-    :SetEquipment(\"铁剑\")\r\n-    :Build()\r\n-```\r\n-\r\n-### 🧬 **原型模式 (Prototype)**\r\n-**用途：** 通过克隆现有对象来创建新对象\r\n-**作用：**\r\n-- 对象复制\r\n-- 模板系统\r\n-- 快速创建\r\n-- 减少初始化开销\r\n-\r\n-**适用场景：**\r\n-- 对象创建开销大\r\n-- 需要对象副本\r\n-- 模板系统\r\n-\r\n-```lua\r\n-local prototype = PrototypePattern.New()\r\n-local original = prototype:Create(\"template\")\r\n-local clone = original:Clone()\r\n-```\r\n-\r\n----\r\n-\r\n-## 🏗️ 结构型模式 (Structural Patterns)\r\n-\r\n-### 🔌 **适配器模式 (Adapter)**\r\n-**用途：** 让不兼容的接口能够协同工作\r\n-**作用：**\r\n-- 第三方库集成\r\n-- 旧系统适配\r\n-- 接口统一\r\n-- 兼容性处理\r\n-\r\n-**适用场景：**\r\n-- 集成第三方库\r\n-- 系统升级兼容\r\n-- 接口不匹配\r\n-\r\n-```lua\r\n-local adapter = AdapterPattern.New()\r\n-local newInterface = adapter:Adapt(oldSystem)\r\n-newInterface:NewMethod()\r\n-```\r\n-\r\n-### 🌉 **桥接模式 (Bridge)**\r\n-**用途：** 将抽象与实现分离，使它们可以独立变化\r\n-**作用：**\r\n-- 平台抽象\r\n-- 渲染器抽象\r\n-- 数据库抽象\r\n-- 网络抽象\r\n-\r\n-**适用场景：**\r\n-- 需要支持多平台\r\n-- 抽象与实现分离\r\n-- 避免继承爆炸\r\n-\r\n-```lua\r\n-local bridge = BridgePattern.New()\r\n-local renderer = bridge:CreateRenderer(\"OpenGL\")\r\n-local shape = bridge:CreateShape(\"Circle\", renderer)\r\n-```\r\n-\r\n-### 🧩 **组合模式 (Composite)**\r\n-**用途：** 将对象组合成树形结构，统一处理单个对象和组合对象\r\n-**作用：**\r\n-- 场景图系统\r\n-- UI组件树\r\n-- 文件系统\r\n-- 游戏对象层次\r\n-\r\n-**适用场景：**\r\n-- 树形结构\r\n-- 部分-整体关系\r\n-- 统一处理接口\r\n-\r\n-```lua\r\n-local composite = CompositePattern.New()\r\n-local root = composite:CreateComponent(\"root\")\r\n-local child1 = composite:CreateComponent(\"child1\")\r\n-root:Add(child1)\r\n-root:Operation()  -- 递归调用所有子组件\r\n-```\r\n-\r\n-### 🎨 **装饰器模式 (Decorator)**\r\n-**用途：** 动态地给对象添加新功能\r\n-**作用：**\r\n-- 装备系统\r\n-- 技能增强\r\n-- 状态效果\r\n-- 功能扩展\r\n-\r\n-**适用场景：**\r\n-- 需要动态添加功能\r\n-- 避免继承爆炸\r\n-- 功能组合\r\n-\r\n-```lua\r\n-local decorator = DecoratorPattern.New()\r\n-local baseWeapon = decorator:CreateWeapon(\"剑\")\r\n-local fireWeapon = decorator:AddFireEffect(baseWeapon)\r\n-local iceWeapon = decorator:AddIceEffect(fireWeapon)\r\n-```\r\n-\r\n-### 🏛️ **外观模式 (Facade)**\r\n-**用途：** 为复杂子系统提供简单接口\r\n-**作用：**\r\n-- 系统封装\r\n-- 简化接口\r\n-- 降低耦合\r\n-- 统一入口\r\n-\r\n-**适用场景：**\r\n-- 复杂系统封装\r\n-- 简化客户端使用\r\n-- 降低系统耦合\r\n-\r\n-```lua\r\n-local facade = FacadePattern.New()\r\n--- 复杂的子系统操作被封装成简单接口\r\n-facade:StartGame()\r\n-facade:SaveGame()\r\n-facade:LoadGame()\r\n-```\r\n-\r\n-### 🦋 **享元模式 (Flyweight)**\r\n-**用途：** 通过共享减少内存使用\r\n-**作用：**\r\n-- 纹理共享\r\n-- 模型共享\r\n-- 配置共享\r\n-- 资源优化\r\n-\r\n-**适用场景：**\r\n-- 大量相似对象\r\n-- 内存优化\r\n-- 资源共享\r\n-\r\n-```lua\r\n-local flyweight = FlyweightPattern.New()\r\n-local texture1 = flyweight:GetTexture(\"grass\")\r\n-local texture2 = flyweight:GetTexture(\"grass\")  -- 共享同一个纹理\r\n-```\r\n-\r\n-### 🎭 **代理模式 (Proxy)**\r\n-**用途：** 控制对其他对象的访问\r\n-**作用：**\r\n-- 权限控制\r\n-- 延迟加载\r\n-- 缓存代理\r\n-- 安全控制\r\n-\r\n-**适用场景：**\r\n-- 访问控制\r\n-- 延迟加载\r\n-- 缓存优化\r\n-\r\n-```lua\r\n-local proxy = ProxyPattern.New()\r\n-local realObject = proxy:GetObject()  -- 可能延迟加载\r\n-proxy:CheckPermission(\"read\")  -- 权限检查\r\n-```\r\n-\r\n----\r\n-\r\n-## 🎭 行为型模式 (Behavioral Patterns)\r\n-\r\n-### 🔗 **责任链模式 (ChainOfResponsibility)**\r\n-**用途：** 将请求沿着处理者链进行传递，直到被处理\r\n-**作用：**\r\n-- 事件处理\r\n-- 权限验证\r\n-- 异常处理\r\n-- 请求过滤\r\n-\r\n-**适用场景：**\r\n-- 多个对象处理请求\r\n-- 请求处理顺序不确定\r\n-- 动态处理链\r\n-\r\n-```lua\r\n-local chain = ChainOfResponsibilityPattern.New()\r\n-chain:AddHandler(handler1)\r\n-chain:AddHandler(handler2)\r\n-chain:HandleRequest(request)\r\n-```\r\n-\r\n-### 📝 **命令模式 (Command)**\r\n-**用途：** 将请求封装成对象，支持请求排队、记录日志、撤销等操作\r\n-**作用：**\r\n-- 撤销/重做系统\r\n-- 宏命令\r\n-- 队列处理\r\n-- 日志记录\r\n-\r\n-**适用场景：**\r\n-- 需要撤销功能\r\n-- 命令排队\r\n-- 宏操作\r\n-\r\n-```lua\r\n-local command = CommandPattern.New()\r\n-local moveCommand = command:CreateMoveCommand(unit, target)\r\n-command:Execute(moveCommand)\r\n-command:Undo()  -- 撤销操作\r\n-```\r\n-\r\n-### 🔤 **解释器模式 (Interpreter)**\r\n-**用途：** 为语言创建解释器\r\n-**作用：**\r\n-- 脚本系统\r\n-- 配置解析\r\n-- 规则引擎\r\n-- 表达式求值\r\n-\r\n-**适用场景：**\r\n-- 简单语言解析\r\n-- 规则引擎\r\n-- 表达式计算\r\n-\r\n-```lua\r\n-local interpreter = InterpreterPattern.New()\r\n-local result = interpreter:Interpret(\"1 + 2 * 3\")\r\n-```\r\n-\r\n-### 🔄 **迭代器模式 (Iterator)**\r\n-**用途：** 提供一种方法顺序访问集合中的元素，而不暴露其内部表示\r\n-**作用：**\r\n-- 集合遍历\r\n-- 自定义遍历\r\n-- 遍历算法\r\n-- 集合封装\r\n-\r\n-**适用场景：**\r\n-- 集合遍历\r\n-- 自定义遍历逻辑\r\n-- 集合封装\r\n-\r\n-```lua\r\n-local iterator = IteratorPattern.New()\r\n-local collection = iterator:CreateCollection()\r\n-for item in collection:Iterator() do\r\n-    print(item)\r\n-end\r\n-```\r\n-\r\n-### 🤝 **中介者模式 (Mediator)**\r\n-**用途：** 封装对象间的交互，降低它们之间的耦合度\r\n-**作用：**\r\n-- 聊天系统\r\n-- 游戏系统协调\r\n-- UI组件协调\r\n-- 模块间通信\r\n-\r\n-**适用场景：**\r\n-- 对象间复杂交互\r\n-- 降低耦合\r\n-- 集中控制\r\n-\r\n-```lua\r\n-local mediator = MediatorPattern.New()\r\n-mediator:RegisterComponent(component1)\r\n-mediator:RegisterComponent(component2)\r\n-component1:SendMessage(\"hello\", mediator)\r\n-```\r\n-\r\n-### 💾 **备忘录模式 (Memento)**\r\n-**用途：** 在不破坏封装的前提下，捕获并外部化对象的内部状态\r\n-**作用：**\r\n-- 游戏存档\r\n-- 撤销系统\r\n-- 状态恢复\r\n-- 快照系统\r\n-\r\n-**适用场景：**\r\n-- 状态保存\r\n-- 撤销功能\r\n-- 快照系统\r\n-\r\n-```lua\r\n-local memento = MementoPattern.New()\r\n-local originator = memento:CreateOriginator()\r\n-local savedState = originator:SaveState()\r\n-originator:RestoreState(savedState)\r\n-```\r\n-\r\n-### 👀 **观察者模式 (Observer)**\r\n-**用途：** 定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会得到通知\r\n-**作用：**\r\n-- 事件系统\r\n-- 数据绑定\r\n-- 消息通知\r\n-- 状态同步\r\n-\r\n-**适用场景：**\r\n-- 事件通知\r\n-- 数据同步\r\n-- 松耦合通信\r\n-\r\n-```lua\r\n-local observer = ObserverPattern.New()\r\n-observer:Subscribe(subscriber1)\r\n-observer:Subscribe(subscriber2)\r\n-observer:Notify(\"event occurred\")\r\n-```\r\n-\r\n-### 🔄 **状态模式 (State)**\r\n-**用途：** 让对象在其内部状态改变时改变其行为\r\n-**作用：**\r\n-- 游戏状态管理\r\n-- 角色状态\r\n-- 系统状态\r\n-- 工作流状态\r\n-\r\n-**适用场景：**\r\n-- 对象状态变化\r\n-- 状态相关行为\r\n-- 状态机实现\r\n-\r\n-```lua\r\n-local state = StatePattern.New()\r\n-local context = state:CreateContext()\r\n-context:SetState(state:CreateState(\"idle\"))\r\n-context:Request()  -- 根据当前状态执行不同行为\r\n-```\r\n-\r\n-### 🎯 **策略模式 (Strategy)**\r\n-**用途：** 定义一系列算法，使它们可以互相替换，算法的变化不会影响使用算法的客户\r\n-**作用：**\r\n-- AI行为选择\r\n-- 算法选择\r\n-- 支付方式\r\n-- 排序算法\r\n-\r\n-**适用场景：**\r\n-- 算法选择\r\n-- 行为选择\r\n-- 避免条件判断\r\n-\r\n-```lua\r\n-local strategy = StrategyPattern.New()\r\n-local context = strategy:CreateContext()\r\n-context:SetStrategy(strategy:CreateStrategy(\"aggressive\"))\r\n-context:ExecuteStrategy()\r\n-```\r\n-\r\n-### 📋 **模板方法模式 (TemplateMethod)**\r\n-**用途：** 在父类中定义算法骨架，让子类重写特定步骤\r\n-**作用：**\r\n-- 算法框架\r\n-- 流程控制\r\n-- 代码复用\r\n-- 扩展点定义\r\n-\r\n-**适用场景：**\r\n-- 算法框架\r\n-- 流程模板\r\n-- 代码复用\r\n-\r\n-```lua\r\n-local template = TemplateMethodPattern.New()\r\n-local concreteClass = template:CreateConcreteClass()\r\n-concreteClass:TemplateMethod()  -- 调用模板方法\r\n-```\r\n-\r\n-### 👥 **访问者模式 (Visitor)**\r\n-**用途：** 在不改变数据结构的前提下，定义作用于其元素的新操作\r\n-**作用：**\r\n-- 数据操作\r\n-- 统计功能\r\n-- 导出功能\r\n-- 功能扩展\r\n-\r\n-**适用场景：**\r\n-- 数据结构稳定\r\n-- 操作经常变化\r\n-- 功能扩展\r\n-\r\n-```lua\r\n-local visitor = VisitorPattern.New()\r\n-local element = visitor:CreateElement()\r\n-local concreteVisitor = visitor:CreateVisitor()\r\n-element:Accept(concreteVisitor)\r\n-```\r\n-\r\n----\r\n-\r\n-## 🚀 高级模式 (Advanced Patterns)\r\n-\r\n-### 🧩 **组件模式 (Component)**\r\n-**用途：** 将游戏对象分解为可重用的组件\r\n-**作用：**\r\n-- 游戏对象系统\r\n-- 模块化设计\r\n-- 功能组合\r\n-- 系统解耦\r\n-\r\n-**适用场景：**\r\n-- 复杂游戏对象\r\n-- 功能模块化\r\n-- 系统解耦\r\n-\r\n-```lua\r\n-local component = ComponentPattern.New()\r\n-local gameObject = component:CreateGameObject()\r\n-gameObject:AddComponent(\"Transform\")\r\n-gameObject:AddComponent(\"Renderer\")\r\n-gameObject:AddComponent(\"Collider\")\r\n-```\r\n-\r\n-### 📡 **事件驱动模式 (EventDriven)**\r\n-**用途：** 通过事件进行松耦合的通信\r\n-**作用：**\r\n-- 系统解耦\r\n-- 异步通信\r\n-- 消息传递\r\n-- 响应式系统\r\n-\r\n-**适用场景：**\r\n-- 系统解耦\r\n-- 异步处理\r\n-- 消息系统\r\n-\r\n-```lua\r\n-local eventSystem = EventDrivenPattern.New()\r\n-eventSystem:Subscribe(\"playerMove\", handler)\r\n-eventSystem:Publish(\"playerMove\", {x = 100, y = 200})\r\n-```\r\n-\r\n-### 🎮 **状态机模式 (StateMachine)**\r\n-**用途：** 管理复杂的状态转换逻辑\r\n-**作用：**\r\n-- 角色状态管理\r\n-- 游戏流程控制\r\n-- AI状态管理\r\n-- 系统状态控制\r\n-\r\n-**适用场景：**\r\n-- 复杂状态管理\r\n-- 状态转换逻辑\r\n-- 流程控制\r\n-\r\n-```lua\r\n-local stateMachine = StateMachinePattern.New()\r\n-stateMachine:AddState(\"idle\")\r\n-stateMachine:AddState(\"walking\")\r\n-stateMachine:AddTransition(\"idle\", \"walking\", \"startWalking\")\r\n-stateMachine:ChangeState(\"idle\")\r\n-```\r\n-\r\n-### 🏢 **服务定位器模式 (ServiceLocator)**\r\n-**用途：** 提供全局的服务访问点\r\n-**作用：**\r\n-- 服务管理\r\n-- 依赖管理\r\n-- 全局访问\r\n-- 服务注册\r\n-\r\n-**适用场景：**\r\n-- 全局服务访问\r\n-- 服务管理\r\n-- 依赖注入\r\n-\r\n-```lua\r\n-local serviceLocator = ServiceLocatorPattern.New()\r\n-serviceLocator:Register(\"audioService\", audioService)\r\n-local audio = serviceLocator:GetService(\"audioService\")\r\n-```\r\n-\r\n-### 🏊 **对象池模式 (ObjectPool)**\r\n-**用途：** 重用对象以减少创建和销毁的开销\r\n-**作用：**\r\n-- 性能优化\r\n-- 内存管理\r\n-- 对象复用\r\n-- 垃圾回收优化\r\n-\r\n-**适用场景：**\r\n-- 频繁创建销毁\r\n-- 性能优化\r\n-- 内存管理\r\n-\r\n-```lua\r\n-local objectPool = ObjectPoolPattern.New()\r\n-local bullet = objectPool:GetObject(\"bullet\")\r\n--- 使用子弹\r\n-objectPool:ReturnObject(bullet)\r\n-```\r\n-\r\n-### 📊 **数据驱动模式 (DataDriven)**\r\n-**用途：** 通过数据配置驱动系统行为\r\n-**作用：**\r\n-- 配置管理\r\n-- 数据驱动\r\n-- 系统配置\r\n-- 行为配置\r\n-\r\n-**适用场景：**\r\n-- 配置驱动\r\n-- 数据驱动\r\n-- 系统配置\r\n-\r\n-```lua\r\n-local dataDriven = DataDrivenPattern.New()\r\n-dataDriven:LoadConfig(\"weapon_config.json\")\r\n-local weapon = dataDriven:CreateWeapon(\"sword\")\r\n-```\r\n-\r\n-### ⚡ **响应式编程模式 (ReactiveProgramming)**\r\n-**用途：** 通过数据流和变化传播来简化编程\r\n-**作用：**\r\n-- 数据流处理\r\n-- 变化传播\r\n-- 异步处理\r\n-- 事件流\r\n-\r\n-**适用场景：**\r\n-- 数据流处理\r\n-- 变化响应\r\n-- 异步编程\r\n-\r\n-```lua\r\n-local reactive = ReactiveProgrammingPattern.New()\r\n-local stream = reactive:CreateStream()\r\n-stream:Subscribe(function(value) print(\"Value changed:\", value) end)\r\n-stream:Next(100)\r\n-```\r\n-\r\n-### 💉 **依赖注入模式 (DependencyInjection)**\r\n-**用途：** 通过外部注入依赖，降低组件间的耦合\r\n-**作用：**\r\n-- 依赖管理\r\n-- 解耦设计\r\n-- 测试友好\r\n-- 配置灵活\r\n-\r\n-**适用场景：**\r\n-- 依赖管理\r\n-- 系统解耦\r\n-- 测试友好\r\n-\r\n-```lua\r\n-local di = DependencyInjectionPattern.New()\r\n-di:Register(\"database\", databaseService)\r\n-di:Register(\"logger\", loggerService)\r\n-local service = di:CreateService(MyService)\r\n-```\r\n-\r\n-### 🚩 **脏标记模式 (DirtyFlag)**\r\n-**用途：** 通过标记避免不必要的计算\r\n-**作用：**\r\n-- 性能优化\r\n-- 缓存管理\r\n-- 计算优化\r\n-- 更新控制\r\n-\r\n-**适用场景：**\r\n-- 性能优化\r\n-- 缓存管理\r\n-- 计算优化\r\n-\r\n-```lua\r\n-local dirtyFlag = DirtyFlagPattern.New()\r\n-local object = dirtyFlag:CreateObject()\r\n-object:MarkDirty()\r\n-if object:IsDirty() then\r\n-    object:Update()\r\n-    object:ClearDirty()\r\n-end\r\n-```\r\n-\r\n-### 🔄 **双缓冲模式 (DoubleBuffer)**\r\n-**用途：** 使用两个缓冲区避免渲染冲突\r\n-**作用：**\r\n-- 渲染优化\r\n-- 动画平滑\r\n-- 避免闪烁\r\n-- 性能提升\r\n-\r\n-**适用场景：**\r\n-- 渲染系统\r\n-- 动画系统\r\n-- 避免闪烁\r\n-\r\n-```lua\r\n-local doubleBuffer = DoubleBufferPattern.New()\r\n-local buffer = doubleBuffer:CreateBuffer()\r\n-buffer:SwapBuffers()\r\n-buffer:DrawToBackBuffer()\r\n-```\r\n-\r\n-### 📍 **数据局部性模式 (DataLocality)**\r\n-**用途：** 通过组织数据布局提高缓存效率\r\n-**作用：**\r\n-- 性能优化\r\n-- 缓存优化\r\n-- 内存访问优化\r\n-- 系统性能\r\n-\r\n-**适用场景：**\r\n-- 性能优化\r\n-- 缓存优化\r\n-- 内存访问优化\r\n-\r\n-```lua\r\n-local dataLocality = DataLocalityPattern.New()\r\n-local optimizedArray = dataLocality:CreateOptimizedArray()\r\n--- 数据按访问模式组织，提高缓存命中率\r\n-```\r\n-\r\n-### 💻 **字节码模式 (Bytecode)**\r\n-**用途：** 通过字节码实现脚本系统\r\n-**作用：**\r\n-- 脚本系统\r\n-- 虚拟机\r\n-- 性能优化\r\n-- 跨平台\r\n-\r\n-**适用场景：**\r\n-- 脚本系统\r\n-- 性能优化\r\n-- 跨平台\r\n-\r\n-```lua\r\n-local bytecode = BytecodePattern.New()\r\n-local script = bytecode:Compile(\"print('Hello World')\")\r\n-bytecode:Execute(script)\r\n-```\r\n-\r\n----\r\n-\r\n-## 🚀 使用指南\r\n-\r\n-### 快速开始\r\n-```lua\r\n--- 1. 选择合适的设计模式\r\n-local pattern = PatternFactory.Create(PatternTypes.SINGLETON)\r\n-\r\n--- 2. 创建模式实例\r\n-local instance = pattern:Create()\r\n-\r\n--- 3. 使用模式功能\r\n-instance:DoSomething()\r\n-```\r\n-\r\n-### 模式选择建议\r\n-- **对象创建**: 使用创建型模式\r\n-- **对象组合**: 使用结构型模式\r\n-- **对象交互**: 使用行为型模式\r\n-- **游戏开发**: 使用高级模式\r\n-\r\n-### 最佳实践\r\n-- **单一职责**: 每个模式只负责一个方面\r\n-- **开闭原则**: 对扩展开放，对修改关闭\r\n-- **依赖倒置**: 依赖抽象而非具体实现\r\n-- **接口隔离**: 客户端不应该依赖不需要的接口\r\n-\r\n----\r\n-\r\n-## 📈 模式对比\r\n-\r\n-| 模式类型 | 主要用途 | 复杂度 | 适用场景 | 性能影响 |\r\n-|----------|----------|--------|----------|----------|\r\n-| **创建型** | 对象创建 | 低-中 | 对象创建逻辑 | 低 |\r\n-| **结构型** | 对象组合 | 中 | 对象关系 | 低-中 |\r\n-| **行为型** | 对象交互 | 中-高 | 对象通信 | 中 |\r\n-| **高级** | 游戏开发 | 高 | 复杂系统 | 中-高 |\r\n-\r\n----\r\n-\r\n-## 🔧 扩展开发\r\n-\r\n-### 添加新的设计模式\r\n-1. 继承基础模式接口\r\n-2. 实现必要的方法\r\n-3. 在工厂中注册\r\n-4. 添加使用示例\r\n-\r\n-### 自定义模式实现\r\n-```lua\r\n-local CustomPattern = BaseClass(IPattern)\r\n-\r\n-function CustomPattern:ctor()\r\n-    -- 初始化代码\r\n-end\r\n-\r\n-function CustomPattern:Execute()\r\n-    -- 模式执行逻辑\r\n-end\r\n-```\r\n-\r\n----\r\n-\r\n-## 📚 总结\r\n-\r\n-这个设计模式库提供了：\r\n-\r\n-✅ **完整的模式覆盖** - 从基础到高级的完整覆盖  \r\n-✅ **游戏开发优化** - 针对游戏开发的专用模式  \r\n-✅ **易用性设计** - 统一的接口和工厂创建  \r\n-✅ **扩展性架构** - 易于添加新的设计模式  \r\n-✅ **实用性强** - 实际项目中的应用场景  \r\n-\r\n-**🎯 核心价值：** 让开发者专注于业务逻辑，而不是架构设计的复杂细节。\r\n-\r\n----\r\n-\r\n-*支持Lua 5.1+ | 完整设计模式 | 游戏开发优化 | 易于扩展 | 🚀 架构设计最佳实践*\r\n"
                },
                {
                    "date": 1767210837886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n │   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n │   ├── State (状态模式) - 状态机就是其最好的理解了\r\n │   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n │   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n-│   └── Visitor (访问者模式) - 策略模式+表驱动模式，通过表驱动模式实现不同元素类型的不同处理逻辑。\r\n+│   └── Visitor (访问者模式) - 策略模式+表驱动模式替代其复杂实现\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)\r\n     ├── EventDriven (事件驱动模式)\r\n     ├── StateMachine (状态机模式)\r\n"
                },
                {
                    "date": 1767210868074,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n │   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n │   ├── State (状态模式) - 状态机就是其最好的理解了\r\n │   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n │   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n-│   └── Visitor (访问者模式) - 策略模式+表驱动模式替代其复杂实现\r\n+│   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)\r\n     ├── EventDriven (事件驱动模式)\r\n     ├── StateMachine (状态机模式)\r\n"
                },
                {
                    "date": 1767210909655,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n │   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n │   ├── State (状态模式) - 状态机就是其最好的理解了\r\n │   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n │   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n-│   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代\r\n+│   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)\r\n     ├── EventDriven (事件驱动模式)\r\n     ├── StateMachine (状态机模式)\r\n"
                },
                {
                    "date": 1767210975389,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,9 +39,9 @@\n │   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n │   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n │   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n-    ├── Component (组件模式)\r\n+    ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n     ├── EventDriven (事件驱动模式)\r\n     ├── StateMachine (状态机模式)\r\n     ├── ServiceLocator (服务定位器模式)\r\n     ├── ObjectPool (对象池模式)\r\n"
                },
                {
                    "date": 1767211027729,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,10 +40,10 @@\n │   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n │   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n-    ├── EventDriven (事件驱动模式)\r\n-    ├── StateMachine (状态机模式)\r\n+    ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n+    ├── StateMachine (状态机模式) - 控制状态切换\r\n     ├── ServiceLocator (服务定位器模式)\r\n     ├── ObjectPool (对象池模式)\r\n     ├── DataDriven (数据驱动模式)\r\n     ├── ReactiveProgramming (响应式编程模式)\r\n"
                },
                {
                    "date": 1767211047047,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n │   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n     ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n-    ├── StateMachine (状态机模式) - 控制状态切换\r\n+    ├── StateMachine (状态机模式) - 控制状态切换，具有流程性，可传递性，可组合性。\r\n     ├── ServiceLocator (服务定位器模式)\r\n     ├── ObjectPool (对象池模式)\r\n     ├── DataDriven (数据驱动模式)\r\n     ├── ReactiveProgramming (响应式编程模式)\r\n"
                },
                {
                    "date": 1767211062614,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n │   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n     ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n-    ├── StateMachine (状态机模式) - 控制状态切换，具有流程性，可传递性，可组合性。\r\n+    ├── StateMachine (状态机模式) - 关注控制状态切换，具有流动性，可传递性，可组合性。\r\n     ├── ServiceLocator (服务定位器模式)\r\n     ├── ObjectPool (对象池模式)\r\n     ├── DataDriven (数据驱动模式)\r\n     ├── ReactiveProgramming (响应式编程模式)\r\n"
                },
                {
                    "date": 1767211129234,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,16 +34,16 @@\n │   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n │   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n │   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n-│   ├── State (状态模式) - 状态机就是其最好的理解了\r\n+│   ├── State (状态模式) - 关注状态变化后, 但是状态机可以兼顾切换时机和状态变化后处理。\r\n │   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n │   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n │   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。\r\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n     ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n-    ├── StateMachine (状态机模式) - 关注控制状态切换，具有流动性，可传递性，可组合性。\r\n+    ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n     ├── ServiceLocator (服务定位器模式)\r\n     ├── ObjectPool (对象池模式)\r\n     ├── DataDriven (数据驱动模式)\r\n     ├── ReactiveProgramming (响应式编程模式)\r\n"
                },
                {
                    "date": 1767211150945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n     ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n     ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n-    ├── ServiceLocator (服务定位器模式)\r\n+    ├── ServiceLocator (服务定位器模式) \r\n     ├── ObjectPool (对象池模式)\r\n     ├── DataDriven (数据驱动模式)\r\n     ├── ReactiveProgramming (响应式编程模式)\r\n     ├── DependencyInjection (依赖注入模式)\r\n"
                },
                {
                    "date": 1767211178479,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,9 +43,9 @@\n     ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n     ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n     ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n     ├── ServiceLocator (服务定位器模式) \r\n-    ├── ObjectPool (对象池模式)\r\n+    ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片\r\n     ├── DataDriven (数据驱动模式)\r\n     ├── ReactiveProgramming (响应式编程模式)\r\n     ├── DependencyInjection (依赖注入模式)\r\n     ├── DirtyFlag (脏标记模式)\r\n"
                },
                {
                    "date": 1767211183997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,9 +43,9 @@\n     ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n     ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n     ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n     ├── ServiceLocator (服务定位器模式) \r\n-    ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片\r\n+    ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片 与 避免GC。\r\n     ├── DataDriven (数据驱动模式)\r\n     ├── ReactiveProgramming (响应式编程模式)\r\n     ├── DependencyInjection (依赖注入模式)\r\n     ├── DirtyFlag (脏标记模式)\r\n"
                },
                {
                    "date": 1767211216977,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,10 +44,10 @@\n     ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n     ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n     ├── ServiceLocator (服务定位器模式) \r\n     ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片 与 避免GC。\r\n-    ├── DataDriven (数据驱动模式)\r\n-    ├── ReactiveProgramming (响应式编程模式)\r\n+    ├── DataDriven (数据驱动模式) - 通过数据驱动业务逻辑，避免硬编码。\r\n+    ├── ReactiveProgramming (响应式编程模式) \r\n     ├── DependencyInjection (依赖注入模式)\r\n     ├── DirtyFlag (脏标记模式)\r\n     ├── DoubleBuffer (双缓冲模式)\r\n     ├── DataLocality (数据局部性模式)\r\n"
                },
                {
                    "date": 1767211241502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,12 +46,12 @@\n     ├── ServiceLocator (服务定位器模式) \r\n     ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片 与 避免GC。\r\n     ├── DataDriven (数据驱动模式) - 通过数据驱动业务逻辑，避免硬编码。\r\n     ├── ReactiveProgramming (响应式编程模式) \r\n-    ├── DependencyInjection (依赖注入模式)\r\n-    ├── DirtyFlag (脏标记模式)\r\n-    ├── DoubleBuffer (双缓冲模式)\r\n-    ├── DataLocality (数据局部性模式)\r\n+    ├── DependencyInjection (依赖注入模式) \r\n+    ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n+    ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n+    ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n     └── Bytecode (字节码模式)\r\n ```\r\n \r\n ---\r\n"
                },
                {
                    "date": 1767211250882,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n     ├── DependencyInjection (依赖注入模式) \r\n     ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n     ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n-    └── Bytecode (字节码模式)\r\n+    └── Bytecode (字节码模式) - 通过字节码实现脚本系统，避免解释执行性能损耗。\r\n ```\r\n \r\n ---\r\n \r\n"
                },
                {
                    "date": 1767211257725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,17 +42,17 @@\n └── Advanced (高级模式) - 游戏开发专用模式\r\n     ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n     ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n     ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n-    ├── ServiceLocator (服务定位器模式) \r\n+    ├── ServiceLocator (服务定位器模式) - 服务定位器模式是一种服务注册和获取的解决方案，通过服务定位器模式，可以实现服务的高效注册和获取，避免服务注册和获取的重复代码。\r\n     ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片 与 避免GC。\r\n     ├── DataDriven (数据驱动模式) - 通过数据驱动业务逻辑，避免硬编码。\r\n     ├── ReactiveProgramming (响应式编程模式) \r\n     ├── DependencyInjection (依赖注入模式) \r\n     ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n     ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n-    └── Bytecode (字节码模式) - 通过字节码实现脚本系统，避免解释执行性能损耗。\r\n+    └── Bytecode (字节码模式) - \r\n ```\r\n \r\n ---\r\n \r\n"
                },
                {
                    "date": 1767211511735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n     ├── DependencyInjection (依赖注入模式) \r\n     ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n     ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n-    └── Bytecode (字节码模式) - \r\n+    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行\r\n ```\r\n \r\n ---\r\n \r\n"
                },
                {
                    "date": 1767211649946,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n     ├── DependencyInjection (依赖注入模式) \r\n     ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n     ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n-    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行\r\n+    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n ```\r\n \r\n ---\r\n \r\n"
                },
                {
                    "date": 1767212013453,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,795 +53,4 @@\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n     └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n ```\r\n \r\n----\r\n-\r\n-## 🏭 创建型模式 (Creational Patterns)\r\n-\r\n-### 🔒 **单例模式 (Singleton)**\r\n-**用途：** 确保一个类只有一个实例，并提供全局访问点\r\n-**作用：** \r\n-- 游戏管理器\r\n-- 配置管理器\r\n-- 资源管理器\r\n-- 日志系统\r\n-\r\n-**适用场景：**\r\n-- 需要全局唯一实例\r\n-- 资源管理\r\n-- 配置管理\r\n-\r\n-```lua\r\n-local singleton = SingletonPattern.New()\r\n-local instance1 = singleton:GetInstance()\r\n-local instance2 = singleton:GetInstance()\r\n-print(instance1 == instance2)  -- true，同一个实例\r\n-```\r\n-\r\n-### 🏭 **工厂模式 (Factory)**\r\n-**用途：** 根据条件创建不同类型的对象\r\n-**作用：**\r\n-- 游戏对象创建\r\n-- 武器系统\r\n-- 敌人生成\r\n-- 道具创建\r\n-\r\n-**适用场景：**\r\n-- 需要根据条件创建对象\r\n-- 对象创建逻辑复杂\r\n-- 支持扩展新类型\r\n-\r\n-```lua\r\n-local factory = FactoryPattern.New()\r\n-local weapon = factory:CreateWeapon(\"sword\")\r\n-local enemy = factory:CreateEnemy(\"goblin\")\r\n-```\r\n-\r\n-### 🏭🏭 **抽象工厂模式 (AbstractFactory)**\r\n-**用途：** 创建一系列相关对象，确保它们相互兼容\r\n-**作用：**\r\n-- 游戏主题系统\r\n-- UI风格系统\r\n-- 关卡风格\r\n-- 种族系统\r\n-\r\n-**适用场景：**\r\n-- 需要创建相关对象族\r\n-- 确保对象兼容性\r\n-- 支持多种风格\r\n-\r\n-```lua\r\n-local factory = AbstractFactoryPattern.New()\r\n-local medievalFactory = factory:CreateFactory(\"medieval\")\r\n-local sword = medievalFactory:CreateWeapon()\r\n-local armor = medievalFactory:CreateArmor()\r\n-```\r\n-\r\n-### 🏗️ **建造者模式 (Builder)**\r\n-**用途：** 分步骤构建复杂对象\r\n-**作用：**\r\n-- 角色创建\r\n-- 关卡构建\r\n-- 配置构建\r\n-- 复杂对象组装\r\n-\r\n-**适用场景：**\r\n-- 对象构建过程复杂\r\n-- 需要分步骤构建\r\n-- 支持不同构建方式\r\n-\r\n-```lua\r\n-local builder = BuilderPattern.New()\r\n-local character = builder:SetName(\"英雄\")\r\n-    :SetClass(\"战士\")\r\n-    :SetLevel(10)\r\n-    :SetEquipment(\"铁剑\")\r\n-    :Build()\r\n-```\r\n-\r\n-### 🧬 **原型模式 (Prototype)**\r\n-**用途：** 通过克隆现有对象来创建新对象\r\n-**作用：**\r\n-- 对象复制\r\n-- 模板系统\r\n-- 快速创建\r\n-- 减少初始化开销\r\n-\r\n-**适用场景：**\r\n-- 对象创建开销大\r\n-- 需要对象副本\r\n-- 模板系统\r\n-\r\n-```lua\r\n-local prototype = PrototypePattern.New()\r\n-local original = prototype:Create(\"template\")\r\n-local clone = original:Clone()\r\n-```\r\n-\r\n----\r\n-\r\n-## 🏗️ 结构型模式 (Structural Patterns)\r\n-\r\n-### 🔌 **适配器模式 (Adapter)**\r\n-**用途：** 让不兼容的接口能够协同工作\r\n-**作用：**\r\n-- 第三方库集成\r\n-- 旧系统适配\r\n-- 接口统一\r\n-- 兼容性处理\r\n-\r\n-**适用场景：**\r\n-- 集成第三方库\r\n-- 系统升级兼容\r\n-- 接口不匹配\r\n-\r\n-```lua\r\n-local adapter = AdapterPattern.New()\r\n-local newInterface = adapter:Adapt(oldSystem)\r\n-newInterface:NewMethod()\r\n-```\r\n-\r\n-### 🌉 **桥接模式 (Bridge)**\r\n-**用途：** 将抽象与实现分离，使它们可以独立变化\r\n-**作用：**\r\n-- 平台抽象\r\n-- 渲染器抽象\r\n-- 数据库抽象\r\n-- 网络抽象\r\n-\r\n-**适用场景：**\r\n-- 需要支持多平台\r\n-- 抽象与实现分离\r\n-- 避免继承爆炸\r\n-\r\n-```lua\r\n-local bridge = BridgePattern.New()\r\n-local renderer = bridge:CreateRenderer(\"OpenGL\")\r\n-local shape = bridge:CreateShape(\"Circle\", renderer)\r\n-```\r\n-\r\n-### 🧩 **组合模式 (Composite)**\r\n-**用途：** 将对象组合成树形结构，统一处理单个对象和组合对象\r\n-**作用：**\r\n-- 场景图系统\r\n-- UI组件树\r\n-- 文件系统\r\n-- 游戏对象层次\r\n-\r\n-**适用场景：**\r\n-- 树形结构\r\n-- 部分-整体关系\r\n-- 统一处理接口\r\n-\r\n-```lua\r\n-local composite = CompositePattern.New()\r\n-local root = composite:CreateComponent(\"root\")\r\n-local child1 = composite:CreateComponent(\"child1\")\r\n-root:Add(child1)\r\n-root:Operation()  -- 递归调用所有子组件\r\n-```\r\n-\r\n-### 🎨 **装饰器模式 (Decorator)**\r\n-**用途：** 动态地给对象添加新功能\r\n-**作用：**\r\n-- 装备系统\r\n-- 技能增强\r\n-- 状态效果\r\n-- 功能扩展\r\n-\r\n-**适用场景：**\r\n-- 需要动态添加功能\r\n-- 避免继承爆炸\r\n-- 功能组合\r\n-\r\n-```lua\r\n-local decorator = DecoratorPattern.New()\r\n-local baseWeapon = decorator:CreateWeapon(\"剑\")\r\n-local fireWeapon = decorator:AddFireEffect(baseWeapon)\r\n-local iceWeapon = decorator:AddIceEffect(fireWeapon)\r\n-```\r\n-\r\n-### 🏛️ **外观模式 (Facade)**\r\n-**用途：** 为复杂子系统提供简单接口\r\n-**作用：**\r\n-- 系统封装\r\n-- 简化接口\r\n-- 降低耦合\r\n-- 统一入口\r\n-\r\n-**适用场景：**\r\n-- 复杂系统封装\r\n-- 简化客户端使用\r\n-- 降低系统耦合\r\n-\r\n-```lua\r\n-local facade = FacadePattern.New()\r\n--- 复杂的子系统操作被封装成简单接口\r\n-facade:StartGame()\r\n-facade:SaveGame()\r\n-facade:LoadGame()\r\n-```\r\n-\r\n-### 🦋 **享元模式 (Flyweight)**\r\n-**用途：** 通过共享减少内存使用\r\n-**作用：**\r\n-- 纹理共享\r\n-- 模型共享\r\n-- 配置共享\r\n-- 资源优化\r\n-\r\n-**适用场景：**\r\n-- 大量相似对象\r\n-- 内存优化\r\n-- 资源共享\r\n-\r\n-```lua\r\n-local flyweight = FlyweightPattern.New()\r\n-local texture1 = flyweight:GetTexture(\"grass\")\r\n-local texture2 = flyweight:GetTexture(\"grass\")  -- 共享同一个纹理\r\n-```\r\n-\r\n-### 🎭 **代理模式 (Proxy)**\r\n-**用途：** 控制对其他对象的访问\r\n-**作用：**\r\n-- 权限控制\r\n-- 延迟加载\r\n-- 缓存代理\r\n-- 安全控制\r\n-\r\n-**适用场景：**\r\n-- 访问控制\r\n-- 延迟加载\r\n-- 缓存优化\r\n-\r\n-```lua\r\n-local proxy = ProxyPattern.New()\r\n-local realObject = proxy:GetObject()  -- 可能延迟加载\r\n-proxy:CheckPermission(\"read\")  -- 权限检查\r\n-```\r\n-\r\n----\r\n-\r\n-## 🎭 行为型模式 (Behavioral Patterns)\r\n-\r\n-### 🔗 **责任链模式 (ChainOfResponsibility)**\r\n-**用途：** 将请求沿着处理者链进行传递，直到被处理\r\n-**作用：**\r\n-- 事件处理\r\n-- 权限验证\r\n-- 异常处理\r\n-- 请求过滤\r\n-\r\n-**适用场景：**\r\n-- 多个对象处理请求\r\n-- 请求处理顺序不确定\r\n-- 动态处理链\r\n-\r\n-```lua\r\n-local chain = ChainOfResponsibilityPattern.New()\r\n-chain:AddHandler(handler1)\r\n-chain:AddHandler(handler2)\r\n-chain:HandleRequest(request)\r\n-```\r\n-\r\n-### 📝 **命令模式 (Command)**\r\n-**用途：** 将请求封装成对象，支持请求排队、记录日志、撤销等操作\r\n-**作用：**\r\n-- 撤销/重做系统\r\n-- 宏命令\r\n-- 队列处理\r\n-- 日志记录\r\n-\r\n-**适用场景：**\r\n-- 需要撤销功能\r\n-- 命令排队\r\n-- 宏操作\r\n-\r\n-```lua\r\n-local command = CommandPattern.New()\r\n-local moveCommand = command:CreateMoveCommand(unit, target)\r\n-command:Execute(moveCommand)\r\n-command:Undo()  -- 撤销操作\r\n-```\r\n-\r\n-### 🔤 **解释器模式 (Interpreter)**\r\n-**用途：** 为语言创建解释器\r\n-**作用：**\r\n-- 脚本系统\r\n-- 配置解析\r\n-- 规则引擎\r\n-- 表达式求值\r\n-\r\n-**适用场景：**\r\n-- 简单语言解析\r\n-- 规则引擎\r\n-- 表达式计算\r\n-\r\n-```lua\r\n-local interpreter = InterpreterPattern.New()\r\n-local result = interpreter:Interpret(\"1 + 2 * 3\")\r\n-```\r\n-\r\n-### 🔄 **迭代器模式 (Iterator)**\r\n-**用途：** 提供一种方法顺序访问集合中的元素，而不暴露其内部表示\r\n-**作用：**\r\n-- 集合遍历\r\n-- 自定义遍历\r\n-- 遍历算法\r\n-- 集合封装\r\n-\r\n-**适用场景：**\r\n-- 集合遍历\r\n-- 自定义遍历逻辑\r\n-- 集合封装\r\n-\r\n-```lua\r\n-local iterator = IteratorPattern.New()\r\n-local collection = iterator:CreateCollection()\r\n-for item in collection:Iterator() do\r\n-    print(item)\r\n-end\r\n-```\r\n-\r\n-### 🤝 **中介者模式 (Mediator)**\r\n-**用途：** 封装对象间的交互，降低它们之间的耦合度\r\n-**作用：**\r\n-- 聊天系统\r\n-- 游戏系统协调\r\n-- UI组件协调\r\n-- 模块间通信\r\n-\r\n-**适用场景：**\r\n-- 对象间复杂交互\r\n-- 降低耦合\r\n-- 集中控制\r\n-\r\n-```lua\r\n-local mediator = MediatorPattern.New()\r\n-mediator:RegisterComponent(component1)\r\n-mediator:RegisterComponent(component2)\r\n-component1:SendMessage(\"hello\", mediator)\r\n-```\r\n-\r\n-### 💾 **备忘录模式 (Memento)**\r\n-**用途：** 在不破坏封装的前提下，捕获并外部化对象的内部状态\r\n-**作用：**\r\n-- 游戏存档\r\n-- 撤销系统\r\n-- 状态恢复\r\n-- 快照系统\r\n-\r\n-**适用场景：**\r\n-- 状态保存\r\n-- 撤销功能\r\n-- 快照系统\r\n-\r\n-```lua\r\n-local memento = MementoPattern.New()\r\n-local originator = memento:CreateOriginator()\r\n-local savedState = originator:SaveState()\r\n-originator:RestoreState(savedState)\r\n-```\r\n-\r\n-### 👀 **观察者模式 (Observer)**\r\n-**用途：** 定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会得到通知\r\n-**作用：**\r\n-- 事件系统\r\n-- 数据绑定\r\n-- 消息通知\r\n-- 状态同步\r\n-\r\n-**适用场景：**\r\n-- 事件通知\r\n-- 数据同步\r\n-- 松耦合通信\r\n-\r\n-```lua\r\n-local observer = ObserverPattern.New()\r\n-observer:Subscribe(subscriber1)\r\n-observer:Subscribe(subscriber2)\r\n-observer:Notify(\"event occurred\")\r\n-```\r\n-\r\n-### 🔄 **状态模式 (State)**\r\n-**用途：** 让对象在其内部状态改变时改变其行为\r\n-**作用：**\r\n-- 游戏状态管理\r\n-- 角色状态\r\n-- 系统状态\r\n-- 工作流状态\r\n-\r\n-**适用场景：**\r\n-- 对象状态变化\r\n-- 状态相关行为\r\n-- 状态机实现\r\n-\r\n-```lua\r\n-local state = StatePattern.New()\r\n-local context = state:CreateContext()\r\n-context:SetState(state:CreateState(\"idle\"))\r\n-context:Request()  -- 根据当前状态执行不同行为\r\n-```\r\n-\r\n-### 🎯 **策略模式 (Strategy)**\r\n-**用途：** 定义一系列算法，使它们可以互相替换，算法的变化不会影响使用算法的客户\r\n-**作用：**\r\n-- AI行为选择\r\n-- 算法选择\r\n-- 支付方式\r\n-- 排序算法\r\n-\r\n-**适用场景：**\r\n-- 算法选择\r\n-- 行为选择\r\n-- 避免条件判断\r\n-\r\n-```lua\r\n-local strategy = StrategyPattern.New()\r\n-local context = strategy:CreateContext()\r\n-context:SetStrategy(strategy:CreateStrategy(\"aggressive\"))\r\n-context:ExecuteStrategy()\r\n-```\r\n-\r\n-### 📋 **模板方法模式 (TemplateMethod)**\r\n-**用途：** 在父类中定义算法骨架，让子类重写特定步骤\r\n-**作用：**\r\n-- 算法框架\r\n-- 流程控制\r\n-- 代码复用\r\n-- 扩展点定义\r\n-\r\n-**适用场景：**\r\n-- 算法框架\r\n-- 流程模板\r\n-- 代码复用\r\n-\r\n-```lua\r\n-local template = TemplateMethodPattern.New()\r\n-local concreteClass = template:CreateConcreteClass()\r\n-concreteClass:TemplateMethod()  -- 调用模板方法\r\n-```\r\n-\r\n-### 👥 **访问者模式 (Visitor)**\r\n-**用途：** 在不改变数据结构的前提下，定义作用于其元素的新操作\r\n-**作用：**\r\n-- 数据操作\r\n-- 统计功能\r\n-- 导出功能\r\n-- 功能扩展\r\n-\r\n-**适用场景：**\r\n-- 数据结构稳定\r\n-- 操作经常变化\r\n-- 功能扩展\r\n-\r\n-```lua\r\n-local visitor = VisitorPattern.New()\r\n-local element = visitor:CreateElement()\r\n-local concreteVisitor = visitor:CreateVisitor()\r\n-element:Accept(concreteVisitor)\r\n-```\r\n-\r\n----\r\n-\r\n-## 🚀 高级模式 (Advanced Patterns)\r\n-\r\n-### 🧩 **组件模式 (Component)**\r\n-**用途：** 将游戏对象分解为可重用的组件\r\n-**作用：**\r\n-- 游戏对象系统\r\n-- 模块化设计\r\n-- 功能组合\r\n-- 系统解耦\r\n-\r\n-**适用场景：**\r\n-- 复杂游戏对象\r\n-- 功能模块化\r\n-- 系统解耦\r\n-\r\n-```lua\r\n-local component = ComponentPattern.New()\r\n-local gameObject = component:CreateGameObject()\r\n-gameObject:AddComponent(\"Transform\")\r\n-gameObject:AddComponent(\"Renderer\")\r\n-gameObject:AddComponent(\"Collider\")\r\n-```\r\n-\r\n-### 📡 **事件驱动模式 (EventDriven)**\r\n-**用途：** 通过事件进行松耦合的通信\r\n-**作用：**\r\n-- 系统解耦\r\n-- 异步通信\r\n-- 消息传递\r\n-- 响应式系统\r\n-\r\n-**适用场景：**\r\n-- 系统解耦\r\n-- 异步处理\r\n-- 消息系统\r\n-\r\n-```lua\r\n-local eventSystem = EventDrivenPattern.New()\r\n-eventSystem:Subscribe(\"playerMove\", handler)\r\n-eventSystem:Publish(\"playerMove\", {x = 100, y = 200})\r\n-```\r\n-\r\n-### 🎮 **状态机模式 (StateMachine)**\r\n-**用途：** 管理复杂的状态转换逻辑\r\n-**作用：**\r\n-- 角色状态管理\r\n-- 游戏流程控制\r\n-- AI状态管理\r\n-- 系统状态控制\r\n-\r\n-**适用场景：**\r\n-- 复杂状态管理\r\n-- 状态转换逻辑\r\n-- 流程控制\r\n-\r\n-```lua\r\n-local stateMachine = StateMachinePattern.New()\r\n-stateMachine:AddState(\"idle\")\r\n-stateMachine:AddState(\"walking\")\r\n-stateMachine:AddTransition(\"idle\", \"walking\", \"startWalking\")\r\n-stateMachine:ChangeState(\"idle\")\r\n-```\r\n-\r\n-### 🏢 **服务定位器模式 (ServiceLocator)**\r\n-**用途：** 提供全局的服务访问点\r\n-**作用：**\r\n-- 服务管理\r\n-- 依赖管理\r\n-- 全局访问\r\n-- 服务注册\r\n-\r\n-**适用场景：**\r\n-- 全局服务访问\r\n-- 服务管理\r\n-- 依赖注入\r\n-\r\n-```lua\r\n-local serviceLocator = ServiceLocatorPattern.New()\r\n-serviceLocator:Register(\"audioService\", audioService)\r\n-local audio = serviceLocator:GetService(\"audioService\")\r\n-```\r\n-\r\n-### 🏊 **对象池模式 (ObjectPool)**\r\n-**用途：** 重用对象以减少创建和销毁的开销\r\n-**作用：**\r\n-- 性能优化\r\n-- 内存管理\r\n-- 对象复用\r\n-- 垃圾回收优化\r\n-\r\n-**适用场景：**\r\n-- 频繁创建销毁\r\n-- 性能优化\r\n-- 内存管理\r\n-\r\n-```lua\r\n-local objectPool = ObjectPoolPattern.New()\r\n-local bullet = objectPool:GetObject(\"bullet\")\r\n--- 使用子弹\r\n-objectPool:ReturnObject(bullet)\r\n-```\r\n-\r\n-### 📊 **数据驱动模式 (DataDriven)**\r\n-**用途：** 通过数据配置驱动系统行为\r\n-**作用：**\r\n-- 配置管理\r\n-- 数据驱动\r\n-- 系统配置\r\n-- 行为配置\r\n-\r\n-**适用场景：**\r\n-- 配置驱动\r\n-- 数据驱动\r\n-- 系统配置\r\n-\r\n-```lua\r\n-local dataDriven = DataDrivenPattern.New()\r\n-dataDriven:LoadConfig(\"weapon_config.json\")\r\n-local weapon = dataDriven:CreateWeapon(\"sword\")\r\n-```\r\n-\r\n-### ⚡ **响应式编程模式 (ReactiveProgramming)**\r\n-**用途：** 通过数据流和变化传播来简化编程\r\n-**作用：**\r\n-- 数据流处理\r\n-- 变化传播\r\n-- 异步处理\r\n-- 事件流\r\n-\r\n-**适用场景：**\r\n-- 数据流处理\r\n-- 变化响应\r\n-- 异步编程\r\n-\r\n-```lua\r\n-local reactive = ReactiveProgrammingPattern.New()\r\n-local stream = reactive:CreateStream()\r\n-stream:Subscribe(function(value) print(\"Value changed:\", value) end)\r\n-stream:Next(100)\r\n-```\r\n-\r\n-### 💉 **依赖注入模式 (DependencyInjection)**\r\n-**用途：** 通过外部注入依赖，降低组件间的耦合\r\n-**作用：**\r\n-- 依赖管理\r\n-- 解耦设计\r\n-- 测试友好\r\n-- 配置灵活\r\n-\r\n-**适用场景：**\r\n-- 依赖管理\r\n-- 系统解耦\r\n-- 测试友好\r\n-\r\n-```lua\r\n-local di = DependencyInjectionPattern.New()\r\n-di:Register(\"database\", databaseService)\r\n-di:Register(\"logger\", loggerService)\r\n-local service = di:CreateService(MyService)\r\n-```\r\n-\r\n-### 🚩 **脏标记模式 (DirtyFlag)**\r\n-**用途：** 通过标记避免不必要的计算\r\n-**作用：**\r\n-- 性能优化\r\n-- 缓存管理\r\n-- 计算优化\r\n-- 更新控制\r\n-\r\n-**适用场景：**\r\n-- 性能优化\r\n-- 缓存管理\r\n-- 计算优化\r\n-\r\n-```lua\r\n-local dirtyFlag = DirtyFlagPattern.New()\r\n-local object = dirtyFlag:CreateObject()\r\n-object:MarkDirty()\r\n-if object:IsDirty() then\r\n-    object:Update()\r\n-    object:ClearDirty()\r\n-end\r\n-```\r\n-\r\n-### 🔄 **双缓冲模式 (DoubleBuffer)**\r\n-**用途：** 使用两个缓冲区避免渲染冲突\r\n-**作用：**\r\n-- 渲染优化\r\n-- 动画平滑\r\n-- 避免闪烁\r\n-- 性能提升\r\n-\r\n-**适用场景：**\r\n-- 渲染系统\r\n-- 动画系统\r\n-- 避免闪烁\r\n-\r\n-```lua\r\n-local doubleBuffer = DoubleBufferPattern.New()\r\n-local buffer = doubleBuffer:CreateBuffer()\r\n-buffer:SwapBuffers()\r\n-buffer:DrawToBackBuffer()\r\n-```\r\n-\r\n-### 📍 **数据局部性模式 (DataLocality)**\r\n-**用途：** 通过组织数据布局提高缓存效率\r\n-**作用：**\r\n-- 性能优化\r\n-- 缓存优化\r\n-- 内存访问优化\r\n-- 系统性能\r\n-\r\n-**适用场景：**\r\n-- 性能优化\r\n-- 缓存优化\r\n-- 内存访问优化\r\n-\r\n-```lua\r\n-local dataLocality = DataLocalityPattern.New()\r\n-local optimizedArray = dataLocality:CreateOptimizedArray()\r\n--- 数据按访问模式组织，提高缓存命中率\r\n-```\r\n-\r\n-### 💻 **字节码模式 (Bytecode)**\r\n-**用途：** 通过字节码实现脚本系统\r\n-**作用：**\r\n-- 脚本系统\r\n-- 虚拟机\r\n-- 性能优化\r\n-- 跨平台\r\n-\r\n-**适用场景：**\r\n-- 脚本系统\r\n-- 性能优化\r\n-- 跨平台\r\n-\r\n-```lua\r\n-local bytecode = BytecodePattern.New()\r\n-local script = bytecode:Compile(\"print('Hello World')\")\r\n-bytecode:Execute(script)\r\n-```\r\n-\r\n----\r\n-\r\n-## 🚀 使用指南\r\n-\r\n-### 快速开始\r\n-```lua\r\n--- 1. 选择合适的设计模式\r\n-local pattern = PatternFactory.Create(PatternTypes.SINGLETON)\r\n-\r\n--- 2. 创建模式实例\r\n-local instance = pattern:Create()\r\n-\r\n--- 3. 使用模式功能\r\n-instance:DoSomething()\r\n-```\r\n-\r\n-### 模式选择建议\r\n-- **对象创建**: 使用创建型模式\r\n-- **对象组合**: 使用结构型模式\r\n-- **对象交互**: 使用行为型模式\r\n-- **游戏开发**: 使用高级模式\r\n-\r\n-### 最佳实践\r\n-- **单一职责**: 每个模式只负责一个方面\r\n-- **开闭原则**: 对扩展开放，对修改关闭\r\n-- **依赖倒置**: 依赖抽象而非具体实现\r\n-- **接口隔离**: 客户端不应该依赖不需要的接口\r\n-\r\n----\r\n-\r\n-## 📈 模式对比\r\n-\r\n-| 模式类型 | 主要用途 | 复杂度 | 适用场景 | 性能影响 |\r\n-|----------|----------|--------|----------|----------|\r\n-| **创建型** | 对象创建 | 低-中 | 对象创建逻辑 | 低 |\r\n-| **结构型** | 对象组合 | 中 | 对象关系 | 低-中 |\r\n-| **行为型** | 对象交互 | 中-高 | 对象通信 | 中 |\r\n-| **高级** | 游戏开发 | 高 | 复杂系统 | 中-高 |\r\n-\r\n----\r\n-\r\n-## 🔧 扩展开发\r\n-\r\n-### 添加新的设计模式\r\n-1. 继承基础模式接口\r\n-2. 实现必要的方法\r\n-3. 在工厂中注册\r\n-4. 添加使用示例\r\n-\r\n-### 自定义模式实现\r\n-```lua\r\n-local CustomPattern = BaseClass(IPattern)\r\n-\r\n-function CustomPattern:ctor()\r\n-    -- 初始化代码\r\n-end\r\n-\r\n-function CustomPattern:Execute()\r\n-    -- 模式执行逻辑\r\n-end\r\n-```\r\n-\r\n----\r\n-\r\n-## 📚 总结\r\n-\r\n-这个设计模式库提供了：\r\n-\r\n-✅ **完整的模式覆盖** - 从基础到高级的完整覆盖  \r\n-✅ **游戏开发优化** - 针对游戏开发的专用模式  \r\n-✅ **易用性设计** - 统一的接口和工厂创建  \r\n-✅ **扩展性架构** - 易于添加新的设计模式  \r\n-✅ **实用性强** - 实际项目中的应用场景  \r\n-\r\n-**🎯 核心价值：** 让开发者专注于业务逻辑，而不是架构设计的复杂细节。\r\n-\r\n----\r\n-\r\n-*支持Lua 5.1+ | 完整设计模式 | 游戏开发优化 | 易于扩展 | 🚀 架构设计最佳实践*\r\n"
                },
                {
                    "date": 1767212382693,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n │   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n │   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n ├── Structural (结构型模式) - 对象组合的艺术\r\n │   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n-│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果\r\n+│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果，里氏替换可以拓展表达\r\n │   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n │   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n │   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n"
                },
                {
                    "date": 1767212433571,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n │   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n │   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n ├── Structural (结构型模式) - 对象组合的艺术\r\n │   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n-│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果，里氏替换可以拓展表达\r\n+│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入）实现抽象与实现分离，通过里氏替换支持抽象扩展，让同一个抽象类可以使用不同的实现，从而产生不同的表达结果\r\n │   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n │   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n │   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n"
                },
                {
                    "date": 1767212454400,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n │   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n │   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n ├── Structural (结构型模式) - 对象组合的艺术\r\n │   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n-│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入）实现抽象与实现分离，通过里氏替换支持抽象扩展，让同一个抽象类可以使用不同的实现，从而产生不同的表达结果\r\n+│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果，里氏替换可以拓展表达方式\r\n │   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n │   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n │   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n"
                },
                {
                    "date": 1767212484558,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,56 @@\n+# 🎯 Lua设计模式库 - 完整指南\r\n+\r\n+## 📋 概述\r\n+\r\n+这是一个功能完整的Lua设计模式库，涵盖了从基础到高级的各种设计模式实现。每个模式都经过精心设计，确保易用性、可扩展性和高性能。\r\n+\r\n+**🎯 设计理念：** 将复杂的设计模式封装成简单易用的工具，让开发者专注于业务逻辑，而不是架构细节。\r\n+\r\n+---\r\n+\r\n+## 🏗️ 架构分类\r\n+\r\n+### 核心模式分类\r\n+```\r\n+Pattern Library (设计模式库)\r\n+├── Creational (创建型模式) - 对象创建的艺术\r\n+│   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n+│   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)\r\n+│   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容\r\n+│   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n+│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n+├── Structural (结构型模式) - 对象组合的艺术\r\n+│   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n+│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入）实现抽象与实现分离，通过里氏替换支持抽象扩展，让同一个抽象类可以使用不同的实现，从而产生不同的表达结果\r\n+│   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n+│   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n+│   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n+│   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n+│   └── Proxy (代理模式) - 可用钩子方法+策略模式替代，避免代理模式滥用\r\n+├── Behavioral (行为型模式) - 对象交互的艺术\r\n+│   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n+│   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n+│   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n+│   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n+│   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n+│   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n+│   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n+│   ├── State (状态模式) - 关注状态变化后, 但是状态机可以兼顾切换时机和状态变化后处理。\r\n+│   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n+│   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n+│   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。\r\n+└── Advanced (高级模式) - 游戏开发专用模式\r\n+    ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n+    ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n+    ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n+    ├── ServiceLocator (服务定位器模式) - 服务定位器模式是一种服务注册和获取的解决方案，通过服务定位器模式，可以实现服务的高效注册和获取，避免服务注册和获取的重复代码。\r\n+    ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片 与 避免GC。\r\n+    ├── DataDriven (数据驱动模式) - 通过数据驱动业务逻辑，避免硬编码。\r\n+    ├── ReactiveProgramming (响应式编程模式) \r\n+    ├── DependencyInjection (依赖注入模式) \r\n+    ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n+    ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n+    ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n+    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n+```\r\n+\r\n"
                },
                {
                    "date": 1767212498300,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n │   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n │   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n ├── Structural (结构型模式) - 对象组合的艺术\r\n │   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n-│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入）实现抽象与实现分离，通过里氏替换支持抽象扩展，让同一个抽象类可以使用不同的实现，从而产生不同的表达结果\r\n+│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果，里氏替换可以拓展表达方式\r\n │   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n │   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n │   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n"
                },
                {
                    "date": 1767212674477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,9 @@\n │   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n │   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n ├── Structural (结构型模式) - 对象组合的艺术\r\n │   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n-│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果，里氏替换可以拓展表达方式\r\n+│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果，里氏替换可以抽象和实现拓展表达方式\r\n │   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n │   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n │   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n │   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n@@ -53,60 +53,4 @@\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n     └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n ```\r\n \r\n-# 🎯 Lua设计模式库 - 完整指南\r\n-\r\n-## 📋 概述\r\n-\r\n-这是一个功能完整的Lua设计模式库，涵盖了从基础到高级的各种设计模式实现。每个模式都经过精心设计，确保易用性、可扩展性和高性能。\r\n-\r\n-**🎯 设计理念：** 将复杂的设计模式封装成简单易用的工具，让开发者专注于业务逻辑，而不是架构细节。\r\n-\r\n----\r\n-\r\n-## 🏗️ 架构分类\r\n-\r\n-### 核心模式分类\r\n-```\r\n-Pattern Library (设计模式库)\r\n-├── Creational (创建型模式) - 对象创建的艺术\r\n-│   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n-│   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)\r\n-│   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容\r\n-│   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n-│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n-├── Structural (结构型模式) - 对象组合的艺术\r\n-│   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n-│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果，里氏替换可以拓展表达方式\r\n-│   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n-│   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n-│   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n-│   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n-│   └── Proxy (代理模式) - 可用钩子方法+策略模式替代，避免代理模式滥用\r\n-├── Behavioral (行为型模式) - 对象交互的艺术\r\n-│   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n-│   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n-│   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n-│   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n-│   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n-│   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n-│   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n-│   ├── State (状态模式) - 关注状态变化后, 但是状态机可以兼顾切换时机和状态变化后处理。\r\n-│   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n-│   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n-│   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。\r\n-└── Advanced (高级模式) - 游戏开发专用模式\r\n-    ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n-    ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n-    ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n-    ├── ServiceLocator (服务定位器模式) - 服务定位器模式是一种服务注册和获取的解决方案，通过服务定位器模式，可以实现服务的高效注册和获取，避免服务注册和获取的重复代码。\r\n-    ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片 与 避免GC。\r\n-    ├── DataDriven (数据驱动模式) - 通过数据驱动业务逻辑，避免硬编码。\r\n-    ├── ReactiveProgramming (响应式编程模式) \r\n-    ├── DependencyInjection (依赖注入模式) \r\n-    ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n-    ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n-    ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n-    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n-```\r\n-\r\n"
                },
                {
                    "date": 1767212681740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,56 @@\n+# 🎯 Lua设计模式库 - 完整指南\r\n+\r\n+## 📋 概述\r\n+\r\n+这是一个功能完整的Lua设计模式库，涵盖了从基础到高级的各种设计模式实现。每个模式都经过精心设计，确保易用性、可扩展性和高性能。\r\n+\r\n+**🎯 设计理念：** 将复杂的设计模式封装成简单易用的工具，让开发者专注于业务逻辑，而不是架构细节。\r\n+\r\n+---\r\n+\r\n+## 🏗️ 架构分类\r\n+\r\n+### 核心模式分类\r\n+```\r\n+Pattern Library (设计模式库)\r\n+├── Creational (创建型模式) - 对象创建的艺术\r\n+│   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n+│   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)\r\n+│   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容\r\n+│   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n+│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n+├── Structural (结构型模式) - 对象组合的艺术\r\n+│   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n+│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果，里氏替换可以拓展抽象和实现表达方式\r\n+│   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n+│   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n+│   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n+│   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n+│   └── Proxy (代理模式) - 可用钩子方法+策略模式替代，避免代理模式滥用\r\n+├── Behavioral (行为型模式) - 对象交互的艺术\r\n+│   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n+│   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n+│   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n+│   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n+│   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n+│   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n+│   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n+│   ├── State (状态模式) - 关注状态变化后, 但是状态机可以兼顾切换时机和状态变化后处理。\r\n+│   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n+│   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n+│   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。\r\n+└── Advanced (高级模式) - 游戏开发专用模式\r\n+    ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n+    ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n+    ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n+    ├── ServiceLocator (服务定位器模式) - 服务定位器模式是一种服务注册和获取的解决方案，通过服务定位器模式，可以实现服务的高效注册和获取，避免服务注册和获取的重复代码。\r\n+    ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片 与 避免GC。\r\n+    ├── DataDriven (数据驱动模式) - 通过数据驱动业务逻辑，避免硬编码。\r\n+    ├── ReactiveProgramming (响应式编程模式) \r\n+    ├── DependencyInjection (依赖注入模式) \r\n+    ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n+    ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n+    ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n+    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n+```\r\n+\r\n"
                },
                {
                    "date": 1767212836783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n ├── Behavioral (行为型模式) - 对象交互的艺术\r\n │   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n │   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n │   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n-│   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n+│   ├── Iterator (迭代器模式) - 提供一种方法顺序访问聚合对象中的元素，而不暴露对象的内部表示\r\n │   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n │   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n │   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n │   ├── State (状态模式) - 关注状态变化后, 但是状态机可以兼顾切换时机和状态变化后处理。\r\n@@ -53,60 +53,4 @@\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n     └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n ```\r\n \r\n-# 🎯 Lua设计模式库 - 完整指南\r\n-\r\n-## 📋 概述\r\n-\r\n-这是一个功能完整的Lua设计模式库，涵盖了从基础到高级的各种设计模式实现。每个模式都经过精心设计，确保易用性、可扩展性和高性能。\r\n-\r\n-**🎯 设计理念：** 将复杂的设计模式封装成简单易用的工具，让开发者专注于业务逻辑，而不是架构细节。\r\n-\r\n----\r\n-\r\n-## 🏗️ 架构分类\r\n-\r\n-### 核心模式分类\r\n-```\r\n-Pattern Library (设计模式库)\r\n-├── Creational (创建型模式) - 对象创建的艺术\r\n-│   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n-│   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)\r\n-│   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容\r\n-│   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n-│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n-├── Structural (结构型模式) - 对象组合的艺术\r\n-│   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n-│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果，里氏替换可以抽象和实现拓展表达方式\r\n-│   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n-│   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n-│   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n-│   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n-│   └── Proxy (代理模式) - 可用钩子方法+策略模式替代，避免代理模式滥用\r\n-├── Behavioral (行为型模式) - 对象交互的艺术\r\n-│   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n-│   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n-│   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n-│   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n-│   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n-│   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n-│   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n-│   ├── State (状态模式) - 关注状态变化后, 但是状态机可以兼顾切换时机和状态变化后处理。\r\n-│   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n-│   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n-│   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。\r\n-└── Advanced (高级模式) - 游戏开发专用模式\r\n-    ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n-    ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n-    ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n-    ├── ServiceLocator (服务定位器模式) - 服务定位器模式是一种服务注册和获取的解决方案，通过服务定位器模式，可以实现服务的高效注册和获取，避免服务注册和获取的重复代码。\r\n-    ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片 与 避免GC。\r\n-    ├── DataDriven (数据驱动模式) - 通过数据驱动业务逻辑，避免硬编码。\r\n-    ├── ReactiveProgramming (响应式编程模式) \r\n-    ├── DependencyInjection (依赖注入模式) \r\n-    ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n-    ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n-    ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n-    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n-```\r\n-\r\n"
                },
                {
                    "date": 1767212851268,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,9 @@\n │   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n │   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)\r\n │   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容\r\n │   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n-│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n+│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销，避免重复赋值\r\n ├── Structural (结构型模式) - 对象组合的艺术\r\n │   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n │   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果，里氏替换可以拓展抽象和实现表达方式\r\n │   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n"
                },
                {
                    "date": 1767212880307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,10 +45,10 @@\n     ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n     ├── ServiceLocator (服务定位器模式) - 服务定位器模式是一种服务注册和获取的解决方案，通过服务定位器模式，可以实现服务的高效注册和获取，避免服务注册和获取的重复代码。\r\n     ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片 与 避免GC。\r\n     ├── DataDriven (数据驱动模式) - 通过数据驱动业务逻辑，避免硬编码。\r\n-    ├── ReactiveProgramming (响应式编程模式) \r\n-    ├── DependencyInjection (依赖注入模式) \r\n+    ├── ReactiveProgramming (响应式编程模式) - 基于数据流和变化传播的编程范式，数据变化自动触发相关计算和更新\r\n+    ├── DependencyInjection (依赖注入模式) - 控制反转的一种实现方式，通过外部注入依赖而不是内部创建，降低耦合度 \r\n     ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n     ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n     └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n"
                }
            ],
            "date": 1767208727919,
            "name": "Commit-0",
            "content": "# 🎯 Lua设计模式库 - 完整指南\r\n\r\n## 📋 概述\r\n\r\n这是一个功能完整的Lua设计模式库，涵盖了从基础到高级的各种设计模式实现。每个模式都经过精心设计，确保易用性、可扩展性和高性能。\r\n\r\n**🎯 设计理念：** 将复杂的设计模式封装成简单易用的工具，让开发者专注于业务逻辑，而不是架构细节。\r\n\r\n---\r\n\r\n## 🏗️ 架构分类\r\n\r\n### 核心模式分类\r\n```\r\nPattern Library (设计模式库)\r\n├── Creational (创建型模式) - 对象创建的艺术\r\n│   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n│   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)\r\n│   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容\r\n│   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值\r\n├── Structural (结构型模式) - 对象组合的艺术\r\n│   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果\r\n│   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n│   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n│   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n│   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n│   └── Proxy (代理模式) - 可用钩子方法+策略模式替代，避免代理模式滥用\r\n├── Behavioral (行为型模式) - 对象交互的艺术\r\n│   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n│   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n│   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n│   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n│   ├── Mediator (中介者模式) - \r\n│   ├── Memento (备忘录模式)\r\n│   ├── Observer (观察者模式)\r\n│   ├── State (状态模式)\r\n│   ├── Strategy (策略模式)\r\n│   ├── TemplateMethod (模板方法模式)\r\n│   └── Visitor (访问者模式)\r\n└── Advanced (高级模式) - 游戏开发专用模式\r\n    ├── Component (组件模式)\r\n    ├── EventDriven (事件驱动模式)\r\n    ├── StateMachine (状态机模式)\r\n    ├── ServiceLocator (服务定位器模式)\r\n    ├── ObjectPool (对象池模式)\r\n    ├── DataDriven (数据驱动模式)\r\n    ├── ReactiveProgramming (响应式编程模式)\r\n    ├── DependencyInjection (依赖注入模式)\r\n    ├── DirtyFlag (脏标记模式)\r\n    ├── DoubleBuffer (双缓冲模式)\r\n    ├── DataLocality (数据局部性模式)\r\n    └── Bytecode (字节码模式)\r\n```\r\n\r\n---\r\n\r\n## 🏭 创建型模式 (Creational Patterns)\r\n\r\n### 🔒 **单例模式 (Singleton)**\r\n**用途：** 确保一个类只有一个实例，并提供全局访问点\r\n**作用：** \r\n- 游戏管理器\r\n- 配置管理器\r\n- 资源管理器\r\n- 日志系统\r\n\r\n**适用场景：**\r\n- 需要全局唯一实例\r\n- 资源管理\r\n- 配置管理\r\n\r\n```lua\r\nlocal singleton = SingletonPattern.New()\r\nlocal instance1 = singleton:GetInstance()\r\nlocal instance2 = singleton:GetInstance()\r\nprint(instance1 == instance2)  -- true，同一个实例\r\n```\r\n\r\n### 🏭 **工厂模式 (Factory)**\r\n**用途：** 根据条件创建不同类型的对象\r\n**作用：**\r\n- 游戏对象创建\r\n- 武器系统\r\n- 敌人生成\r\n- 道具创建\r\n\r\n**适用场景：**\r\n- 需要根据条件创建对象\r\n- 对象创建逻辑复杂\r\n- 支持扩展新类型\r\n\r\n```lua\r\nlocal factory = FactoryPattern.New()\r\nlocal weapon = factory:CreateWeapon(\"sword\")\r\nlocal enemy = factory:CreateEnemy(\"goblin\")\r\n```\r\n\r\n### 🏭🏭 **抽象工厂模式 (AbstractFactory)**\r\n**用途：** 创建一系列相关对象，确保它们相互兼容\r\n**作用：**\r\n- 游戏主题系统\r\n- UI风格系统\r\n- 关卡风格\r\n- 种族系统\r\n\r\n**适用场景：**\r\n- 需要创建相关对象族\r\n- 确保对象兼容性\r\n- 支持多种风格\r\n\r\n```lua\r\nlocal factory = AbstractFactoryPattern.New()\r\nlocal medievalFactory = factory:CreateFactory(\"medieval\")\r\nlocal sword = medievalFactory:CreateWeapon()\r\nlocal armor = medievalFactory:CreateArmor()\r\n```\r\n\r\n### 🏗️ **建造者模式 (Builder)**\r\n**用途：** 分步骤构建复杂对象\r\n**作用：**\r\n- 角色创建\r\n- 关卡构建\r\n- 配置构建\r\n- 复杂对象组装\r\n\r\n**适用场景：**\r\n- 对象构建过程复杂\r\n- 需要分步骤构建\r\n- 支持不同构建方式\r\n\r\n```lua\r\nlocal builder = BuilderPattern.New()\r\nlocal character = builder:SetName(\"英雄\")\r\n    :SetClass(\"战士\")\r\n    :SetLevel(10)\r\n    :SetEquipment(\"铁剑\")\r\n    :Build()\r\n```\r\n\r\n### 🧬 **原型模式 (Prototype)**\r\n**用途：** 通过克隆现有对象来创建新对象\r\n**作用：**\r\n- 对象复制\r\n- 模板系统\r\n- 快速创建\r\n- 减少初始化开销\r\n\r\n**适用场景：**\r\n- 对象创建开销大\r\n- 需要对象副本\r\n- 模板系统\r\n\r\n```lua\r\nlocal prototype = PrototypePattern.New()\r\nlocal original = prototype:Create(\"template\")\r\nlocal clone = original:Clone()\r\n```\r\n\r\n---\r\n\r\n## 🏗️ 结构型模式 (Structural Patterns)\r\n\r\n### 🔌 **适配器模式 (Adapter)**\r\n**用途：** 让不兼容的接口能够协同工作\r\n**作用：**\r\n- 第三方库集成\r\n- 旧系统适配\r\n- 接口统一\r\n- 兼容性处理\r\n\r\n**适用场景：**\r\n- 集成第三方库\r\n- 系统升级兼容\r\n- 接口不匹配\r\n\r\n```lua\r\nlocal adapter = AdapterPattern.New()\r\nlocal newInterface = adapter:Adapt(oldSystem)\r\nnewInterface:NewMethod()\r\n```\r\n\r\n### 🌉 **桥接模式 (Bridge)**\r\n**用途：** 将抽象与实现分离，使它们可以独立变化\r\n**作用：**\r\n- 平台抽象\r\n- 渲染器抽象\r\n- 数据库抽象\r\n- 网络抽象\r\n\r\n**适用场景：**\r\n- 需要支持多平台\r\n- 抽象与实现分离\r\n- 避免继承爆炸\r\n\r\n```lua\r\nlocal bridge = BridgePattern.New()\r\nlocal renderer = bridge:CreateRenderer(\"OpenGL\")\r\nlocal shape = bridge:CreateShape(\"Circle\", renderer)\r\n```\r\n\r\n### 🧩 **组合模式 (Composite)**\r\n**用途：** 将对象组合成树形结构，统一处理单个对象和组合对象\r\n**作用：**\r\n- 场景图系统\r\n- UI组件树\r\n- 文件系统\r\n- 游戏对象层次\r\n\r\n**适用场景：**\r\n- 树形结构\r\n- 部分-整体关系\r\n- 统一处理接口\r\n\r\n```lua\r\nlocal composite = CompositePattern.New()\r\nlocal root = composite:CreateComponent(\"root\")\r\nlocal child1 = composite:CreateComponent(\"child1\")\r\nroot:Add(child1)\r\nroot:Operation()  -- 递归调用所有子组件\r\n```\r\n\r\n### 🎨 **装饰器模式 (Decorator)**\r\n**用途：** 动态地给对象添加新功能\r\n**作用：**\r\n- 装备系统\r\n- 技能增强\r\n- 状态效果\r\n- 功能扩展\r\n\r\n**适用场景：**\r\n- 需要动态添加功能\r\n- 避免继承爆炸\r\n- 功能组合\r\n\r\n```lua\r\nlocal decorator = DecoratorPattern.New()\r\nlocal baseWeapon = decorator:CreateWeapon(\"剑\")\r\nlocal fireWeapon = decorator:AddFireEffect(baseWeapon)\r\nlocal iceWeapon = decorator:AddIceEffect(fireWeapon)\r\n```\r\n\r\n### 🏛️ **外观模式 (Facade)**\r\n**用途：** 为复杂子系统提供简单接口\r\n**作用：**\r\n- 系统封装\r\n- 简化接口\r\n- 降低耦合\r\n- 统一入口\r\n\r\n**适用场景：**\r\n- 复杂系统封装\r\n- 简化客户端使用\r\n- 降低系统耦合\r\n\r\n```lua\r\nlocal facade = FacadePattern.New()\r\n-- 复杂的子系统操作被封装成简单接口\r\nfacade:StartGame()\r\nfacade:SaveGame()\r\nfacade:LoadGame()\r\n```\r\n\r\n### 🦋 **享元模式 (Flyweight)**\r\n**用途：** 通过共享减少内存使用\r\n**作用：**\r\n- 纹理共享\r\n- 模型共享\r\n- 配置共享\r\n- 资源优化\r\n\r\n**适用场景：**\r\n- 大量相似对象\r\n- 内存优化\r\n- 资源共享\r\n\r\n```lua\r\nlocal flyweight = FlyweightPattern.New()\r\nlocal texture1 = flyweight:GetTexture(\"grass\")\r\nlocal texture2 = flyweight:GetTexture(\"grass\")  -- 共享同一个纹理\r\n```\r\n\r\n### 🎭 **代理模式 (Proxy)**\r\n**用途：** 控制对其他对象的访问\r\n**作用：**\r\n- 权限控制\r\n- 延迟加载\r\n- 缓存代理\r\n- 安全控制\r\n\r\n**适用场景：**\r\n- 访问控制\r\n- 延迟加载\r\n- 缓存优化\r\n\r\n```lua\r\nlocal proxy = ProxyPattern.New()\r\nlocal realObject = proxy:GetObject()  -- 可能延迟加载\r\nproxy:CheckPermission(\"read\")  -- 权限检查\r\n```\r\n\r\n---\r\n\r\n## 🎭 行为型模式 (Behavioral Patterns)\r\n\r\n### 🔗 **责任链模式 (ChainOfResponsibility)**\r\n**用途：** 将请求沿着处理者链进行传递，直到被处理\r\n**作用：**\r\n- 事件处理\r\n- 权限验证\r\n- 异常处理\r\n- 请求过滤\r\n\r\n**适用场景：**\r\n- 多个对象处理请求\r\n- 请求处理顺序不确定\r\n- 动态处理链\r\n\r\n```lua\r\nlocal chain = ChainOfResponsibilityPattern.New()\r\nchain:AddHandler(handler1)\r\nchain:AddHandler(handler2)\r\nchain:HandleRequest(request)\r\n```\r\n\r\n### 📝 **命令模式 (Command)**\r\n**用途：** 将请求封装成对象，支持请求排队、记录日志、撤销等操作\r\n**作用：**\r\n- 撤销/重做系统\r\n- 宏命令\r\n- 队列处理\r\n- 日志记录\r\n\r\n**适用场景：**\r\n- 需要撤销功能\r\n- 命令排队\r\n- 宏操作\r\n\r\n```lua\r\nlocal command = CommandPattern.New()\r\nlocal moveCommand = command:CreateMoveCommand(unit, target)\r\ncommand:Execute(moveCommand)\r\ncommand:Undo()  -- 撤销操作\r\n```\r\n\r\n### 🔤 **解释器模式 (Interpreter)**\r\n**用途：** 为语言创建解释器\r\n**作用：**\r\n- 脚本系统\r\n- 配置解析\r\n- 规则引擎\r\n- 表达式求值\r\n\r\n**适用场景：**\r\n- 简单语言解析\r\n- 规则引擎\r\n- 表达式计算\r\n\r\n```lua\r\nlocal interpreter = InterpreterPattern.New()\r\nlocal result = interpreter:Interpret(\"1 + 2 * 3\")\r\n```\r\n\r\n### 🔄 **迭代器模式 (Iterator)**\r\n**用途：** 提供一种方法顺序访问集合中的元素，而不暴露其内部表示\r\n**作用：**\r\n- 集合遍历\r\n- 自定义遍历\r\n- 遍历算法\r\n- 集合封装\r\n\r\n**适用场景：**\r\n- 集合遍历\r\n- 自定义遍历逻辑\r\n- 集合封装\r\n\r\n```lua\r\nlocal iterator = IteratorPattern.New()\r\nlocal collection = iterator:CreateCollection()\r\nfor item in collection:Iterator() do\r\n    print(item)\r\nend\r\n```\r\n\r\n### 🤝 **中介者模式 (Mediator)**\r\n**用途：** 封装对象间的交互，降低它们之间的耦合度\r\n**作用：**\r\n- 聊天系统\r\n- 游戏系统协调\r\n- UI组件协调\r\n- 模块间通信\r\n\r\n**适用场景：**\r\n- 对象间复杂交互\r\n- 降低耦合\r\n- 集中控制\r\n\r\n```lua\r\nlocal mediator = MediatorPattern.New()\r\nmediator:RegisterComponent(component1)\r\nmediator:RegisterComponent(component2)\r\ncomponent1:SendMessage(\"hello\", mediator)\r\n```\r\n\r\n### 💾 **备忘录模式 (Memento)**\r\n**用途：** 在不破坏封装的前提下，捕获并外部化对象的内部状态\r\n**作用：**\r\n- 游戏存档\r\n- 撤销系统\r\n- 状态恢复\r\n- 快照系统\r\n\r\n**适用场景：**\r\n- 状态保存\r\n- 撤销功能\r\n- 快照系统\r\n\r\n```lua\r\nlocal memento = MementoPattern.New()\r\nlocal originator = memento:CreateOriginator()\r\nlocal savedState = originator:SaveState()\r\noriginator:RestoreState(savedState)\r\n```\r\n\r\n### 👀 **观察者模式 (Observer)**\r\n**用途：** 定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会得到通知\r\n**作用：**\r\n- 事件系统\r\n- 数据绑定\r\n- 消息通知\r\n- 状态同步\r\n\r\n**适用场景：**\r\n- 事件通知\r\n- 数据同步\r\n- 松耦合通信\r\n\r\n```lua\r\nlocal observer = ObserverPattern.New()\r\nobserver:Subscribe(subscriber1)\r\nobserver:Subscribe(subscriber2)\r\nobserver:Notify(\"event occurred\")\r\n```\r\n\r\n### 🔄 **状态模式 (State)**\r\n**用途：** 让对象在其内部状态改变时改变其行为\r\n**作用：**\r\n- 游戏状态管理\r\n- 角色状态\r\n- 系统状态\r\n- 工作流状态\r\n\r\n**适用场景：**\r\n- 对象状态变化\r\n- 状态相关行为\r\n- 状态机实现\r\n\r\n```lua\r\nlocal state = StatePattern.New()\r\nlocal context = state:CreateContext()\r\ncontext:SetState(state:CreateState(\"idle\"))\r\ncontext:Request()  -- 根据当前状态执行不同行为\r\n```\r\n\r\n### 🎯 **策略模式 (Strategy)**\r\n**用途：** 定义一系列算法，使它们可以互相替换，算法的变化不会影响使用算法的客户\r\n**作用：**\r\n- AI行为选择\r\n- 算法选择\r\n- 支付方式\r\n- 排序算法\r\n\r\n**适用场景：**\r\n- 算法选择\r\n- 行为选择\r\n- 避免条件判断\r\n\r\n```lua\r\nlocal strategy = StrategyPattern.New()\r\nlocal context = strategy:CreateContext()\r\ncontext:SetStrategy(strategy:CreateStrategy(\"aggressive\"))\r\ncontext:ExecuteStrategy()\r\n```\r\n\r\n### 📋 **模板方法模式 (TemplateMethod)**\r\n**用途：** 在父类中定义算法骨架，让子类重写特定步骤\r\n**作用：**\r\n- 算法框架\r\n- 流程控制\r\n- 代码复用\r\n- 扩展点定义\r\n\r\n**适用场景：**\r\n- 算法框架\r\n- 流程模板\r\n- 代码复用\r\n\r\n```lua\r\nlocal template = TemplateMethodPattern.New()\r\nlocal concreteClass = template:CreateConcreteClass()\r\nconcreteClass:TemplateMethod()  -- 调用模板方法\r\n```\r\n\r\n### 👥 **访问者模式 (Visitor)**\r\n**用途：** 在不改变数据结构的前提下，定义作用于其元素的新操作\r\n**作用：**\r\n- 数据操作\r\n- 统计功能\r\n- 导出功能\r\n- 功能扩展\r\n\r\n**适用场景：**\r\n- 数据结构稳定\r\n- 操作经常变化\r\n- 功能扩展\r\n\r\n```lua\r\nlocal visitor = VisitorPattern.New()\r\nlocal element = visitor:CreateElement()\r\nlocal concreteVisitor = visitor:CreateVisitor()\r\nelement:Accept(concreteVisitor)\r\n```\r\n\r\n---\r\n\r\n## 🚀 高级模式 (Advanced Patterns)\r\n\r\n### 🧩 **组件模式 (Component)**\r\n**用途：** 将游戏对象分解为可重用的组件\r\n**作用：**\r\n- 游戏对象系统\r\n- 模块化设计\r\n- 功能组合\r\n- 系统解耦\r\n\r\n**适用场景：**\r\n- 复杂游戏对象\r\n- 功能模块化\r\n- 系统解耦\r\n\r\n```lua\r\nlocal component = ComponentPattern.New()\r\nlocal gameObject = component:CreateGameObject()\r\ngameObject:AddComponent(\"Transform\")\r\ngameObject:AddComponent(\"Renderer\")\r\ngameObject:AddComponent(\"Collider\")\r\n```\r\n\r\n### 📡 **事件驱动模式 (EventDriven)**\r\n**用途：** 通过事件进行松耦合的通信\r\n**作用：**\r\n- 系统解耦\r\n- 异步通信\r\n- 消息传递\r\n- 响应式系统\r\n\r\n**适用场景：**\r\n- 系统解耦\r\n- 异步处理\r\n- 消息系统\r\n\r\n```lua\r\nlocal eventSystem = EventDrivenPattern.New()\r\neventSystem:Subscribe(\"playerMove\", handler)\r\neventSystem:Publish(\"playerMove\", {x = 100, y = 200})\r\n```\r\n\r\n### 🎮 **状态机模式 (StateMachine)**\r\n**用途：** 管理复杂的状态转换逻辑\r\n**作用：**\r\n- 角色状态管理\r\n- 游戏流程控制\r\n- AI状态管理\r\n- 系统状态控制\r\n\r\n**适用场景：**\r\n- 复杂状态管理\r\n- 状态转换逻辑\r\n- 流程控制\r\n\r\n```lua\r\nlocal stateMachine = StateMachinePattern.New()\r\nstateMachine:AddState(\"idle\")\r\nstateMachine:AddState(\"walking\")\r\nstateMachine:AddTransition(\"idle\", \"walking\", \"startWalking\")\r\nstateMachine:ChangeState(\"idle\")\r\n```\r\n\r\n### 🏢 **服务定位器模式 (ServiceLocator)**\r\n**用途：** 提供全局的服务访问点\r\n**作用：**\r\n- 服务管理\r\n- 依赖管理\r\n- 全局访问\r\n- 服务注册\r\n\r\n**适用场景：**\r\n- 全局服务访问\r\n- 服务管理\r\n- 依赖注入\r\n\r\n```lua\r\nlocal serviceLocator = ServiceLocatorPattern.New()\r\nserviceLocator:Register(\"audioService\", audioService)\r\nlocal audio = serviceLocator:GetService(\"audioService\")\r\n```\r\n\r\n### 🏊 **对象池模式 (ObjectPool)**\r\n**用途：** 重用对象以减少创建和销毁的开销\r\n**作用：**\r\n- 性能优化\r\n- 内存管理\r\n- 对象复用\r\n- 垃圾回收优化\r\n\r\n**适用场景：**\r\n- 频繁创建销毁\r\n- 性能优化\r\n- 内存管理\r\n\r\n```lua\r\nlocal objectPool = ObjectPoolPattern.New()\r\nlocal bullet = objectPool:GetObject(\"bullet\")\r\n-- 使用子弹\r\nobjectPool:ReturnObject(bullet)\r\n```\r\n\r\n### 📊 **数据驱动模式 (DataDriven)**\r\n**用途：** 通过数据配置驱动系统行为\r\n**作用：**\r\n- 配置管理\r\n- 数据驱动\r\n- 系统配置\r\n- 行为配置\r\n\r\n**适用场景：**\r\n- 配置驱动\r\n- 数据驱动\r\n- 系统配置\r\n\r\n```lua\r\nlocal dataDriven = DataDrivenPattern.New()\r\ndataDriven:LoadConfig(\"weapon_config.json\")\r\nlocal weapon = dataDriven:CreateWeapon(\"sword\")\r\n```\r\n\r\n### ⚡ **响应式编程模式 (ReactiveProgramming)**\r\n**用途：** 通过数据流和变化传播来简化编程\r\n**作用：**\r\n- 数据流处理\r\n- 变化传播\r\n- 异步处理\r\n- 事件流\r\n\r\n**适用场景：**\r\n- 数据流处理\r\n- 变化响应\r\n- 异步编程\r\n\r\n```lua\r\nlocal reactive = ReactiveProgrammingPattern.New()\r\nlocal stream = reactive:CreateStream()\r\nstream:Subscribe(function(value) print(\"Value changed:\", value) end)\r\nstream:Next(100)\r\n```\r\n\r\n### 💉 **依赖注入模式 (DependencyInjection)**\r\n**用途：** 通过外部注入依赖，降低组件间的耦合\r\n**作用：**\r\n- 依赖管理\r\n- 解耦设计\r\n- 测试友好\r\n- 配置灵活\r\n\r\n**适用场景：**\r\n- 依赖管理\r\n- 系统解耦\r\n- 测试友好\r\n\r\n```lua\r\nlocal di = DependencyInjectionPattern.New()\r\ndi:Register(\"database\", databaseService)\r\ndi:Register(\"logger\", loggerService)\r\nlocal service = di:CreateService(MyService)\r\n```\r\n\r\n### 🚩 **脏标记模式 (DirtyFlag)**\r\n**用途：** 通过标记避免不必要的计算\r\n**作用：**\r\n- 性能优化\r\n- 缓存管理\r\n- 计算优化\r\n- 更新控制\r\n\r\n**适用场景：**\r\n- 性能优化\r\n- 缓存管理\r\n- 计算优化\r\n\r\n```lua\r\nlocal dirtyFlag = DirtyFlagPattern.New()\r\nlocal object = dirtyFlag:CreateObject()\r\nobject:MarkDirty()\r\nif object:IsDirty() then\r\n    object:Update()\r\n    object:ClearDirty()\r\nend\r\n```\r\n\r\n### 🔄 **双缓冲模式 (DoubleBuffer)**\r\n**用途：** 使用两个缓冲区避免渲染冲突\r\n**作用：**\r\n- 渲染优化\r\n- 动画平滑\r\n- 避免闪烁\r\n- 性能提升\r\n\r\n**适用场景：**\r\n- 渲染系统\r\n- 动画系统\r\n- 避免闪烁\r\n\r\n```lua\r\nlocal doubleBuffer = DoubleBufferPattern.New()\r\nlocal buffer = doubleBuffer:CreateBuffer()\r\nbuffer:SwapBuffers()\r\nbuffer:DrawToBackBuffer()\r\n```\r\n\r\n### 📍 **数据局部性模式 (DataLocality)**\r\n**用途：** 通过组织数据布局提高缓存效率\r\n**作用：**\r\n- 性能优化\r\n- 缓存优化\r\n- 内存访问优化\r\n- 系统性能\r\n\r\n**适用场景：**\r\n- 性能优化\r\n- 缓存优化\r\n- 内存访问优化\r\n\r\n```lua\r\nlocal dataLocality = DataLocalityPattern.New()\r\nlocal optimizedArray = dataLocality:CreateOptimizedArray()\r\n-- 数据按访问模式组织，提高缓存命中率\r\n```\r\n\r\n### 💻 **字节码模式 (Bytecode)**\r\n**用途：** 通过字节码实现脚本系统\r\n**作用：**\r\n- 脚本系统\r\n- 虚拟机\r\n- 性能优化\r\n- 跨平台\r\n\r\n**适用场景：**\r\n- 脚本系统\r\n- 性能优化\r\n- 跨平台\r\n\r\n```lua\r\nlocal bytecode = BytecodePattern.New()\r\nlocal script = bytecode:Compile(\"print('Hello World')\")\r\nbytecode:Execute(script)\r\n```\r\n\r\n---\r\n\r\n## 🚀 使用指南\r\n\r\n### 快速开始\r\n```lua\r\n-- 1. 选择合适的设计模式\r\nlocal pattern = PatternFactory.Create(PatternTypes.SINGLETON)\r\n\r\n-- 2. 创建模式实例\r\nlocal instance = pattern:Create()\r\n\r\n-- 3. 使用模式功能\r\ninstance:DoSomething()\r\n```\r\n\r\n### 模式选择建议\r\n- **对象创建**: 使用创建型模式\r\n- **对象组合**: 使用结构型模式\r\n- **对象交互**: 使用行为型模式\r\n- **游戏开发**: 使用高级模式\r\n\r\n### 最佳实践\r\n- **单一职责**: 每个模式只负责一个方面\r\n- **开闭原则**: 对扩展开放，对修改关闭\r\n- **依赖倒置**: 依赖抽象而非具体实现\r\n- **接口隔离**: 客户端不应该依赖不需要的接口\r\n\r\n---\r\n\r\n## 📈 模式对比\r\n\r\n| 模式类型 | 主要用途 | 复杂度 | 适用场景 | 性能影响 |\r\n|----------|----------|--------|----------|----------|\r\n| **创建型** | 对象创建 | 低-中 | 对象创建逻辑 | 低 |\r\n| **结构型** | 对象组合 | 中 | 对象关系 | 低-中 |\r\n| **行为型** | 对象交互 | 中-高 | 对象通信 | 中 |\r\n| **高级** | 游戏开发 | 高 | 复杂系统 | 中-高 |\r\n\r\n---\r\n\r\n## 🔧 扩展开发\r\n\r\n### 添加新的设计模式\r\n1. 继承基础模式接口\r\n2. 实现必要的方法\r\n3. 在工厂中注册\r\n4. 添加使用示例\r\n\r\n### 自定义模式实现\r\n```lua\r\nlocal CustomPattern = BaseClass(IPattern)\r\n\r\nfunction CustomPattern:ctor()\r\n    -- 初始化代码\r\nend\r\n\r\nfunction CustomPattern:Execute()\r\n    -- 模式执行逻辑\r\nend\r\n```\r\n\r\n---\r\n\r\n## 📚 总结\r\n\r\n这个设计模式库提供了：\r\n\r\n✅ **完整的模式覆盖** - 从基础到高级的完整覆盖  \r\n✅ **游戏开发优化** - 针对游戏开发的专用模式  \r\n✅ **易用性设计** - 统一的接口和工厂创建  \r\n✅ **扩展性架构** - 易于添加新的设计模式  \r\n✅ **实用性强** - 实际项目中的应用场景  \r\n\r\n**🎯 核心价值：** 让开发者专注于业务逻辑，而不是架构设计的复杂细节。\r\n\r\n---\r\n\r\n*支持Lua 5.1+ | 完整设计模式 | 游戏开发优化 | 易于扩展 | 🚀 架构设计最佳实践*\r\n"
        }
    ]
}