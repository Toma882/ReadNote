{
    "sourceFile": "Assets/UnityEditor/README_Attributes.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1746867746423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1746868873518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,8 +12,35 @@\n [SerializeField] // 这是一个特性，使私有字段在Inspector中可见\r\n private int myPrivateVariable;\r\n ```\r\n \r\n+### AttributeUsage\r\n+\r\n+`AttributeUsage` 是 C# 中用于控制特性如何使用的元特性。它可以规定特性可以应用的目标类型、是否允许多次使用以及是否从父类继承。\r\n+\r\n+```csharp\r\n+[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = true)]\r\n+public class MyCustomAttribute : PropertyAttribute\r\n+{\r\n+    // 特性实现\r\n+}\r\n+```\r\n+\r\n+### AttributeTargets\r\n+\r\n+`AttributeTargets` 是一个枚举类型，定义了特性可以应用的目标类型。常见的目标类型包括：\r\n+\r\n+- `AttributeTargets.Class` - 应用于类\r\n+- `AttributeTargets.Field` - 应用于字段\r\n+- `AttributeTargets.Method` - 应用于方法\r\n+- `AttributeTargets.Property` - 应用于属性\r\n+- `AttributeTargets.All` - 应用于所有可能的元素\r\n+\r\n+可以使用按位或运算符 `|` 组合多个目标，例如：\r\n+```csharp\r\n+[AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]\r\n+```\r\n+\r\n ## UML类图\r\n \r\n ```\r\n +---------------------------+\r\n@@ -77,8 +104,16 @@\n │   ├── 编辑器初始化\r\n │   │   ├── InitializeOnLoad - 编辑器加载时执行\r\n │   │   ├── InitializeOnLoadMethod - 编辑器加载时执行方法\r\n │   │   └── DidReloadScripts - 脚本重新加载时执行\r\n+│   ├── 设置相关\r\n+│   │   ├── SettingsProvider - 创建设置提供者\r\n+│   │   ├── UserSetting - 用户设置\r\n+│   │   └── SettingsProviderGroup - 设置提供者组\r\n+│   ├── Gizmo相关\r\n+│   │   ├── GizmoDrawer - Gizmo绘制器\r\n+│   │   ├── DrawGizmo - 绘制Gizmo\r\n+│   │   └── GizmoIcon - Gizmo图标\r\n │   └── 自定义编辑器\r\n │       ├── CustomEditor - 自定义检视器\r\n │       ├── CanEditMultipleObjects - 可编辑多对象\r\n │       └── CustomPropertyDrawer - 自定义属性绘制器\r\n@@ -126,8 +161,10 @@\n | **TextAreaAttribute** | 字符串字段 | 显示多行文本区域 | `[TextArea(3, 10)]` |\r\n | **ColorUsageAttribute** | Color字段 | 自定义颜色选择器 | `[ColorUsage(true, true)]` |\r\n | **MultilineAttribute** | 字符串字段 | 显示多行输入框 | `[Multiline(3)]` |\r\n | **DelayedAttribute** | 值类型字段 | 延迟更新值 | `[Delayed]` |\r\n+| **InspectorNameAttribute** | 枚举值/字段 | 自定义Inspector显示名称 | `[InspectorName(\"Friendly Name\")]` |\r\n+| **GradientUsageAttribute** | Gradient字段 | 自定义渐变编辑器 | `[GradientUsage(true)]` |\r\n \r\n ### 序列化特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n@@ -135,8 +172,10 @@\n | **SerializeField** | 私有字段 | 使私有字段可在Inspector中显示 | `[SerializeField]` |\r\n | **NonSerialized** | 公有字段 | 阻止字段序列化 | `[System.NonSerialized]` |\r\n | **SerializeReference** | 引用类型 | 序列化对象引用而非对象本身 | `[SerializeReference]` |\r\n | **Serializable** | 类 | 标记类为可序列化 | `[System.Serializable]` |\r\n+| **FormerlySerializedAs** | 字段 | 重命名字段时保持序列化兼容性 | `[FormerlySerializedAs(\"oldName\")]` |\r\n+| **PreferBinarySerialization** | ScriptableObject | 使用二进制序列化而非YAML | `[PreferBinarySerialization]` |\r\n \r\n ### 菜单特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n@@ -156,8 +195,10 @@\n | **ExecuteAlways** | 类 | 在编辑和运行模式下执行 | `[ExecuteAlways]` |\r\n | **AddComponentMenu** | 类 | 添加到组件菜单 | `[AddComponentMenu(\"Custom/MyComponent\")]` |\r\n | **HideInInspector** | 字段 | 在Inspector中隐藏字段 | `[HideInInspector]` |\r\n | **SelectionBase** | 类 | 设为场景选择基础 | `[SelectionBase]` |\r\n+| **DefaultExecutionOrder** | 类 | 设置脚本执行顺序 | `[DefaultExecutionOrder(-100)]` |\r\n+| **Icon** | 类 | 为组件设置图标 | `[Icon(\"Assets/Icons/MyIcon.png\")]` |\r\n \r\n ### 编辑器定制特性\r\n \r\n | 特性名称 | 应用目标 | 描述 | 示例 |\r\n@@ -168,8 +209,24 @@\n | **InitializeOnLoad** | 类 | 编辑器加载时初始化 | `[InitializeOnLoad]` |\r\n | **InitializeOnLoadMethod** | 静态方法 | 编辑器加载时执行方法 | `[InitializeOnLoadMethod]` |\r\n | **OnOpenAsset** | 静态方法 | 资源打开时执行 | `[OnOpenAsset]` |\r\n \r\n+### Gizmo相关特性\r\n+\r\n+| 特性名称 | 应用目标 | 描述 | 示例 |\r\n+|---------|---------|------|------|\r\n+| **DrawGizmo** | 静态方法 | 绘制场景视图中的Gizmo | `[DrawGizmo(GizmoType.Selected)]` |\r\n+| **GizmoDrawer** | 类 | 定义Gizmo绘制器 | 自定义实现 |\r\n+| **GizmoIcon** | 类 | 为对象添加Gizmo图标 | 自定义实现 |\r\n+\r\n+### 设置相关特性\r\n+\r\n+| 特性名称 | 应用目标 | 描述 | 示例 |\r\n+|---------|---------|------|------|\r\n+| **SettingsProvider** | 类 | 创建设置提供者 | `[SettingsProvider]` |\r\n+| **UserSetting** | 字段 | 标记为用户设置 | `[UserSetting]` |\r\n+| **SettingsProviderGroup** | 类 | 创建设置提供者组 | `[SettingsProviderGroup]` |\r\n+\r\n ## 使用案例\r\n \r\n ### 案例1: 自定义组件检视器\r\n \r\n@@ -335,8 +392,159 @@\n     }\r\n }\r\n ```\r\n \r\n+### 案例4: Gizmo绘制与自定义图标\r\n+\r\n+```csharp\r\n+// 使用DrawGizmo特性的Gizmo绘制\r\n+public class GizmoExample : MonoBehaviour\r\n+{\r\n+    public float radius = 1.0f;\r\n+    public Color gizmoColor = Color.yellow;\r\n+}\r\n+\r\n+// Gizmo绘制器 - 与MonoBehaviour分离\r\n+public class GizmoExampleDrawer\r\n+{\r\n+    [DrawGizmo(GizmoType.Selected | GizmoType.Active)]\r\n+    static void DrawGizmo(GizmoExample example, GizmoType gizmoType)\r\n+    {\r\n+        Gizmos.color = example.gizmoColor;\r\n+        Gizmos.DrawWireSphere(example.transform.position, example.radius);\r\n+        \r\n+        // 只为选中对象绘制额外指示器\r\n+        if (gizmoType == GizmoType.Selected)\r\n+        {\r\n+            Gizmos.color = new Color(example.gizmoColor.r, example.gizmoColor.g, example.gizmoColor.b, 0.3f);\r\n+            Gizmos.DrawSphere(example.transform.position, example.radius);\r\n+        }\r\n+    }\r\n+}\r\n+```\r\n+\r\n+### 案例5: 设置提供者\r\n+\r\n+```csharp\r\n+// 使用SettingsProvider特性创建设置面板\r\n+public class MyCustomSettings\r\n+{\r\n+    private const string SettingsPath = \"Project/MyCustomSettings\";\r\n+    \r\n+    private static SerializedObject settingsObject;\r\n+    private static SerializedProperty exampleProperty;\r\n+    \r\n+    // 创建设置提供者\r\n+    [SettingsProvider]\r\n+    public static SettingsProvider CreateSettingsProvider()\r\n+    {\r\n+        var provider = new SettingsProvider(SettingsPath, SettingsScope.Project)\r\n+        {\r\n+            label = \"My Custom Settings\",\r\n+            guiHandler = (searchContext) =>\r\n+            {\r\n+                // 确保设置对象已初始化\r\n+                if (settingsObject == null)\r\n+                {\r\n+                    var settings = MyCustomSettingsAsset.GetOrCreateSettings();\r\n+                    settingsObject = new SerializedObject(settings);\r\n+                    exampleProperty = settingsObject.FindProperty(\"exampleValue\");\r\n+                }\r\n+                \r\n+                // 开始绘制设置界面\r\n+                EditorGUILayout.PropertyField(exampleProperty, new GUIContent(\"Example Value\"));\r\n+                \r\n+                // 应用修改\r\n+                if (settingsObject.hasModifiedProperties)\r\n+                {\r\n+                    settingsObject.ApplyModifiedProperties();\r\n+                }\r\n+            },\r\n+            keywords = new HashSet<string>(new[] { \"Custom\", \"Example\", \"Settings\" })\r\n+        };\r\n+        \r\n+        return provider;\r\n+    }\r\n+}\r\n+\r\n+// 设置资源类\r\n+[CreateAssetMenu(fileName = \"MyCustomSettings\", menuName = \"Settings/My Custom Settings\")]\r\n+public class MyCustomSettingsAsset : ScriptableObject\r\n+{\r\n+    public float exampleValue = 1.0f;\r\n+    \r\n+    private static MyCustomSettingsAsset instance;\r\n+    \r\n+    public static MyCustomSettingsAsset GetOrCreateSettings()\r\n+    {\r\n+        if (instance != null)\r\n+            return instance;\r\n+            \r\n+        const string settingsPath = \"Assets/Settings/MyCustomSettings.asset\";\r\n+        \r\n+        instance = AssetDatabase.LoadAssetAtPath<MyCustomSettingsAsset>(settingsPath);\r\n+        if (instance != null)\r\n+            return instance;\r\n+            \r\n+        // 创建新设置资源\r\n+        instance = CreateInstance<MyCustomSettingsAsset>();\r\n+        \r\n+        // 确保目录存在\r\n+        if (!AssetDatabase.IsValidFolder(\"Assets/Settings\"))\r\n+            AssetDatabase.CreateFolder(\"Assets\", \"Settings\");\r\n+            \r\n+        AssetDatabase.CreateAsset(instance, settingsPath);\r\n+        AssetDatabase.SaveAssets();\r\n+        \r\n+        return instance;\r\n+    }\r\n+}\r\n+```\r\n+\r\n+## 自定义特性的创建与使用\r\n+\r\n+### 创建自定义特性\r\n+\r\n+要创建自定义特性，需要继承 `PropertyAttribute` 类，并可选择实现相应的 `PropertyDrawer`：\r\n+\r\n+```csharp\r\n+// 定义特性\r\n+[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]\r\n+public class ReadOnlyAttribute : PropertyAttribute\r\n+{\r\n+    // 无需额外实现\r\n+}\r\n+\r\n+// 实现属性绘制器\r\n+[CustomPropertyDrawer(typeof(ReadOnlyAttribute))]\r\n+public class ReadOnlyDrawer : PropertyDrawer\r\n+{\r\n+    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\r\n+    {\r\n+        // 禁用GUI\r\n+        GUI.enabled = false;\r\n+        \r\n+        // 绘制标准字段\r\n+        EditorGUI.PropertyField(position, property, label, true);\r\n+        \r\n+        // 恢复GUI状态\r\n+        GUI.enabled = true;\r\n+    }\r\n+}\r\n+```\r\n+\r\n+### 使用自定义特性\r\n+\r\n+```csharp\r\n+public class ExampleBehaviour : MonoBehaviour\r\n+{\r\n+    [ReadOnly]\r\n+    public string readOnlyText = \"This field cannot be edited\";\r\n+    \r\n+    public string editableText = \"This field can be edited\";\r\n+}\r\n+```\r\n+\r\n ## 特性使用最佳实践\r\n \r\n 1. **组合使用特性**：多个特性可以组合使用，如`[SerializeField]`和`[Range(0,100)]`\r\n \r\n@@ -347,7 +555,15 @@\n 4. **性能考虑**：`ExecuteInEditMode`和`InitializeOnLoad`特性可能影响编辑器性能，应谨慎使用\r\n \r\n 5. **特性继承**：特性不会被继承，需要为每个类单独添加特性\r\n \r\n+6. **特性与类型安全**：在创建自定义特性时，考虑添加类型检查，确保特性只应用于兼容的字段类型\r\n+\r\n+7. **避免特性滥用**：过多使用特性可能导致代码可读性下降，应合理使用\r\n\\ No newline at end of file\n+\r\n+8. **文档化特性行为**：为自定义特性提供清晰的文档，说明其行为和使用方法\r\n+\r\n ## 总结\r\n \r\n-Unity特性系统是扩展编辑器和定制组件行为的强大工具。通过合理使用特性，可以显著提升开发效率、改善编辑器体验并实现复杂的定制功能。特性的组合使用尤其重要，能够创建直观、便于使用的组件检视器和编辑工具。 \n+Unity特性系统是扩展编辑器和定制组件行为的强大工具。通过合理使用特性，可以显著提升开发效率、改善编辑器体验并实现复杂的定制功能。特性的组合使用尤其重要，能够创建直观、便于使用的组件检视器和编辑工具。\r\n+\r\n+无论是使用Unity提供的内置特性，还是创建自定义特性，掌握特性系统都能使你的Unity开发流程更加高效和灵活。通过理解每个特性的用途和应用场景，你可以根据项目需求选择最合适的特性组合，创建出既直观又强大的工具和组件。 \n\\ No newline at end of file\n"
                }
            ],
            "date": 1746867746423,
            "name": "Commit-0",
            "content": "# Unity特性(Attributes)详解\r\n\r\n## 概述\r\n\r\nUnity的特性(Attributes)系统是扩展编辑器和控制组件行为的强大工具。通过特性，开发者可以自定义Inspector界面、控制序列化行为、定义菜单项和调整编译设置等。本文档详细介绍Unity特性系统的架构、常用特性及其应用场景。\r\n\r\n## 特性基础\r\n\r\n特性(Attributes)是一种向代码添加元数据的机制，通过方括号`[]`标记。Unity使用这些元数据来修改编辑器行为或运行时行为，无需开发者编写额外的功能代码。\r\n\r\n```csharp\r\n[SerializeField] // 这是一个特性，使私有字段在Inspector中可见\r\nprivate int myPrivateVariable;\r\n```\r\n\r\n## UML类图\r\n\r\n```\r\n+---------------------------+\r\n|        Attribute          | <-- C#基类\r\n+---------------------------+\r\n| + AttributeTargets        |\r\n| + AllowMultiple           |\r\n+---------------------------+\r\n             ^\r\n             |\r\n+---------------------------+       +----------------------------+\r\n|    PropertyAttribute      | <---- |       CustomEditor         |\r\n+---------------------------+       +----------------------------+\r\n| + order                   |       | + inspectedType            |\r\n+--------------^------------+       | + editorForChildClasses    |\r\n               |                    +----------------------------+\r\n               |                    | + OnInspectorGUI()         |\r\n     +---------+----------+         +----------------------------+\r\n     |                    |\r\n+----------------+  +------------------+\r\n|    RangeAttribute |  | HeaderAttribute |\r\n+----------------+  +------------------+\r\n| + min          |  | + header         |\r\n| + max          |  +------------------+\r\n+----------------+\r\n     \r\n+---------------------------+       +---------------------------+\r\n|      ContextMenuItem      |       |      InitializeOnLoad     |\r\n+---------------------------+       +---------------------------+\r\n| + name                    |       |                           |\r\n| + function                |       |                           |\r\n+---------------------------+       +---------------------------+\r\n\r\n+---------------------------+       +---------------------------+\r\n|        MenuItem           |       |    ExecuteInEditMode      |\r\n+---------------------------+       +---------------------------+\r\n| + itemName                |       |                           |\r\n| + validate                |       |                           |\r\n+---------------------------+       +---------------------------+\r\n```\r\n\r\n## 思维导图\r\n\r\n```\r\nUnity特性系统\r\n├── 编辑器特性\r\n│   ├── 界面相关\r\n│   │   ├── HeaderAttribute - 添加标题\r\n│   │   ├── SpaceAttribute - 添加空间\r\n│   │   ├── TooltipAttribute - 添加提示\r\n│   │   ├── TextAreaAttribute - 多行文本\r\n│   │   ├── ColorUsageAttribute - 颜色选择器\r\n│   │   ├── RangeAttribute - 范围滑动条\r\n│   │   ├── MultilineAttribute - 多行输入\r\n│   │   └── DelayedAttribute - 延迟输入\r\n│   ├── 菜单相关\r\n│   │   ├── MenuItem - 创建菜单项\r\n│   │   ├── ContextMenu - 右键菜单\r\n│   │   ├── ContextMenuItem - 右键菜单项\r\n│   │   └── CreateAssetMenu - 创建资源菜单\r\n│   ├── 编辑器初始化\r\n│   │   ├── InitializeOnLoad - 编辑器加载时执行\r\n│   │   ├── InitializeOnLoadMethod - 编辑器加载时执行方法\r\n│   │   └── DidReloadScripts - 脚本重新加载时执行\r\n│   └── 自定义编辑器\r\n│       ├── CustomEditor - 自定义检视器\r\n│       ├── CanEditMultipleObjects - 可编辑多对象\r\n│       └── CustomPropertyDrawer - 自定义属性绘制器\r\n├── 运行时特性\r\n│   ├── 序列化相关\r\n│   │   ├── SerializeField - 序列化私有字段\r\n│   │   ├── NonSerialized - 不序列化\r\n│   │   ├── SerializeReference - 引用序列化\r\n│   │   └── Serializable - 可序列化类\r\n│   ├── 组件相关\r\n│   │   ├── RequireComponent - 需要组件\r\n│   │   ├── DisallowMultipleComponent - 禁止多组件\r\n│   │   ├── AddComponentMenu - 添加组件菜单\r\n│   │   └── HideInInspector - 在检视器中隐藏\r\n│   ├── 执行相关\r\n│   │   ├── ExecuteInEditMode - 编辑模式执行\r\n│   │   ├── ExecuteAlways - 总是执行\r\n│   │   └── RuntimeInitializeOnLoadMethod - 运行时初始化\r\n│   └── 场景相关\r\n│       ├── SelectionBase - 选择基础\r\n│       └── PreferBinarySerialization - 偏好二进制序列化\r\n└── API相关特性\r\n    ├── 可见性控制\r\n    │   ├── HideInInspector - 隐藏\r\n    │   ├── FormerlySerializedAs - 曾序列化为\r\n    │   └── ShowInInspector - 在检视器中显示\r\n    ├── 弃用与兼容性\r\n    │   ├── Obsolete - 过时\r\n    │   └── HelpURL - 帮助URL\r\n    └── 其他\r\n        ├── AssemblyIsEditorAssembly - 编辑器程序集\r\n        └── GUITarget - GUI目标\r\n```\r\n\r\n## 常用特性一览表\r\n\r\n### 编辑器界面特性\r\n\r\n| 特性名称 | 应用目标 | 描述 | 示例 |\r\n|---------|---------|------|------|\r\n| **HeaderAttribute** | 字段 | 在Inspector中添加标题 | `[Header(\"Player Settings\")]` |\r\n| **TooltipAttribute** | 字段 | 添加鼠标悬停提示 | `[Tooltip(\"Player's movement speed\")]` |\r\n| **RangeAttribute** | 数值字段 | 限制数值范围并显示滑动条 | `[Range(0, 100)]` |\r\n| **SpaceAttribute** | 字段 | 在Inspector中添加空间 | `[Space(10)]` |\r\n| **TextAreaAttribute** | 字符串字段 | 显示多行文本区域 | `[TextArea(3, 10)]` |\r\n| **ColorUsageAttribute** | Color字段 | 自定义颜色选择器 | `[ColorUsage(true, true)]` |\r\n| **MultilineAttribute** | 字符串字段 | 显示多行输入框 | `[Multiline(3)]` |\r\n| **DelayedAttribute** | 值类型字段 | 延迟更新值 | `[Delayed]` |\r\n\r\n### 序列化特性\r\n\r\n| 特性名称 | 应用目标 | 描述 | 示例 |\r\n|---------|---------|------|------|\r\n| **SerializeField** | 私有字段 | 使私有字段可在Inspector中显示 | `[SerializeField]` |\r\n| **NonSerialized** | 公有字段 | 阻止字段序列化 | `[System.NonSerialized]` |\r\n| **SerializeReference** | 引用类型 | 序列化对象引用而非对象本身 | `[SerializeReference]` |\r\n| **Serializable** | 类 | 标记类为可序列化 | `[System.Serializable]` |\r\n\r\n### 菜单特性\r\n\r\n| 特性名称 | 应用目标 | 描述 | 示例 |\r\n|---------|---------|------|------|\r\n| **MenuItem** | 静态方法 | 创建菜单项 | `[MenuItem(\"Tools/Reset Transform\")]` |\r\n| **ContextMenu** | 方法 | 为组件添加右键菜单项 | `[ContextMenu(\"Reset\")]` |\r\n| **ContextMenuItem** | 字段 | 为字段添加右键菜单项 | `[ContextMenuItem(\"Reset\", \"ResetValue\")]` |\r\n| **CreateAssetMenu** | 类 | 在\"Create\"菜单中添加选项 | `[CreateAssetMenu(fileName = \"New Data\", menuName = \"Game/Data\")]` |\r\n\r\n### 组件相关特性\r\n\r\n| 特性名称 | 应用目标 | 描述 | 示例 |\r\n|---------|---------|------|------|\r\n| **RequireComponent** | 类 | 添加依赖组件 | `[RequireComponent(typeof(Rigidbody))]` |\r\n| **DisallowMultipleComponent** | 类 | 禁止多个相同组件 | `[DisallowMultipleComponent]` |\r\n| **ExecuteInEditMode** | 类 | 在编辑模式下执行 | `[ExecuteInEditMode]` |\r\n| **ExecuteAlways** | 类 | 在编辑和运行模式下执行 | `[ExecuteAlways]` |\r\n| **AddComponentMenu** | 类 | 添加到组件菜单 | `[AddComponentMenu(\"Custom/MyComponent\")]` |\r\n| **HideInInspector** | 字段 | 在Inspector中隐藏字段 | `[HideInInspector]` |\r\n| **SelectionBase** | 类 | 设为场景选择基础 | `[SelectionBase]` |\r\n\r\n### 编辑器定制特性\r\n\r\n| 特性名称 | 应用目标 | 描述 | 示例 |\r\n|---------|---------|------|------|\r\n| **CustomEditor** | 编辑器类 | 自定义Inspector | `[CustomEditor(typeof(MyComponent))]` |\r\n| **CustomPropertyDrawer** | 属性绘制类 | 自定义属性绘制 | `[CustomPropertyDrawer(typeof(MyClass))]` |\r\n| **CanEditMultipleObjects** | 编辑器类 | 支持多对象编辑 | `[CanEditMultipleObjects]` |\r\n| **InitializeOnLoad** | 类 | 编辑器加载时初始化 | `[InitializeOnLoad]` |\r\n| **InitializeOnLoadMethod** | 静态方法 | 编辑器加载时执行方法 | `[InitializeOnLoadMethod]` |\r\n| **OnOpenAsset** | 静态方法 | 资源打开时执行 | `[OnOpenAsset]` |\r\n\r\n## 使用案例\r\n\r\n### 案例1: 自定义组件检视器\r\n\r\n```csharp\r\n// 组件定义\r\npublic class PlayerController : MonoBehaviour\r\n{\r\n    [Header(\"Movement Settings\")]\r\n    [Tooltip(\"Player movement speed in units per second\")]\r\n    [Range(1, 20)]\r\n    public float moveSpeed = 5f;\r\n    \r\n    [Header(\"Jump Settings\")]\r\n    [Tooltip(\"Jump force applied to the player\")]\r\n    public float jumpForce = 10f;\r\n    \r\n    [Space(10)]\r\n    [Header(\"Advanced Settings\")]\r\n    [SerializeField]\r\n    private bool useGravity = true;\r\n    \r\n    [TextArea(3, 5)]\r\n    public string playerDescription = \"Default player character\";\r\n    \r\n    [ContextMenu(\"Reset Values\")]\r\n    void ResetValues()\r\n    {\r\n        moveSpeed = 5f;\r\n        jumpForce = 10f;\r\n        useGravity = true;\r\n    }\r\n}\r\n\r\n// 自定义检视器\r\n[CustomEditor(typeof(PlayerController))]\r\n[CanEditMultipleObjects]\r\npublic class PlayerControllerEditor : Editor\r\n{\r\n    public override void OnInspectorGUI()\r\n    {\r\n        PlayerController player = (PlayerController)target;\r\n        \r\n        EditorGUILayout.LabelField(\"Player Stats Overview\", EditorStyles.boldLabel);\r\n        \r\n        EditorGUI.BeginChangeCheck();\r\n        // 绘制默认检视器\r\n        DrawDefaultInspector();\r\n        \r\n        // 添加自定义按钮\r\n        if(GUILayout.Button(\"Test Jump\"))\r\n        {\r\n            // 执行测试跳跃逻辑\r\n        }\r\n        \r\n        if(EditorGUI.EndChangeCheck())\r\n        {\r\n            Undo.RecordObject(player, \"Changed Player Settings\");\r\n            // 处理更改\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 案例2: 菜单扩展与编辑器工具\r\n\r\n```csharp\r\npublic static class EditorTools\r\n{\r\n    [MenuItem(\"Tools/Reset Scene Objects\")]\r\n    private static void ResetSceneObjects()\r\n    {\r\n        GameObject[] objects = Selection.gameObjects;\r\n        foreach(GameObject obj in objects)\r\n        {\r\n            Undo.RecordObject(obj.transform, \"Reset Transform\");\r\n            obj.transform.position = Vector3.zero;\r\n            obj.transform.rotation = Quaternion.identity;\r\n            obj.transform.localScale = Vector3.one;\r\n        }\r\n    }\r\n    \r\n    [MenuItem(\"Tools/Reset Scene Objects\", true)]\r\n    private static bool ValidateResetSceneObjects()\r\n    {\r\n        return Selection.gameObjects.Length > 0;\r\n    }\r\n    \r\n    [InitializeOnLoadMethod]\r\n    private static void OnProjectLoaded()\r\n    {\r\n        Debug.Log(\"Project loaded in editor\");\r\n        EditorApplication.hierarchyChanged += OnHierarchyChanged;\r\n    }\r\n    \r\n    private static void OnHierarchyChanged()\r\n    {\r\n        // 响应层级视图变化\r\n    }\r\n}\r\n```\r\n\r\n### 案例3: 自定义属性绘制器\r\n\r\n```csharp\r\n// 自定义序列化字段\r\n[System.Serializable]\r\npublic class FloatRange\r\n{\r\n    public float min = 0;\r\n    public float max = 1;\r\n    \r\n    public FloatRange(float min, float max)\r\n    {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    \r\n    public float GetRandomValue()\r\n    {\r\n        return Random.Range(min, max);\r\n    }\r\n}\r\n\r\n// 自定义属性绘制器\r\n[CustomPropertyDrawer(typeof(FloatRange))]\r\npublic class FloatRangeDrawer : PropertyDrawer\r\n{\r\n    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\r\n    {\r\n        EditorGUI.BeginProperty(position, label, property);\r\n        \r\n        position = EditorGUI.PrefixLabel(position, GUIUtility.GetControlID(FocusType.Passive), label);\r\n        \r\n        var minProp = property.FindPropertyRelative(\"min\");\r\n        var maxProp = property.FindPropertyRelative(\"max\");\r\n        \r\n        var minValue = minProp.floatValue;\r\n        var maxValue = maxProp.floatValue;\r\n        \r\n        float rangeMin = 0;\r\n        float rangeMax = 10;\r\n        \r\n        var rangeBounds = new Rect(position);\r\n        rangeBounds.width = position.width;\r\n        \r\n        EditorGUI.MinMaxSlider(rangeBounds, ref minValue, ref maxValue, rangeMin, rangeMax);\r\n        \r\n        var minRect = new Rect(position);\r\n        minRect.width = 50;\r\n        position.xMin += 55;\r\n        \r\n        var maxRect = new Rect(position);\r\n        maxRect.width = 50;\r\n        position.xMin += 55;\r\n        \r\n        minValue = EditorGUI.FloatField(minRect, minValue);\r\n        maxValue = EditorGUI.FloatField(maxRect, maxValue);\r\n        \r\n        minProp.floatValue = minValue;\r\n        maxProp.floatValue = maxValue;\r\n        \r\n        EditorGUI.EndProperty();\r\n    }\r\n}\r\n```\r\n\r\n## 特性使用最佳实践\r\n\r\n1. **组合使用特性**：多个特性可以组合使用，如`[SerializeField]`和`[Range(0,100)]`\r\n\r\n2. **顺序与分组**：使用`Header`和`Space`特性合理组织Inspector界面，提高可读性\r\n\r\n3. **编写自定义特性**：继承`PropertyAttribute`和`PropertyDrawer`可创建自定义特性\r\n\r\n4. **性能考虑**：`ExecuteInEditMode`和`InitializeOnLoad`特性可能影响编辑器性能，应谨慎使用\r\n\r\n5. **特性继承**：特性不会被继承，需要为每个类单独添加特性\r\n\r\n## 总结\r\n\r\nUnity特性系统是扩展编辑器和定制组件行为的强大工具。通过合理使用特性，可以显著提升开发效率、改善编辑器体验并实现复杂的定制功能。特性的组合使用尤其重要，能够创建直观、便于使用的组件检视器和编辑工具。 "
        }
    ]
}