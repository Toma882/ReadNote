{
    "sourceFile": "游戏开发精粹/1/3.数学技巧.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1764086802479,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764087337090,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-﻿# 数学技巧\r\n+# 数学技巧\r\n \r\n ## 1. 可预测随机数生成器\r\n \r\n 使用种子（Seed）生成可重现的随机数序列，确保相同种子产生相同序列。核心思路是：使用线性同余生成器（LCG）或其他确定性算法，通过种子初始化状态，每次调用生成下一个随机数并更新状态。这样既保证了随机性，又实现了可重现性，特别适用于需要回放、同步、测试等场景。\r\n"
                },
                {
                    "date": 1764087385758,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-﻿# 数学技巧\r\n+# 数学技巧\r\n \r\n ## 1. 可预测随机数生成器\r\n \r\n 使用种子（Seed）生成可重现的随机数序列，确保相同种子产生相同序列。核心思路是：使用线性同余生成器（LCG）或其他确定性算法，通过种子初始化状态，每次调用生成下一个随机数并更新状态。这样既保证了随机性，又实现了可重现性，特别适用于需要回放、同步、测试等场景。\r\n"
                }
            ],
            "date": 1764086802479,
            "name": "Commit-0",
            "content": "# 数学技巧\r\n\r\n## 1. 可预测随机数生成器\r\n\r\n使用种子（Seed）生成可重现的随机数序列，确保相同种子产生相同序列。核心思路是：使用线性同余生成器（LCG）或其他确定性算法，通过种子初始化状态，每次调用生成下一个随机数并更新状态。这样既保证了随机性，又实现了可重现性，特别适用于需要回放、同步、测试等场景。\r\n\r\n**伪代码：**\r\n```lua\r\n-- 线性同余生成器（LCG）\r\nclass PredictableRandom {\r\n    seed = 0\r\n    state = 0\r\n    \r\n    function Init(seed) {\r\n        this.seed = seed\r\n        this.state = seed\r\n    }\r\n    \r\n    function Next() {\r\n        -- LCG公式: (a * state + c) mod m\r\n        state = (1103515245 * state + 12345) mod (2^31)\r\n        return state / (2^31)  -- 归一化到[0,1)\r\n    }\r\n    \r\n    function NextInt(min, max) {\r\n        return min + floor(Next() * (max - min))\r\n    }\r\n}\r\n\r\n-- 使用示例\r\nlocal rng = PredictableRandom.New()\r\nrng:Init(12345)  -- 设置种子\r\nlocal value1 = rng:Next()  -- 可重现的随机数\r\nlocal value2 = rng:NextInt(1, 100)  -- 可重现的随机整数\r\n```\r\n\r\n## 2. 替换算法（置换算法）\r\n\r\n通过数组元素的交换实现随机排列，生成无重复的随机序列。核心思路是：从数组末尾开始，每次随机选择一个位置与当前位置交换，确保每个元素只被选择一次。这样既保证了随机性，又避免了重复，特别适用于洗牌、随机选择、生成唯一ID等场景。\r\n\r\n**伪代码：**\r\n```lua\r\n-- Fisher-Yates洗牌算法\r\nfunction Shuffle(array) {\r\n    for i = array.length - 1; i > 0; i-- {\r\n        -- 随机选择[0, i]范围内的索引\r\n        j = random(0, i + 1)\r\n        \r\n        -- 交换元素\r\n        temp = array[i]\r\n        array[i] = array[j]\r\n        array[j] = temp\r\n    }\r\n    return array\r\n}\r\n\r\n-- 使用示例\r\nlocal cards = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\r\nShuffle(cards)  -- 洗牌后的数组\r\n```\r\n\r\n## 3. **无限宇宙算法**\r\n\r\n通过分块生成和坐标映射实现无限大的游戏世界，无需预先生成整个地图。核心思路是：将世界划分为固定大小的区块（Chunk），根据玩家位置动态加载和卸载区块，使用哈希函数将世界坐标映射到区块坐标。这样既实现了无限世界，又控制了内存占用，特别适用于开放世界、程序化生成等场景。\r\n\r\n**伪代码：**\r\n```lua\r\n-- 区块管理系统\r\nclass InfiniteUniverse {\r\n    chunkSize = 100  -- 区块大小\r\n    loadedChunks = {}  -- 已加载的区块\r\n    \r\n    function GetChunkCoord(worldX, worldZ) {\r\n        chunkX = floor(worldX / chunkSize)\r\n        chunkZ = floor(worldZ / chunkSize)\r\n        return {x = chunkX, z = chunkZ}\r\n    }\r\n    \r\n    function GetChunkKey(chunkX, chunkZ) {\r\n        return chunkX .. \"_\" .. chunkZ  -- 生成唯一键\r\n    }\r\n    \r\n    function LoadChunk(chunkX, chunkZ) {\r\n        key = GetChunkKey(chunkX, chunkZ)\r\n        if not loadedChunks[key] {\r\n            -- 程序化生成区块内容\r\n            chunk = GenerateChunk(chunkX, chunkZ)\r\n            loadedChunks[key] = chunk\r\n        }\r\n        return loadedChunks[key]\r\n    }\r\n    \r\n    function UnloadDistantChunks(playerX, playerZ, radius) {\r\n        playerChunk = GetChunkCoord(playerX, playerZ)\r\n        for key, chunk in pairs(loadedChunks) {\r\n            chunkCoord = ParseChunkKey(key)\r\n            distance = Distance(playerChunk, chunkCoord)\r\n            if distance > radius {\r\n                UnloadChunk(chunk)\r\n                loadedChunks[key] = nil\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n-- 使用示例\r\nlocal universe = InfiniteUniverse.New()\r\nlocal chunk = universe:LoadChunk(0, 0)  -- 加载区块(0,0)\r\nuniverse:UnloadDistantChunks(playerX, playerZ, 5)  -- 卸载距离超过5的区块\r\n```\r\n\r\n## 4. 插值方法\r\n\r\n在已知数据点之间计算中间值，实现平滑过渡效果。核心思路是：根据时间或参数t（0到1之间），在起始值和目标值之间进行插值计算，支持线性、平滑、缓动等多种插值函数。这样既实现了平滑的数值过渡，又提供了多种视觉效果，特别适用于动画、UI过渡、相机移动等场景。\r\n\r\n**伪代码：**\r\n```lua\r\n-- 线性插值\r\nfunction Lerp(start, target, t) {\r\n    t = Clamp(t, 0, 1)  -- 限制t在[0,1]\r\n    return start + (target - start) * t\r\n}\r\n\r\n-- 平滑插值（SmoothStep） \r\nfunction SmoothStep(start, target, t) {\r\n    t = Clamp(t, 0, 1)\r\n    t = t * t * (3 - 2 * t)  -- 平滑曲线\r\n    return Lerp(start, target, t)\r\n}\r\n\r\n-- 缓动插值（Ease In Out）\r\nfunction EaseInOut(start, target, t) {\r\n    t = Clamp(t, 0, 1)\r\n    t = t < 0.5 ? 2 * t * t : 1 - pow(-2 * t + 2, 2) / 2\r\n    return Lerp(start, target, t)\r\n}\r\n\r\n-- 向量插值\r\nfunction LerpVector3(start, target, t) {\r\n    return {\r\n        x = Lerp(start.x, target.x, t),\r\n        y = Lerp(start.y, target.y, t),\r\n        z = Lerp(start.z, target.z, t)\r\n    }\r\n}\r\n\r\n-- 使用示例\r\nlocal currentPos = {x = 0, y = 0, z = 0}\r\nlocal targetPos = {x = 10, y = 5, z = 3}\r\nlocal t = 0.5  -- 50%进度\r\nlocal interpolated = LerpVector3(currentPos, targetPos, t)\r\n```\r\n\r\n## 5. 求刚体运动方程的积分\r\n\r\n通过数值积分方法计算刚体的位置和速度，实现物理模拟。核心思路是：使用欧拉法、Verlet积分或RK4等方法，根据力和加速度计算速度变化，根据速度计算位置变化，每帧更新物理状态。这样既实现了真实的物理运动，又保证了数值稳定性，特别适用于物理引擎、弹道计算、碰撞检测等场景。\r\n\r\n### 公式推导过程\r\n\r\n#### 步骤1：基础物理定律\r\n\r\n**牛顿第二定律：**\r\n```\r\nF = ma\r\n```\r\n其中：\r\n- F = 力（Force）\r\n- m = 质量（Mass）\r\n- a = 加速度（Acceleration）\r\n\r\n**加速度定义：**\r\n```\r\na = dv/dt  (加速度是速度对时间的导数)\r\n```\r\n\r\n**速度定义：**\r\n```\r\nv = dp/dt  (速度是位置对时间的导数)\r\n```\r\n\r\n#### 步骤2：从微分方程到积分\r\n\r\n**速度的积分：**\r\n```\r\ndv = a * dt\r\n∫dv = ∫a * dt\r\nv(t) = v₀ + ∫a(t)dt\r\n```\r\n\r\n**位置的积分：**\r\n```\r\ndp = v * dt\r\n∫dp = ∫v(t)dt\r\np(t) = p₀ + ∫v(t)dt\r\n```\r\n\r\n#### 步骤3：欧拉法推导（显式欧拉）\r\n\r\n**基本思想：** 用矩形近似积分\r\n\r\n**速度更新：**\r\n```\r\nv(t+Δt) = v(t) + a(t) * Δt\r\n```\r\n推导：\r\n- 从 v(t+Δt) = v(t) + ∫[t到t+Δt] a(τ)dτ\r\n- 用矩形近似：∫[t到t+Δt] a(τ)dτ ≈ a(t) * Δt\r\n- 因此：v(t+Δt) ≈ v(t) + a(t) * Δt\r\n\r\n**位置更新：**\r\n```\r\np(t+Δt) = p(t) + v(t) * Δt\r\n```\r\n推导：\r\n- 从 p(t+Δt) = p(t) + ∫[t到t+Δt] v(τ)dτ\r\n- 用矩形近似：∫[t到t+Δt] v(τ)dτ ≈ v(t) * Δt\r\n- 因此：p(t+Δt) ≈ p(t) + v(t) * Δt\r\n\r\n**误差分析：**\r\n- 局部截断误差：O(Δt²)\r\n- 全局误差：O(Δt)\r\n- 优点：简单易实现\r\n- 缺点：精度较低，可能不稳定\r\n\r\n#### 步骤4：Verlet积分推导\r\n\r\n**基本思想：** 使用泰勒展开，利用对称性提高精度\r\n\r\n**泰勒展开：**\r\n```\r\np(t+Δt) = p(t) + v(t)Δt + (1/2)a(t)Δt² + O(Δt³)\r\np(t-Δt) = p(t) - v(t)Δt + (1/2)a(t)Δt² + O(Δt³)\r\n```\r\n\r\n**相加消去速度项：**\r\n```\r\np(t+Δt) + p(t-Δt) = 2p(t) + a(t)Δt² + O(Δt³)\r\n```\r\n\r\n**Verlet位置公式：**\r\n```\r\np(t+Δt) = 2p(t) - p(t-Δt) + a(t)Δt²\r\n```\r\n\r\n**速度计算（从位置差分）：**\r\n```\r\nv(t) = [p(t+Δt) - p(t-Δt)] / (2Δt)\r\n```\r\n或者使用半步长：\r\n```\r\nv(t) = [p(t) - p(t-Δt)] / Δt\r\n```\r\n\r\n**误差分析：**\r\n- 局部截断误差：O(Δt³)\r\n- 全局误差：O(Δt²)\r\n- 优点：精度更高，能量守恒更好\r\n- 缺点：需要保存上一帧位置\r\n\r\n#### 步骤5：完整推导示例（自由落体）\r\n\r\n**初始条件：**\r\n```\r\np₀ = 0, v₀ = 0, a = -g (重力加速度)\r\n```\r\n\r\n**欧拉法：**\r\n```\r\nv₁ = v₀ + a*Δt = 0 + (-g)*Δt = -g*Δt\r\np₁ = p₀ + v₀*Δt = 0 + 0*Δt = 0\r\n\r\nv₂ = v₁ + a*Δt = -g*Δt + (-g)*Δt = -2g*Δt\r\np₂ = p₁ + v₁*Δt = 0 + (-g*Δt)*Δt = -g*Δt²\r\n```\r\n\r\n**解析解（对比）：**\r\n```\r\nv(t) = -gt\r\np(t) = -(1/2)gt²\r\n```\r\n\r\n**在t=Δt时：**\r\n- 解析解：p(Δt) = -(1/2)g*Δt²\r\n- 欧拉法：p₁ = 0（误差较大）\r\n- 改进：使用v₁计算p₁，p₁ = -(1/2)g*Δt²（更准确）\r\n\r\n#### 步骤6：不同积分方法对比\r\n\r\n| 方法 | 精度 | 稳定性 | 计算量 | 适用场景 |\r\n|------|------|--------|--------|----------|\r\n| **显式欧拉** | O(Δt) | 较差 | 低 | 简单物理、快速原型 |\r\n| **隐式欧拉** | O(Δt) | 好 | 高 | 需要稳定性的场景 |\r\n| **Verlet** | O(Δt²) | 好 | 中 | 分子动力学、游戏物理 |\r\n| **RK4** | O(Δt⁴) | 好 | 高 | 高精度需求 |\r\n\r\n#### 步骤7：实际应用注意事项\r\n\r\n1. **时间步长选择：**\r\n   - 固定时间步：Δt = 1/60 ≈ 0.016s（60FPS）\r\n   - 可变时间步：Δt = Time.deltaTime（适应帧率变化）\r\n   - 子步长：大Δt拆分为多个小步，提高精度\r\n\r\n2. **数值稳定性：**\r\n   - 欧拉法：Δt过大可能导致能量发散\r\n   - Verlet：能量守恒更好，适合长时间模拟\r\n   - 阻尼：添加速度阻尼避免数值误差累积\r\n\r\n3. **改进的欧拉法（半隐式欧拉）：**\r\n   ```\r\n   v(t+Δt) = v(t) + a(t) * Δt\r\n   p(t+Δt) = p(t) + v(t+Δt) * Δt  // 使用新速度\r\n   ```\r\n   这样位置更新使用新速度，精度更高。\r\n\r\n**伪代码：**\r\n```lua\r\n-- 欧拉法积分\r\nclass RigidBody {\r\n    position = {x = 0, y = 0, z = 0}\r\n    velocity = {x = 0, y = 0, z = 0}\r\n    mass = 1.0\r\n    force = {x = 0, y = 0, z = 0}\r\n    \r\n    function Update(deltaTime) {\r\n        -- 计算加速度: F = ma => a = F/m\r\n        acceleration = {\r\n            x = force.x / mass,\r\n            y = force.y / mass,\r\n            z = force.z / mass\r\n        }\r\n        \r\n        -- 欧拉法积分: v = v0 + a*dt, p = p0 + v*dt\r\n        velocity.x = velocity.x + acceleration.x * deltaTime\r\n        velocity.y = velocity.y + acceleration.y * deltaTime\r\n        velocity.z = velocity.z + acceleration.z * deltaTime\r\n        \r\n        position.x = position.x + velocity.x * deltaTime\r\n        position.y = position.y + velocity.y * deltaTime\r\n        position.z = position.z + velocity.z * deltaTime\r\n        \r\n        -- 重置力（每帧重新计算）\r\n        force = {x = 0, y = 0, z = 0}\r\n    }\r\n    \r\n    function AddForce(fx, fy, fz) {\r\n        force.x = force.x + fx\r\n        force.y = force.y + fy\r\n        force.z = force.z + fz\r\n    }\r\n}\r\n\r\n-- Verlet积分（更稳定）\r\nfunction VerletIntegration(position, velocity, acceleration, deltaTime) {\r\n    -- 保存上一帧位置\r\n    oldPosition = position\r\n    \r\n    -- 更新位置: p = 2*p - p_old + a*dt^2\r\n    newPosition = {\r\n        x = 2 * position.x - oldPosition.x + acceleration.x * deltaTime * deltaTime,\r\n        y = 2 * position.y - oldPosition.y + acceleration.y * deltaTime * deltaTime,\r\n        z = 2 * position.z - oldPosition.z + acceleration.z * deltaTime * deltaTime\r\n    }\r\n    \r\n    -- 计算速度: v = (p - p_old) / dt\r\n    newVelocity = {\r\n        x = (newPosition.x - oldPosition.x) / deltaTime,\r\n        y = (newPosition.y - oldPosition.y) / deltaTime,\r\n        z = (newPosition.z - oldPosition.z) / deltaTime\r\n    }\r\n    \r\n    return newPosition, newVelocity\r\n}\r\n\r\n-- 使用示例\r\nlocal body = RigidBody.New()\r\nbody:AddForce(0, -9.8, 0)  -- 重力\r\nbody:Update(0.016)  -- 更新（假设60FPS）\r\n```\r\n\r\n"
        }
    ]
}