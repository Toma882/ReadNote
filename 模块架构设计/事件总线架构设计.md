# CommunicationBus 通讯总线

## 设计核心

CommunicationBus 是一个统一的通讯总线系统，通过多频道架构提供四种不同的通信模式，满足游戏开发中各种场景的通信需求。

### 整体数据流图

```mermaid
flowchart TB
    subgraph "应用层"
        App1[应用模块1]
        App2[应用模块2]
        App3[应用模块3]
    end
    
    subgraph "CommunicationBus 统一接口层"
        CB[CommunicationBus]
    end
    
    subgraph "频道层"
        EC[EventChannel<br/>发布-订阅]
        MC[MessageChannel<br/>点对点]
        PC[PushChannel<br/>数据推送]
        QC[QueryChannel<br/>请求-响应]
    end
    
    subgraph "基础组件"
        ProgC[progresserGroup<br/>处理器组基础类]
    end
    
    App1 -->|Broadcast/Subscribe| CB
    App2 -->|Broadcast/Subscribe| CB
    App3 -->|QueryData/PushData| CB
    
    CB -->|路由| EC
    CB -->|路由| MC
    CB -->|路由| PC
    CB -->|路由| QC
    
    PC --> ProgC
    QC --> ProgC
    
    EC -->|通知| App1
    EC -->|通知| App2
    MC -->|消息| App2
    PC -->|处理| App3
    QC -->|结果| App3
    
    style CB fill:#e1f5ff
    style EC fill:#fff4e1
    style MC fill:#fff4e1
    style PC fill:#e8f5e9
    style QC fill:#e8f5e9
    style ProgC fill:#f3e5f5
```

## 系统架构

### 架构图

```mermaid
graph TB
    CB[CommunicationBus<br/>统一接口层]
    
    CB --> EC[EventChannel<br/>发布-订阅模式]
    CB --> MC[MessageChannel<br/>点对点模式]
    CB --> PC[PushChannel<br/>数据推送模式]
    CB --> QC[QueryChannel<br/>请求-响应模式]
    
    PC --> ProgC1[progresserGroup<br/>处理器组基础类]
    QC --> ProgC2[progresserGroup<br/>处理器组基础类]
    
    EC --> EL[EventListeners<br/>事件监听器集合]
    MC --> ML[MessageListeners<br/>消息监听器集合]
    PC --> DQ[DataQueuePool<br/>数据队列池]
    QC --> QD[QueryDelegates<br/>查询委托集合]
    
    ProgC1 --> SubSet1[SubscriberSet<br/>订阅者集合]
    ProgC1 --> HandlerMap[HandlerMap<br/>处理器映射]
    
    ProgC2 --> SubSet2[SubscriberSet<br/>订阅者集合]
    ProgC2 --> QD
    
    style CB fill:#e1f5ff
    style EC fill:#fff4e1
    style MC fill:#fff4e1
    style PC fill:#e8f5e9
    style QC fill:#e8f5e9
    style ProgC1 fill:#f3e5f5
    style ProgC2 fill:#f3e5f5
```

### 组件关系

```text
CommunicationBus (统一接口层)
    ├── EventChannel (发布-订阅模式)
    ├── MessageChannel (点对点模式)
    ├── PushChannel (数据推送模式)
    │   └── progresserGroup (处理器组基础类)
    └── QueryChannel (请求-响应模式)
        └── progresserGroup (处理器组基础类)
```

## 四种通信模式

### 1. EventChannel - 发布-订阅模式

**设计理念**: 一对多事件通知，支持多个订阅者同时接收同一事件。

**特点**:

- 支持多个订阅者订阅同一事件
- 支持作用域过滤（Global/Local/Group/Range）
- 事件广播时所有匹配的订阅者都会收到通知

**流程图**:

```mermaid
sequenceDiagram
    participant P as 发布者
    participant CB as CommunicationBus
    participant EC as EventChannel
    participant S1 as 订阅者1
    participant S2 as 订阅者2
    participant S3 as 订阅者3
    
    Note over S1,S3: 订阅阶段
    S1->>CB: Subscribe(EventContext)
    S2->>CB: Subscribe(EventContext)
    S3->>CB: Subscribe(EventContext)
    CB->>EC: 注册订阅者
    
    Note over P,S3: 广播阶段
    P->>CB: Broadcast(EventContext, data)
    CB->>EC: 路由到EventChannel
    EC->>EC: 根据broadcastId查找监听器
    EC->>EC: 根据scopeType过滤订阅者
    
    par 并行通知所有匹配订阅者
        EC->>S1: 执行回调(data)
        EC->>S2: 执行回调(data)
    end
    
    Note over S3: S3不匹配scopeType，不接收
```

**流程**:

```text
发布者 → Broadcast(EventContext) → EventChannel → 匹配订阅者 → 执行回调
```

### 2. MessageChannel - 点对点模式

**设计理念**: 一对一消息传递，后订阅覆盖前订阅。

**特点**:

- 每个消息ID只能有一个订阅者
- 新订阅会覆盖旧订阅
- 适用于需要唯一接收者的场景

**流程图**:

```mermaid
sequenceDiagram
    participant S1 as 订阅者1
    participant CB as CommunicationBus
    participant MC as MessageChannel
    participant S2 as 订阅者2
    participant Sender as 发送者
    
    Note over S1: 第一个订阅
    S1->>CB: Subscribe(MessageContext)
    CB->>MC: 注册订阅者1
    
    Note over S2: 第二个订阅（覆盖）
    S2->>CB: Subscribe(MessageContext)
    CB->>MC: 覆盖订阅者1，注册订阅者2
    
    Note over Sender: 发送消息
    Sender->>CB: Broadcast(MessageContext, data)
    CB->>MC: 路由到MessageChannel
    MC->>MC: 查找唯一订阅者
    MC->>S2: 执行回调(data)
    
    Note over S1: 订阅者1不再接收消息
```

### 3. PushChannel - 数据推送模式

**设计理念**: 数据驱动模式，支持批量数据处理和延迟处理。

**特点**:

- 数据先推送到队列，按需处理
- 支持 IsDirty 机制控制处理时机
- 支持多种数据类型独立处理
- 每个订阅者拥有独立的数据队列

**流程图**:

```mermaid
flowchart TD
    Start([数据源]) --> Push[PushData<br/>推送数据]
    Push --> Queue{数据队列<br/>按订阅者+数据类型}
    Queue --> Queue1[订阅者1队列]
    Queue --> Queue2[订阅者2队列]
    
    Queue1 --> Wait[等待处理]
    Queue2 --> Wait
    
    Wait --> Process[ProcessData<br/>处理数据]
    Process --> Check{检查IsDirty}
    
    Check -->|IsDirty=true| Batch[批量处理<br/>所有队列数据]
    Check -->|IsDirty=false| Skip[跳过处理]
    
    Batch --> Handler[执行处理器<br/>processFunction]
    Handler --> Mark[MarkDirty<br/>标记已处理]
    Mark --> Clear[清空队列]
    
    Skip --> End([结束])
    Clear --> End
    
    style Queue fill:#e1f5ff
    style Check fill:#fff4e1
    style Batch fill:#e8f5e9
```

**关键机制**:

- **数据队列**: 按订阅者和数据类型组织，使用 LuaSet 去重
- **IsDirty**: 处理器可控制是否处理数据（默认处理）
- **批量处理**: 一次性处理队列中所有数据
- **推送链**: 处理一个数据类型时，可以触发下一个数据类型的推送，形成链式处理

### 推送链机制

PushChannel 支持推送链模式，即处理一个数据类型时，可以在处理器中触发下一个数据类型的推送，形成链式数据流。

**推送链流程图**:

```mermaid
flowchart LR
    Start([初始触发]) --> EI[EquipInstall<br/>装备安装]
    EI -->|处理时推送| FI[FeatInstall<br/>专长安装]
    FI -->|处理时推送| SD[SkillData<br/>技能数据]
    SD -->|处理时推送| ED[EffectData<br/>效果数据]
    ED --> End([链式处理完成])
    
    style EI fill:#e1f5ff
    style FI fill:#fff4e1
    style SD fill:#e8f5e9
    style ED fill:#f3e5f5
```

**推送链序列图**:

```mermaid
sequenceDiagram
    participant Source as 数据源
    participant PC as PushChannel
    participant Handler1 as EquipInstall处理器
    participant Handler2 as FeatInstall处理器
    participant Handler3 as SkillData处理器
    participant Handler4 as EffectData处理器
    
    Source->>PC: PushData(EquipInstall)
    PC->>PC: 数据入队
    
    Note over PC: ProcessData触发处理
    PC->>Handler1: 处理EquipInstall数据
    Handler1->>PC: PushData(FeatInstall)
    PC->>PC: FeatInstall数据入队
    
    PC->>Handler2: 处理FeatInstall数据
    Handler2->>PC: PushData(SkillData)
    PC->>PC: SkillData数据入队
    
    PC->>Handler3: 处理SkillData数据
    Handler3->>PC: PushData(EffectData)
    PC->>PC: EffectData数据入队
    
    PC->>Handler4: 处理EffectData数据
    Handler4->>PC: 处理完成
    
    Note over PC: 推送链处理完成
```

**推送链特点**:

- **链式触发**: 每个处理器的处理过程可以触发下一个数据类型的推送
- **自动流转**: 数据按照定义的链式关系自动流转处理
- **解耦设计**: 每个环节独立处理，降低模块间耦合
- **灵活扩展**: 可以轻松添加或修改链式环节

**设计模式**:

推送链采用了 **管道-过滤器模式（Pipeline-Filter Pattern）** 和 **责任链模式（Chain of Responsibility）** 的混合设计：

- **管道-过滤器模式**：数据在 PushChannel 管道中流动，每个 Handler 作为过滤器处理数据，处理完后可以产生新的数据推送到管道中继续流动
- **责任链模式变种**：每个 Handler 处理完自己的数据类型后，主动触发下一个环节的数据推送，形成责任链式的处理流程

**模式优势**:

- ✅ **解耦**: 每个 Handler 独立，不直接依赖其他 Handler
- ✅ **灵活**: 可以动态添加、移除或调整链式环节
- ✅ **可扩展**: 新的数据类型可以轻松插入到链中
- ✅ **可测试**: 每个环节可以独立测试

### 4. QueryChannel - 请求-响应模式

**设计理念**: 同步查询模式，立即返回结果。

**特点**:

- 同步调用，立即返回结果
- 支持带参数的查询
- 查询不存在的委托返回 false

**流程图**:

```mermaid
sequenceDiagram
    participant Q as 查询者
    participant CB as CommunicationBus
    participant QC as QueryChannel
    participant PC as progresserGroup
    participant D as 委托函数
    
    Note over D: 注册阶段
    D->>CB: AddQueryDelegate(QueryDelegateContext)
    CB->>PC: 注册委托函数
    
    Note over Q: 查询阶段
    Q->>CB: QueryData(QueryContext, args)
    CB->>QC: 路由到QueryChannel
    QC->>PC: GetQueryDelegate(context)
    PC->>PC: 查找委托函数
    
    alt 委托存在
        PC-->>QC: 返回委托函数
        QC->>D: 执行委托函数(args)
        D-->>QC: 返回结果
        QC-->>CB: 返回结果
        CB-->>Q: 返回结果
    else 委托不存在
        PC-->>QC: 返回nil
        QC-->>CB: 返回false
        CB-->>Q: 返回false
    end
```

## 统一接口设计

CommunicationBus 提供统一的接口层，根据 Context 中的 `channelType` 自动路由到对应的频道：

### 接口路由图

```mermaid
flowchart LR
    User[用户代码] --> CB[CommunicationBus]
    
    CB --> Route{根据channelType<br/>路由}
    
    Route -->|Event| EC[EventChannel]
    Route -->|Message| MC[MessageChannel]
    Route -->|Push| PC[PushChannel]
    Route -->|Query| QC[QueryChannel]
    
    CB --> Methods[统一接口]
    Methods --> M1[Broadcast]
    Methods --> M2[Subscribe]
    Methods --> M3[Unsubscribe]
    Methods --> M4[QueryData]
    Methods --> M5[PushData]
    Methods --> M6[ProcessData]
    
    style CB fill:#e1f5ff
    style Route fill:#fff4e1
    style Methods fill:#e8f5e9
```

### 接口列表

- `Broadcast(context, ...)`: 统一发送接口
- `Subscribe(context)`: 统一订阅接口
- `Unsubscribe(context)`: 统一取消订阅接口
- `QueryData(context, ...)`: 查询接口（仅 Query 频道）
- `PushData(context)`: 数据推送接口（仅 Push 频道）
- `ProcessData(subscriber)`: 数据处理接口（仅 Push 频道）

## 作用域机制

系统支持四种作用域类型，用于过滤消息接收者：

### 作用域过滤图

```mermaid
graph TB
    Sender[发送者] --> Scope{作用域类型}
    
    Scope -->|Global| All[所有订阅者]
    Scope -->|Local| Local[局部范围订阅者]
    Scope -->|Group| Group[同组订阅者]
    Scope -->|Range| Range[距离范围内订阅者]
    
    All --> Sub1[订阅者1]
    All --> Sub2[订阅者2]
    All --> Sub3[订阅者3]
    
    Local --> Sub1
    Local --> Sub2
    
    Group --> Sub2
    Group --> Sub3
    
    Range --> Sub1
    
    style Scope fill:#fff4e1
    style All fill:#e8f5e9
    style Local fill:#e8f5e9
    style Group fill:#e8f5e9
    style Range fill:#e8f5e9
```

### 作用域类型

- **Global**: 全局作用域，所有订阅者都能收到
- **Local**: 局部作用域，只有指定范围内的订阅者能收到
- **Group**: 组作用域，只有同组的订阅者能收到
- **Range**: 距离作用域，只有距离范围内的订阅者能收到

## 核心组件

### ProgresserGroup（处理器组基础类）

**命名说明**：

- **类名**：`ProgresserGroup`（大写开头，表示类）
- **变量名**：`progresserGroup`（小写开头，表示实例）

ProgresserGroup 是 PushChannel 和 QueryChannel 的基础组件，提供：

**组件结构图**:

```mermaid
classDiagram
    class ProgresserGroup {
        +LuaSet subscriberSet
        +table linkHandlerMap
        +table queryDelegates
        +Subscribe(subscriber)
        +Unsubscribe(subscriber)
        +AddHandler(context)
        +GetHandlers(subscriber)
        +RemoveHandler(subscriber, handler)
        +AddQueryDelegate(context)
        +GetQueryDelegate(context)
        +Clear()
    }
    
    class PushChannel {
        +ProgresserGroup progresserGroup
        +table dataQueuePool
        +PushData(context)
        +ProcessData(subscriber)
        +ProcessHandler(context)
        +PopAllData(subscriber, dataType)
    }
    
    class QueryChannel {
        +ProgresserGroup progresserGroup
        +QueryData(context, ...args)
    }
    
    ProgresserGroup <|-- PushChannel : 使用
    ProgresserGroup <|-- QueryChannel : 使用
```

**功能**:

- **订阅管理**: 管理订阅者集合
- **处理器管理**: 管理每个订阅者的处理器列表
- **委托管理**: 管理查询委托（Query 专用）

### 数据上下文类型

系统使用类型化的上下文对象来传递参数：

- `BroadcastContext`: 广播上下文
- `BroadcastSubscribeContext`: 订阅上下文
- `PushDataContext`: 推送数据上下文
- `ProgressHandlerContext`: 处理器上下文
- `QueryDelegateContext`: 查询委托上下文

## 使用场景

- **EventChannel**: UI事件、游戏事件、系统通知
- **MessageChannel**: 命令传递、状态同步、唯一接收者场景
- **PushChannel**: 属性变更、批量数据更新、延迟处理场景
- **QueryChannel**: 数据查询、状态获取、同步调用场景

## 设计优势

1. **统一接口**: 所有通信模式通过统一接口访问，降低使用复杂度
2. **类型安全**: 使用类型化的上下文对象，减少参数错误
3. **灵活扩展**: 频道架构易于扩展新的通信模式
4. **性能优化**: PushChannel 支持批量处理和延迟处理，减少频繁调用
5. **错误处理**: 所有频道都包含错误捕获机制，避免回调错误影响系统稳定性
