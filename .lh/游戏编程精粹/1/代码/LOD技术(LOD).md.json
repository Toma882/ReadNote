{
    "sourceFile": "游戏编程精粹/1/代码/LOD技术(LOD).md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1765003233802,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1765003233802,
            "name": "Commit-0",
            "content": "# LOD技术（Level of Detail）- C#实现\r\n\r\n## 核心概念\r\n\r\n- **定义**：根据距离和屏幕空间选择不同细节层次的模型，优化渲染性能\r\n- **核心思想**：远距离使用低精度模型，近距离使用高精度模型\r\n- **应用场景**：大规模场景优化、减少DrawCall、提高帧率\r\n- **Unity应用**：Unity有LOD Group组件，但了解选择算法有助于优化\r\n\r\n---\r\n\r\n## 4.9 几何体细节层次选择问题（LOD）\r\n\r\n### 核心原理\r\n\r\n- **算法思想**：根据对象到摄像机的距离或屏幕空间大小，选择不同细节层次的模型\r\n- **LOD级别**：通常有3-4个级别（LOD0高精度，LOD1中精度，LOD2低精度，LOD3最低精度）\r\n- **选择标准**：\r\n  - **距离**：根据对象到摄像机的距离\r\n  - **屏幕空间**：根据对象在屏幕上的大小（像素数）\r\n  - **重要性**：根据对象的重要性（玩家关注度）\r\n\r\n### 实现代码\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// LOD选择算法\r\n/// </summary>\r\npublic static class LODSelection\r\n{\r\n    /// <summary>\r\n    /// 基于距离的LOD选择\r\n    /// </summary>\r\n    public static int SelectLODByDistance(Vector3 objectPos, Vector3 cameraPos, float[] distanceThresholds)\r\n    {\r\n        float distance = Vector3.Distance(objectPos, cameraPos);\r\n        \r\n        for (int i = 0; i < distanceThresholds.Length; i++)\r\n        {\r\n            if (distance <= distanceThresholds[i])\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n        \r\n        return distanceThresholds.Length;  // 最远距离，使用最低LOD\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 基于屏幕空间的LOD选择（更准确）\r\n    /// </summary>\r\n    public static int SelectLODByScreenSpace(Bounds bounds, Camera camera, float[] screenSizeThresholds)\r\n    {\r\n        // 计算对象在屏幕上的大小（像素数）\r\n        float screenSize = GetScreenSize(bounds, camera);\r\n        \r\n        for (int i = 0; i < screenSizeThresholds.Length; i++)\r\n        {\r\n            if (screenSize >= screenSizeThresholds[i])\r\n            {\r\n                return i;\r\n            }\r\n        }\r\n        \r\n        return screenSizeThresholds.Length;  // 最小屏幕空间，使用最低LOD\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 计算对象在屏幕上的大小（像素数）\r\n    /// </summary>\r\n    private static float GetScreenSize(Bounds bounds, Camera camera)\r\n    {\r\n        // 计算包围盒的8个顶点在屏幕上的投影\r\n        Vector3[] corners = GetBoundsCorners(bounds);\r\n        Vector2 minScreen = new Vector2(float.MaxValue, float.MaxValue);\r\n        Vector2 maxScreen = new Vector2(float.MinValue, float.MinValue);\r\n        \r\n        foreach (Vector3 corner in corners)\r\n        {\r\n            Vector3 screenPos = camera.WorldToScreenPoint(corner);\r\n            if (screenPos.z > 0)  // 在摄像机前方\r\n            {\r\n                minScreen.x = Mathf.Min(minScreen.x, screenPos.x);\r\n                minScreen.y = Mathf.Min(minScreen.y, screenPos.y);\r\n                maxScreen.x = Mathf.Max(maxScreen.x, screenPos.x);\r\n                maxScreen.y = Mathf.Max(maxScreen.y, screenPos.y);\r\n            }\r\n        }\r\n        \r\n        // 计算屏幕空间大小（像素数）\r\n        float width = maxScreen.x - minScreen.x;\r\n        float height = maxScreen.y - minScreen.y;\r\n        return Mathf.Max(width, height);\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取包围盒的8个顶点\r\n    /// </summary>\r\n    private static Vector3[] GetBoundsCorners(Bounds bounds)\r\n    {\r\n        Vector3 center = bounds.center;\r\n        Vector3 extents = bounds.extents;\r\n        \r\n        return new Vector3[]\r\n        {\r\n            center + new Vector3(-extents.x, -extents.y, -extents.z),\r\n            center + new Vector3(extents.x, -extents.y, -extents.z),\r\n            center + new Vector3(-extents.x, extents.y, -extents.z),\r\n            center + new Vector3(extents.x, extents.y, -extents.z),\r\n            center + new Vector3(-extents.x, -extents.y, extents.z),\r\n            center + new Vector3(extents.x, -extents.y, extents.z),\r\n            center + new Vector3(-extents.x, extents.y, extents.z),\r\n            center + new Vector3(extents.x, extents.y, extents.z)\r\n        };\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 综合LOD选择（距离 + 屏幕空间）\r\n    /// </summary>\r\n    public static int SelectLOD(Bounds bounds, Vector3 objectPos, Camera camera, \r\n        float[] distanceThresholds, float[] screenSizeThresholds)\r\n    {\r\n        // 先基于距离选择\r\n        int distanceLOD = SelectLODByDistance(objectPos, camera.transform.position, distanceThresholds);\r\n        \r\n        // 再基于屏幕空间选择\r\n        int screenLOD = SelectLODByScreenSpace(bounds, camera, screenSizeThresholds);\r\n        \r\n        // 选择较低的LOD（更优化）\r\n        return Mathf.Max(distanceLOD, screenLOD);\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// LOD管理器\r\n/// </summary>\r\npublic class LODManager : MonoBehaviour\r\n{\r\n    public Camera mainCamera;\r\n    public List<LODObject> lodObjects = new List<LODObject>();\r\n    \r\n    [Header(\"LOD阈值\")]\r\n    public float[] distanceThresholds = new float[] { 10f, 30f, 60f };\r\n    public float[] screenSizeThresholds = new float[] { 200f, 100f, 50f };\r\n    \r\n    void Update()\r\n    {\r\n        foreach (LODObject lodObj in lodObjects)\r\n        {\r\n            if (lodObj != null && lodObj.gameObject.activeSelf)\r\n            {\r\n                int lodLevel = LODSelection.SelectLOD(\r\n                    lodObj.bounds,\r\n                    lodObj.transform.position,\r\n                    mainCamera,\r\n                    distanceThresholds,\r\n                    screenSizeThresholds\r\n                );\r\n                \r\n                lodObj.SetLOD(lodLevel);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// LOD对象\r\n/// </summary>\r\npublic class LODObject : MonoBehaviour\r\n{\r\n    public Renderer[] lodRenderers;  // 不同LOD级别的Renderer\r\n    public Bounds bounds;\r\n    \r\n    void Start()\r\n    {\r\n        // 计算包围盒\r\n        if (lodRenderers.Length > 0 && lodRenderers[0] != null)\r\n        {\r\n            bounds = lodRenderers[0].bounds;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 设置LOD级别\r\n    /// </summary>\r\n    public void SetLOD(int lodLevel)\r\n    {\r\n        for (int i = 0; i < lodRenderers.Length; i++)\r\n        {\r\n            if (lodRenderers[i] != null)\r\n            {\r\n                lodRenderers[i].enabled = (i == lodLevel);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4.12 独立于观察的渐进网格（Progressive Mesh）\r\n\r\n### 核心原理\r\n\r\n- **算法思想**：动态调整模型细节，根据距离或重要性逐步简化或细化网格\r\n- **特点**：比传统LOD更灵活，可以平滑过渡\r\n- **应用**：大规模场景优化、动态细节调整\r\n\r\n### 实现代码\r\n\r\n```csharp\r\n/// <summary>\r\n/// 渐进网格简化（基于边折叠）\r\n/// </summary>\r\npublic class ProgressiveMesh\r\n{\r\n    /// <summary>\r\n    /// 网格边\r\n    /// </summary>\r\n    public struct Edge\r\n    {\r\n        public int vertex1;\r\n        public int vertex2;\r\n        public float cost;  // 折叠代价\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 简化网格（减少顶点数）\r\n    /// </summary>\r\n    public static Mesh SimplifyMesh(Mesh originalMesh, int targetVertexCount)\r\n    {\r\n        // 获取原始网格数据\r\n        Vector3[] vertices = originalMesh.vertices;\r\n        int[] triangles = originalMesh.triangles;\r\n        \r\n        // 计算边折叠代价\r\n        List<Edge> edges = CalculateEdgeCosts(vertices, triangles);\r\n        \r\n        // 按代价排序\r\n        edges.Sort((a, b) => a.cost.CompareTo(b.cost));\r\n        \r\n        // 逐步折叠边，直到达到目标顶点数\r\n        // 注意：这是简化版本，实际实现更复杂\r\n        \r\n        // 创建简化后的网格\r\n        Mesh simplifiedMesh = new Mesh();\r\n        // ... 实现网格简化逻辑\r\n        \r\n        return simplifiedMesh;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 计算边折叠代价\r\n    /// </summary>\r\n    private static List<Edge> CalculateEdgeCosts(Vector3[] vertices, int[] triangles)\r\n    {\r\n        List<Edge> edges = new List<Edge>();\r\n        \r\n        // 遍历所有三角形，找到所有边\r\n        for (int i = 0; i < triangles.Length; i += 3)\r\n        {\r\n            int v1 = triangles[i];\r\n            int v2 = triangles[i + 1];\r\n            int v3 = triangles[i + 2];\r\n            \r\n            // 计算三条边的折叠代价\r\n            AddEdge(edges, v1, v2, vertices);\r\n            AddEdge(edges, v2, v3, vertices);\r\n            AddEdge(edges, v3, v1, vertices);\r\n        }\r\n        \r\n        return edges;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 添加边（如果不存在）\r\n    /// </summary>\r\n    private static void AddEdge(List<Edge> edges, int v1, int v2, Vector3[] vertices)\r\n    {\r\n        // 检查边是否已存在\r\n        foreach (Edge edge in edges)\r\n        {\r\n            if ((edge.vertex1 == v1 && edge.vertex2 == v2) ||\r\n                (edge.vertex1 == v2 && edge.vertex2 == v1))\r\n            {\r\n                return;\r\n            }\r\n        }\r\n        \r\n        // 计算折叠代价（简化：使用边长度）\r\n        float cost = Vector3.Distance(vertices[v1], vertices[v2]);\r\n        \r\n        edges.Add(new Edge { vertex1 = v1, vertex2 = v2, cost = cost });\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 渐进网格管理器\r\n/// </summary>\r\npublic class ProgressiveMeshManager : MonoBehaviour\r\n{\r\n    public MeshFilter meshFilter;\r\n    public Camera mainCamera;\r\n    \r\n    [Header(\"LOD设置\")]\r\n    public int[] lodVertexCounts = new int[] { 1000, 500, 200, 50 };\r\n    public float[] distanceThresholds = new float[] { 10f, 30f, 60f };\r\n    \r\n    private Mesh[] lodMeshes;\r\n    private Mesh originalMesh;\r\n    \r\n    void Start()\r\n    {\r\n        originalMesh = meshFilter.mesh;\r\n        lodMeshes = new Mesh[lodVertexCounts.Length];\r\n        \r\n        // 生成不同LOD级别的网格\r\n        for (int i = 0; i < lodVertexCounts.Length; i++)\r\n        {\r\n            lodMeshes[i] = ProgressiveMesh.SimplifyMesh(originalMesh, lodVertexCounts[i]);\r\n        }\r\n    }\r\n    \r\n    void Update()\r\n    {\r\n        float distance = Vector3.Distance(transform.position, mainCamera.transform.position);\r\n        \r\n        // 根据距离选择LOD\r\n        int lodLevel = 0;\r\n        for (int i = 0; i < distanceThresholds.Length; i++)\r\n        {\r\n            if (distance > distanceThresholds[i])\r\n            {\r\n                lodLevel = i + 1;\r\n            }\r\n        }\r\n        \r\n        lodLevel = Mathf.Clamp(lodLevel, 0, lodMeshes.Length - 1);\r\n        meshFilter.mesh = lodMeshes[lodLevel];\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Unity应用建议\r\n\r\n1. **使用Unity LOD Group**：\r\n   - Unity有内置LOD Group组件\r\n   - 在Inspector中设置不同LOD级别的模型\r\n   - 自动根据距离切换\r\n\r\n2. **性能优化**：\r\n   - 合理设置LOD阈值\r\n   - 使用屏幕空间大小而非仅距离\r\n   - 考虑对象重要性\r\n\r\n3. **渐进网格**：\r\n   - Unity不直接支持，需要使用第三方工具\r\n   - 可以使用`Mesh Simplifier`等插件\r\n   - 或自己实现边折叠算法\r\n\r\n---\r\n\r\n## 参考文献\r\n\r\n- 《游戏编程精粹1》- 4.9 几何体细节层次选择问题（LOD）\r\n- 《游戏编程精粹1》- 4.12 独立于观察的渐进网格\r\n\r\n"
        }
    ]
}