using UnityEngine;
using Unity.Jobs;
using Unity.Collections;
using Unity.Mathematics;
using Unity.Burst;
using Unity.Jobs.LowLevel.Unsafe;

/// <summary>
/// Unity JobSystem 完整 API 示例
/// 涵盖所有重要的 Job 接口、NativeContainer、分配器和最佳实践
/// </summary>
public class JobsCompleteExample : MonoBehaviour
{
    [Header("测试设置")]
    [SerializeField] private int arraySize = 10000;
    [SerializeField] private bool useBurst = true;
    
    private void Start()
    {
        Debug.Log("=== Unity JobSystem 完整 API 示例 ===");
        TestAllJobInterfaces();
        TestAllNativeContainers();
        TestAllocators();
        TestDependencyManagement();
        TestAsyncPattern();
    }

    #region 1. 所有 Job 接口示例

    /// <summary>
    /// 测试所有 Job 接口
    /// </summary>
    private void TestAllJobInterfaces()
    {
        Debug.Log("\n--- 1. 所有 Job 接口示例 ---");
        
        // 1.1 IJob - 单任务
        TestIJob();
        
        // 1.2 IJobParallelFor - 并行循环
        TestIJobParallelFor();
        
        // 1.3 IJobParallelForTransform - Transform 并行处理
        TestIJobParallelForTransform();
        
        // 1.4 IJobFor - 单线程循环（Unity 2021.2+）
        TestIJobFor();
        
        // 1.5 IJobParallelForBatch - 批量并行处理
        TestIJobParallelForBatch();
    }

    /// <summary>
    /// 1.1 IJob - 单任务接口
    /// 适用场景：需要顺序执行的任务，或需要访问共享数据
    /// </summary>
    private void TestIJob()
    {
        Debug.Log("1.1 IJob - 单任务");
        
        NativeArray<float> input = new NativeArray<float>(arraySize, Allocator.TempJob);
        NativeArray<float> output = new NativeArray<float>(arraySize, Allocator.TempJob);
        
        for (int i = 0; i < arraySize; i++)
        {
            input[i] = i;
        }
        
        var job = new SimpleJob
        {
            input = input,
            output = output,
            multiplier = 2.0f
        };
        
        JobHandle handle = job.Schedule();
        handle.Complete();
        
        Debug.Log($"IJob 结果: {output[0]}, {output[arraySize - 1]}");
        
        input.Dispose();
        output.Dispose();
    }

    /// <summary>
    /// 1.2 IJobParallelFor - 并行循环接口
    /// 适用场景：大量独立数据的并行处理
    /// </summary>
    private void TestIJobParallelFor()
    {
        Debug.Log("1.2 IJobParallelFor - 并行循环");
        
        NativeArray<Vector3> positions = new NativeArray<Vector3>(arraySize, Allocator.TempJob);
        NativeArray<Vector3> velocities = new NativeArray<Vector3>(arraySize, Allocator.TempJob);
        
        for (int i = 0; i < arraySize; i++)
        {
            positions[i] = Vector3.zero;
            velocities[i] = new Vector3(1, 0, 0);
        }
        
        var job = new ParallelJob
        {
            positions = positions,
            velocities = velocities,
            deltaTime = 0.016f
        };
        
        // Schedule(数组长度, 批次大小)
        // 批次大小建议：64-128，太小会有调度开销，太大会负载不均
        JobHandle handle = job.Schedule(arraySize, 64);
        handle.Complete();
        
        Debug.Log($"IJobParallelFor 结果: {positions[0]}, {positions[arraySize - 1]}");
        
        positions.Dispose();
        velocities.Dispose();
    }

    /// <summary>
    /// 1.3 IJobParallelForTransform - Transform 并行处理
    /// 适用场景：大量 Transform 的并行更新
    /// </summary>
    private void TestIJobParallelForTransform()
    {
        Debug.Log("1.3 IJobParallelForTransform - Transform 并行处理");
        
        // 注意：需要先创建 TransformAccessArray
        // 这里只是示例，实际使用时需要传入真实的 Transform 数组
        /*
        Transform[] transforms = new Transform[10];
        TransformAccessArray transformArray = new TransformAccessArray(transforms);
        
        var job = new TransformJob
        {
            deltaTime = Time.deltaTime
        };
        
        JobHandle handle = job.Schedule(transformArray);
        handle.Complete();
        
        transformArray.Dispose();
        */
        
        Debug.Log("IJobParallelForTransform 需要 TransformAccessArray（示例代码已注释）");
    }

    /// <summary>
    /// 1.4 IJobFor - 单线程循环（Unity 2021.2+）
    /// 适用场景：需要顺序执行但想利用 Job 系统的依赖管理
    /// </summary>
    private void TestIJobFor()
    {
        Debug.Log("1.4 IJobFor - 单线程循环");
        
        NativeArray<int> data = new NativeArray<int>(arraySize, Allocator.TempJob);
        
        var job = new ForJob
        {
            data = data
        };
        
        JobHandle handle = job.Schedule(arraySize);
        handle.Complete();
        
        Debug.Log($"IJobFor 结果: {data[0]}, {data[arraySize - 1]}");
        
        data.Dispose();
    }

    /// <summary>
    /// 1.5 IJobParallelForBatch - 批量并行处理
    /// 适用场景：需要批量处理数据，减少调度开销
    /// </summary>
    private void TestIJobParallelForBatch()
    {
        Debug.Log("1.5 IJobParallelForBatch - 批量并行处理");
        
        NativeArray<float> input = new NativeArray<float>(arraySize, Allocator.TempJob);
        NativeArray<float> output = new NativeArray<float>(arraySize, Allocator.TempJob);
        
        for (int i = 0; i < arraySize; i++)
        {
            input[i] = i;
        }
        
        var job = new BatchJob
        {
            input = input,
            output = output
        };
        
        // Schedule(数组长度, 批次大小)
        JobHandle handle = job.Schedule(arraySize, 64);
        handle.Complete();
        
        Debug.Log($"IJobParallelForBatch 结果: {output[0]}, {output[arraySize - 1]}");
        
        input.Dispose();
        output.Dispose();
    }

    #endregion

    #region 2. 所有 NativeContainer 示例

    /// <summary>
    /// 测试所有 NativeContainer 类型
    /// </summary>
    private void TestAllNativeContainers()
    {
        Debug.Log("\n--- 2. 所有 NativeContainer 示例 ---");
        
        TestNativeArray();
        TestNativeList();
        TestNativeHashMap();
        TestNativeQueue();
    }

    /// <summary>
    /// 2.1 NativeArray<T> - 固定大小数组
    /// </summary>
    private void TestNativeArray()
    {
        Debug.Log("2.1 NativeArray<T> - 固定大小数组");
        
        NativeArray<int> array = new NativeArray<int>(100, Allocator.TempJob);
        
        for (int i = 0; i < array.Length; i++)
        {
            array[i] = i * 2;
        }
        
        Debug.Log($"NativeArray 长度: {array.Length}, 第一个元素: {array[0]}");
        
        array.Dispose();
    }

    /// <summary>
    /// 2.2 NativeList<T> - 动态列表
    /// </summary>
    private void TestNativeList()
    {
        Debug.Log("2.2 NativeList<T> - 动态列表");
        
        NativeList<int> list = new NativeList<int>(10, Allocator.TempJob);
        
        for (int i = 0; i < 20; i++)
        {
            list.Add(i);
        }
        
        Debug.Log($"NativeList 长度: {list.Length}, 容量: {list.Capacity}");
        
        // 转换为数组
        NativeArray<int> array = list.ToArray(Allocator.TempJob);
        Debug.Log($"转换为数组后长度: {array.Length}");
        
        array.Dispose();
        list.Dispose();
    }

    /// <summary>
    /// 2.3 NativeHashMap<K,V> - 哈希表
    /// </summary>
    private void TestNativeHashMap()
    {
        Debug.Log("2.3 NativeHashMap<K,V> - 哈希表");
        
        NativeHashMap<int, float> map = new NativeHashMap<int, float>(100, Allocator.TempJob);
        
        for (int i = 0; i < 50; i++)
        {
            map.TryAdd(i, i * 1.5f);
        }
        
        if (map.TryGetValue(10, out float value))
        {
            Debug.Log($"NativeHashMap 查找 key=10, value={value}");
        }
        
        Debug.Log($"NativeHashMap 元素数量: {map.Count()}");
        
        map.Dispose();
    }

    /// <summary>
    /// 2.4 NativeQueue<T> - 队列
    /// </summary>
    private void TestNativeQueue()
    {
        Debug.Log("2.4 NativeQueue<T> - 队列");
        
        NativeQueue<int> queue = new NativeQueue<int>(Allocator.TempJob);
        
        for (int i = 0; i < 10; i++)
        {
            queue.Enqueue(i);
        }
        
        Debug.Log($"NativeQueue 元素数量: {queue.Count}");
        
        if (queue.TryDequeue(out int value))
        {
            Debug.Log($"出队元素: {value}");
        }
        
        queue.Dispose();
    }

    #endregion

    #region 3. 所有分配器示例

    /// <summary>
    /// 测试所有分配器类型
    /// </summary>
    private void TestAllocators()
    {
        Debug.Log("\n--- 3. 所有分配器示例 ---");
        
        TestAllocatorTemp();
        TestAllocatorTempJob();
        TestAllocatorPersistent();
    }

    /// <summary>
    /// 3.1 Allocator.Temp - 最快，只能存活1帧
    /// 适用场景：同一帧内使用的临时数据
    /// </summary>
    private void TestAllocatorTemp()
    {
        Debug.Log("3.1 Allocator.Temp - 临时分配器（1帧）");
        
        NativeArray<int> temp = new NativeArray<int>(100, Allocator.Temp);
        
        // 使用数据...
        temp[0] = 100;
        
        // 必须在同一帧内释放，否则会报错
        temp.Dispose();
        
        Debug.Log("Allocator.Temp 使用完成（必须在同一帧释放）");
    }

    /// <summary>
    /// 3.2 Allocator.TempJob - 工作线程使用
    /// 适用场景：Job 中使用，需要手动释放
    /// </summary>
    private void TestAllocatorTempJob()
    {
        Debug.Log("3.2 Allocator.TempJob - 工作线程分配器");
        
        NativeArray<float> job = new NativeArray<float>(100, Allocator.TempJob);
        
        var testJob = new SimpleJob
        {
            input = job,
            output = job,
            multiplier = 1.0f
        };
        
        JobHandle handle = testJob.Schedule();
        handle.Complete();
        
        // 必须在 Job 完成后释放
        job.Dispose();
        
        Debug.Log("Allocator.TempJob 使用完成（Job 完成后释放）");
    }

    /// <summary>
    /// 3.3 Allocator.Persistent - 长期存在
    /// 适用场景：需要长期存在的数据，性能最差但最灵活
    /// </summary>
    private void TestAllocatorPersistent()
    {
        Debug.Log("3.3 Allocator.Persistent - 持久分配器");
        
        NativeArray<int> persistent = new NativeArray<int>(100, Allocator.Persistent);
        
        for (int i = 0; i < 100; i++)
        {
            persistent[i] = i;
        }
        
        Debug.Log($"Allocator.Persistent 使用完成（可以跨帧使用，记得在 OnDestroy 中释放）");
        
        // 实际项目中应该在 OnDestroy 中释放
        persistent.Dispose();
    }

    #endregion

    #region 4. 依赖关系管理

    /// <summary>
    /// 测试依赖关系管理
    /// </summary>
    private void TestDependencyManagement()
    {
        Debug.Log("\n--- 4. 依赖关系管理 ---");
        
        NativeArray<float> data1 = new NativeArray<float>(arraySize, Allocator.TempJob);
        NativeArray<float> data2 = new NativeArray<float>(arraySize, Allocator.TempJob);
        NativeArray<float> data3 = new NativeArray<float>(arraySize, Allocator.TempJob);
        
        // Job1 和 Job2 并行执行
        var job1 = new SimpleJob
        {
            input = data1,
            output = data2,
            multiplier = 2.0f
        };
        
        var job2 = new SimpleJob
        {
            input = data1,
            output = data3,
            multiplier = 3.0f
        };
        
        JobHandle handle1 = job1.Schedule();
        JobHandle handle2 = job2.Schedule();
        
        // Job3 等待 Job1 和 Job2 完成
        var job3 = new SimpleJob
        {
            input = data2,
            output = data3,
            multiplier = 0.5f
        };
        
        // 合并依赖
        JobHandle combined = JobHandle.CombineDependencies(handle1, handle2);
        JobHandle handle3 = job3.Schedule(combined);
        
        handle3.Complete();
        
        Debug.Log("依赖关系管理：Job1 和 Job2 并行，Job3 等待前两个完成");
        
        data1.Dispose();
        data2.Dispose();
        data3.Dispose();
    }

    #endregion

    #region 5. 异步等待模式

    /// <summary>
    /// 测试异步等待模式
    /// </summary>
    private void TestAsyncPattern()
    {
        Debug.Log("\n--- 5. 异步等待模式 ---");
        
        NativeArray<float> input = new NativeArray<float>(arraySize, Allocator.TempJob);
        NativeArray<float> output = new NativeArray<float>(arraySize, Allocator.TempJob);
        
        var job = new SimpleJob
        {
            input = input,
            output = output,
            multiplier = 2.0f
        };
        
        // 不立即 Complete，在 LateUpdate 或其他地方等待
        JobHandle handle = job.Schedule();
        
        Debug.Log("Job 已调度，可以在 LateUpdate 中等待完成");
        
        // 实际项目中可以这样：
        // private JobHandle currentHandle;
        // 
        // void Update()
        // {
        //     currentHandle = job.Schedule();
        // }
        // 
        // void LateUpdate()
        // {
        //     currentHandle.Complete();
        //     // 使用结果...
        // }
        
        handle.Complete();
        
        input.Dispose();
        output.Dispose();
    }

    #endregion

    #region 6. Burst 编译优化

    /// <summary>
    /// Burst 编译优化示例
    /// Burst 可以将 Job 代码编译成高度优化的机器码，性能提升 2-10 倍
    /// </summary>
    private void TestBurstCompilation()
    {
        Debug.Log("\n--- 6. Burst 编译优化 ---");
        
        if (useBurst)
        {
            NativeArray<float> input = new NativeArray<float>(arraySize, Allocator.TempJob);
            NativeArray<float> output = new NativeArray<float>(arraySize, Allocator.TempJob);
            
            var job = new BurstJob
            {
                input = input,
                output = output
            };
            
            JobHandle handle = job.Schedule();
            handle.Complete();
            
            Debug.Log("Burst 编译的 Job 执行完成（性能提升 2-10 倍）");
            
            input.Dispose();
            output.Dispose();
        }
    }

    #endregion
}

#region Job 结构体定义

/// <summary>
/// 1.1 IJob - 单任务
/// </summary>
public struct SimpleJob : IJob
{
    [ReadOnly] public NativeArray<float> input;
    public NativeArray<float> output;
    public float multiplier;

    public void Execute()
    {
        for (int i = 0; i < input.Length; i++)
        {
            output[i] = input[i] * multiplier;
        }
    }
}

/// <summary>
/// 1.2 IJobParallelFor - 并行循环
/// </summary>
public struct ParallelJob : IJobParallelFor
{
    public NativeArray<Vector3> positions;
    [ReadOnly] public NativeArray<Vector3> velocities;
    public float deltaTime;

    public void Execute(int index)
    {
        positions[index] += velocities[index] * deltaTime;
    }
}

/// <summary>
/// 1.3 IJobParallelForTransform - Transform 并行处理
/// </summary>
public struct TransformJob : IJobParallelForTransform
{
    public float deltaTime;

    public void Execute(int index, TransformAccess transform)
    {
        transform.position += Vector3.up * deltaTime;
    }
}

/// <summary>
/// 1.4 IJobFor - 单线程循环
/// </summary>
public struct ForJob : IJobFor
{
    public NativeArray<int> data;

    public void Execute(int index)
    {
        data[index] = index * index;
    }
}

/// <summary>
/// 1.5 IJobParallelForBatch - 批量并行处理
/// </summary>
public struct BatchJob : IJobParallelForBatch
{
    [ReadOnly] public NativeArray<float> input;
    public NativeArray<float> output;

    public void Execute(int startIndex, int count)
    {
        for (int i = startIndex; i < startIndex + count; i++)
        {
            output[i] = input[i] * 2.0f;
        }
    }
}

/// <summary>
/// 6. Burst 编译优化示例
/// 添加 [BurstCompile] 特性可以启用 Burst 编译，性能提升 2-10 倍
/// </summary>
[BurstCompile]
public struct BurstJob : IJob
{
    [ReadOnly] public NativeArray<float> input;
    public NativeArray<float> output;

    public void Execute()
    {
        for (int i = 0; i < input.Length; i++)
        {
            output[i] = math.sqrt(input[i]); // 使用 Unity.Mathematics 的数学函数
        }
    }
}

#endregion

#region 最佳实践总结

/*
 * Unity JobSystem 最佳实践：
 * 
 * 1. 选择合适的 Job 接口：
 *    - IJob: 需要顺序执行或访问共享数据
 *    - IJobParallelFor: 大量独立数据的并行处理（最常用）
 *    - IJobParallelForTransform: Transform 并行更新
 *    - IJobFor: 需要顺序但想利用依赖管理
 *    - IJobParallelForBatch: 批量处理减少调度开销
 * 
 * 2. 选择合适的分配器：
 *    - Allocator.Temp: 同一帧内使用的临时数据（最快）
 *    - Allocator.TempJob: Job 中使用（最常用）
 *    - Allocator.Persistent: 长期存在的数据（性能最差）
 * 
 * 3. 内存管理：
 *    - 必须释放所有 NativeContainer（Dispose）
 *    - 在 OnDestroy 中释放 Persistent 分配器
 *    - 在 Job.Complete() 后释放 TempJob 分配器
 * 
 * 4. 性能优化：
 *    - 使用 [BurstCompile] 启用 Burst 编译（性能提升 2-10 倍）
 *    - 使用 [ReadOnly] 标记只读数据
 *    - IJobParallelFor 的批次大小建议 64-128
 *    - 避免在 Job 中访问 Unity API
 * 
 * 5. 依赖管理：
 *    - 使用 JobHandle.CombineDependencies 合并依赖
 *    - 使用异步等待模式减少主线程阻塞
 * 
 * 6. 数据安全：
 *    - 使用 [ReadOnly] 标记只读数据
 *    - IJobParallelFor 保证每个 index 只执行一次
 *    - 不要在 Job 中访问 Unity API（会报错）
 * 
 * 7. 适用场景：
 *    ✅ 大量数学计算（向量、矩阵）
 *    ✅ 网格顶点处理
 *    ✅ 寻路计算
 *    ✅ 物理模拟
 *    ❌ 需要访问 Unity API
 *    ❌ 简单的少量计算（开销大于收益）
 */

#endregion

