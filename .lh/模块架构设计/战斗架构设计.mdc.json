{
    "sourceFile": "模块架构设计/战斗架构设计.mdc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1767016974447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767017089060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -92,8 +92,114 @@\n ```\n \n ---\n \n+## 四层循环架构设计\n+\n+### 循环层次关系\n+\n+```mermaid\n+graph TB\n+    subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n+        BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n+        BattleCheck -->|否| TurnLoop[回合循环]\n+        BattleCheck -->|是| BattleEnd[战斗结束]\n+        TurnLoop --> BattleCheck\n+    end\n+    \n+    subgraph TurnLoop[\"回合循环<br/>TurnLoop\"]\n+        TurnStart[回合开始] --> TeamLoop[阵营循环]\n+        TeamLoop --> TurnEnd[回合结束]\n+        TurnEnd --> TurnCheck{是否还有回合?}\n+        TurnCheck -->|是| TurnStart\n+        TurnCheck -->|否| TurnLoopEnd[回合循环结束]\n+    end\n+    \n+    subgraph TeamLoop[\"阵营循环<br/>TeamLoop\"]\n+        TeamStart[阵营开始] --> UnitLoop[单位循环]\n+        UnitLoop --> TeamEnd[阵营结束]\n+        TeamEnd --> TeamCheck{是否还有阵营?}\n+        TeamCheck -->|是| TeamStart\n+        TeamCheck -->|否| TeamLoopEnd[阵营循环结束]\n+    end\n+    \n+    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n+        UnitStart[单位开始] --> UnitAction[单位行动]\n+        UnitAction --> UnitEnd[单位结束]\n+        UnitEnd --> UnitCheck{是否还有单位?}\n+        UnitCheck -->|是| UnitStart\n+        UnitCheck -->|否| UnitLoopEnd[单位循环结束]\n+    end\n+    \n+    BattleLoop --> TurnLoop\n+    TurnLoop --> TeamLoop\n+    TeamLoop --> UnitLoop\n+    \n+    style BattleLoop fill:#ffebee\n+    style TurnLoop fill:#fff4e1\n+    style TeamLoop fill:#c8e6c9\n+    style UnitLoop fill:#e1f5ff\n+```\n+\n+### 循环管理器设计\n+\n+```mermaid\n+graph TB\n+    subgraph LoopManager[\"循环管理器<br/>LoopManager\"]\n+        BattleLoopManager[\"战斗循环管理器<br/>BattleLoopManager\"]\n+        TurnLoopManager[\"回合循环管理器<br/>TurnLoopManager\"]\n+        TeamLoopManager[\"阵营循环管理器<br/>TeamLoopManager\"]\n+        UnitLoopManager[\"单位循环管理器<br/>UnitLoopManager\"]\n+    end\n+    \n+    subgraph BattleContext[\"战斗上下文<br/>BattleContext\"]\n+        BattleState[\"战斗状态<br/>battleState\"]\n+        TurnState[\"回合状态<br/>turnState\"]\n+        TeamState[\"阵营状态<br/>teamState\"]\n+        UnitState[\"单位状态<br/>unitState\"]\n+    end\n+    \n+    BattleLoopManager -->|维护| BattleState\n+    TurnLoopManager -->|维护| TurnState\n+    TeamLoopManager -->|维护| TeamState\n+    UnitLoopManager -->|维护| UnitState\n+    \n+    BattleLoopManager -->|驱动| TurnLoopManager\n+    TurnLoopManager -->|驱动| TeamLoopManager\n+    TeamLoopManager -->|驱动| UnitLoopManager\n+    \n+    style LoopManager fill:#f3e5f5\n+    style BattleContext fill:#e8f5e9\n+```\n+\n+### 循环职责说明\n+\n+#### 1. 战斗循环（BattleLoop）\n+- **职责**：管理整个战斗的生命周期\n+- **状态**：BattleState（未开始/进行中/已结束）\n+- **触发**：战斗开始/结束条件检查\n+- **维护**：BattleLoopManager\n+\n+#### 2. 回合循环（TurnLoop）\n+- **职责**：管理回合的循环和切换\n+- **状态**：TurnState（回合编号/当前回合/回合数）\n+- **触发**：回合开始/结束条件检查\n+- **维护**：TurnLoopManager\n+\n+#### 3. 阵营循环（TeamLoop）\n+- **职责**：管理阵营内单位的行动顺序\n+- **状态**：TeamState（当前阵营/阵营列表/行动顺序）\n+- **触发**：阵营切换/单位行动完成\n+- **维护**：TeamLoopManager\n+\n+#### 4. 单位循环（UnitLoop）\n+- **职责**：管理单个单位的行动流程\n+- **状态**：UnitState（当前单位/行动状态/行动完成）\n+- **触发**：单位行动开始/结束\n+- **维护**：UnitLoopManager\n+\n+---\n+\n ## 分层职责说明\n \n ### 输入层（InputLayer）\n - **职责**：接收玩家输入和AI输入\n"
                },
                {
                    "date": 1767017432603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,15 +7,17 @@\n ---\n \n ## 核心设计理念\n \n-### 1. 回合驱动为核心\n+### 1. 多层循环架构为核心\n \n-**本质**：战斗系统的核心是回合流程的驱动和管理\n-- 战斗流程 = 回合循环驱动\n-- 回合管理 = 先攻计算 → 行动轮 → 回合结束\n-- 状态同步 = 回合状态在参与者间同步\n-- 流程控制 = 回合流程控制战斗节奏\n+**本质**：战斗系统的核心是四层循环的维护和管理\n+- **战斗循环**：管理整个战斗的生命周期\n+- **回合循环**：管理回合的循环和切换\n+- **阵营循环**：管理阵营内单位的行动顺序\n+- **单位循环**：管理单个单位的行动流程\n+- **循环驱动**：所有战斗逻辑都在循环框架内执行\n+- **状态维护**：每层循环维护自己的状态，驱动下层循环\n \n ### 2. 数据驱动架构\n \n **本质**：战斗特性通过配置数据实现，无需修改代码\n@@ -23,20 +25,20 @@\n - 回合流程、状态转换 → 通过配置数据调整\n - 新增战斗机制 → 扩展配置数据即可\n - 战斗平衡 → 调整配置数值即可\n \n-### 3. 分层架构 + 状态机控制\n+### 3. 分层架构（循环内的功能组织）\n \n-**本质**：分层架构实现职责分离，状态机控制实现流程管理\n-- 多层架构：输入层、决策层、执行层、表现层、管理层\n-- 状态机：战斗状态、回合状态、角色状态\n+**本质**：分层架构是循环内的功能组织方式，不是主要架构\n+- 功能组织：输入层、决策层、执行层、表现层、管理层\n+- 执行位置：所有分层功能都在单位循环内执行\n - 解耦设计：层间通过Context和CommunicationBus通信\n \n ---\n \n ## 整体架构设计\n \n-### 分层架构 + 回合驱动\n+### 多层循环架构（主要架构）\n \n ```mermaid\n graph TB\n     subgraph InputLayer[\"输入层<br/>InputLayer\"]\n"
                },
                {
                    "date": 1767017444235,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,66 +38,8 @@\n ## 整体架构设计\n \n ### 多层循环架构（主要架构）\n \n-```mermaid\n-graph TB\n-    subgraph InputLayer[\"输入层<br/>InputLayer\"]\n-        PlayerInput[\"玩家输入<br/>PlayerInput\"]\n-        AIInput[\"AI输入<br/>AIInput\"]\n-        InputValidator[\"输入验证器<br/>InputValidator\"]\n-    end\n-    \n-    subgraph DecisionLayer[\"决策层<br/>DecisionLayer\"]\n-        TurnManager[\"回合管理器<br/>TurnManager\"]\n-        ActionSelector[\"行动选择器<br/>ActionSelector\"]\n-        TargetSelector[\"目标选择器<br/>TargetSelector\"]\n-    end\n-    \n-    subgraph ExecutionLayer[\"执行层<br/>ExecutionLayer\"]\n-        ActionExecutor[\"行动执行器<br/>ActionExecutor\"]\n-        DamageCalculator[\"伤害计算器<br/>DamageCalculator\"]\n-        EffectApplier[\"效果应用器<br/>EffectApplier\"]\n-    end\n-    \n-    subgraph PresentationLayer[\"表现层<br/>PresentationLayer\"]\n-        VisualPlayer[\"视觉播放器<br/>VisualPlayer\"]\n-        AudioPlayer[\"音频播放器<br/>AudioPlayer\"]\n-        UIManager[\"UI管理器<br/>UIManager\"]\n-    end\n-    \n-    subgraph ManagementLayer[\"管理层<br/>ManagementLayer\"]\n-        BattleStateManager[\"战斗状态管理器<br/>BattleStateManager\"]\n-        ParticipantManager[\"参与者管理器<br/>ParticipantManager\"]\n-        BattleContext[\"战斗上下文<br/>BattleContext\"]\n-    end\n-    \n-    subgraph DataLayer[\"数据层<br/>DataLayer\"]\n-        BattleConfig[\"战斗配置<br/>BattleConfig\"]\n-        TurnData[\"回合数据<br/>TurnData\"]\n-        BattleData[\"战斗数据<br/>BattleData\"]\n-    end\n-    \n-    InputLayer -->|BattleContext<br/>+inputData| DecisionLayer\n-    DecisionLayer -->|BattleContext<br/>+decisionData| ExecutionLayer\n-    ExecutionLayer -->|BattleContext<br/>+executionData| PresentationLayer\n-    PresentationLayer -->|BattleContext<br/>+presentationData| ManagementLayer\n-    ManagementLayer -->|状态更新| InputLayer\n-    ManagementLayer -->|数据持久化| DataLayer\n-    DataLayer -.数据查询.-> DecisionLayer\n-    \n-    style InputLayer fill:#ffebee\n-    style DecisionLayer fill:#fff4e1\n-    style ExecutionLayer fill:#c8e6c9\n-    style PresentationLayer fill:#e1f5ff\n-    style ManagementLayer fill:#f3e5f5\n-    style DataLayer fill:#e8f5e9\n-```\n-\n----\n-\n-## 四层循环架构设计\n-\n ### 循环层次关系\n \n ```mermaid\n graph TB\n"
                },
                {
                    "date": 1767017456548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,10 +38,12 @@\n ## 整体架构设计\n \n ### 多层循环架构（主要架构）\n \n-### 循环层次关系\n+**核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n \n+#### 循环层次关系\n+\n ```mermaid\n graph TB\n     subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n         BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n"
                },
                {
                    "date": 1767017477402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,35 +144,72 @@\n - **维护**：UnitLoopManager\n \n ---\n \n-## 分层职责说明\n+### 分层架构（循环内的功能组织）\n \n-### 输入层（InputLayer）\n+**说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n+\n+#### 单位循环内的分层功能\n+\n+```mermaid\n+graph TB\n+    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n+        UnitStart[单位开始] --> InputLayer[输入层<br/>接收输入]\n+        InputLayer --> DecisionLayer[决策层<br/>选择行动/目标]\n+        DecisionLayer --> ExecutionLayer[执行层<br/>执行行动/计算伤害]\n+        ExecutionLayer --> PresentationLayer[表现层<br/>播放表现]\n+        PresentationLayer --> ManagementLayer[管理层<br/>更新状态]\n+        ManagementLayer --> UnitEnd[单位结束]\n+    end\n+    \n+    DataLayer[数据层<br/>配置数据] -.数据查询.-> DecisionLayer\n+    DataLayer -.数据查询.-> ExecutionLayer\n+    \n+    style UnitLoop fill:#e1f5ff\n+    style InputLayer fill:#ffebee\n+    style DecisionLayer fill:#fff4e1\n+    style ExecutionLayer fill:#c8e6c9\n+    style PresentationLayer fill:#e1f5ff\n+    style ManagementLayer fill:#f3e5f5\n+    style DataLayer fill:#e8f5e9\n+```\n+\n+#### 分层职责说明\n+\n+**重要**：以下所有分层功能都在**单位循环**内执行，不是独立的架构层次。\n+\n+##### 输入层（InputLayer）\n+- **执行位置**：单位循环内\n - **职责**：接收玩家输入和AI输入\n - **核心组件**：PlayerInput、AIInput、InputValidator\n - **输出**：BattleContext + inputData\n \n-### 决策层（DecisionLayer）\n-- **职责**：回合管理、行动选择、目标选择\n-- **核心组件**：TurnManager、ActionSelector、TargetSelector\n+##### 决策层（DecisionLayer）\n+- **执行位置**：单位循环内\n+- **职责**：行动选择、目标选择\n+- **核心组件**：ActionSelector、TargetSelector\n - **输出**：BattleContext + decisionData\n \n-### 执行层（ExecutionLayer）\n+##### 执行层（ExecutionLayer）\n+- **执行位置**：单位循环内\n - **职责**：行动执行、伤害计算、效果应用\n - **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n - **输出**：BattleContext + executionData\n \n-### 表现层（PresentationLayer）\n+##### 表现层（PresentationLayer）\n+- **执行位置**：单位循环内\n - **职责**：视觉表现、音频播放、UI更新\n - **核心组件**：VisualPlayer、AudioPlayer、UIManager\n - **输出**：BattleContext + presentationData\n \n-### 管理层（ManagementLayer）\n-- **职责**：战斗状态管理、参与者管理、Context管理\n-- **核心组件**：BattleStateManager、ParticipantManager、BattleContext\n-- **输出**：状态更新、数据持久化\n+##### 管理层（ManagementLayer）\n+- **执行位置**：单位循环内（状态更新）、循环间（循环管理）\n+- **职责**：战斗状态管理、参与者管理、Context管理、循环管理\n+- **核心组件**：BattleStateManager、ParticipantManager、BattleContext、LoopManager\n+- **输出**：状态更新、数据持久化、循环驱动\n \n-### 数据层（DataLayer）\n+##### 数据层（DataLayer）\n+- **执行位置**：所有循环和分层功能中\n - **职责**：战斗配置、回合数据、战斗数据\n - **核心组件**：BattleConfig、TurnData、BattleData\n - **输出**：配置数据查询\n"
                },
                {
                    "date": 1767017686371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,8 +144,113 @@\n - **维护**：UnitLoopManager\n \n ---\n \n+## 多层循环架构模式\n+\n+### 层次状态机（Hierarchical State Machine）\n+\n+**核心观点**：多层循环架构最适合使用**层次状态机（Hierarchical State Machine）**模式。\n+\n+#### 为什么是层次状态机？\n+\n+**原因**：\n+- **循环嵌套 = 状态嵌套**：每层循环都是一个状态机，可以包含子状态机\n+- **状态层次结构**：战斗状态机 → 回合状态机 → 阵营状态机 → 单位状态机\n+- **状态自动管理**：父状态机进入时自动重置子状态机，父状态机更新时自动更新子状态机\n+- **状态隔离**：每层循环的状态独立管理，互不干扰\n+\n+**适用场景**：\n+- 战斗状态机包含回合状态机（战斗进行中状态）\n+- 回合状态机包含阵营状态机（回合行动状态）\n+- 阵营状态机包含单位状态机（阵营行动状态）\n+- 单位状态机管理单位行动流程\n+\n+#### 层次状态机设计\n+\n+```mermaid\n+graph TB\n+    subgraph BattleFSM[\"战斗状态机<br/>BattleFSM<br/>HierarchicalFSM\"]\n+        BattleState1[准备中]\n+        BattleState2[进行中]\n+        BattleState3[暂停]\n+        BattleState4[结束]\n+        \n+        BattleState2 -->|包含| TurnFSM[回合状态机<br/>TurnFSM]\n+        BattleState4 -->|包含| ResultFSM[结果状态机<br/>ResultFSM]\n+    end\n+    \n+    subgraph TurnFSM[\"回合状态机<br/>TurnFSM<br/>HierarchicalFSM\"]\n+        TurnState1[回合开始]\n+        TurnState2[回合行动]\n+        TurnState3[回合结束]\n+        \n+        TurnState2 -->|包含| TeamFSM[阵营状态机<br/>TeamFSM]\n+    end\n+    \n+    subgraph TeamFSM[\"阵营状态机<br/>TeamFSM<br/>HierarchicalFSM\"]\n+        TeamState1[阵营开始]\n+        TeamState2[阵营行动]\n+        TeamState3[阵营结束]\n+        \n+        TeamState2 -->|包含| UnitFSM[单位状态机<br/>UnitFSM]\n+    end\n+    \n+    subgraph UnitFSM[\"单位状态机<br/>UnitFSM<br/>FSMBase\"]\n+        UnitState1[单位开始]\n+        UnitState2[单位行动]\n+        UnitState3[单位结束]\n+    end\n+    \n+    style BattleFSM fill:#ffebee\n+    style TurnFSM fill:#fff4e1\n+    style TeamFSM fill:#c8e6c9\n+    style UnitFSM fill:#e1f5ff\n+```\n+\n+#### 层次状态机特点\n+\n+1. **状态嵌套**：\n+   - 父状态机可以包含子状态机\n+   - 子状态机在父状态机进入时自动重置\n+   - 子状态机在父状态机更新时自动更新\n+\n+2. **状态隔离**：\n+   - 每层状态机独立管理自己的状态\n+   - 状态转换只在当前状态机内进行\n+   - 父状态机状态变化不影响子状态机状态\n+\n+3. **自动管理**：\n+   - 父状态机进入时，自动重置子状态机\n+   - 父状态机更新时，自动更新子状态机\n+   - 父状态机退出时，自动清理子状态机\n+\n+4. **循环驱动**：\n+   - 每层状态机的状态转换驱动循环推进\n+   - 状态机状态决定循环是否继续\n+   - 状态机状态决定循环行为\n+\n+#### 实现要点\n+\n+1. **层次状态机接口**：\n+   - `AddSubFSM(stateId, subFSM)`：为某个状态添加子状态机\n+   - `EnterCurrentState()`：进入当前状态时，自动重置子状态机\n+   - `UpdateCurrentState()`：更新当前状态时，自动更新子状态机\n+\n+2. **状态机层次结构**：\n+   - 战斗状态机（HierarchicalFSM）：包含回合状态机和结果状态机\n+   - 回合状态机（HierarchicalFSM）：包含阵营状态机\n+   - 阵营状态机（HierarchicalFSM）：包含单位状态机\n+   - 单位状态机（FSMBase）：最底层状态机，不包含子状态机\n+\n+3. **循环管理器 = 层次状态机**：\n+   - BattleLoopManager = 战斗状态机\n+   - TurnLoopManager = 回合状态机\n+   - TeamLoopManager = 阵营状态机\n+   - UnitLoopManager = 单位状态机\n+\n+---\n+\n ### 分层架构（循环内的功能组织）\n \n **说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n \n"
                },
                {
                    "date": 1767088777887,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -247,8 +247,74 @@\n    - TurnLoopManager = 回合状态机\n    - TeamLoopManager = 阵营状态机\n    - UnitLoopManager = 单位状态机\n \n+```mermaid\n+sequenceDiagram\n+    participant Main as 主状态机\n+    participant Round as 回合状态机\n+    participant Team as 阵营状态机\n+    participant Unit as 单位状态机\n+    \n+    Note over Main: 战斗开始\n+    Main->>Main: PREPARING → IN_PROGRESS\n+    Main->>Round: 进入IN_PROGRESS，激活回合状态机\n+    \n+    Note over Round: 第1回合开始\n+    Round->>Round: ROUND_START\n+    Round->>Round: CheckRoundActionCondition() → ROUND_ACTION\n+    Round->>Team: 进入ROUND_ACTION，激活阵营状态机\n+    \n+    Note over Team: 玩家阵营开始\n+    Team->>Team: TEAM_START\n+    Team->>Team: CheckTeamActionCondition() → TEAM_ACTION\n+    Team->>Unit: 进入TEAM_ACTION，激活单位状态机\n+    \n+    Note over Unit: 单位1行动\n+    Unit->>Unit: UNIT_START\n+    Unit->>Unit: CheckUnitActionCondition() → UNIT_ACTION\n+    Unit->>Unit: 执行行动\n+    Unit->>Unit: CheckUnitEndCondition() → UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → UNIT_START (还有单位2)\n+    \n+    Note over Unit: 单位2行动\n+    Unit->>Unit: UNIT_START\n+    Unit->>Unit: UNIT_ACTION\n+    Unit->>Unit: UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → false (没有更多单位)\n+    \n+    Note over Team: 玩家阵营结束\n+    Team->>Team: CheckTeamEndCondition() → TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → TEAM_START (还有敌人阵营)\n+    \n+    Note over Team: 敌人阵营开始\n+    Team->>Team: TEAM_START\n+    Team->>Team: TEAM_ACTION\n+    Team->>Unit: 激活单位状态机（敌人单位1）\n+    Unit->>Unit: UNIT_START → UNIT_ACTION → UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → UNIT_START (还有单位2)\n+    Unit->>Unit: UNIT_START → UNIT_ACTION → UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → false\n+    Team->>Team: TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → false (没有更多阵营)\n+    \n+    Note over Round: 第1回合结束\n+    Round->>Round: CheckRoundEndCondition() → ROUND_END\n+    Round->>Round: CheckNextRoundCondition() → ROUND_START (还有第2回合)\n+    \n+    Note over Round: 第2回合开始\n+    Round->>Round: ROUND_START → ROUND_ACTION\n+    Round->>Team: 激活阵营状态机\n+    Team->>Team: TEAM_START → TEAM_ACTION → TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → TEAM_START (循环)\n+    Team->>Team: TEAM_START → TEAM_ACTION → TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → false\n+    Round->>Round: ROUND_END\n+    Round->>Round: CheckNextRoundCondition() → false (战斗结束)\n+    \n+    Note over Main: 战斗结束\n+    Main->>Main: CheckBattleEndCondition() → ENDED\n+    Main->>Main: 激活结果状态机\n ---\n \n ### 分层架构（循环内的功能组织）\n \n"
                },
                {
                    "date": 1767088789349,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -313,8 +313,9 @@\n     \n     Note over Main: 战斗结束\n     Main->>Main: CheckBattleEndCondition() → ENDED\n     Main->>Main: 激活结果状态机\n+```\n ---\n \n ### 分层架构（循环内的功能组织）\n \n"
                }
            ],
            "date": 1767016974447,
            "name": "Commit-0",
            "content": "# 战斗系统架构设计\n\n## 设计目标\n\n设计一套完整的回合制战斗系统架构，支持DND规则、回合管理、状态机控制、AI决策，实现战斗流程管理、伤害计算、效果应用，提供数据驱动的配置化战斗系统。\n\n---\n\n## 核心设计理念\n\n### 1. 回合驱动为核心\n\n**本质**：战斗系统的核心是回合流程的驱动和管理\n- 战斗流程 = 回合循环驱动\n- 回合管理 = 先攻计算 → 行动轮 → 回合结束\n- 状态同步 = 回合状态在参与者间同步\n- 流程控制 = 回合流程控制战斗节奏\n\n### 2. 数据驱动架构\n\n**本质**：战斗特性通过配置数据实现，无需修改代码\n- 战斗规则、伤害计算、效果应用 → 通过配置数据定义\n- 回合流程、状态转换 → 通过配置数据调整\n- 新增战斗机制 → 扩展配置数据即可\n- 战斗平衡 → 调整配置数值即可\n\n### 3. 分层架构 + 状态机控制\n\n**本质**：分层架构实现职责分离，状态机控制实现流程管理\n- 多层架构：输入层、决策层、执行层、表现层、管理层\n- 状态机：战斗状态、回合状态、角色状态\n- 解耦设计：层间通过Context和CommunicationBus通信\n\n---\n\n## 整体架构设计\n\n### 分层架构 + 回合驱动\n\n```mermaid\ngraph TB\n    subgraph InputLayer[\"输入层<br/>InputLayer\"]\n        PlayerInput[\"玩家输入<br/>PlayerInput\"]\n        AIInput[\"AI输入<br/>AIInput\"]\n        InputValidator[\"输入验证器<br/>InputValidator\"]\n    end\n    \n    subgraph DecisionLayer[\"决策层<br/>DecisionLayer\"]\n        TurnManager[\"回合管理器<br/>TurnManager\"]\n        ActionSelector[\"行动选择器<br/>ActionSelector\"]\n        TargetSelector[\"目标选择器<br/>TargetSelector\"]\n    end\n    \n    subgraph ExecutionLayer[\"执行层<br/>ExecutionLayer\"]\n        ActionExecutor[\"行动执行器<br/>ActionExecutor\"]\n        DamageCalculator[\"伤害计算器<br/>DamageCalculator\"]\n        EffectApplier[\"效果应用器<br/>EffectApplier\"]\n    end\n    \n    subgraph PresentationLayer[\"表现层<br/>PresentationLayer\"]\n        VisualPlayer[\"视觉播放器<br/>VisualPlayer\"]\n        AudioPlayer[\"音频播放器<br/>AudioPlayer\"]\n        UIManager[\"UI管理器<br/>UIManager\"]\n    end\n    \n    subgraph ManagementLayer[\"管理层<br/>ManagementLayer\"]\n        BattleStateManager[\"战斗状态管理器<br/>BattleStateManager\"]\n        ParticipantManager[\"参与者管理器<br/>ParticipantManager\"]\n        BattleContext[\"战斗上下文<br/>BattleContext\"]\n    end\n    \n    subgraph DataLayer[\"数据层<br/>DataLayer\"]\n        BattleConfig[\"战斗配置<br/>BattleConfig\"]\n        TurnData[\"回合数据<br/>TurnData\"]\n        BattleData[\"战斗数据<br/>BattleData\"]\n    end\n    \n    InputLayer -->|BattleContext<br/>+inputData| DecisionLayer\n    DecisionLayer -->|BattleContext<br/>+decisionData| ExecutionLayer\n    ExecutionLayer -->|BattleContext<br/>+executionData| PresentationLayer\n    PresentationLayer -->|BattleContext<br/>+presentationData| ManagementLayer\n    ManagementLayer -->|状态更新| InputLayer\n    ManagementLayer -->|数据持久化| DataLayer\n    DataLayer -.数据查询.-> DecisionLayer\n    \n    style InputLayer fill:#ffebee\n    style DecisionLayer fill:#fff4e1\n    style ExecutionLayer fill:#c8e6c9\n    style PresentationLayer fill:#e1f5ff\n    style ManagementLayer fill:#f3e5f5\n    style DataLayer fill:#e8f5e9\n```\n\n---\n\n## 分层职责说明\n\n### 输入层（InputLayer）\n- **职责**：接收玩家输入和AI输入\n- **核心组件**：PlayerInput、AIInput、InputValidator\n- **输出**：BattleContext + inputData\n\n### 决策层（DecisionLayer）\n- **职责**：回合管理、行动选择、目标选择\n- **核心组件**：TurnManager、ActionSelector、TargetSelector\n- **输出**：BattleContext + decisionData\n\n### 执行层（ExecutionLayer）\n- **职责**：行动执行、伤害计算、效果应用\n- **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n- **输出**：BattleContext + executionData\n\n### 表现层（PresentationLayer）\n- **职责**：视觉表现、音频播放、UI更新\n- **核心组件**：VisualPlayer、AudioPlayer、UIManager\n- **输出**：BattleContext + presentationData\n\n### 管理层（ManagementLayer）\n- **职责**：战斗状态管理、参与者管理、Context管理\n- **核心组件**：BattleStateManager、ParticipantManager、BattleContext\n- **输出**：状态更新、数据持久化\n\n### 数据层（DataLayer）\n- **职责**：战斗配置、回合数据、战斗数据\n- **核心组件**：BattleConfig、TurnData、BattleData\n- **输出**：配置数据查询\n"
        }
    ]
}