# Unity 面试题总结 - 网络相关

> **整理时间**：2025年  
> **用途**：面试准备 + Unity网络编程知识复习  
> **重点**：TCP/UDP、Socket、序列化、HTTP/HTTPS等核心知识点

---

## 目录

1. [客户端与服务器交互方式](#1-客户端与服务器交互方式有几种)
2. [OSI七层模型](#2-osi七层模型有哪些每一层的作用)
3. [UDP/TCP含义和区别](#3-udptcp含义区别)
4. [TCP/IP协议栈](#4-tcpip协议栈各个层次及分别的功能)
5. [WWW的方法](#5-写出www的几个方法)
6. [Socket粘包](#6-socket粘包)
7. [Socket的封包、拆包](#7-socket的封包拆包)
8. [Socket客户端队列问题](#8-socket-客户端-队列-的问题)
9. [TCP拥塞控制](#9-为什么会出现tcp-拥塞控制)
10. [序列化与反序列化](#10-简述序列化与反序列化)
11. [序列化的多种方案](#11-序列化的多种方案)
12. [网络抖动](#12-网络抖动)
13. [HTTP与HTTPS的区别](#13-http与https的区别)

---

## 1. 客户端与服务器交互方式有几种？

**Socket**：通常也称作"套接字"，实现服务器和客户端之间的物理连接，并进行数据传输，主要有UDP和TCP两个协议。Socket处于网络协议的传输层。

**协议传输**：主要有http协议和基于http协议的Soap协议（web service），常见的方式是http的post和get请求，web服务。

---

## 2. OSI七层模型有哪些，每一层的作用

### 应用层（Application Layer）

是OSI参考模型的最高层。

它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。

### 表示层（Presentation Layer）

是OSI模型的第六层。

它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是"处理用户信息的表示问题，如编码、数据格式转换和加密解密"等。

### 会话层（Session Layer）

是OSI模型的第5层。

是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。

### 传输层（Transport Layer）

向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议：TCP/IP中的TCP协议、Novell网络中的SPX协议和微软的NetBIOS/NetBEUI协议。

传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。

### 网络层（Network Layer）

它是OSI参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。

一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题。

### 数据链路层（Data Link Layer）

通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。

### 物理层（Physical Layer）

利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。

物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。

---

## 3. UDP/TCP含义，区别

### UDP协议

**全称**：用户数据报协议（User Datagram Protocol）

**特点**：
- 面向无连接
- 面向报文
- 不可靠性
- 有单播，多播，广播的功能
- 头部开销小，传输数据报文时是很高效的

### TCP协议

**全称**：传输控制协议（Transmission Control Protocol）

是一种面向连接的、可靠的、基于字节流的传输层通信协议。三次握手、四次挥手

**特点**：
- 面向连接
- 仅支持单播传输
- 面向字节流
- 可靠传输
- 提供拥塞控制
- TCP提供全双工通信

---

## 4. TCP/IP协议栈各个层次及分别的功能？

### 网络接口层

这是协议栈的最低层，对应OSI的物理层和数据链路层，主要完成数据帧的实际发送和接收。

### 网络层

处理分组在网络中的活动，例如路由选择和转发等，这一层主要包括IP协议、ARP、ICMP协议等。

### 传输层

主要功能是提供应用程序之间的通信，这一层主要是TCP/UDP协议。

### 应用层

用来处理特定的应用，针对不同的应用提供了不同的协议，例如进行文件传输时用到的FTP协议，发送email用到的SMTP等。

---

## 5. 写出WWW的几个方法

- **WWW.LoadFromCacheOrDownload**：可被用于将Assets Bundles自动缓存到本地磁盘
- **WWW.Dispose**：释放现有的 WWW 对象
- **WWW.isDone**：是否完成下载？（只读）
- **WWW.progress**：下载进度（只读）

---

## 6. Socket粘包

### 什么是粘包？

顾名思义，其实就是多个独立的数据包连到一块儿。

### 什么情况下需要考虑粘包？

实际情况如下：

1. **如果利用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题。**

2. **如果发送的数据无结构，比如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包。**

3. **如果双方建立连接，需要在连接后一段时间内发送不同结构数据，如连接后，有好几种结构**：
   - "good good study"
   - "day day up"
   
   那这样的话，如果发送方连续发送这个两个包出去，接收方一次接收可能会是"good good studyday day up"这样接收方就傻了，因为协议没有规定这么奇怪的字符串，所以要把它分包处理，至于怎么分也需要双方组织一个比较好的包结构，所以一般可能会在头加一个数据长度之类的包，以确保接收。

**所以说**：Tcp连续发送消息的时候，会出现消息一起发送过来的问题，这时候需要考虑粘包的问题。

### 粘包出现的原因

在流传输中，UDP不会出现粘包，因为它有消息边界。

1. **发送端需要等缓冲区满才发送出去，造成粘包**（发送端出现粘包）
2. **接收端没有及时接收缓冲区包数据，造成一次性接收多个包，出现粘包**（接收端出现粘包）

### 解决粘包

1. **缓冲区过大造成了粘包，所以在发送/接收消息时先将消息的长度作为消息的一部分发出去，这样接收方就可以根据接收到的消息长度来动态定义缓冲区的大小。**（这种方法就是所谓的自定义协议，这种方法是最常用的）

2. **对发送的数据进行处理，每条消息的首尾加上特殊字符，然后再把要发送的所有消息放入一个字符串中，最后将这个字符串发送出去，接收方接收到这个字符串之后，再通过特殊标记操作字符串，把每条消息截出来。**（这种方法只适合数据量较小的情况）

**注**：要记住这一点：TCP对上层来说是一个流协议，所谓流，就是没有界限的一串数据。大家可以想想河里的流水，是连成一片的，其间是没有分界线的，也就是没有包的概念。所以我们必须自己定义包长或者分隔符来区分每一条消息。

---

## 7. Socket的封包、拆包

### 为什么基于TCP的通信程序需要封包、拆包?

**答**：TCP是流协议，所谓流，就是没有界限的一串数据。但是程序中却有多种不同的数据包，那就很可能会出现如上所说的粘包问题，所以就需要在发送端封包，在接收端拆包。

### 那么如何封包、拆包？

**答**：封包就是给一段数据加上包头或者包尾。比如说我们上面为解决粘包所使用的两种方法，其实就是封包与拆包的具体实现。

---

## 8. Socket 客户端 队列 的问题

项目中采用了socket通信，通过TCP发送数据给服务器端，因为项目需要，要同时开启大量的线程去发送不同的数据给服务器端，然后服务器端返回不同的数据。由于操作频繁，经常会阻塞，或没有接收到服务器端返回的数据；

因此考虑到使用一个队列：将同一ip下的数据存入一个队列中，通过队列协调发送；当第一条数据发送出去没有收到服务器端返回的数据时，让第二条数据插入队列中排队，当第三条数据也发送出来后，继续排队，以此类推；

如果当第四条数据发出来的时候，存入队列中，第一条数据收服务器端返回数据后，队列中的第二条第三条数据就扔掉，直接发送第四条数据

---

## 9. 为什么会出现TCP 拥塞控制

拥塞的发生是因为路由器缓存溢出，拥塞会导致丢包，但丢包不一定触发拥塞。拥塞控制是快速传输的基础。一个拥塞控制算法一般包括慢启动算法、拥塞避免算法、快速重传算法、快速恢复算法四部分。

---

## 10. 简述序列化与反序列化

**序列化**：简单理解成把对象转换为容易传输的格式的过程。

比如，可以序列化一个对象，然后使用HTTP通过Internet在客户端和服务器端之间传输该对象

**反序列化**：将已经序列化过后的数据恢复成原先对象的过程。

---

## 11. 序列化的多种方案

### XML

指可扩展标记语言（eXtensible Markup Language）。是一种通用和重量级的数据交换格式。以文本结构存储。

**优点**：
- 格式更为标准和统一
- 更容易和其它系统进行远程交互
- 数据共享比较方便

**缺点**：
- 相比于JSON，由于需要成对的数据标签，数据更加的冗余
- 而JSON使用键值对，压缩了数据空间并且更加可读

### JSON

是一种通用和轻量级的数据交换格式。以文本结构存储。

**优点**：
- 简单易用开发成本低
- 跨语言
- 轻量级数据交换
- 非冗长性（对比xml标签简单括号闭环）

**缺点**：
- 体积大，影响高并发
- 无版本检查，自己做兼容
- 片段的创建和验证过程比一般的XML复杂
- 缺乏命名空间导致信息混合
- 没有XML格式这么推广的深入人心和使用广泛，没有XML那么通用性

### Protobuf

protocol buffer是Google的一种独立和轻量级的数据交换格式。以二进制结构进行存储。

Protobuf是一种以有效并可扩展的格式编码结构化数据的方式。

**优点**：
- 跨平台多语言，可自定义数据结构
- 字段被编号，新添加的字段不影响老结构。解决了向后兼容问题
- 序列化后体积相比json和xml很小，适合网络传输
- 序列化反序列化速度很快，快于Json的处理速度
- 自动化生成代码，简单易用
- 二进制消息，效率高，性能高
- Netty等框架集成了该协议，提供了编解码器提高开发效率

**缺点**：
- 二进制格式，可读性差（抓包dump后的数据很难看懂）
- 对象冗余，字段很多，生成的类较大，占用空间
- 默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）

### 三者比较

- **JSON**：一般的web项目中，最流行的主要还是json。因为浏览器对于json数据支持非常好，有很多内建的函数支持。
- **XML**：在webservice中应用最为广泛，但是相比于json，它的数据更加冗余，因为需要成对的闭合标签。json使用了键值对的方式，不仅压缩了一定的数据空间，同时也具有可读性。
- **Protobuf**：是后起之秀，是谷歌开源的一种数据格式，适合高性能，对响应速度有要求的数据传输场景。因为profobuf是二进制数据格式，需要编码和解码。数据本身不具有可读性。因此只能反序列化之后得到真正可读的数据。

---

## 12. 网络抖动

### 什么是网络抖动

如果网络发生拥塞，排队延迟将影响端到端的延迟，并导致通过同一连接传输的分组延迟各不相同，而抖动，就是用来描述这样一延迟变化的程度。

它是网络延时变化，最大延迟与最小延迟的时间差；

如最大延迟是20毫秒，最小延迟为5毫秒，那么网络抖动就是15毫秒，它主要标识一个网络的稳定性。

### 造成网络抖动的原因

如果网络发生拥塞，排队延迟将影响端到端的延迟，并导致通过同一连接传输的分组延迟各不相同；

当网络设备无法发送相同数据的流量，因此他们的数据包缓冲区已满并开始丢弃数据包。如果端点上的网络没有干扰，则每个数据包都会到达。

但是，如果端点缓冲区满了，会使数据包到达的越来越晚，导致抖动。而抖动，就是用来描述这样一延迟变化的程度。因此，抖动对于实时性的传输将会是一个重要参数，比如：VOIP，视频等。

### 解决方法

1. **数据包接收端的抖动缓存**：缓存指针队列对接收到的数据包进行排序后，将接收到的数据包插入抖动缓存指针队列的相应位置；

2. **抖动缓存指针队列的出队线程定时器**：以一定时间间隔触发出队线程，出队线程判断抖动缓存指针队列队头的数据包，是否应该在当前触发时刻出队，如果是，则将该数据包出队。

---

## 13. http与https的区别

| 特性 | HTTP | HTTPS |
|------|------|-------|
| 安全性 | HTTP协议以明文方式发送内容，不提供任何方式的数据加密。HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息 | HTTPS则是具有安全性的SSL加密传输协议 |
| 连接方式 | - | HTTP和HTTPS使用的是完全不同的连接方式 |
| 端口 | 80 | 443 |
| 证书 | - | HTTPS协议需要到CA申请证书 |
| 协议组成 | - | HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全 |

### HTTPS协议的主要作用

1. **建立一个信息安全通道**：来保证数据传输的安全
2. **确认网站的真实性**

### HTTPS工作原理

HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

---

## 总结

这份Unity网络相关面试题总结涵盖了以下核心知识点：

1. **网络基础**：OSI七层模型、TCP/IP协议栈
2. **传输协议**：TCP与UDP的区别和特点
3. **Socket编程**：粘包问题、封包拆包、客户端队列
4. **序列化**：XML、JSON、Protobuf三种方案的比较
5. **网络优化**：网络抖动的原因和解决方法
6. **安全协议**：HTTP与HTTPS的区别

这些知识点是Unity网络编程中的核心内容，掌握这些内容对于面试和实际开发都非常重要。

---

**参考来源**：CSDN博客 - 呆呆敲代码的小Y

