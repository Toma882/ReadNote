{
    "sourceFile": "Assets/UnityEditor/Chapter 8 UnityAPI/Unity/Burst/BurstExample.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1750930238638,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1750930238638,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing Unity.Burst;\r\nusing Unity.Collections;\r\nusing Unity.Jobs;\r\nusing Unity.Mathematics;\r\nusing System;\r\n\r\n/// <summary>\r\n/// Unity.Burst 命名空间案例演示\r\n/// 展示Burst编译器的高性能计算功能\r\n/// </summary>\r\npublic class BurstExample : MonoBehaviour\r\n{\r\n    [Header(\"Burst设置\")]\r\n    [SerializeField] private bool enableBurst = true;\r\n    [SerializeField] private int arraySize = 1000000;\r\n    [SerializeField] private int iterationCount = 100;\r\n    \r\n    [Header(\"性能测试\")]\r\n    [SerializeField] private float burstTime = 0f;\r\n    [SerializeField] private float managedTime = 0f;\r\n    [SerializeField] private float speedup = 0f;\r\n    \r\n    [Header(\"计算结果\")]\r\n    [SerializeField] private float[] results;\r\n    [SerializeField] private float sum = 0f;\r\n    [SerializeField] private float average = 0f;\r\n    [SerializeField] private float maxValue = 0f;\r\n    [SerializeField] private float minValue = 0f;\r\n    \r\n    // 测试数据\r\n    private NativeArray<float> testData;\r\n    private bool isInitialized = false;\r\n    \r\n    private void Start()\r\n    {\r\n        InitializeBurstSystem();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 初始化Burst系统\r\n    /// </summary>\r\n    private void InitializeBurstSystem()\r\n    {\r\n        // 检查Burst是否可用\r\n        if (!BurstCompiler.IsEnabled)\r\n        {\r\n            Debug.LogWarning(\"Burst编译器未启用\");\r\n            return;\r\n        }\r\n        \r\n        // 创建测试数据\r\n        CreateTestData();\r\n        \r\n        isInitialized = true;\r\n        Debug.Log(\"Burst系统初始化完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 创建测试数据\r\n    /// </summary>\r\n    private void CreateTestData()\r\n    {\r\n        // 分配原生数组\r\n        testData = new NativeArray<float>(arraySize, Allocator.Persistent);\r\n        \r\n        // 填充随机数据\r\n        for (int i = 0; i < arraySize; i++)\r\n        {\r\n            testData[i] = UnityEngine.Random.Range(0f, 1000f);\r\n        }\r\n        \r\n        Debug.Log($\"测试数据已创建，大小: {arraySize}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 运行Burst性能测试\r\n    /// </summary>\r\n    [ContextMenu(\"运行Burst性能测试\")]\r\n    public void RunBurstPerformanceTest()\r\n    {\r\n        if (!isInitialized)\r\n        {\r\n            Debug.LogError(\"Burst系统未初始化\");\r\n            return;\r\n        }\r\n        \r\n        Debug.Log(\"开始Burst性能测试...\");\r\n        \r\n        // 测试Burst版本\r\n        var burstJob = new BurstMathJob\r\n        {\r\n            input = testData,\r\n            output = new NativeArray<float>(arraySize, Allocator.TempJob)\r\n        };\r\n        \r\n        var burstHandle = burstJob.Schedule();\r\n        \r\n        var stopwatch = System.Diagnostics.Stopwatch.StartNew();\r\n        burstHandle.Complete();\r\n        stopwatch.Stop();\r\n        \r\n        burstTime = (float)stopwatch.Elapsed.TotalMilliseconds;\r\n        \r\n        // 保存结果\r\n        results = new float[arraySize];\r\n        burstJob.output.CopyTo(results);\r\n        \r\n        // 计算统计信息\r\n        CalculateStatistics();\r\n        \r\n        // 清理\r\n        burstJob.output.Dispose();\r\n        \r\n        Debug.Log($\"Burst版本完成，耗时: {burstTime:F2}ms\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 运行托管代码性能测试\r\n    /// </summary>\r\n    [ContextMenu(\"运行托管代码性能测试\")]\r\n    public void RunManagedPerformanceTest()\r\n    {\r\n        if (!isInitialized)\r\n        {\r\n            Debug.LogError(\"Burst系统未初始化\");\r\n            return;\r\n        }\r\n        \r\n        Debug.Log(\"开始托管代码性能测试...\");\r\n        \r\n        var managedData = new float[arraySize];\r\n        testData.CopyTo(managedData);\r\n        \r\n        var output = new float[arraySize];\r\n        \r\n        var stopwatch = System.Diagnostics.Stopwatch.StartNew();\r\n        \r\n        // 执行托管代码计算\r\n        for (int iter = 0; iter < iterationCount; iter++)\r\n        {\r\n            for (int i = 0; i < arraySize; i++)\r\n            {\r\n                output[i] = ManagedMath(managedData[i]);\r\n            }\r\n        }\r\n        \r\n        stopwatch.Stop();\r\n        managedTime = (float)stopwatch.Elapsed.TotalMilliseconds;\r\n        \r\n        // 计算加速比\r\n        if (managedTime > 0)\r\n        {\r\n            speedup = managedTime / burstTime;\r\n        }\r\n        \r\n        Debug.Log($\"托管代码版本完成，耗时: {managedTime:F2}ms\");\r\n        Debug.Log($\"Burst加速比: {speedup:F2}x\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 托管代码数学计算\r\n    /// </summary>\r\n    /// <param name=\"value\">输入值</param>\r\n    /// <returns>计算结果</returns>\r\n    private float ManagedMath(float value)\r\n    {\r\n        // 模拟复杂的数学计算\r\n        float result = value;\r\n        \r\n        // 正弦波计算\r\n        result += math.sin(value * 0.1f) * 10f;\r\n        \r\n        // 平方根计算\r\n        result += math.sqrt(math.abs(value)) * 0.5f;\r\n        \r\n        // 指数计算\r\n        result += math.exp(value * 0.01f) * 0.1f;\r\n        \r\n        // 对数计算\r\n        if (value > 0)\r\n        {\r\n            result += math.log(value + 1f) * 2f;\r\n        }\r\n        \r\n        // 三角函数\r\n        result += math.cos(value * 0.05f) * 5f;\r\n        result += math.tan(value * 0.02f) * 1f;\r\n        \r\n        // 幂运算\r\n        result += math.pow(value, 0.5f) * 3f;\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 计算统计信息\r\n    /// </summary>\r\n    private void CalculateStatistics()\r\n    {\r\n        if (results == null || results.Length == 0)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        sum = 0f;\r\n        maxValue = float.MinValue;\r\n        minValue = float.MaxValue;\r\n        \r\n        for (int i = 0; i < results.Length; i++)\r\n        {\r\n            float value = results[i];\r\n            sum += value;\r\n            \r\n            if (value > maxValue)\r\n            {\r\n                maxValue = value;\r\n            }\r\n            \r\n            if (value < minValue)\r\n            {\r\n                minValue = value;\r\n            }\r\n        }\r\n        \r\n        average = sum / results.Length;\r\n        \r\n        Debug.Log($\"统计信息 - 总和: {sum:F2}, 平均值: {average:F2}, 最大值: {maxValue:F2}, 最小值: {minValue:F2}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 运行向量运算测试\r\n    /// </summary>\r\n    [ContextMenu(\"运行向量运算测试\")]\r\n    public void RunVectorMathTest()\r\n    {\r\n        if (!isInitialized)\r\n        {\r\n            Debug.LogError(\"Burst系统未初始化\");\r\n            return;\r\n        }\r\n        \r\n        Debug.Log(\"开始向量运算测试...\");\r\n        \r\n        var vectorJob = new BurstVectorJob\r\n        {\r\n            input = new NativeArray<float3>(arraySize, Allocator.TempJob),\r\n            output = new NativeArray<float3>(arraySize, Allocator.TempJob)\r\n        };\r\n        \r\n        // 填充向量数据\r\n        for (int i = 0; i < arraySize; i++)\r\n        {\r\n            vectorJob.input[i] = new float3(\r\n                UnityEngine.Random.Range(-100f, 100f),\r\n                UnityEngine.Random.Range(-100f, 100f),\r\n                UnityEngine.Random.Range(-100f, 100f)\r\n            );\r\n        }\r\n        \r\n        var handle = vectorJob.Schedule();\r\n        handle.Complete();\r\n        \r\n        // 计算向量统计\r\n        float3 sum = float3.zero;\r\n        float maxMagnitude = 0f;\r\n        \r\n        for (int i = 0; i < arraySize; i++)\r\n        {\r\n            sum += vectorJob.output[i];\r\n            float magnitude = math.length(vectorJob.output[i]);\r\n            if (magnitude > maxMagnitude)\r\n            {\r\n                maxMagnitude = magnitude;\r\n            }\r\n        }\r\n        \r\n        float3 average = sum / arraySize;\r\n        \r\n        Debug.Log($\"向量运算完成 - 平均向量: {average}, 最大幅度: {maxMagnitude:F2}\");\r\n        \r\n        // 清理\r\n        vectorJob.input.Dispose();\r\n        vectorJob.output.Dispose();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 运行矩阵运算测试\r\n    /// </summary>\r\n    [ContextMenu(\"运行矩阵运算测试\")]\r\n    public void RunMatrixMathTest()\r\n    {\r\n        if (!isInitialized)\r\n        {\r\n            Debug.LogError(\"Burst系统未初始化\");\r\n            return;\r\n        }\r\n        \r\n        Debug.Log(\"开始矩阵运算测试...\");\r\n        \r\n        var matrixJob = new BurstMatrixJob\r\n        {\r\n            input = new NativeArray<float4x4>(arraySize / 100, Allocator.TempJob),\r\n            output = new NativeArray<float4x4>(arraySize / 100, Allocator.TempJob)\r\n        };\r\n        \r\n        // 填充矩阵数据\r\n        for (int i = 0; i < matrixJob.input.Length; i++)\r\n        {\r\n            matrixJob.input[i] = float4x4.TRS(\r\n                new float3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)),\r\n                quaternion.Euler(UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f)),\r\n                new float3(UnityEngine.Random.Range(0.1f, 2f), UnityEngine.Random.Range(0.1f, 2f), UnityEngine.Random.Range(0.1f, 2f))\r\n            );\r\n        }\r\n        \r\n        var handle = matrixJob.Schedule();\r\n        handle.Complete();\r\n        \r\n        Debug.Log($\"矩阵运算完成，处理了 {matrixJob.input.Length} 个矩阵\");\r\n        \r\n        // 清理\r\n        matrixJob.input.Dispose();\r\n        matrixJob.output.Dispose();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 运行并行计算测试\r\n    /// </summary>\r\n    [ContextMenu(\"运行并行计算测试\")]\r\n    public void RunParallelComputationTest()\r\n    {\r\n        if (!isInitialized)\r\n        {\r\n            Debug.LogError(\"Burst系统未初始化\");\r\n            return;\r\n        }\r\n        \r\n        Debug.Log(\"开始并行计算测试...\");\r\n        \r\n        var parallelJob = new BurstParallelJob\r\n        {\r\n            input = testData,\r\n            output = new NativeArray<float>(arraySize, Allocator.TempJob),\r\n            iterationCount = iterationCount\r\n        };\r\n        \r\n        var handle = parallelJob.Schedule(arraySize, 64);\r\n        handle.Complete();\r\n        \r\n        // 计算并行结果统计\r\n        float parallelSum = 0f;\r\n        for (int i = 0; i < arraySize; i++)\r\n        {\r\n            parallelSum += parallelJob.output[i];\r\n        }\r\n        \r\n        Debug.Log($\"并行计算完成，总和: {parallelSum:F2}\");\r\n        \r\n        // 清理\r\n        parallelJob.output.Dispose();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取Burst信息\r\n    /// </summary>\r\n    public void GetBurstInfo()\r\n    {\r\n        Debug.Log(\"=== Burst信息 ===\");\r\n        Debug.Log($\"Burst启用: {BurstCompiler.IsEnabled}\");\r\n        Debug.Log($\"Burst编译器版本: {BurstCompiler.Version}\");\r\n        Debug.Log($\"数组大小: {arraySize}\");\r\n        Debug.Log($\"迭代次数: {iterationCount}\");\r\n        Debug.Log($\"Burst耗时: {burstTime:F2}ms\");\r\n        Debug.Log($\"托管代码耗时: {managedTime:F2}ms\");\r\n        Debug.Log($\"加速比: {speedup:F2}x\");\r\n        Debug.Log($\"系统初始化: {isInitialized}\");\r\n        \r\n        if (results != null)\r\n        {\r\n            Debug.Log($\"计算结果数量: {results.Length}\");\r\n            Debug.Log($\"计算结果总和: {sum:F2}\");\r\n            Debug.Log($\"计算结果平均值: {average:F2}\");\r\n            Debug.Log($\"计算结果最大值: {maxValue:F2}\");\r\n            Debug.Log($\"计算结果最小值: {minValue:F2}\");\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 重置Burst设置\r\n    /// </summary>\r\n    public void ResetBurstSettings()\r\n    {\r\n        // 重置性能数据\r\n        burstTime = 0f;\r\n        managedTime = 0f;\r\n        speedup = 0f;\r\n        \r\n        // 重置结果\r\n        results = null;\r\n        sum = 0f;\r\n        average = 0f;\r\n        maxValue = 0f;\r\n        minValue = 0f;\r\n        \r\n        Debug.Log(\"Burst设置已重置\");\r\n    }\r\n    \r\n    private void OnDestroy()\r\n    {\r\n        // 清理原生数组\r\n        if (testData.IsCreated)\r\n        {\r\n            testData.Dispose();\r\n        }\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// Burst数学计算Job\r\n/// </summary>\r\n[BurstCompile]\r\npublic struct BurstMathJob : IJob\r\n{\r\n    [ReadOnly] public NativeArray<float> input;\r\n    [WriteOnly] public NativeArray<float> output;\r\n    \r\n    public void Execute()\r\n    {\r\n        for (int i = 0; i < input.Length; i++)\r\n        {\r\n            output[i] = BurstMath(input[i]);\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// Burst优化的数学计算\r\n    /// </summary>\r\n    /// <param name=\"value\">输入值</param>\r\n    /// <returns>计算结果</returns>\r\n    private float BurstMath(float value)\r\n    {\r\n        // 使用Burst优化的数学函数\r\n        float result = value;\r\n        \r\n        // 正弦波计算\r\n        result += math.sin(value * 0.1f) * 10f;\r\n        \r\n        // 平方根计算\r\n        result += math.sqrt(math.abs(value)) * 0.5f;\r\n        \r\n        // 指数计算\r\n        result += math.exp(value * 0.01f) * 0.1f;\r\n        \r\n        // 对数计算\r\n        if (value > 0)\r\n        {\r\n            result += math.log(value + 1f) * 2f;\r\n        }\r\n        \r\n        // 三角函数\r\n        result += math.cos(value * 0.05f) * 5f;\r\n        result += math.tan(value * 0.02f) * 1f;\r\n        \r\n        // 幂运算\r\n        result += math.pow(value, 0.5f) * 3f;\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// Burst向量运算Job\r\n/// </summary>\r\n[BurstCompile]\r\npublic struct BurstVectorJob : IJob\r\n{\r\n    [ReadOnly] public NativeArray<float3> input;\r\n    [WriteOnly] public NativeArray<float3> output;\r\n    \r\n    public void Execute()\r\n    {\r\n        for (int i = 0; i < input.Length; i++)\r\n        {\r\n            float3 vec = input[i];\r\n            \r\n            // 向量运算\r\n            float3 result = vec;\r\n            \r\n            // 向量旋转\r\n            result = math.mul(quaternion.Euler(0, 45, 0), result);\r\n            \r\n            // 向量缩放\r\n            result *= 1.5f;\r\n            \r\n            // 向量归一化\r\n            if (math.lengthsq(result) > 0)\r\n            {\r\n                result = math.normalize(result);\r\n            }\r\n            \r\n            // 向量反射\r\n            float3 normal = new float3(0, 1, 0);\r\n            result = math.reflect(result, normal);\r\n            \r\n            output[i] = result;\r\n        }\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// Burst矩阵运算Job\r\n/// </summary>\r\n[BurstCompile]\r\npublic struct BurstMatrixJob : IJob\r\n{\r\n    [ReadOnly] public NativeArray<float4x4> input;\r\n    [WriteOnly] public NativeArray<float4x4> output;\r\n    \r\n    public void Execute()\r\n    {\r\n        for (int i = 0; i < input.Length; i++)\r\n        {\r\n            float4x4 matrix = input[i];\r\n            \r\n            // 矩阵运算\r\n            float4x4 result = matrix;\r\n            \r\n            // 矩阵转置\r\n            result = math.transpose(result);\r\n            \r\n            // 矩阵求逆\r\n            if (math.determinant(result) != 0)\r\n            {\r\n                result = math.inverse(result);\r\n            }\r\n            \r\n            // 矩阵乘法\r\n            float4x4 rotation = float4x4.RotateY(math.radians(30f));\r\n            result = math.mul(result, rotation);\r\n            \r\n            output[i] = result;\r\n        }\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// Burst并行计算Job\r\n/// </summary>\r\n[BurstCompile]\r\npublic struct BurstParallelJob : IJobParallelFor\r\n{\r\n    [ReadOnly] public NativeArray<float> input;\r\n    [WriteOnly] public NativeArray<float> output;\r\n    public int iterationCount;\r\n    \r\n    public void Execute(int index)\r\n    {\r\n        float value = input[index];\r\n        \r\n        // 多次迭代计算\r\n        for (int iter = 0; iter < iterationCount; iter++)\r\n        {\r\n            value = BurstMath(value);\r\n        }\r\n        \r\n        output[index] = value;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// Burst优化的数学计算\r\n    /// </summary>\r\n    /// <param name=\"value\">输入值</param>\r\n    /// <returns>计算结果</returns>\r\n    private float BurstMath(float value)\r\n    {\r\n        float result = value;\r\n        \r\n        // 复杂的数学运算\r\n        result += math.sin(value * 0.1f) * 10f;\r\n        result += math.sqrt(math.abs(value)) * 0.5f;\r\n        result += math.exp(value * 0.01f) * 0.1f;\r\n        \r\n        if (value > 0)\r\n        {\r\n            result += math.log(value + 1f) * 2f;\r\n        }\r\n        \r\n        result += math.cos(value * 0.05f) * 5f;\r\n        result += math.tan(value * 0.02f) * 1f;\r\n        result += math.pow(value, 0.5f) * 3f;\r\n        \r\n        return result;\r\n    }\r\n} "
        }
    ]
}