{
    "sourceFile": "Collections/CollectionsExample.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1761419668619,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1761419680695,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,19 +1,20 @@\n // CollectionsExample.cs\r\n // .NET集合API使用详解示例\r\n-// 包含List、Dictionary、HashSet、Queue、Stack、LinkedList、Linq等常用集合类型\r\n+// 包含List、Dictionary、ConcurrentDictionary、HashSet、Queue、Stack、LinkedList、Linq等常用集合类型\r\n // 每个方法、关键步骤、枚举值均有详细中文注释\r\n // 适合.NET初学者学习和查阅\r\n // \r\n // 主要功能模块：\r\n // 1. List<T> - 动态数组，支持随机访问和动态扩容\r\n // 2. Dictionary<TKey,TValue> - 键值对集合，快速查找\r\n-// 3. HashSet<T> - 无序不重复集合，快速查找和去重\r\n-// 4. Queue<T> - 队列，先进先出(FIFO)\r\n-// 5. Stack<T> - 栈，后进先出(LIFO)\r\n-// 6. LinkedList<T> - 双向链表，高效插入删除\r\n-// 7. LINQ - 语言集成查询，强大的数据操作\r\n-// 8. 高级集合操作 - 性能优化和特殊用法\r\n+// 3. ConcurrentDictionary<TKey,TValue> - 线程安全的键值对集合\r\n+// 4. HashSet<T> - 无序不重复集合，快速查找和去重\r\n+// 5. Queue<T> - 队列，先进先出(FIFO)\r\n+// 6. Stack<T> - 栈，后进先出(LIFO)\r\n+// 7. LinkedList<T> - 双向链表，高效插入删除\r\n+// 8. LINQ - 语言集成查询，强大的数据操作\r\n+// 9. 高级集合操作 - 性能优化和特殊用法\r\n \r\n using System;\r\n using System.Collections.Generic;\r\n using System.Collections.Concurrent;\r\n@@ -23,13 +24,14 @@\n namespace DotNet.Collections\r\n {\r\n     /// <summary>\r\n     /// .NET集合API使用详解示例\r\n-    /// 演示List、Dictionary、HashSet、Queue、Stack、LinkedList、Linq等常用集合类型\r\n+    /// 演示List、Dictionary、ConcurrentDictionary、HashSet、Queue、Stack、LinkedList、Linq等常用集合类型\r\n     /// \r\n     /// 重要说明：\r\n     /// - List<T>是最常用的集合类型，适合大多数场景\r\n     /// - Dictionary<TKey,TValue>提供O(1)的查找性能\r\n+    /// - ConcurrentDictionary<TKey,TValue>提供线程安全的字典操作\r\n     /// - HashSet<T>适合去重和快速成员检查\r\n     /// - Queue和Stack适合特定算法场景\r\n     /// - LinkedList<T>适合频繁插入删除操作\r\n     /// - LINQ提供强大的数据查询和转换功能\r\n"
                },
                {
                    "date": 1761419686641,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -76,8 +76,9 @@\n             Debug.Log($\"测试数据规模: {testDataSize}\");\r\n             \r\n             ListExample();      // List<T> 动态数组\r\n             DictionaryExample(); // Dictionary<TKey, TValue> 键值对集合\r\n+            ConcurrentDictionaryExample(); // ConcurrentDictionary<TKey, TValue> 线程安全字典\r\n             HashSetExample();   // HashSet<T> 无序不重复集合\r\n             QueueExample();     // Queue<T> 队列（先进先出）\r\n             StackExample();     // Stack<T> 栈（后进先出）\r\n             LinkedListExample(); // LinkedList<T> 双向链表\r\n"
                },
                {
                    "date": 1761419695791,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,19 +56,20 @@\n         }\r\n \r\n         /// <summary>\r\n         /// 运行所有集合相关示例\r\n-        /// 按顺序执行：List -> Dictionary -> HashSet -> Queue -> Stack -> LinkedList -> Linq -> 高级集合操作\r\n+        /// 按顺序执行：List -> Dictionary -> ConcurrentDictionary -> HashSet -> Queue -> Stack -> LinkedList -> Linq -> 高级集合操作\r\n         /// \r\n         /// 执行流程：\r\n         /// 1. 基础动态数组操作\r\n         /// 2. 键值对集合操作\r\n-        /// 3. 无序不重复集合操作\r\n-        /// 4. 队列操作\r\n-        /// 5. 栈操作\r\n-        /// 6. 链表操作\r\n-        /// 7. LINQ查询操作\r\n-        /// 8. 高级集合功能\r\n+        /// 3. 线程安全字典操作\r\n+        /// 4. 无序不重复集合操作\r\n+        /// 5. 队列操作\r\n+        /// 6. 栈操作\r\n+        /// 7. 链表操作\r\n+        /// 8. LINQ查询操作\r\n+        /// 9. 高级集合功能\r\n         /// </summary>\r\n         private void RunAllExamples()\r\n         {\r\n             Debug.Log(\"=== .NET集合API示例开始 ===\");\r\n"
                },
                {
                    "date": 1761419763503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -566,8 +566,246 @@\n                 Debug.LogError($\"异常类型: {ex.GetType().Name}\");\r\n             }\r\n         }\r\n \r\n+        // ================= ConcurrentDictionary<TKey, TValue> 线程安全字典 =================\r\n+        /// <summary>\r\n+        /// ConcurrentDictionary<TKey, TValue> 线程安全字典示例\r\n+        /// ConcurrentDictionary提供线程安全的字典操作，适合多线程环境\r\n+        /// \r\n+        /// 主要特性：\r\n+        /// - 线程安全，支持并发读写\r\n+        /// - O(1)平均查找性能\r\n+        /// - 原子操作，避免竞态条件\r\n+        /// - 无锁设计，性能优异\r\n+        /// \r\n+        /// 使用场景：\r\n+        /// - 多线程环境下的数据共享\r\n+        /// - 缓存系统\r\n+        /// - 计数器集合\r\n+        /// - 状态管理\r\n+        /// \r\n+        /// 注意事项：\r\n+        /// - 比普通Dictionary稍慢\r\n+        /// - 某些操作不是原子性的\r\n+        /// - 迭代时可能看到不一致的状态\r\n+        /// </summary>\r\n+        private void ConcurrentDictionaryExample()\r\n+        {\r\n+            Debug.Log(\"--- ConcurrentDictionary<TKey, TValue> 线程安全字典示例 ---\");\r\n+            \r\n+            try\r\n+            {\r\n+                // ========== 创建和初始化 ==========\r\n+                \r\n+                // 创建空并发字典\r\n+                // 参数说明：无\r\n+                // 返回值：ConcurrentDictionary<TKey, TValue> - 空并发字典实例\r\n+                var emptyConcurrentDict = new ConcurrentDictionary<string, int>();\r\n+                Debug.Log($\"空并发字典容量: {emptyConcurrentDict.Count}\");\r\n+                \r\n+                // 创建并初始化并发字典\r\n+                // 参数说明：collection - 初始键值对集合\r\n+                // 返回值：ConcurrentDictionary<TKey, TValue> - 包含初始元素的并发字典\r\n+                var concurrentScores = new ConcurrentDictionary<string, int>\r\n+                {\r\n+                    [\"Alice\"] = 95,\r\n+                    [\"Bob\"] = 87,\r\n+                    [\"Charlie\"] = 92,\r\n+                    [\"David\"] = 78,\r\n+                    [\"Eve\"] = 89\r\n+                };\r\n+                Debug.Log($\"初始化并发字典: {concurrentScores.Count}个键值对\");\r\n+                \r\n+                // 指定初始容量\r\n+                // 参数说明：capacity - 初始容量\r\n+                // 返回值：ConcurrentDictionary<TKey, TValue> - 指定容量的空并发字典\r\n+                var capacityConcurrentDict = new ConcurrentDictionary<string, int>(100);\r\n+                Debug.Log($\"指定容量的并发字典已创建\");\r\n+                \r\n+                // ========== 线程安全的添加和更新操作 ==========\r\n+                \r\n+                // TryAdd: 尝试添加键值对（线程安全）\r\n+                // 参数说明：key - 键, value - 值\r\n+                // 返回值：bool - 是否添加成功\r\n+                // 时间复杂度：平均O(1)\r\n+                bool addResult = concurrentScores.TryAdd(\"Frank\", 85);\r\n+                Debug.Log($\"TryAdd(Frank, 85)结果: {addResult}, 当前数量: {concurrentScores.Count}\");\r\n+                \r\n+                // TryAdd 重复键会失败\r\n+                bool addDuplicateResult = concurrentScores.TryAdd(\"Alice\", 100);\r\n+                Debug.Log($\"TryAdd重复键(Alice, 100)结果: {addDuplicateResult}\");\r\n+                \r\n+                // TryUpdate: 尝试更新值（线程安全）\r\n+                // 参数说明：key - 键, newValue - 新值, comparisonValue - 期望的旧值\r\n+                // 返回值：bool - 是否更新成功\r\n+                bool updateResult = concurrentScores.TryUpdate(\"Alice\", 98, 95);\r\n+                Debug.Log($\"TryUpdate(Alice, 98, 95)结果: {updateResult}\");\r\n+                \r\n+                // TryUpdate 期望值不匹配会失败\r\n+                bool updateFailResult = concurrentScores.TryUpdate(\"Alice\", 100, 90);\r\n+                Debug.Log($\"TryUpdate期望值不匹配结果: {updateFailResult}\");\r\n+                \r\n+                // AddOrUpdate: 添加或更新（线程安全）\r\n+                // 参数说明：key - 键, addValue - 添加时的值, updateValueFactory - 更新时的值工厂\r\n+                // 返回值：TValue - 最终的值\r\n+                int finalValue = concurrentScores.AddOrUpdate(\"Grace\", 91, (key, oldValue) => oldValue + 5);\r\n+                Debug.Log($\"AddOrUpdate(Grace)结果: {finalValue}\");\r\n+                \r\n+                // AddOrUpdate 更新现有值\r\n+                int updatedValue = concurrentScores.AddOrUpdate(\"Alice\", 0, (key, oldValue) => oldValue + 2);\r\n+                Debug.Log($\"AddOrUpdate(Alice)更新结果: {updatedValue}\");\r\n+                \r\n+                // GetOrAdd: 获取或添加（线程安全）\r\n+                // 参数说明：key - 键, value - 添加时的值\r\n+                // 返回值：TValue - 获取或添加的值\r\n+                int getOrAddValue = concurrentScores.GetOrAdd(\"Henry\", 88);\r\n+                Debug.Log($\"GetOrAdd(Henry, 88)结果: {getOrAddValue}\");\r\n+                \r\n+                // GetOrAdd 获取现有值\r\n+                int existingValue = concurrentScores.GetOrAdd(\"Alice\", 0);\r\n+                Debug.Log($\"GetOrAdd(Alice)获取现有值: {existingValue}\");\r\n+                \r\n+                // ========== 线程安全的访问操作 ==========\r\n+                \r\n+                // TryGetValue: 尝试获取值（线程安全）\r\n+                // 参数说明：key - 键, value - 输出参数，存储获取的值\r\n+                // 返回值：bool - 是否获取成功\r\n+                if (concurrentScores.TryGetValue(\"Bob\", out int bobScore))\r\n+                {\r\n+                    Debug.Log($\"TryGetValue(Bob)成功: {bobScore}\");\r\n+                }\r\n+                \r\n+                // TryGetValue 不存在的键\r\n+                if (!concurrentScores.TryGetValue(\"NonExistent\", out int nonExistentScore))\r\n+                {\r\n+                    Debug.Log($\"TryGetValue(NonExistent)失败\");\r\n+                }\r\n+                \r\n+                // 索引器访问（线程安全）\r\n+                // 参数说明：key - 键\r\n+                // 返回值：TValue - 值\r\n+                // 注意事项：如果键不存在会抛出异常\r\n+                int aliceScore = concurrentScores[\"Alice\"];\r\n+                Debug.Log($\"索引器访问Alice: {aliceScore}\");\r\n+                \r\n+                // ContainsKey: 检查键是否存在（线程安全）\r\n+                // 参数说明：key - 键\r\n+                // 返回值：bool - 是否存在\r\n+                bool containsAlice = concurrentScores.ContainsKey(\"Alice\");\r\n+                bool containsNonExistent = concurrentScores.ContainsKey(\"NonExistent\");\r\n+                Debug.Log($\"ContainsKey(Alice): {containsAlice}, ContainsKey(NonExistent): {containsNonExistent}\");\r\n+                \r\n+                // ========== 线程安全的删除操作 ==========\r\n+                \r\n+                // TryRemove: 尝试删除键值对（线程安全）\r\n+                // 参数说明：key - 键, value - 输出参数，存储被删除的值\r\n+                // 返回值：bool - 是否删除成功\r\n+                if (concurrentScores.TryRemove(\"David\", out int removedScore))\r\n+                {\r\n+                    Debug.Log($\"TryRemove(David)成功，删除的值: {removedScore}, 剩余数量: {concurrentScores.Count}\");\r\n+                }\r\n+                \r\n+                // TryRemove 不存在的键\r\n+                if (!concurrentScores.TryRemove(\"NonExistent\", out int nonRemovedScore))\r\n+                {\r\n+                    Debug.Log($\"TryRemove(NonExistent)失败\");\r\n+                }\r\n+                \r\n+                // ========== 批量操作 ==========\r\n+                \r\n+                // ToArray: 转换为数组（线程安全）\r\n+                // 参数说明：无\r\n+                // 返回值：KeyValuePair<TKey, TValue>[] - 键值对数组\r\n+                var keyValuePairs = concurrentScores.ToArray();\r\n+                Debug.Log($\"ToArray结果: {keyValuePairs.Length}个键值对\");\r\n+                \r\n+                // Keys: 获取所有键的集合（线程安全）\r\n+                // 参数说明：无\r\n+                // 返回值：ICollection<TKey> - 键的集合\r\n+                var keys = concurrentScores.Keys;\r\n+                Debug.Log($\"Keys集合: {string.Join(\", \", keys)}\");\r\n+                \r\n+                // Values: 获取所有值的集合（线程安全）\r\n+                // 参数说明：无\r\n+                // 返回值：ICollection<TValue> - 值的集合\r\n+                var values = concurrentScores.Values;\r\n+                Debug.Log($\"Values集合: {string.Join(\", \", values)}\");\r\n+                \r\n+                // Count: 获取键值对数量（线程安全）\r\n+                // 参数说明：无\r\n+                // 返回值：int - 键值对数量\r\n+                int count = concurrentScores.Count;\r\n+                Debug.Log($\"当前键值对数量: {count}\");\r\n+                \r\n+                // IsEmpty: 检查是否为空（线程安全）\r\n+                // 参数说明：无\r\n+                // 返回值：bool - 是否为空\r\n+                bool isEmpty = concurrentScores.IsEmpty;\r\n+                Debug.Log($\"字典是否为空: {isEmpty}\");\r\n+                \r\n+                // ========== 高级操作 ==========\r\n+                \r\n+                // GetEnumerator: 获取枚举器（线程安全）\r\n+                // 参数说明：无\r\n+                // 返回值：IEnumerator<KeyValuePair<TKey, TValue>> - 枚举器\r\n+                Debug.Log(\"遍历并发字典:\");\r\n+                foreach (var kvp in concurrentScores)\r\n+                {\r\n+                    Debug.Log($\"  {kvp.Key}: {kvp.Value}\");\r\n+                }\r\n+                \r\n+                // Clear: 清空字典（线程安全）\r\n+                // 参数说明：无\r\n+                // 返回值：void\r\n+                var tempDict = new ConcurrentDictionary<string, int>(concurrentScores);\r\n+                tempDict.Clear();\r\n+                Debug.Log($\"Clear后数量: {tempDict.Count}\");\r\n+                \r\n+                // ========== 性能测试 ==========\r\n+                \r\n+                if (showPerformanceTests)\r\n+                {\r\n+                    Debug.Log(\"--- ConcurrentDictionary性能测试 ---\");\r\n+                    \r\n+                    var perfDict = new ConcurrentDictionary<int, string>();\r\n+                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();\r\n+                    \r\n+                    // 添加性能测试\r\n+                    for (int i = 0; i < testDataSize; i++)\r\n+                    {\r\n+                        perfDict.TryAdd(i, $\"Value_{i}\");\r\n+                    }\r\n+                    stopwatch.Stop();\r\n+                    Debug.Log($\"添加{testDataSize}个元素耗时: {stopwatch.ElapsedMilliseconds}ms\");\r\n+                    \r\n+                    // 查找性能测试\r\n+                    stopwatch.Restart();\r\n+                    for (int i = 0; i < testDataSize; i++)\r\n+                    {\r\n+                        perfDict.TryGetValue(i, out string value);\r\n+                    }\r\n+                    stopwatch.Stop();\r\n+                    Debug.Log($\"查找{testDataSize}次耗时: {stopwatch.ElapsedMilliseconds}ms\");\r\n+                    \r\n+                    // 更新性能测试\r\n+                    stopwatch.Restart();\r\n+                    for (int i = 0; i < testDataSize; i++)\r\n+                    {\r\n+                        perfDict.TryUpdate(i, $\"Updated_{i}\", $\"Value_{i}\");\r\n+                    }\r\n+                    stopwatch.Stop();\r\n+                    Debug.Log($\"更新{testDataSize}次耗时: {stopwatch.ElapsedMilliseconds}ms\");\r\n+                }\r\n+                \r\n+            }\r\n+            catch (Exception ex)\r\n+            {\r\n+                Debug.LogError($\"ConcurrentDictionary操作出错: {ex.Message}\");\r\n+                Debug.LogError($\"异常类型: {ex.GetType().Name}\");\r\n+            }\r\n+        }\r\n+\r\n         // ================= HashSet<T> 无序不重复集合 =================\r\n         /// <summary>\r\n         /// HashSet<T> 无序不重复集合示例\r\n         /// HashSet提供O(1)的查找性能，元素唯一且无序\r\n"
                }
            ],
            "date": 1761419668619,
            "name": "Commit-0",
            "content": "// CollectionsExample.cs\r\n// .NET集合API使用详解示例\r\n// 包含List、Dictionary、HashSet、Queue、Stack、LinkedList、Linq等常用集合类型\r\n// 每个方法、关键步骤、枚举值均有详细中文注释\r\n// 适合.NET初学者学习和查阅\r\n// \r\n// 主要功能模块：\r\n// 1. List<T> - 动态数组，支持随机访问和动态扩容\r\n// 2. Dictionary<TKey,TValue> - 键值对集合，快速查找\r\n// 3. HashSet<T> - 无序不重复集合，快速查找和去重\r\n// 4. Queue<T> - 队列，先进先出(FIFO)\r\n// 5. Stack<T> - 栈，后进先出(LIFO)\r\n// 6. LinkedList<T> - 双向链表，高效插入删除\r\n// 7. LINQ - 语言集成查询，强大的数据操作\r\n// 8. 高级集合操作 - 性能优化和特殊用法\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Concurrent;\r\nusing System.Linq;\r\nusing UnityEngine;\r\n\r\nnamespace DotNet.Collections\r\n{\r\n    /// <summary>\r\n    /// .NET集合API使用详解示例\r\n    /// 演示List、Dictionary、HashSet、Queue、Stack、LinkedList、Linq等常用集合类型\r\n    /// \r\n    /// 重要说明：\r\n    /// - List<T>是最常用的集合类型，适合大多数场景\r\n    /// - Dictionary<TKey,TValue>提供O(1)的查找性能\r\n    /// - HashSet<T>适合去重和快速成员检查\r\n    /// - Queue和Stack适合特定算法场景\r\n    /// - LinkedList<T>适合频繁插入删除操作\r\n    /// - LINQ提供强大的数据查询和转换功能\r\n    /// - 跨平台注意：集合行为在不同平台基本一致\r\n    /// </summary>\r\n    public class CollectionsExample : MonoBehaviour\r\n    {\r\n        [Header(\"集合示例配置\")]\r\n        [Tooltip(\"是否自动运行所有示例代码\")]\r\n        [SerializeField] private bool runExamples = true;\r\n        [Tooltip(\"是否显示性能测试结果\")]\r\n        [SerializeField] private bool showPerformanceTests = true;\r\n        [Tooltip(\"测试数据规模\")]\r\n        [SerializeField] private int testDataSize = 1000;\r\n\r\n        private void Start()\r\n        {\r\n            if (runExamples)\r\n            {\r\n                RunAllExamples();\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// 运行所有集合相关示例\r\n        /// 按顺序执行：List -> Dictionary -> HashSet -> Queue -> Stack -> LinkedList -> Linq -> 高级集合操作\r\n        /// \r\n        /// 执行流程：\r\n        /// 1. 基础动态数组操作\r\n        /// 2. 键值对集合操作\r\n        /// 3. 无序不重复集合操作\r\n        /// 4. 队列操作\r\n        /// 5. 栈操作\r\n        /// 6. 链表操作\r\n        /// 7. LINQ查询操作\r\n        /// 8. 高级集合功能\r\n        /// </summary>\r\n        private void RunAllExamples()\r\n        {\r\n            Debug.Log(\"=== .NET集合API示例开始 ===\");\r\n            Debug.Log($\"性能测试显示: {showPerformanceTests}\");\r\n            Debug.Log($\"测试数据规模: {testDataSize}\");\r\n            \r\n            ListExample();      // List<T> 动态数组\r\n            DictionaryExample(); // Dictionary<TKey, TValue> 键值对集合\r\n            HashSetExample();   // HashSet<T> 无序不重复集合\r\n            QueueExample();     // Queue<T> 队列（先进先出）\r\n            StackExample();     // Stack<T> 栈（后进先出）\r\n            LinkedListExample(); // LinkedList<T> 双向链表\r\n            LinqExample();      // LINQ查询操作\r\n            AdvancedCollectionsExample(); // 高级集合操作\r\n            \r\n            Debug.Log(\"=== .NET集合API示例结束 ===\");\r\n        }\r\n\r\n        // ================= List<T> 动态数组 =================\r\n        /// <summary>\r\n        /// List<T> 动态数组示例\r\n        /// List是最常用的集合类型，支持动态扩容，随机访问\r\n        /// \r\n        /// 主要特性：\r\n        /// - 动态扩容，自动管理内存\r\n        /// - O(1)随机访问，O(n)插入删除\r\n        /// - 支持索引访问和迭代\r\n        /// - 丰富的内置方法\r\n        /// \r\n        /// 注意事项：\r\n        /// - 频繁插入删除时考虑LinkedList\r\n        /// - 大量数据时考虑指定初始容量\r\n        /// - 线程不安全，多线程需要同步\r\n        /// - 值类型存储在连续内存中\r\n        /// </summary>\r\n        private void ListExample()\r\n        {\r\n            Debug.Log(\"--- List<T> 动态数组示例 ---\");\r\n            \r\n            try\r\n            {\r\n                // ========== 创建和初始化 ==========\r\n                \r\n                // 创建空List\r\n                // 参数说明：无\r\n                // 返回值：List<T> - 空列表实例\r\n                // 注意事项：初始容量为0，首次添加时扩容\r\n                var emptyList = new List<int>();\r\n                Debug.Log($\"空List容量: {emptyList.Capacity}, 长度: {emptyList.Count}\");\r\n                \r\n                // 创建并初始化List\r\n                // 参数说明：collection - 初始元素集合\r\n                // 返回值：List<T> - 包含初始元素的列表\r\n                // 注意事项：集合初始化器语法，编译器自动优化\r\n                var numbers = new List<int> { 1, 2, 3, 4, 5 };\r\n                var names = new List<string> { \"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\" };\r\n                Debug.Log($\"初始化List: {string.Join(\", \", numbers)}\");\r\n                \r\n                // 指定初始容量（优化性能）\r\n                // 参数说明：capacity - 初始容量\r\n                // 返回值：List<T> - 指定容量的空列表\r\n                // 注意事项：避免频繁扩容，提升性能\r\n                var capacityList = new List<int>(100);\r\n                Debug.Log($\"指定容量的List: {capacityList.Capacity}\");\r\n                \r\n                // ========== 添加元素操作 ==========\r\n                \r\n                // Add: 在末尾添加单个元素\r\n                // 参数说明：item - 要添加的元素\r\n                // 返回值：void\r\n                // 时间复杂度：平均O(1)，最坏O(n)（需要扩容）\r\n                numbers.Add(6);\r\n                Debug.Log($\"Add(6)后: {string.Join(\", \", numbers)}\");\r\n                \r\n                // Insert: 在指定位置插入元素\r\n                // 参数说明：index - 插入位置, item - 要插入的元素\r\n                // 返回值：void\r\n                // 时间复杂度：O(n)，需要移动后续元素\r\n                numbers.Insert(0, 0);\r\n                Debug.Log($\"Insert(0, 0)后: {string.Join(\", \", numbers)}\");\r\n                \r\n                // AddRange: 在末尾添加多个元素\r\n                // 参数说明：collection - 要添加的元素集合\r\n                // 返回值：void\r\n                // 注意事项：比多次Add更高效\r\n                numbers.AddRange(new int[] { 7, 8, 9 });\r\n                Debug.Log($\"AddRange([7,8,9])后: {string.Join(\", \", numbers)}\");\r\n                \r\n                // InsertRange: 在指定位置插入多个元素\r\n                // 参数说明：index - 插入位置, collection - 要插入的元素集合\r\n                // 返回值：void\r\n                // 时间复杂度：O(n + m)，n为列表长度，m为插入元素数量\r\n                numbers.InsertRange(3, new int[] { 10, 11 });\r\n                Debug.Log($\"InsertRange(3, [10,11])后: {string.Join(\", \", numbers)}\");\r\n                \r\n                // ========== 访问元素操作 ==========\r\n                \r\n                // 索引访问\r\n                // 参数说明：index - 元素索引\r\n                // 返回值：T - 指定位置的元素\r\n                // 时间复杂度：O(1)\r\n                Debug.Log($\"第一个元素: {numbers[0]}\");\r\n                Debug.Log($\"最后一个元素: {numbers[^1]}\"); // C# 8.0 索引语法\r\n                Debug.Log($\"倒数第二个元素: {numbers[^2]}\");\r\n                \r\n                // 获取元素数量\r\n                // 参数说明：无\r\n                // 返回值：int - 元素数量\r\n                Debug.Log($\"List长度: {numbers.Count}\");\r\n                Debug.Log($\"List容量: {numbers.Capacity}\");\r\n                \r\n                // 检查容量使用率\r\n                double usageRate = (double)numbers.Count / numbers.Capacity * 100;\r\n                Debug.Log($\"容量使用率: {usageRate:F1}%\");\r\n                \r\n                // ========== 查找元素操作 ==========\r\n                \r\n                // IndexOf: 查找元素的第一个索引\r\n                // 参数说明：item - 要查找的元素\r\n                // 返回值：int - 元素索引，-1表示未找到\r\n                // 时间复杂度：O(n)\r\n                int index = numbers.IndexOf(5);\r\n                Debug.Log($\"IndexOf(5): {index}\");\r\n                \r\n                // LastIndexOf: 查找元素的最后一个索引\r\n                // 参数说明：item - 要查找的元素\r\n                // 返回值：int - 元素索引，-1表示未找到\r\n                // 时间复杂度：O(n)\r\n                numbers.Add(5); // 添加重复元素\r\n                int lastIndex = numbers.LastIndexOf(5);\r\n                Debug.Log($\"LastIndexOf(5): {lastIndex}\");\r\n                \r\n                // Contains: 检查是否包含元素\r\n                // 参数说明：item - 要检查的元素\r\n                // 返回值：bool - 是否包含\r\n                // 时间复杂度：O(n)\r\n                bool contains = numbers.Contains(10);\r\n                Debug.Log($\"Contains(10): {contains}\");\r\n                \r\n                // Exists: 使用条件查找元素\r\n                // 参数说明：match - 匹配条件委托\r\n                // 返回值：bool - 是否存在满足条件的元素\r\n                // 时间复杂度：O(n)\r\n                bool exists = numbers.Exists(x => x > 10);\r\n                Debug.Log($\"Exists(x > 10): {exists}\");\r\n                \r\n                // Find: 查找第一个满足条件的元素\r\n                // 参数说明：match - 匹配条件委托\r\n                // 返回值：T - 找到的元素，默认值表示未找到\r\n                // 时间复杂度：O(n)\r\n                int found = numbers.Find(x => x % 2 == 0);\r\n                Debug.Log($\"Find(第一个偶数): {found}\");\r\n                \r\n                // FindAll: 查找所有满足条件的元素\r\n                // 参数说明：match - 匹配条件委托\r\n                // 返回值：List<T> - 满足条件的元素列表\r\n                // 时间复杂度：O(n)\r\n                var evenNumbers = numbers.FindAll(x => x % 2 == 0);\r\n                Debug.Log($\"FindAll(所有偶数): {string.Join(\", \", evenNumbers)}\");\r\n                \r\n                // FindIndex: 查找第一个满足条件的元素索引\r\n                // 参数说明：match - 匹配条件委托\r\n                // 返回值：int - 元素索引，-1表示未找到\r\n                int findIndex = numbers.FindIndex(x => x > 8);\r\n                Debug.Log($\"FindIndex(x > 8): {findIndex}\");\r\n                \r\n                // ========== 排序和反转操作 ==========\r\n                \r\n                // Sort: 排序（默认升序）\r\n                // 参数说明：无或comparison - 比较委托\r\n                // 返回值：void\r\n                // 时间复杂度：O(n log n)\r\n                numbers.Sort();\r\n                Debug.Log($\"Sort()后: {string.Join(\", \", numbers)}\");\r\n                \r\n                // Sort: 自定义排序（降序）\r\n                // 参数说明：comparison - 比较委托\r\n                // 返回值：void\r\n                numbers.Sort((a, b) => b.CompareTo(a));\r\n                Debug.Log($\"Sort(降序)后: {string.Join(\", \", numbers)}\");\r\n                \r\n                // Reverse: 反转\r\n                // 参数说明：无\r\n                // 返回值：void\r\n                // 时间复杂度：O(n)\r\n                numbers.Reverse();\r\n                Debug.Log($\"Reverse()后: {string.Join(\", \", numbers)}\");\r\n                \r\n                // ========== 移除元素操作 ==========\r\n                \r\n                // Remove: 移除第一个匹配的元素\r\n                // 参数说明：item - 要移除的元素\r\n                // 返回值：bool - 是否成功移除\r\n                // 时间复杂度：O(n)\r\n                bool removed = numbers.Remove(5);\r\n                Debug.Log($\"Remove(5)成功: {removed}\");\r\n                Debug.Log($\"移除后: {string.Join(\", \", numbers)}\");\r\n                \r\n                // RemoveAt: 移除指定位置的元素\r\n                // 参数说明：index - 要移除的位置\r\n                // 返回值：void\r\n                // 时间复杂度：O(n)，需要移动后续元素\r\n                numbers.RemoveAt(0);\r\n                Debug.Log($\"RemoveAt(0)后: {string.Join(\", \", numbers)}\");\r\n                \r\n                // RemoveRange: 移除指定范围的元素\r\n                // 参数说明：index - 起始位置, count - 移除数量\r\n                // 返回值：void\r\n                // 时间复杂度：O(n)\r\n                numbers.RemoveRange(0, 2);\r\n                Debug.Log($\"RemoveRange(0, 2)后: {string.Join(\", \", numbers)}\");\r\n                \r\n                // RemoveAll: 移除所有满足条件的元素\r\n                // 参数说明：match - 匹配条件委托\r\n                // 返回值：int - 移除的元素数量\r\n                // 时间复杂度：O(n)\r\n                int removedCount = numbers.RemoveAll(x => x < 5);\r\n                Debug.Log($\"RemoveAll(x < 5)移除了{removedCount}个元素\");\r\n                Debug.Log($\"移除后: {string.Join(\", \", numbers)}\");\r\n                \r\n                // ========== 转换操作 ==========\r\n                \r\n                // ToArray: 转换为数组\r\n                // 参数说明：无\r\n                // 返回值：T[] - 数组副本\r\n                // 时间复杂度：O(n)\r\n                int[] array = numbers.ToArray();\r\n                Debug.Log($\"ToArray(): {string.Join(\", \", array)}\");\r\n                \r\n                // ToList: 创建副本\r\n                // 参数说明：无\r\n                // 返回值：List<T> - 列表副本\r\n                // 时间复杂度：O(n)\r\n                var copy = numbers.ToList();\r\n                Debug.Log($\"ToList()副本: {string.Join(\", \", copy)}\");\r\n                \r\n                // ========== 清空操作 ==========\r\n                \r\n                // Clear: 清空所有元素\r\n                // 参数说明：无\r\n                // 返回值：void\r\n                // 时间复杂度：O(n)\r\n                numbers.Clear();\r\n                Debug.Log($\"Clear()后长度: {numbers.Count}\");\r\n                \r\n                // TrimExcess: 释放多余容量\r\n                // 参数说明：无\r\n                // 返回值：void\r\n                // 注意事项：只有当使用率低于90%时才释放\r\n                numbers.TrimExcess();\r\n                Debug.Log($\"TrimExcess()后容量: {numbers.Capacity}\");\r\n                \r\n                // ========== 性能测试 ==========\r\n                \r\n                if (showPerformanceTests)\r\n                {\r\n                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();\r\n                    \r\n                    // 测试添加性能\r\n                    var perfList = new List<int>();\r\n                    for (int i = 0; i < testDataSize; i++)\r\n                    {\r\n                        perfList.Add(i);\r\n                    }\r\n                    stopwatch.Stop();\r\n                    Debug.Log($\"添加{testDataSize}个元素耗时: {stopwatch.ElapsedMilliseconds}ms\");\r\n                    \r\n                    // 测试查找性能\r\n                    stopwatch.Restart();\r\n                    for (int i = 0; i < 1000; i++)\r\n                    {\r\n                        perfList.Contains(i % testDataSize);\r\n                    }\r\n                    stopwatch.Stop();\r\n                    Debug.Log($\"1000次Contains操作耗时: {stopwatch.ElapsedMilliseconds}ms\");\r\n                }\r\n                \r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogError($\"List操作出错: {ex.Message}\");\r\n                Debug.LogError($\"异常类型: {ex.GetType().Name}\");\r\n            }\r\n        }\r\n\r\n        // ================= Dictionary<TKey, TValue> 键值对集合 =================\r\n        /// <summary>\r\n        /// Dictionary<TKey, TValue> 键值对集合示例\r\n        /// Dictionary提供快速的键值对查找，键必须唯一\r\n        /// \r\n        /// 主要特性：\r\n        /// - O(1)平均查找、插入、删除性能\r\n        /// - 键必须唯一，值可以重复\r\n        /// - 基于哈希表实现\r\n        /// - 无序存储\r\n        /// \r\n        /// 注意事项：\r\n        /// - 键类型必须实现GetHashCode和Equals\r\n        /// - 频繁修改时考虑ConcurrentDictionary\r\n        /// - 自定义类型作为键需要正确实现哈希\r\n        /// - 线程不安全，多线程需要同步\r\n        /// </summary>\r\n        private void DictionaryExample()\r\n        {\r\n            Debug.Log(\"--- Dictionary<TKey, TValue> 键值对集合示例 ---\");\r\n            \r\n            try\r\n            {\r\n                // ========== 创建和初始化 ==========\r\n                \r\n                // 创建空字典\r\n                // 参数说明：无\r\n                // 返回值：Dictionary<TKey, TValue> - 空字典实例\r\n                var emptyDict = new Dictionary<string, int>();\r\n                Debug.Log($\"空字典容量: {emptyDict.Count}\");\r\n                \r\n                // 创建并初始化字典\r\n                // 参数说明：collection - 初始键值对集合\r\n                // 返回值：Dictionary<TKey, TValue> - 包含初始元素的字典\r\n                var scores = new Dictionary<string, int>\r\n                {\r\n                    { \"Alice\", 95 },\r\n                    { \"Bob\", 87 },\r\n                    { \"Charlie\", 92 },\r\n                    { \"David\", 78 },\r\n                    { \"Eve\", 89 }\r\n                };\r\n                Debug.Log($\"初始化字典: {scores.Count}个键值对\");\r\n                \r\n                // 指定初始容量\r\n                // 参数说明：capacity - 初始容量\r\n                // 返回值：Dictionary<TKey, TValue> - 指定容量的空字典\r\n                var capacityDict = new Dictionary<string, int>(100);\r\n                Debug.Log($\"指定容量的字典已创建\");\r\n                \r\n                // ========== 添加和更新操作 ==========\r\n                \r\n                // Add: 添加键值对\r\n                // 参数说明：key - 键, value - 值\r\n                // 返回值：void\r\n                // 时间复杂度：平均O(1)\r\n                scores.Add(\"Frank\", 85);\r\n                Debug.Log($\"Add(Frank, 85)后: {scores.Count}个键值对\");\r\n                \r\n                // 索引器：添加或更新\r\n                // 参数说明：key - 键\r\n                // 返回值：TValue - 值\r\n                // 注意事项：如果键不存在则添加，存在则更新\r\n                scores[\"Alice\"] = 98; // 更新\r\n                scores[\"Grace\"] = 91; // 添加\r\n                Debug.Log($\"使用索引器后: {scores.Count}个键值对\");\r\n                \r\n                // TryAdd: 尝试添加（.NET Core 3.0+）\r\n                // 参数说明：key - 键, value - 值\r\n                // 返回值：bool - 是否成功添加\r\n                bool added = scores.TryAdd(\"Henry\", 88);\r\n                Debug.Log($\"TryAdd(Henry, 88): {added}\");\r\n                \r\n                // ========== 访问和查找操作 ==========\r\n                \r\n                // 索引器访问\r\n                // 参数说明：key - 键\r\n                // 返回值：TValue - 值\r\n                // 注意事项：键不存在时抛出异常\r\n                int aliceScore = scores[\"Alice\"];\r\n                Debug.Log($\"Alice的分数: {aliceScore}\");\r\n                \r\n                // TryGetValue: 安全获取值\r\n                // 参数说明：key - 键, value - 输出值\r\n                // 返回值：bool - 是否找到键\r\n                // 时间复杂度：平均O(1)\r\n                if (scores.TryGetValue(\"Bob\", out int bobScore))\r\n                {\r\n                    Debug.Log($\"Bob的分数: {bobScore}\");\r\n                }\r\n                else\r\n                {\r\n                    Debug.Log(\"未找到Bob的分数\");\r\n                }\r\n                \r\n                // ContainsKey: 检查是否包含键\r\n                // 参数说明：key - 键\r\n                // 返回值：bool - 是否包含\r\n                // 时间复杂度：平均O(1)\r\n                bool hasKey = scores.ContainsKey(\"Charlie\");\r\n                Debug.Log($\"包含Charlie: {hasKey}\");\r\n                \r\n                // ContainsValue: 检查是否包含值\r\n                // 参数说明：value - 值\r\n                // 返回值：bool - 是否包含\r\n                // 时间复杂度：O(n)\r\n                bool hasValue = scores.ContainsValue(95);\r\n                Debug.Log($\"包含分数95: {hasValue}\");\r\n                \r\n                // ========== 遍历操作 ==========\r\n                \r\n                // 遍历所有键值对\r\n                Debug.Log(\"所有键值对:\");\r\n                foreach (var kvp in scores)\r\n                {\r\n                    Debug.Log($\"  {kvp.Key}: {kvp.Value}\");\r\n                }\r\n                \r\n                // 遍历所有键\r\n                Debug.Log(\"所有键:\");\r\n                foreach (string key in scores.Keys)\r\n                {\r\n                    Debug.Log($\"  {key}\");\r\n                }\r\n                \r\n                // 遍历所有值\r\n                Debug.Log(\"所有值:\");\r\n                foreach (int value in scores.Values)\r\n                {\r\n                    Debug.Log($\"  {value}\");\r\n                }\r\n                \r\n                // ========== 移除操作 ==========\r\n                \r\n                // Remove: 移除键值对\r\n                // 参数说明：key - 要移除的键\r\n                // 返回值：bool - 是否成功移除\r\n                // 时间复杂度：平均O(1)\r\n                bool removed = scores.Remove(\"David\");\r\n                Debug.Log($\"Remove(David): {removed}\");\r\n                Debug.Log($\"移除后: {scores.Count}个键值对\");\r\n                \r\n                // TryRemove: 尝试移除（.NET Core 3.0+）\r\n                // 参数说明：key - 要移除的键, value - 输出被移除的值\r\n                // 返回值：bool - 是否成功移除\r\n                if (scores.TryRemove(\"Eve\", out int eveScore))\r\n                {\r\n                    Debug.Log($\"TryRemove(Eve): 成功，值为{eveScore}\");\r\n                }\r\n                \r\n                // Clear: 清空字典\r\n                // 参数说明：无\r\n                // 返回值：void\r\n                scores.Clear();\r\n                Debug.Log($\"Clear()后: {scores.Count}个键值对\");\r\n                \r\n                // ========== 高级操作 ==========\r\n                \r\n                // 重新添加数据用于演示\r\n                scores = new Dictionary<string, int>\r\n                {\r\n                    { \"Alice\", 95 }, { \"Bob\", 87 }, { \"Charlie\", 92 },\r\n                    { \"David\", 78 }, { \"Eve\", 89 }, { \"Frank\", 85 }\r\n                };\r\n                \r\n                // 获取或添加默认值\r\n                // 参数说明：key - 键, defaultValue - 默认值\r\n                // 返回值：TValue - 值\r\n                int graceScore = scores.GetValueOrDefault(\"Grace\", 0);\r\n                Debug.Log($\"Grace的分数(默认0): {graceScore}\");\r\n                \r\n                // 条件更新\r\n                if (scores.ContainsKey(\"Alice\"))\r\n                {\r\n                    scores[\"Alice\"] = Math.Max(scores[\"Alice\"], 100);\r\n                }\r\n                Debug.Log($\"Alice更新后分数: {scores[\"Alice\"]}\");\r\n                \r\n                // ========== 性能测试 ==========\r\n                \r\n                if (showPerformanceTests)\r\n                {\r\n                    var perfDict = new Dictionary<int, string>();\r\n                    \r\n                    // 测试添加性能\r\n                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();\r\n                    for (int i = 0; i < testDataSize; i++)\r\n                    {\r\n                        perfDict[i] = $\"Value{i}\";\r\n                    }\r\n                    stopwatch.Stop();\r\n                    Debug.Log($\"添加{testDataSize}个键值对耗时: {stopwatch.ElapsedMilliseconds}ms\");\r\n                    \r\n                    // 测试查找性能\r\n                    stopwatch.Restart();\r\n                    for (int i = 0; i < 10000; i++)\r\n                    {\r\n                        perfDict.TryGetValue(i % testDataSize, out _);\r\n                    }\r\n                    stopwatch.Stop();\r\n                    Debug.Log($\"10000次查找操作耗时: {stopwatch.ElapsedMilliseconds}ms\");\r\n                }\r\n                \r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogError($\"Dictionary操作出错: {ex.Message}\");\r\n                Debug.LogError($\"异常类型: {ex.GetType().Name}\");\r\n            }\r\n        }\r\n\r\n        // ================= HashSet<T> 无序不重复集合 =================\r\n        /// <summary>\r\n        /// HashSet<T> 无序不重复集合示例\r\n        /// HashSet提供O(1)的查找性能，元素唯一且无序\r\n        /// </summary>\r\n        private void HashSetExample()\r\n        {\r\n            Debug.Log(\"--- HashSet<T> 无序不重复集合示例 ---\");\r\n            \r\n            // ========== 创建和初始化 ==========\r\n            \r\n            // 创建空HashSet\r\n            var emptySet = new HashSet<int>();\r\n            \r\n            // 创建并初始化HashSet\r\n            var uniqueNumbers = new HashSet<int> { 1, 2, 3, 4, 5 };\r\n            var names = new HashSet<string> { \"Alice\", \"Bob\", \"Charlie\" };\r\n            \r\n            // 指定比较器\r\n            var caseInsensitiveNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase)\r\n            {\r\n                \"Alice\", \"alice\", \"BOB\", \"Bob\"\r\n            };\r\n            Debug.Log($\"不区分大小写的HashSet: {string.Join(\", \", caseInsensitiveNames)}\");\r\n            \r\n            // ========== 添加元素操作 ==========\r\n            \r\n            // Add: 添加元素\r\n            bool added = uniqueNumbers.Add(6);\r\n            Debug.Log($\"添加6成功: {added}\");\r\n            \r\n            // 添加重复元素\r\n            bool duplicateAdded = uniqueNumbers.Add(1);\r\n            Debug.Log($\"添加重复的1成功: {duplicateAdded}\");\r\n            \r\n            // AddRange: 添加多个元素\r\n            uniqueNumbers.UnionWith(new int[] { 7, 8, 9 });\r\n            Debug.Log($\"添加数组后: {string.Join(\", \", uniqueNumbers)}\");\r\n            \r\n            // ========== 检查操作 ==========\r\n            \r\n            // Contains: 检查是否包含元素\r\n            bool contains = uniqueNumbers.Contains(5);\r\n            Debug.Log($\"是否包含5: {contains}\");\r\n            \r\n            // ========== 集合操作 ==========\r\n            \r\n            var set1 = new HashSet<int> { 1, 2, 3, 4 };\r\n            var set2 = new HashSet<int> { 3, 4, 5, 6 };\r\n            \r\n            // 并集 (Union)\r\n            var union = new HashSet<int>(set1);\r\n            union.UnionWith(set2);\r\n            Debug.Log($\"并集: {string.Join(\", \", union)}\");\r\n            \r\n            // 交集 (Intersection)\r\n            var intersection = new HashSet<int>(set1);\r\n            intersection.IntersectWith(set2);\r\n            Debug.Log($\"交集: {string.Join(\", \", intersection)}\");\r\n            \r\n            // 差集 (Difference)\r\n            var difference = new HashSet<int>(set1);\r\n            difference.ExceptWith(set2);\r\n            Debug.Log($\"差集: {string.Join(\", \", difference)}\");\r\n            \r\n            // 对称差集 (Symmetric Difference)\r\n            var symmetricDifference = new HashSet<int>(set1);\r\n            symmetricDifference.SymmetricExceptWith(set2);\r\n            Debug.Log($\"对称差集: {string.Join(\", \", symmetricDifference)}\");\r\n            \r\n            // ========== 集合关系检查 ==========\r\n            \r\n            // 子集检查\r\n            bool isSubset = set1.IsSubsetOf(union);\r\n            Debug.Log($\"set1是union的子集: {isSubset}\");\r\n            \r\n            // 超集检查\r\n            bool isSuperset = union.IsSupersetOf(set1);\r\n            Debug.Log($\"union是set1的超集: {isSuperset}\");\r\n            \r\n            // 真子集检查\r\n            bool isProperSubset = set1.IsProperSubsetOf(union);\r\n            Debug.Log($\"set1是union的真子集: {isProperSubset}\");\r\n            \r\n            // 重叠检查\r\n            bool overlaps = set1.Overlaps(set2);\r\n            Debug.Log($\"set1和set2有重叠: {overlaps}\");\r\n            \r\n            // 相等检查\r\n            bool equals = set1.SetEquals(set2);\r\n            Debug.Log($\"set1和set2相等: {equals}\");\r\n            \r\n            // ========== 移除操作 ==========\r\n            \r\n            // Remove: 移除元素\r\n            bool removed = uniqueNumbers.Remove(5);\r\n            Debug.Log($\"移除5成功: {removed}\");\r\n            \r\n            // RemoveWhere: 条件移除\r\n            int removedCount = uniqueNumbers.RemoveWhere(x => x > 8);\r\n            Debug.Log($\"移除了{removedCount}个大于8的元素\");\r\n            \r\n            // ========== 转换操作 ==========\r\n            \r\n            // ToArray: 转换为数组\r\n            int[] array = uniqueNumbers.ToArray();\r\n            Debug.Log($\"转换为数组: {string.Join(\", \", array)}\");\r\n            \r\n            // ToList: 转换为List\r\n            var list = uniqueNumbers.ToList();\r\n            Debug.Log($\"转换为List: {string.Join(\", \", list)}\");\r\n            \r\n            // 清空集合\r\n            uniqueNumbers.Clear();\r\n            Debug.Log($\"清空后数量: {uniqueNumbers.Count}\");\r\n        }\r\n\r\n        // ================= Queue<T> 队列（先进先出） =================\r\n        /// <summary>\r\n        /// Queue<T> 队列示例\r\n        /// Queue实现先进先出(FIFO)的数据结构\r\n        /// </summary>\r\n        private void QueueExample()\r\n        {\r\n            Debug.Log(\"--- Queue<T> 队列示例 ---\");\r\n            \r\n            // ========== 创建队列 ==========\r\n            \r\n            // 创建空队列\r\n            var queue = new Queue<string>();\r\n            \r\n            // 指定初始容量\r\n            var capacityQueue = new Queue<int>(100);\r\n            \r\n            // ========== 入队操作 ==========\r\n            \r\n            // Enqueue: 入队\r\n            queue.Enqueue(\"第一个\");\r\n            queue.Enqueue(\"第二个\");\r\n            queue.Enqueue(\"第三个\");\r\n            Debug.Log($\"入队后数量: {queue.Count}\");\r\n            \r\n            // ========== 出队操作 ==========\r\n            \r\n            // Peek: 查看队首元素（不移除）\r\n            string peeked = queue.Peek();\r\n            Debug.Log($\"队首元素: {peeked}\");\r\n            Debug.Log($\"查看后数量: {queue.Count}\");\r\n            \r\n            // Dequeue: 出队\r\n            string dequeued = queue.Dequeue();\r\n            Debug.Log($\"出队元素: {dequeued}\");\r\n            Debug.Log($\"出队后数量: {queue.Count}\");\r\n            \r\n            // ========== 检查操作 ==========\r\n            \r\n            // Contains: 检查是否包含元素\r\n            bool contains = queue.Contains(\"第二个\");\r\n            Debug.Log($\"是否包含'第二个': {contains}\");\r\n            \r\n            // ========== 遍历操作 ==========\r\n            \r\n            Debug.Log(\"队列中剩余元素:\");\r\n            foreach (string item in queue)\r\n            {\r\n                Debug.Log($\"元素: {item}\");\r\n            }\r\n            \r\n            // ========== 清空操作 ==========\r\n            \r\n            // Clear: 清空队列\r\n            queue.Clear();\r\n            Debug.Log($\"清空后数量: {queue.Count}\");\r\n            \r\n            // ========== 高级操作 ==========\r\n            \r\n            // 批量入队\r\n            var numberQueue = new Queue<int>();\r\n            for (int i = 1; i <= 5; i++)\r\n            {\r\n                numberQueue.Enqueue(i);\r\n            }\r\n            \r\n            // 批量出队\r\n            Debug.Log(\"批量出队:\");\r\n            while (numberQueue.Count > 0)\r\n            {\r\n                int num = numberQueue.Dequeue();\r\n                Debug.Log($\"出队: {num}\");\r\n            }\r\n        }\r\n\r\n        // ================= Stack<T> 栈（后进先出） =================\r\n        /// <summary>\r\n        /// Stack<T> 栈示例\r\n        /// Stack实现后进先出(LIFO)的数据结构\r\n        /// </summary>\r\n        private void StackExample()\r\n        {\r\n            Debug.Log(\"--- Stack<T> 栈示例 ---\");\r\n            \r\n            // ========== 创建栈 ==========\r\n            \r\n            // 创建空栈\r\n            var stack = new Stack<string>();\r\n            \r\n            // 指定初始容量\r\n            var capacityStack = new Stack<int>(100);\r\n            \r\n            // ========== 压栈操作 ==========\r\n            \r\n            // Push: 压栈\r\n            stack.Push(\"底部\");\r\n            stack.Push(\"中间\");\r\n            stack.Push(\"顶部\");\r\n            Debug.Log($\"压栈后数量: {stack.Count}\");\r\n            \r\n            // ========== 出栈操作 ==========\r\n            \r\n            // Peek: 查看栈顶元素（不移除）\r\n            string peeked = stack.Peek();\r\n            Debug.Log($\"栈顶元素: {peeked}\");\r\n            Debug.Log($\"查看后数量: {stack.Count}\");\r\n            \r\n            // Pop: 出栈\r\n            string popped = stack.Pop();\r\n            Debug.Log($\"出栈元素: {popped}\");\r\n            Debug.Log($\"出栈后数量: {stack.Count}\");\r\n            \r\n            // ========== 检查操作 ==========\r\n            \r\n            // Contains: 检查是否包含元素\r\n            bool contains = stack.Contains(\"中间\");\r\n            Debug.Log($\"是否包含'中间': {contains}\");\r\n            \r\n            // ========== 遍历操作 ==========\r\n            \r\n            Debug.Log(\"栈中剩余元素:\");\r\n            foreach (string item in stack)\r\n            {\r\n                Debug.Log($\"元素: {item}\");\r\n            }\r\n            \r\n            // ========== 清空操作 ==========\r\n            \r\n            // Clear: 清空栈\r\n            stack.Clear();\r\n            Debug.Log($\"清空后数量: {stack.Count}\");\r\n            \r\n            // ========== 高级操作 ==========\r\n            \r\n            // 批量压栈\r\n            var numberStack = new Stack<int>();\r\n            for (int i = 1; i <= 5; i++)\r\n            {\r\n                numberStack.Push(i);\r\n            }\r\n            \r\n            // 批量出栈\r\n            Debug.Log(\"批量出栈:\");\r\n            while (numberStack.Count > 0)\r\n            {\r\n                int num = numberStack.Pop();\r\n                Debug.Log($\"出栈: {num}\");\r\n            }\r\n        }\r\n\r\n        // ================= LinkedList<T> 双向链表 =================\r\n        /// <summary>\r\n        /// LinkedList<T> 双向链表示例\r\n        /// LinkedList提供O(1)的插入和删除操作，但随机访问较慢\r\n        /// </summary>\r\n        private void LinkedListExample()\r\n        {\r\n            Debug.Log(\"--- LinkedList<T> 双向链表示例 ---\");\r\n            \r\n            // ========== 创建链表 ==========\r\n            \r\n            // 创建空链表\r\n            var linkedList = new LinkedList<string>();\r\n            \r\n            // ========== 添加节点操作 ==========\r\n            \r\n            // AddFirst: 在开头添加节点\r\n            linkedList.AddFirst(\"第一个\");\r\n            linkedList.AddFirst(\"新的第一个\");\r\n            \r\n            // AddLast: 在末尾添加节点\r\n            linkedList.AddLast(\"最后一个\");\r\n            linkedList.AddLast(\"新的最后一个\");\r\n            \r\n            // AddAfter: 在指定节点后添加\r\n            var firstNode = linkedList.First;\r\n            linkedList.AddAfter(firstNode, \"在第一个之后\");\r\n            \r\n            // AddBefore: 在指定节点前添加\r\n            var lastNode = linkedList.Last;\r\n            linkedList.AddBefore(lastNode, \"在最后一个之前\");\r\n            \r\n            Debug.Log($\"添加节点后数量: {linkedList.Count}\");\r\n            \r\n            // ========== 访问节点操作 ==========\r\n            \r\n            // First/Last: 获取首尾节点\r\n            Debug.Log($\"第一个节点: {linkedList.First?.Value}\");\r\n            Debug.Log($\"最后一个节点: {linkedList.Last?.Value}\");\r\n            \r\n            // 遍历节点\r\n            Debug.Log(\"所有节点:\");\r\n            foreach (string item in linkedList)\r\n            {\r\n                Debug.Log($\"节点: {item}\");\r\n            }\r\n            \r\n            // ========== 查找操作 ==========\r\n            \r\n            // Find: 查找第一个匹配的节点\r\n            var foundNode = linkedList.Find(\"第一个\");\r\n            if (foundNode != null)\r\n            {\r\n                Debug.Log($\"找到节点: {foundNode.Value}\");\r\n            }\r\n            \r\n            // FindLast: 查找最后一个匹配的节点\r\n            var lastFoundNode = linkedList.FindLast(\"最后一个\");\r\n            if (lastFoundNode != null)\r\n            {\r\n                Debug.Log($\"找到最后一个节点: {lastFoundNode.Value}\");\r\n            }\r\n            \r\n            // Contains: 检查是否包含元素\r\n            bool contains = linkedList.Contains(\"第一个\");\r\n            Debug.Log($\"是否包含'第一个': {contains}\");\r\n            \r\n            // ========== 移除操作 ==========\r\n            \r\n            // Remove: 移除第一个匹配的元素\r\n            bool removed = linkedList.Remove(\"第一个\");\r\n            Debug.Log($\"移除'第一个'成功: {removed}\");\r\n            \r\n            // RemoveFirst: 移除第一个节点\r\n            linkedList.RemoveFirst();\r\n            Debug.Log($\"移除第一个节点后数量: {linkedList.Count}\");\r\n            \r\n            // RemoveLast: 移除最后一个节点\r\n            linkedList.RemoveLast();\r\n            Debug.Log($\"移除最后一个节点后数量: {linkedList.Count}\");\r\n            \r\n            // ========== 清空操作 ==========\r\n            \r\n            // Clear: 清空链表\r\n            linkedList.Clear();\r\n            Debug.Log($\"清空后数量: {linkedList.Count}\");\r\n        }\r\n\r\n        // ================= LINQ查询操作 =================\r\n        /// <summary>\r\n        /// LINQ查询操作示例\r\n        /// LINQ提供强大的查询和操作集合的功能\r\n        /// </summary>\r\n        private void LinqExample()\r\n        {\r\n            Debug.Log(\"--- LINQ查询操作示例 ---\");\r\n            \r\n            // ========== 准备测试数据 ==========\r\n            \r\n            var people = new List<Person>\r\n            {\r\n                new Person { Name = \"Alice\", Age = 25, City = \"北京\" },\r\n                new Person { Name = \"Bob\", Age = 30, City = \"上海\" },\r\n                new Person { Name = \"Charlie\", Age = 35, City = \"北京\" },\r\n                new Person { Name = \"David\", Age = 28, City = \"广州\" },\r\n                new Person { Name = \"Eve\", Age = 32, City = \"上海\" }\r\n            };\r\n            \r\n            var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\r\n            \r\n            // ========== 基本查询操作 ==========\r\n            \r\n            // Where: 过滤\r\n            var adults = people.Where(p => p.Age >= 30);\r\n            Debug.Log($\"成年人数量: {adults.Count()}\");\r\n            \r\n            // Select: 投影\r\n            var names = people.Select(p => p.Name);\r\n            Debug.Log($\"所有姓名: {string.Join(\", \", names)}\");\r\n            \r\n            // OrderBy: 排序\r\n            var sortedByAge = people.OrderBy(p => p.Age);\r\n            Debug.Log(\"按年龄排序:\");\r\n            foreach (var person in sortedByAge)\r\n            {\r\n                Debug.Log($\"{person.Name}: {person.Age}\");\r\n            }\r\n            \r\n            // ========== 聚合操作 ==========\r\n            \r\n            // Count: 计数\r\n            int totalPeople = people.Count();\r\n            Debug.Log($\"总人数: {totalPeople}\");\r\n            \r\n            // Sum: 求和\r\n            int totalAge = people.Sum(p => p.Age);\r\n            Debug.Log($\"总年龄: {totalAge}\");\r\n            \r\n            // Average: 平均值\r\n            double avgAge = people.Average(p => p.Age);\r\n            Debug.Log($\"平均年龄: {avgAge:F2}\");\r\n            \r\n            // Max/Min: 最大值/最小值\r\n            int maxAge = people.Max(p => p.Age);\r\n            int minAge = people.Min(p => p.Age);\r\n            Debug.Log($\"最大年龄: {maxAge}, 最小年龄: {minAge}\");\r\n            \r\n            // ========== 分组操作 ==========\r\n            \r\n            // GroupBy: 分组\r\n            var groupByCity = people.GroupBy(p => p.City);\r\n            Debug.Log(\"按城市分组:\");\r\n            foreach (var group in groupByCity)\r\n            {\r\n                Debug.Log($\"{group.Key}: {group.Count()}人\");\r\n                foreach (var person in group)\r\n                {\r\n                    Debug.Log($\"  - {person.Name}\");\r\n                }\r\n            }\r\n            \r\n            // ========== 连接操作 ==========\r\n            \r\n            // Join: 连接\r\n            var cities = new List<string> { \"北京\", \"上海\", \"深圳\" };\r\n            var joinResult = people.Join(cities, p => p.City, c => c, (p, c) => new { p.Name, City = c });\r\n            Debug.Log(\"连接结果:\");\r\n            foreach (var item in joinResult)\r\n            {\r\n                Debug.Log($\"{item.Name} - {item.City}\");\r\n            }\r\n            \r\n            // ========== 集合操作 ==========\r\n            \r\n            // Distinct: 去重\r\n            var uniqueCities = people.Select(p => p.City).Distinct();\r\n            Debug.Log($\"唯一城市: {string.Join(\", \", uniqueCities)}\");\r\n            \r\n            // Union: 并集\r\n            var set1 = new int[] { 1, 2, 3 };\r\n            var set2 = new int[] { 3, 4, 5 };\r\n            var union = set1.Union(set2);\r\n            Debug.Log($\"并集: {string.Join(\", \", union)}\");\r\n            \r\n            // Intersect: 交集\r\n            var intersect = set1.Intersect(set2);\r\n            Debug.Log($\"交集: {string.Join(\", \", intersect)}\");\r\n            \r\n            // Except: 差集\r\n            var except = set1.Except(set2);\r\n            Debug.Log($\"差集: {string.Join(\", \", except)}\");\r\n            \r\n            // ========== 分页操作 ==========\r\n            \r\n            // Skip/Take: 分页\r\n            var page1 = numbers.Skip(0).Take(3);\r\n            var page2 = numbers.Skip(3).Take(3);\r\n            Debug.Log($\"第一页: {string.Join(\", \", page1)}\");\r\n            Debug.Log($\"第二页: {string.Join(\", \", page2)}\");\r\n            \r\n            // ========== 条件操作 ==========\r\n            \r\n            // Any: 是否存在满足条件的元素\r\n            bool hasOldPerson = people.Any(p => p.Age > 40);\r\n            Debug.Log($\"是否有40岁以上的人: {hasOldPerson}\");\r\n            \r\n            // All: 是否所有元素都满足条件\r\n            bool allAdults = people.All(p => p.Age >= 18);\r\n            Debug.Log($\"是否都是成年人: {allAdults}\");\r\n            \r\n            // First/FirstOrDefault: 获取第一个元素\r\n            var firstPerson = people.First();\r\n            var firstOrDefault = people.FirstOrDefault(p => p.Age > 40);\r\n            Debug.Log($\"第一个: {firstPerson.Name}\");\r\n            Debug.Log($\"第一个40岁以上的: {firstOrDefault?.Name ?? \"无\"}\");\r\n            \r\n            // Single/SingleOrDefault: 获取唯一元素\r\n            var singlePerson = people.Single(p => p.Name == \"Alice\");\r\n            Debug.Log($\"唯一的Alice: {singlePerson.Name}\");\r\n        }\r\n\r\n        // ================= 高级集合操作 =================\r\n        /// <summary>\r\n        /// 高级集合操作示例\r\n        /// 包括线程安全集合、只读集合、并发集合等\r\n        /// </summary>\r\n        private void AdvancedCollectionsExample()\r\n        {\r\n            Debug.Log(\"--- 高级集合操作示例 ---\");\r\n            \r\n            // ========== 只读集合 ==========\r\n            \r\n            var originalList = new List<int> { 1, 2, 3, 4, 5 };\r\n            var readOnlyList = originalList.AsReadOnly();\r\n            Debug.Log($\"只读集合数量: {readOnlyList.Count}\");\r\n            \r\n            // 尝试修改只读集合会抛出异常\r\n            try\r\n            {\r\n                // readOnlyList.Add(6); // 这会抛出异常\r\n                Debug.Log(\"只读集合不能修改\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogError($\"修改只读集合出错: {ex.Message}\");\r\n            }\r\n            \r\n            // ========== 数组操作 ==========\r\n            \r\n            var array = new int[] { 1, 2, 3, 4, 5 };\r\n            \r\n            // Array.Sort: 数组排序\r\n            Array.Sort(array);\r\n            Debug.Log($\"排序后数组: {string.Join(\", \", array)}\");\r\n            \r\n            // Array.Reverse: 数组反转\r\n            Array.Reverse(array);\r\n            Debug.Log($\"反转后数组: {string.Join(\", \", array)}\");\r\n            \r\n            // Array.Find: 查找元素\r\n            int found = Array.Find(array, x => x > 3);\r\n            Debug.Log($\"找到大于3的元素: {found}\");\r\n            \r\n            // Array.FindAll: 查找所有满足条件的元素\r\n            var foundAll = Array.FindAll(array, x => x % 2 == 0);\r\n            Debug.Log($\"所有偶数: {string.Join(\", \", foundAll)}\");\r\n            \r\n            // ========== 集合初始化器 ==========\r\n            \r\n            // 集合初始化器语法\r\n            var list = new List<int> { 1, 2, 3, 4, 5 };\r\n            var dict = new Dictionary<string, int>\r\n            {\r\n                [\"A\"] = 1,\r\n                [\"B\"] = 2,\r\n                [\"C\"] = 3\r\n            };\r\n            var set = new HashSet<int> { 1, 2, 3, 4, 5 };\r\n            \r\n            Debug.Log($\"初始化器创建的集合数量: List={list.Count}, Dict={dict.Count}, Set={set.Count}\");\r\n            \r\n            // ========== 集合转换 ==========\r\n            \r\n            // 数组转List\r\n            var arrayToList = array.ToList();\r\n            Debug.Log($\"数组转List: {arrayToList.Count}个元素\");\r\n            \r\n            // List转数组\r\n            var listToArray = list.ToArray();\r\n            Debug.Log($\"List转数组: {listToArray.Length}个元素\");\r\n            \r\n            // 集合转Dictionary\r\n            var people = new List<Person>\r\n            {\r\n                new Person { Name = \"Alice\", Age = 25 },\r\n                new Person { Name = \"Bob\", Age = 30 }\r\n            };\r\n            var peopleDict = people.ToDictionary(p => p.Name, p => p.Age);\r\n            Debug.Log($\"集合转Dictionary: {peopleDict.Count}个键值对\");\r\n            \r\n            // ========== 集合比较 ==========\r\n            \r\n            var list1 = new List<int> { 1, 2, 3 };\r\n            var list2 = new List<int> { 1, 2, 3 };\r\n            var list3 = new List<int> { 3, 2, 1 };\r\n            \r\n            // 序列相等比较\r\n            bool equal1 = list1.SequenceEqual(list2);\r\n            bool equal2 = list1.SequenceEqual(list3);\r\n            Debug.Log($\"list1和list2相等: {equal1}\");\r\n            Debug.Log($\"list1和list3相等: {equal2}\");\r\n            \r\n            // ========== 集合性能优化 ==========\r\n            \r\n            // 预分配容量\r\n            var optimizedList = new List<int>(1000);\r\n            Debug.Log($\"预分配容量的List容量: {optimizedList.Capacity}\");\r\n            \r\n            // 使用HashSet提高查找性能\r\n            var largeSet = new HashSet<int>();\r\n            for (int i = 0; i < 10000; i++)\r\n            {\r\n                largeSet.Add(i);\r\n            }\r\n            bool fastLookup = largeSet.Contains(5000);\r\n            Debug.Log($\"HashSet快速查找: {fastLookup}\");\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 用于演示的Person类\r\n    /// </summary>\r\n    [System.Serializable]\r\n    public class Person\r\n    {\r\n        public string Name { get; set; }\r\n        public int Age { get; set; }\r\n        public string City { get; set; }\r\n\r\n        public override string ToString()\r\n        {\r\n            return $\"{Name} ({Age}岁, {City})\";\r\n        }\r\n    }\r\n} "
        }
    ]
}