{
    "sourceFile": "游戏编程精粹/1/代码/Flocking（群集行为）.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1764412629611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764412639143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-﻿## Flocking（群集行为）\r\n+## Flocking（群集行为）\r\n \r\n ### 核心概念\r\n \r\n - **定义**：Craig Reynolds于1987年提出的分布式行为模型，模拟鸟群、鱼群等生物群体行为\r\n"
                },
                {
                    "date": 1764412646449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-﻿## Flocking（群集行为）\r\n+## Flocking（群集行为）\r\n \r\n ### 核心概念\r\n \r\n - **定义**：Craig Reynolds于1987年提出的分布式行为模型，模拟鸟群、鱼群等生物群体行为\r\n"
                }
            ],
            "date": 1764412629611,
            "name": "Commit-0",
            "content": "## Flocking（群集行为）\r\n\r\n### 核心概念\r\n\r\n- **定义**：Craig Reynolds于1987年提出的分布式行为模型，模拟鸟群、鱼群等生物群体行为\r\n- **特点**：通过简单规则组合产生复杂的群体运动，展现涌现行为（emergent behavior）\r\n- **应用场景**：Unreal、Half-Life中的怪物和生物，Enemy Nations的部队队形，RTS/RPG中的群体动画\r\n\r\n```csharp\r\npublic class Boid\r\n{\r\n    public Vector3 Position { get; set; }\r\n    public Vector3 Velocity { get; set; }\r\n    public Vector3 Orientation { get; set; }\r\n    \r\n    public float PerceptionRange { get; set; } = 10f;\r\n    public float MaxSpeed { get; set; } = 5f;\r\n    public float MaxVelocityChange { get; set; } = 2f;\r\n    \r\n    private List<Boid> visibleFriends = new List<Boid>();\r\n    private List<Boid> visibleEnemies = new List<Boid>();\r\n    \r\n    // 四个定向行为规则\r\n    public void FlockIt(List<Boid> allBoids, List<Boid> enemies)\r\n    {\r\n        // 1. 检测可见的同伴和敌人\r\n        SeeFriends(allBoids);\r\n        SeeEnemies(enemies);\r\n        \r\n        // 2. 累积所有定向行为的矢量变化\r\n        Vector3 changeVector = Vector3.zero;\r\n        \r\n        changeVector += KeepDistance() * 1.5f;      // 分离（权重1.5）\r\n        changeVector += MatchHeading() * 1.0f;      // 对齐（权重1.0）\r\n        changeVector += SteerToCenter() * 1.0f;     // 聚集（权重1.0）\r\n        changeVector += FleeEnemies() * 2.0f;      // 躲避（权重2.0，优先级高）\r\n        \r\n        // 3. 单位化并应用变化\r\n        if (changeVector.magnitude > 0)\r\n        {\r\n            changeVector.Normalize();\r\n            Velocity += changeVector * MaxVelocityChange;\r\n            \r\n            // 限制最大速度\r\n            if (Velocity.magnitude > MaxSpeed)\r\n                Velocity = Velocity.normalized * MaxSpeed;\r\n        }\r\n        \r\n        // 4. 更新位置和朝向\r\n        Position += Velocity * Time.deltaTime;\r\n        ComputeRPY();\r\n        WorldBound();\r\n    }\r\n    \r\n    // 分离：避免与邻近个体过于接近\r\n    private Vector3 KeepDistance()\r\n    {\r\n        if (visibleFriends.Count == 0) return Vector3.zero;\r\n        \r\n        Vector3 steer = Vector3.zero;\r\n        int count = 0;\r\n        \r\n        foreach (var friend in visibleFriends)\r\n        {\r\n            float distance = Vector3.Distance(Position, friend.Position);\r\n            if (distance > 0 && distance < PerceptionRange)\r\n            {\r\n                Vector3 diff = Position - friend.Position;\r\n                diff.Normalize();\r\n                diff /= distance; // 距离越近，影响越大\r\n                steer += diff;\r\n                count++;\r\n            }\r\n        }\r\n        \r\n        if (count > 0)\r\n            steer /= count;\r\n        \r\n        return steer;\r\n    }\r\n    \r\n    // 对齐：与邻近个体的平均航向对齐\r\n    private Vector3 MatchHeading()\r\n    {\r\n        if (visibleFriends.Count == 0) return Vector3.zero;\r\n        \r\n        Vector3 averageVelocity = Vector3.zero;\r\n        foreach (var friend in visibleFriends)\r\n        {\r\n            averageVelocity += friend.Velocity;\r\n        }\r\n        averageVelocity /= visibleFriends.Count;\r\n        \r\n        return (averageVelocity - Velocity).normalized;\r\n    }\r\n    \r\n    // 聚集：向邻近个体的平均位置移动\r\n    private Vector3 SteerToCenter()\r\n    {\r\n        if (visibleFriends.Count == 0) return Vector3.zero;\r\n        \r\n        Vector3 centerOfMass = Vector3.zero;\r\n        foreach (var friend in visibleFriends)\r\n        {\r\n            centerOfMass += friend.Position;\r\n        }\r\n        centerOfMass /= visibleFriends.Count;\r\n        \r\n        return (centerOfMass - Position).normalized;\r\n    }\r\n    \r\n    // 躲避：避开敌人\r\n    private Vector3 FleeEnemies()\r\n    {\r\n        if (visibleEnemies.Count == 0) return Vector3.zero;\r\n        \r\n        Vector3 fleeVector = Vector3.zero;\r\n        foreach (var enemy in visibleEnemies)\r\n        {\r\n            Vector3 away = Position - enemy.Position;\r\n            float distance = away.magnitude;\r\n            if (distance > 0)\r\n            {\r\n                away.Normalize();\r\n                away /= distance; // 距离越近，逃离越急\r\n                fleeVector += away;\r\n            }\r\n        }\r\n        \r\n        return fleeVector.normalized;\r\n    }\r\n    \r\n    // 检测可见的同伴\r\n    private void SeeFriends(List<Boid> allBoids)\r\n    {\r\n        visibleFriends.Clear();\r\n        foreach (var boid in allBoids)\r\n        {\r\n            if (boid != this && CanISee(boid))\r\n                visibleFriends.Add(boid);\r\n        }\r\n    }\r\n    \r\n    // 检测可见的敌人\r\n    private void SeeEnemies(List<Boid> enemies)\r\n    {\r\n        visibleEnemies.Clear();\r\n        foreach (var enemy in enemies)\r\n        {\r\n            if (CanISee(enemy))\r\n                visibleEnemies.Add(enemy);\r\n        }\r\n    }\r\n    \r\n    // 判断是否可见\r\n    private bool CanISee(Boid other)\r\n    {\r\n        float distance = Vector3.Distance(Position, other.Position);\r\n        return distance <= PerceptionRange;\r\n    }\r\n    \r\n    // 计算Roll/Pitch/Yaw朝向\r\n    private void ComputeRPY()\r\n    {\r\n        if (Velocity.magnitude > 0.1f)\r\n        {\r\n            Quaternion targetRotation = Quaternion.LookRotation(Velocity.normalized);\r\n            Orientation = targetRotation.eulerAngles;\r\n        }\r\n    }\r\n    \r\n    // 边界处理（环绕）\r\n    private void WorldBound()\r\n    {\r\n        // 假设世界边界为Box，超出边界则环绕到对面\r\n        // 可根据需要实现反弹或其他行为\r\n    }\r\n}\r\n```\r\n\r\n#### Flock类（群体管理）\r\n\r\n```csharp\r\npublic class Flock\r\n{\r\n    private List<Boid> members = new List<Boid>();\r\n    public int Count => members.Count;\r\n    \r\n    public void AddBoid(Boid boid)\r\n    {\r\n        if (!members.Contains(boid))\r\n            members.Add(boid);\r\n    }\r\n    \r\n    public void RemoveBoid(Boid boid)\r\n    {\r\n        members.Remove(boid);\r\n    }\r\n    \r\n    public void Update(List<Boid> enemies)\r\n    {\r\n        foreach (var boid in members)\r\n        {\r\n            boid.FlockIt(members, enemies);\r\n        }\r\n    }\r\n    \r\n    public List<Boid> GetAllMembers()\r\n    {\r\n        return new List<Boid>(members); // 返回副本，避免外部修改\r\n    }\r\n    \r\n    public Boid GetFirstMember()\r\n    {\r\n        return members.Count > 0 ? members[0] : null;\r\n    }\r\n}\r\n```\r\n\r\n#### FlockManager类（全局管理 - 优化版）\r\n\r\n```csharp\r\npublic class FlockManager : MonoBehaviour\r\n{\r\n    private List<Flock> flocks = new List<Flock>();\r\n    \r\n    // 优化1：缓存敌人列表，避免每帧重建\r\n    private Dictionary<Flock, List<Boid>> enemyCache = new Dictionary<Flock, List<Boid>>();\r\n    \r\n    // 优化2：控制更新频率（可选）\r\n    [SerializeField] private float updateInterval = 0.1f; // 每0.1秒更新一次\r\n    private float lastUpdateTime = 0f;\r\n    \r\n    // 优化3：分帧更新（可选）\r\n    [SerializeField] private int boidsPerFrame = 10; // 每帧更新10个boid\r\n    private int currentBoidIndex = 0;\r\n    \r\n    public void AddFlock(Flock flock)\r\n    {\r\n        flocks.Add(flock);\r\n        enemyCache[flock] = new List<Boid>();\r\n    }\r\n    \r\n    void Update()\r\n    {\r\n        // 方式1：固定时间间隔更新（推荐）\r\n        if (Time.time - lastUpdateTime >= updateInterval)\r\n        {\r\n            UpdateAllFlocks();\r\n            lastUpdateTime = Time.time;\r\n        }\r\n        \r\n        // 方式2：分帧更新（适合大量boid）\r\n        // UpdateFlocksIncrementally();\r\n    }\r\n    \r\n    // 固定时间间隔更新\r\n    private void UpdateAllFlocks()\r\n    {\r\n        // 预计算所有flock的敌人列表（在Update外）\r\n        RefreshEnemyCache();\r\n        \r\n        // 更新所有flock\r\n        foreach (var flock in flocks)\r\n        {\r\n            flock.Update(enemyCache[flock]);\r\n        }\r\n    }\r\n    \r\n    // 刷新敌人缓存（只在需要时调用，不在每帧Update中）\r\n    private void RefreshEnemyCache()\r\n    {\r\n        foreach (var currentFlock in flocks)\r\n        {\r\n            List<Boid> enemies = new List<Boid>();\r\n            foreach (var otherFlock in flocks)\r\n            {\r\n                if (otherFlock != currentFlock)\r\n                {\r\n                    enemies.AddRange(otherFlock.GetAllMembers());\r\n                }\r\n            }\r\n            enemyCache[currentFlock] = enemies;\r\n        }\r\n    }\r\n    \r\n    // 分帧更新（适合大量boid，避免单帧卡顿）\r\n    private void UpdateFlocksIncrementally()\r\n    {\r\n        int updated = 0;\r\n        foreach (var flock in flocks)\r\n        {\r\n            var members = flock.GetAllMembers();\r\n            for (int i = 0; i < members.Count && updated < boidsPerFrame; i++)\r\n            {\r\n                int index = (currentBoidIndex + i) % members.Count;\r\n                var boid = members[index];\r\n                \r\n                // 获取该boid所属flock的敌人\r\n                var enemies = GetEnemiesForFlock(flock);\r\n                boid.FlockIt(members, enemies);\r\n                \r\n                updated++;\r\n            }\r\n        }\r\n        \r\n        currentBoidIndex = (currentBoidIndex + boidsPerFrame) % GetTotalBoidCount();\r\n    }\r\n    \r\n    private List<Boid> GetEnemiesForFlock(Flock flock)\r\n    {\r\n        if (!enemyCache.ContainsKey(flock))\r\n            RefreshEnemyCache();\r\n        return enemyCache[flock];\r\n    }\r\n    \r\n    private int GetTotalBoidCount()\r\n    {\r\n        int count = 0;\r\n        foreach (var flock in flocks)\r\n            count += flock.Count;\r\n        return count > 0 ? count : 1;\r\n    }\r\n}\r\n```\r\n\r\n#### 关于Enemy的说明\r\n\r\n**为什么需要Enemy？**\r\n- Enemy是Reynolds的**第四规则（躲避）**，用于实现：\r\n  - 躲避其他flock的成员（如兔子躲避狐狸）\r\n  - 躲避障碍物\r\n  - 实现捕食-被捕食关系\r\n- **不是必须的**：如果只需要基本的群集行为（分离、对齐、聚集），可以移除Enemy相关代码\r\n\r\n**Enemy是否必须在Update外？**\r\n- **当前实现**：在Update内每帧收集，效率低\r\n- **优化方案**：\r\n  - 使用`enemyCache`缓存敌人列表\r\n  - 只在flock成员变化时刷新缓存\r\n  - 或使用固定时间间隔刷新（如每0.5秒）\r\n\r\n**Update频率优化**\r\n- **固定时间间隔**：使用`updateInterval`控制更新频率（如0.1秒），减少CPU占用\r\n- **分帧更新**：每帧只更新部分boid，避免单帧卡顿\r\n- **LOD系统**：距离摄像机远的flock降低更新频率"
        }
    ]
}