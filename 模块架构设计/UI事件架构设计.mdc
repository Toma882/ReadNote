# UI 事件架构设计

## 核心设计理念

**统一协程管理**：所有 Press/Continue 事件由静态 `PressCoroutineManager` 统一管理，只有一个全局协程。按需启动/停止，避免每个实例都运行 Update()。

**时间点各自管理**：每个 Listener 自己管理时间点（Press 间隔、Continue 频率），全局协程只负责遍历和调用检查方法。

**按需注册机制**：只有注册了 Press/Continue 事件的 Listener 才会注册到管理器，减少不必要的协程开销。

**对象池复用**：PointerEventData 使用对象池复用，减少 GC 压力。

**实例缓存机制**：UIEventListener 实例使用静态字典缓存，避免重复 GetComponent 调用。

---

## 整体架构图

```mermaid
graph TB
    subgraph Core["核心系统"]
        subgraph Cache["缓存系统"]
            ListenerCache[UIEventListener缓存<br/>Dictionary<int, UIEventListener>]
            EventPool[事件数据对象池<br/>Stack<PointerEventData>]
        end
        
        subgraph Manager["协程管理器"]
            PressManager[PressCoroutineManager<br/>静态类]
            GlobalCoroutine[全局协程<br/>每0.08秒遍历]
            ActiveSet[activeListeners<br/>HashSet]
        end
        
        subgraph Listener["UIEventListener"]
            EventTypes[registeredEventTypes<br/>HashSet快速查找]
            EventDic[eventDic<br/>Dictionary事件字典]
            ScrollRect[ScrollRect缓存<br/>懒加载机制]
        end
    end
    
    subgraph Events["事件类型"]
        Click[Click点击]
        Down[Down按下]
        Up[Up抬起]
        DoubleClick[DoubleClick双击]
        Press[Press长按]
        Continue[Continue持续]
        Drag[Drag拖拽]
        Enter[Enter进入]
        Exit[Exit离开]
    end
    
    Cache --> Listener
    Manager --> Listener
    Listener --> Events
    
    style Cache fill:#c8e6c9
    style Manager fill:#fff4e1
    style Listener fill:#e1f5ff
    style Events fill:#ffebee
```

---

## Press/Continue 事件流程

```mermaid
graph TB
    subgraph User["用户操作"]
        Down[按下]
        Up[抬起]
    end
    
    subgraph Listener["UIEventListener"]
        CheckNeed[检查是否需要协程<br/>Press/Continue事件]
        Register[注册到管理器]
        UpdateCheck[UpdateTimeCheck<br/>检查时间点]
        Unregister[注销]
    end
    
    subgraph Manager["PressCoroutineManager<br/>静态类"]
        HashSet[activeListeners<br/>HashSet]
        Coroutine[全局协程<br/>每0.08秒遍历]
        Start[启动协程<br/>首个注册时]
        Stop[停止协程<br/>全部注销后]
    end
    
    subgraph Events["事件触发"]
        Press[Press事件]
        Continue[Continue事件]
    end
    
    Down --> CheckNeed
    CheckNeed -->|需要| Register
    CheckNeed -->|不需要| Events
    Register --> HashSet
    Register -->|首个| Start
    Start --> Coroutine
    
    Coroutine -->|遍历| HashSet
    HashSet --> UpdateCheck
    UpdateCheck -->|达到时间| Press
    UpdateCheck -->|每次检查| Continue
    
    Up --> Unregister
    Unregister --> HashSet
    Unregister -->|全部注销| Stop
    Stop --> Coroutine
    
    style Manager fill:#c8e6c9
    style Coroutine fill:#fff4e1
    style Listener fill:#e1f5ff
```

---

## 性能优化要点

### 协程管理优化
- **统一协程**：从 N 个 Update() 优化为 1 个全局协程，性能提升约 N 倍
- **按需注册**：只有需要时间事件的 Listener 才注册，减少不必要的遍历
- **时间点自管理**：每个 Listener 自己管理时间逻辑，全局协程只负责调度
- **List 复用**：协程中复用静态 List，避免每次创建新对象，减少 GC 压力

### 缓存优化
- **实例缓存**：UIEventListener 使用静态字典缓存，避免重复 GetComponent，性能提升约 100 倍（缓存命中时）
- **ScrollRect 缓存**：OnEnable 时缓存，懒加载机制确保健壮性
- **事件类型缓存**：使用 HashSet 快速查找，比 Dictionary.ContainsKey 快约 3 倍

### 对象池优化
- **事件数据池**：PointerEventData 使用对象池复用，减少约 90% GC 压力
- **池容量**：MAX_POOL_SIZE = 50，平衡内存和性能

### 查找优化
- **TryGetValue**：字典查找使用 TryGetValue，避免两次查找，性能提升约 50%
- **HashSet 查找**：事件类型检查使用 HashSet，O(1) 复杂度

---

## 事件类型支持

支持 11 种事件类型：
- **Click**：点击事件
- **Down**：按下事件
- **Up**：抬起事件
- **DoubleClick**：双击事件
- **Press**：长按事件（按时间间隔连续触发）
- **Continue**：持续事件（每次检查都触发）
- **BeginDrag**：开始拖拽
- **Drag**：拖拽中
- **EndDrag**：结束拖拽
- **Enter**：鼠标进入
- **Exit**：鼠标离开

---

## 性能对比

| 优化项 | 最初版本 | 当前版本 | 性能提升 |
|--------|---------|---------|---------|
| GetComponent 缓存 | 每次调用 | 静态字典缓存 | **~100倍** |
| PointerEventData | 每次创建 | 对象池复用 | **~90% GC减少** |
| Press/Continue 事件 | N个Update() | 1个全局协程 | **~N倍** |
| 字典查找 | ContainsKey+索引 | TryGetValue | **~50%** |
| 事件类型检查 | Dictionary | HashSet | **~3倍** |
| ScrollRect 查找 | 每次查找 | 缓存+懒加载 | **~10倍** |

**整体性能提升：约 10-100 倍（取决于使用场景）**
