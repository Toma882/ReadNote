{
    "sourceFile": "UnityEditor/Assets/~UnityAPI/UnityEngine/Coroutine/CoroutineExample.cs.txt",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1766053227829,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1766053227829,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// Unity Coroutine（协程）完整 API 示例\r\n/// 协程是Unity中实现异步操作和延迟执行的核心机制\r\n/// 协程不是多线程，而是在主线程上按帧执行的协同程序\r\n/// </summary>\r\npublic class CoroutineExample : MonoBehaviour\r\n{\r\n    [Header(\"协程设置\")]\r\n    [SerializeField] private bool autoStart = true;\r\n    [SerializeField] private float waitTime = 2.0f;\r\n    [SerializeField] private int repeatCount = 5;\r\n    \r\n    [Header(\"协程状态\")]\r\n    [SerializeField] private bool isRunning = false;\r\n    [SerializeField] private int activeCoroutines = 0;\r\n    [SerializeField] private string currentCoroutineName = \"\";\r\n    \r\n    // 协程句柄\r\n    private Coroutine currentCoroutine;\r\n    private List<Coroutine> activeCoroutinesList = new List<Coroutine>();\r\n    \r\n    private void Start()\r\n    {\r\n        Debug.Log(\"=== Unity Coroutine（协程）完整 API 示例 ===\");\r\n        \r\n        if (autoStart)\r\n        {\r\n            TestAllCoroutineFeatures();\r\n        }\r\n    }\r\n    \r\n    #region 1. 基础协程操作\r\n    \r\n    /// <summary>\r\n    /// 测试所有协程功能\r\n    /// </summary>\r\n    private void TestAllCoroutineFeatures()\r\n    {\r\n        Debug.Log(\"\\n--- 1. 基础协程操作 ---\");\r\n        \r\n        // 1.1 启动协程\r\n        TestStartCoroutine();\r\n        \r\n        // 1.2 停止协程\r\n        StartCoroutine(TestStopCoroutine());\r\n        \r\n        // 1.3 协程生命周期\r\n        StartCoroutine(TestCoroutineLifecycle());\r\n        \r\n        Debug.Log(\"\\n--- 2. yield 等待类型 ---\");\r\n        \r\n        // 2.1 yield return null\r\n        StartCoroutine(TestYieldNull());\r\n        \r\n        // 2.2 WaitForSeconds\r\n        StartCoroutine(TestWaitForSeconds());\r\n        \r\n        // 2.3 WaitForEndOfFrame\r\n        StartCoroutine(TestWaitForEndOfFrame());\r\n        \r\n        // 2.4 WaitForFixedUpdate\r\n        StartCoroutine(TestWaitForFixedUpdate());\r\n        \r\n        // 2.5 WaitUntil / WaitWhile\r\n        StartCoroutine(TestWaitUntilWhile());\r\n        \r\n        Debug.Log(\"\\n--- 3. 协程参数传递 ---\");\r\n        \r\n        // 3.1 带参数的协程\r\n        StartCoroutine(TestCoroutineWithParameters(\"参数1\", 100));\r\n        \r\n        Debug.Log(\"\\n--- 4. 协程嵌套 ---\");\r\n        \r\n        // 4.1 嵌套协程\r\n        StartCoroutine(TestNestedCoroutines());\r\n        \r\n        Debug.Log(\"\\n--- 5. 协程与线程的区别 ---\");\r\n        \r\n        // 5.1 协程在主线程执行\r\n        StartCoroutine(TestCoroutineMainThread());\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 1.1 启动协程\r\n    /// StartCoroutine 可以接受 IEnumerator 方法或字符串方法名\r\n    /// </summary>\r\n    private void TestStartCoroutine()\r\n    {\r\n        Debug.Log(\"1.1 启动协程\");\r\n        \r\n        // 方式1：直接传入方法（推荐）\r\n        currentCoroutine = StartCoroutine(SimpleCoroutine());\r\n        \r\n        // 方式2：传入字符串方法名（不推荐，性能较差，且无法传参）\r\n        // StartCoroutine(\"SimpleCoroutine\");\r\n        \r\n        // 方式3：传入 IEnumerator 对象\r\n        IEnumerator enumerator = SimpleCoroutine();\r\n        StartCoroutine(enumerator);\r\n        \r\n        isRunning = true;\r\n        activeCoroutines++;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 简单的协程示例\r\n    /// </summary>\r\n    private IEnumerator SimpleCoroutine()\r\n    {\r\n        Debug.Log(\"协程开始执行\");\r\n        yield return new WaitForSeconds(1.0f);\r\n        Debug.Log(\"协程执行完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 1.2 停止协程\r\n    /// StopCoroutine 可以停止正在运行的协程\r\n    /// </summary>\r\n    private IEnumerator TestStopCoroutine()\r\n    {\r\n        Debug.Log(\"1.2 停止协程\");\r\n        \r\n        Coroutine coroutine = StartCoroutine(LongRunningCoroutine());\r\n        \r\n        // 等待一段时间后停止协程\r\n        yield return new WaitForSeconds(2.0f);\r\n        \r\n        if (coroutine != null)\r\n        {\r\n            StopCoroutine(coroutine);\r\n            Debug.Log(\"协程已停止\");\r\n        }\r\n        \r\n        // 停止所有协程\r\n        // StopAllCoroutines();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 长时间运行的协程\r\n    /// </summary>\r\n    private IEnumerator LongRunningCoroutine()\r\n    {\r\n        for (int i = 0; i < 10; i++)\r\n        {\r\n            Debug.Log($\"协程运行中: {i}\");\r\n            yield return new WaitForSeconds(0.5f);\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 1.3 协程生命周期\r\n    /// 协程在 GameObject 或 Component 被禁用/销毁时会自动停止\r\n    /// </summary>\r\n    private IEnumerator TestCoroutineLifecycle()\r\n    {\r\n        Debug.Log(\"1.3 协程生命周期\");\r\n        \r\n        Debug.Log(\"协程开始，GameObject 激活状态: \" + gameObject.activeSelf);\r\n        \r\n        yield return new WaitForSeconds(1.0f);\r\n        \r\n        // 如果 GameObject 被禁用，协程会暂停\r\n        // gameObject.SetActive(false);\r\n        \r\n        yield return new WaitForSeconds(1.0f);\r\n        \r\n        // 如果 GameObject 被销毁，协程会停止\r\n        // Destroy(gameObject);\r\n        \r\n        Debug.Log(\"协程生命周期测试完成\");\r\n    }\r\n    \r\n    #endregion\r\n    \r\n    #region 2. yield 等待类型\r\n    \r\n    /// <summary>\r\n    /// 2.1 yield return null\r\n    /// 等待一帧，在下一帧继续执行\r\n    /// </summary>\r\n    private IEnumerator TestYieldNull()\r\n    {\r\n        Debug.Log(\"2.1 yield return null - 等待一帧\");\r\n        \r\n        for (int i = 0; i < 5; i++)\r\n        {\r\n            Debug.Log($\"帧 {i}: Time.frameCount = {Time.frameCount}\");\r\n            yield return null; // 等待下一帧\r\n        }\r\n        \r\n        Debug.Log(\"yield return null 测试完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 2.2 WaitForSeconds\r\n    /// 等待指定的秒数（受 Time.timeScale 影响）\r\n    /// </summary>\r\n    private IEnumerator TestWaitForSeconds()\r\n    {\r\n        Debug.Log(\"2.2 WaitForSeconds - 等待指定时间\");\r\n        \r\n        Debug.Log($\"开始时间: {Time.time}\");\r\n        yield return new WaitForSeconds(waitTime);\r\n        Debug.Log($\"结束时间: {Time.time}，等待了 {waitTime} 秒\");\r\n        \r\n        // WaitForSecondsRealtime - 不受 Time.timeScale 影响\r\n        Debug.Log(\"使用 WaitForSecondsRealtime（不受 timeScale 影响）\");\r\n        yield return new WaitForSecondsRealtime(1.0f);\r\n        Debug.Log(\"WaitForSecondsRealtime 完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 2.3 WaitForEndOfFrame\r\n    /// 等待当前帧的所有渲染完成\r\n    /// 常用于截图、UI更新等操作\r\n    /// </summary>\r\n    private IEnumerator TestWaitForEndOfFrame()\r\n    {\r\n        Debug.Log(\"2.3 WaitForEndOfFrame - 等待帧结束\");\r\n        \r\n        Debug.Log(\"帧开始，准备等待帧结束\");\r\n        yield return new WaitForEndOfFrame();\r\n        Debug.Log(\"帧结束，可以执行截图等操作\");\r\n        \r\n        // 示例：截图操作\r\n        // ScreenCapture.CaptureScreenshot(\"screenshot.png\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 2.4 WaitForFixedUpdate\r\n    /// 等待下一次 FixedUpdate 调用\r\n    /// 常用于物理相关的延迟操作\r\n    /// </summary>\r\n    private IEnumerator TestWaitForFixedUpdate()\r\n    {\r\n        Debug.Log(\"2.4 WaitForFixedUpdate - 等待物理更新\");\r\n        \r\n        Debug.Log(\"等待 FixedUpdate\");\r\n        yield return new WaitForFixedUpdate();\r\n        Debug.Log(\"FixedUpdate 完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 2.5 WaitUntil / WaitWhile\r\n    /// WaitUntil: 等待条件为 true\r\n    /// WaitWhile: 等待条件为 false\r\n    /// </summary>\r\n    private IEnumerator TestWaitUntilWhile()\r\n    {\r\n        Debug.Log(\"2.5 WaitUntil / WaitWhile - 条件等待\");\r\n        \r\n        bool condition = false;\r\n        \r\n        // WaitUntil - 等待 condition 变为 true\r\n        Debug.Log(\"等待 condition 变为 true\");\r\n        yield return new WaitUntil(() => condition);\r\n        Debug.Log(\"condition 已变为 true\");\r\n        \r\n        // 模拟条件变化\r\n        StartCoroutine(ChangeConditionAfterDelay(() => condition = true, 2.0f));\r\n        yield return new WaitUntil(() => condition);\r\n        Debug.Log(\"WaitUntil 完成\");\r\n        \r\n        // WaitWhile - 等待 condition 变为 false\r\n        condition = true;\r\n        Debug.Log(\"等待 condition 变为 false\");\r\n        StartCoroutine(ChangeConditionAfterDelay(() => condition = false, 2.0f));\r\n        yield return new WaitWhile(() => condition);\r\n        Debug.Log(\"WaitWhile 完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 延迟改变条件的辅助协程\r\n    /// </summary>\r\n    private IEnumerator ChangeConditionAfterDelay(System.Action action, float delay)\r\n    {\r\n        yield return new WaitForSeconds(delay);\r\n        action?.Invoke();\r\n    }\r\n    \r\n    #endregion\r\n    \r\n    #region 3. 协程参数传递\r\n    \r\n    /// <summary>\r\n    /// 3.1 带参数的协程\r\n    /// 协程方法可以接受参数，通过闭包或类成员变量传递\r\n    /// </summary>\r\n    private IEnumerator TestCoroutineWithParameters(string message, int count)\r\n    {\r\n        Debug.Log(\"3.1 带参数的协程\");\r\n        \r\n        for (int i = 0; i < count; i++)\r\n        {\r\n            Debug.Log($\"{message}: {i}\");\r\n            yield return new WaitForSeconds(0.1f);\r\n        }\r\n        \r\n        Debug.Log(\"带参数协程执行完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 使用闭包传递参数\r\n    /// </summary>\r\n    private void StartCoroutineWithClosure()\r\n    {\r\n        string message = \"闭包参数\";\r\n        int value = 42;\r\n        \r\n        StartCoroutine(CoroutineWithClosure(message, value));\r\n    }\r\n    \r\n    private IEnumerator CoroutineWithClosure(string msg, int val)\r\n    {\r\n        Debug.Log($\"使用闭包: {msg}, {val}\");\r\n        yield return null;\r\n    }\r\n    \r\n    #endregion\r\n    \r\n    #region 4. 协程嵌套\r\n    \r\n    /// <summary>\r\n    /// 4.1 嵌套协程\r\n    /// 协程中可以启动其他协程，实现复杂的异步流程\r\n    /// </summary>\r\n    private IEnumerator TestNestedCoroutines()\r\n    {\r\n        Debug.Log(\"4.1 嵌套协程\");\r\n        \r\n        Debug.Log(\"外层协程开始\");\r\n        \r\n        // 启动内层协程并等待其完成\r\n        yield return StartCoroutine(InnerCoroutine());\r\n        \r\n        Debug.Log(\"外层协程继续执行\");\r\n        yield return new WaitForSeconds(1.0f);\r\n        \r\n        Debug.Log(\"外层协程完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 内层协程\r\n    /// </summary>\r\n    private IEnumerator InnerCoroutine()\r\n    {\r\n        Debug.Log(\"内层协程开始\");\r\n        \r\n        for (int i = 0; i < 3; i++)\r\n        {\r\n            Debug.Log($\"内层协程: {i}\");\r\n            yield return new WaitForSeconds(0.5f);\r\n        }\r\n        \r\n        Debug.Log(\"内层协程完成\");\r\n    }\r\n    \r\n    #endregion\r\n    \r\n    #region 5. 协程与线程的区别\r\n    \r\n    /// <summary>\r\n    /// 5.1 协程在主线程执行\r\n    /// 协程不是多线程，所有操作都在主线程执行\r\n    /// 可以安全访问 Unity API\r\n    /// </summary>\r\n    private IEnumerator TestCoroutineMainThread()\r\n    {\r\n        Debug.Log(\"5.1 协程在主线程执行\");\r\n        \r\n        // 协程中可以安全访问 Unity API\r\n        Debug.Log($\"当前帧数: {Time.frameCount}\");\r\n        Debug.Log($\"当前时间: {Time.time}\");\r\n        \r\n        // 可以访问 GameObject 和 Component\r\n        Transform transform = GetComponent<Transform>();\r\n        if (transform != null)\r\n        {\r\n            Debug.Log($\"GameObject 名称: {transform.name}\");\r\n        }\r\n        \r\n        yield return new WaitForSeconds(1.0f);\r\n        \r\n        Debug.Log(\"协程与线程区别：协程在主线程，可以访问 Unity API\");\r\n    }\r\n    \r\n    #endregion\r\n    \r\n    #region 6. 协程性能优化\r\n    \r\n    /// <summary>\r\n    /// 6.1 协程性能优化建议\r\n    /// </summary>\r\n    private void TestCoroutinePerformance()\r\n    {\r\n        Debug.Log(\"6.1 协程性能优化\");\r\n        \r\n        // 优化1：避免频繁创建 WaitForSeconds\r\n        // ❌ 不好：每次都创建新对象\r\n        // yield return new WaitForSeconds(1.0f);\r\n        \r\n        // ✅ 好：缓存 WaitForSeconds 对象\r\n        WaitForSeconds waitOneSecond = new WaitForSeconds(1.0f);\r\n        StartCoroutine(OptimizedCoroutine(waitOneSecond));\r\n        \r\n        // 优化2：使用 yield return null 代替 WaitForSeconds(0)\r\n        // ❌ 不好：yield return new WaitForSeconds(0);\r\n        // ✅ 好：yield return null;\r\n        \r\n        // 优化3：避免在 Update 中频繁启动协程\r\n        // ❌ 不好：在 Update 中 StartCoroutine\r\n        // ✅ 好：使用标志位控制，只启动一次\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 优化的协程示例\r\n    /// </summary>\r\n    private IEnumerator OptimizedCoroutine(WaitForSeconds waitTime)\r\n    {\r\n        for (int i = 0; i < repeatCount; i++)\r\n        {\r\n            Debug.Log($\"优化协程: {i}\");\r\n            yield return waitTime; // 复用 WaitForSeconds 对象\r\n        }\r\n    }\r\n    \r\n    #endregion\r\n    \r\n    #region 7. 协程实际应用场景\r\n    \r\n    /// <summary>\r\n    /// 7.1 延迟执行\r\n    /// </summary>\r\n    public void DelayedAction(System.Action action, float delay)\r\n    {\r\n        StartCoroutine(DelayedActionCoroutine(action, delay));\r\n    }\r\n    \r\n    private IEnumerator DelayedActionCoroutine(System.Action action, float delay)\r\n    {\r\n        yield return new WaitForSeconds(delay);\r\n        action?.Invoke();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 7.2 定时重复执行\r\n    /// </summary>\r\n    public void StartRepeatingAction(System.Action action, float interval, int times)\r\n    {\r\n        StartCoroutine(RepeatingActionCoroutine(action, interval, times));\r\n    }\r\n    \r\n    private IEnumerator RepeatingActionCoroutine(System.Action action, float interval, int times)\r\n    {\r\n        WaitForSeconds waitInterval = new WaitForSeconds(interval);\r\n        \r\n        for (int i = 0; i < times; i++)\r\n        {\r\n            action?.Invoke();\r\n            yield return waitInterval;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 7.3 异步加载资源\r\n    /// </summary>\r\n    public void LoadResourceAsync<T>(string path, System.Action<T> onComplete) where T : Object\r\n    {\r\n        StartCoroutine(LoadResourceAsyncCoroutine<T>(path, onComplete));\r\n    }\r\n    \r\n    private IEnumerator LoadResourceAsyncCoroutine<T>(string path, System.Action<T> onComplete) where T : Object\r\n    {\r\n        ResourceRequest request = Resources.LoadAsync<T>(path);\r\n        \r\n        while (!request.isDone)\r\n        {\r\n            Debug.Log($\"加载进度: {request.progress * 100}%\");\r\n            yield return null;\r\n        }\r\n        \r\n        T resource = request.asset as T;\r\n        onComplete?.Invoke(resource);\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 7.4 渐变动画\r\n    /// </summary>\r\n    public void FadeInOut(SpriteRenderer spriteRenderer, float duration)\r\n    {\r\n        StartCoroutine(FadeInOutCoroutine(spriteRenderer, duration));\r\n    }\r\n    \r\n    private IEnumerator FadeInOutCoroutine(SpriteRenderer spriteRenderer, float duration)\r\n    {\r\n        Color color = spriteRenderer.color;\r\n        float halfDuration = duration / 2.0f;\r\n        float elapsed = 0.0f;\r\n        \r\n        // 淡入\r\n        while (elapsed < halfDuration)\r\n        {\r\n            elapsed += Time.deltaTime;\r\n            color.a = Mathf.Lerp(0, 1, elapsed / halfDuration);\r\n            spriteRenderer.color = color;\r\n            yield return null;\r\n        }\r\n        \r\n        elapsed = 0.0f;\r\n        \r\n        // 淡出\r\n        while (elapsed < halfDuration)\r\n        {\r\n            elapsed += Time.deltaTime;\r\n            color.a = Mathf.Lerp(1, 0, elapsed / halfDuration);\r\n            spriteRenderer.color = color;\r\n            yield return null;\r\n        }\r\n    }\r\n    \r\n    #endregion\r\n    \r\n    #region 8. 协程管理\r\n    \r\n    /// <summary>\r\n    /// 8.1 停止所有协程\r\n    /// </summary>\r\n    public void StopAllRunningCoroutines()\r\n    {\r\n        StopAllCoroutines();\r\n        activeCoroutines = 0;\r\n        activeCoroutinesList.Clear();\r\n        isRunning = false;\r\n        Debug.Log(\"所有协程已停止\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 8.2 检查协程是否运行\r\n    /// </summary>\r\n    public bool IsCoroutineRunning(Coroutine coroutine)\r\n    {\r\n        return coroutine != null;\r\n    }\r\n    \r\n    private void OnDestroy()\r\n    {\r\n        // 清理所有协程\r\n        StopAllCoroutines();\r\n    }\r\n    \r\n    #endregion\r\n}\r\n\r\n#region 最佳实践总结\r\n\r\n/*\r\n * Unity Coroutine（协程）最佳实践：\r\n * \r\n * 1. 协程特点：\r\n *    - 协程不是多线程，在主线程执行\r\n *    - 可以安全访问 Unity API\r\n *    - 通过 yield 实现延迟和异步操作\r\n *    - 协程在 GameObject 禁用/销毁时会自动停止\r\n * \r\n * 2. yield 类型选择：\r\n *    - yield return null: 等待一帧（最常用）\r\n *    - WaitForSeconds: 等待指定时间（受 timeScale 影响）\r\n *    - WaitForSecondsRealtime: 等待指定时间（不受 timeScale 影响）\r\n *    - WaitForEndOfFrame: 等待帧结束（截图、UI更新）\r\n *    - WaitForFixedUpdate: 等待物理更新\r\n *    - WaitUntil / WaitWhile: 条件等待\r\n * \r\n * 3. 性能优化：\r\n *    - 缓存 WaitForSeconds 对象，避免频繁创建\r\n *    - 使用 yield return null 代替 WaitForSeconds(0)\r\n *    - 避免在 Update 中频繁启动协程\r\n *    - 及时停止不需要的协程\r\n * \r\n * 4. 协程管理：\r\n *    - 保存 Coroutine 句柄以便停止\r\n *    - 在 OnDestroy 中清理协程\r\n *    - 使用 StopAllCoroutines() 停止所有协程\r\n * \r\n * 5. 适用场景：\r\n *    ✅ 延迟执行\r\n *    ✅ 定时重复执行\r\n *    ✅ 异步加载资源\r\n *    ✅ 渐变动画\r\n *    ✅ 分帧处理\r\n *    ✅ 等待条件满足\r\n *    ❌ CPU 密集型计算（应使用 JobSystem）\r\n *    ❌ 需要真正多线程的操作\r\n * \r\n * 6. 与线程的区别：\r\n *    - 协程：主线程，可以访问 Unity API，按帧执行\r\n *    - 线程：独立线程，不能访问 Unity API，并行执行\r\n * \r\n * 7. 注意事项：\r\n *    - GameObject 禁用时协程会暂停\r\n *    - GameObject 销毁时协程会停止\r\n *    - 协程中的异常不会自动捕获\r\n *    - 协程不能返回值（可以使用回调）\r\n */\r\n\r\n#endregion\r\n\r\n"
        }
    ]
}