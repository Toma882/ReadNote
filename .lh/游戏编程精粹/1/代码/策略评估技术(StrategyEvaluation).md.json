{
    "sourceFile": "游戏编程精粹/1/代码/策略评估技术(StrategyEvaluation).md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764867921843,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764867921843,
            "name": "Commit-0",
            "content": "# 策略评估技术 - C#实现\r\n\r\n## 核心概念\r\n\r\n- **定义**：资源分配树、依存图等策略评估技术，用于RTS/策略游戏的AI决策\r\n- **核心思想**：通过评估资源分配和依存关系，做出最优策略决策\r\n- **应用场景**：RTS游戏的经济规划、资源分配、建筑顺序决策\r\n\r\n## 资源分配树\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// 资源分配树节点\r\n/// </summary>\r\npublic class ResourceAllocationNode\r\n{\r\n    public string resourceType;     // 资源类型（木材、矿石、食物等）\r\n    public float currentAmount;      // 当前数量\r\n    public float desiredAmount;      // 期望数量\r\n    public float priority;            // 优先级\r\n    \r\n    public List<ResourceAllocationNode> children;  // 子节点\r\n    \r\n    public ResourceAllocationNode(string type)\r\n    {\r\n        resourceType = type;\r\n        currentAmount = 0f;\r\n        desiredAmount = 0f;\r\n        priority = 1f;\r\n        children = new List<ResourceAllocationNode>();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 计算资源缺口\r\n    /// </summary>\r\n    public float GetDeficit()\r\n    {\r\n        return Mathf.Max(0f, desiredAmount - currentAmount);\r\n    }\r\n}\r\n```\r\n\r\n## 依存图\r\n\r\n```csharp\r\n/// <summary>\r\n/// 依存图节点：表示游戏中的建筑、单位等\r\n/// </summary>\r\npublic class DependencyNode\r\n{\r\n    public string name;              // 节点名称\r\n    public List<string> dependencies;  // 依赖项（前置条件）\r\n    public float value;              // 节点价值\r\n    public bool isBuilt;              // 是否已建造\r\n    \r\n    public DependencyNode(string nodeName)\r\n    {\r\n        name = nodeName;\r\n        dependencies = new List<string>();\r\n        value = 0f;\r\n        isBuilt = false;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 检查是否可以建造（所有依赖是否满足）\r\n    /// </summary>\r\n    public bool CanBuild(Dictionary<string, bool> builtNodes)\r\n    {\r\n        foreach (string dep in dependencies)\r\n        {\r\n            if (!builtNodes.ContainsKey(dep) || !builtNodes[dep])\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 依存图：管理所有节点的依赖关系\r\n/// </summary>\r\npublic class DependencyGraph\r\n{\r\n    private Dictionary<string, DependencyNode> nodes;\r\n    \r\n    public DependencyGraph()\r\n    {\r\n        nodes = new Dictionary<string, DependencyNode>();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 添加节点\r\n    /// </summary>\r\n    public void AddNode(DependencyNode node)\r\n    {\r\n        nodes[node.name] = node;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 查找脆弱的依赖（如果被破坏会影响多个节点）\r\n    /// </summary>\r\n    public List<string> FindVulnerableDependencies()\r\n    {\r\n        Dictionary<string, int> dependencyCount = new Dictionary<string, int>();\r\n        \r\n        // 统计每个节点被依赖的次数\r\n        foreach (var node in nodes.Values)\r\n        {\r\n            foreach (string dep in node.dependencies)\r\n            {\r\n                if (!dependencyCount.ContainsKey(dep))\r\n                    dependencyCount[dep] = 0;\r\n                dependencyCount[dep]++;\r\n            }\r\n        }\r\n        \r\n        // 找出被依赖次数最多的节点（最脆弱）\r\n        List<string> vulnerable = new List<string>();\r\n        int maxCount = 0;\r\n        \r\n        foreach (var kvp in dependencyCount)\r\n        {\r\n            if (kvp.Value > maxCount)\r\n            {\r\n                maxCount = kvp.Value;\r\n                vulnerable.Clear();\r\n                vulnerable.Add(kvp.Key);\r\n            }\r\n            else if (kvp.Value == maxCount)\r\n            {\r\n                vulnerable.Add(kvp.Key);\r\n            }\r\n        }\r\n        \r\n        return vulnerable;\r\n    }\r\n}\r\n```\r\n\r\n## 策略决策\r\n\r\n```csharp\r\n/// <summary>\r\n/// 策略评估器：基于资源分配和依存关系做出决策\r\n/// </summary>\r\npublic class StrategyEvaluator\r\n{\r\n    private ResourceAllocationTree resourceTree;\r\n    private DependencyGraph dependencyGraph;\r\n    \r\n    /// <summary>\r\n    /// 评估当前资源分配情况\r\n    /// </summary>\r\n    public float EvaluateResourceAllocation()\r\n    {\r\n        float score = 0f;\r\n        \r\n        // 遍历资源树，评估资源分配\r\n        EvaluateNode(resourceTree.root, ref score);\r\n        \r\n        return score;\r\n    }\r\n    \r\n    private void EvaluateNode(ResourceAllocationNode node, ref float score)\r\n    {\r\n        // 计算资源缺口（越小越好）\r\n        float deficit = node.GetDeficit();\r\n        float nodeScore = 1f / (1f + deficit) * node.priority;\r\n        score += nodeScore;\r\n        \r\n        // 递归评估子节点\r\n        foreach (var child in node.children)\r\n        {\r\n            EvaluateNode(child, ref score);\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 选择最佳建造顺序\r\n    /// </summary>\r\n    public List<string> GetOptimalBuildOrder()\r\n    {\r\n        List<string> buildOrder = new List<string>();\r\n        Dictionary<string, bool> builtNodes = new Dictionary<string, bool>();\r\n        \r\n        // 贪心算法：每次选择价值最高且可建造的节点\r\n        while (buildOrder.Count < nodes.Count)\r\n        {\r\n            DependencyNode bestNode = null;\r\n            float bestValue = float.MinValue;\r\n            \r\n            foreach (var node in dependencyGraph.GetNodes())\r\n            {\r\n                if (node.isBuilt || !node.CanBuild(builtNodes))\r\n                    continue;\r\n                \r\n                // 计算节点价值（考虑依赖关系）\r\n                float value = CalculateNodeValue(node, builtNodes);\r\n                \r\n                if (value > bestValue)\r\n                {\r\n                    bestValue = value;\r\n                    bestNode = node;\r\n                }\r\n            }\r\n            \r\n            if (bestNode != null)\r\n            {\r\n                buildOrder.Add(bestNode.name);\r\n                builtNodes[bestNode.name] = true;\r\n                bestNode.isBuilt = true;\r\n            }\r\n            else\r\n            {\r\n                break;  // 无法继续建造\r\n            }\r\n        }\r\n        \r\n        return buildOrder;\r\n    }\r\n    \r\n    private float CalculateNodeValue(DependencyNode node, Dictionary<string, bool> builtNodes)\r\n    {\r\n        float value = node.value;\r\n        \r\n        // 如果依赖的节点还未建造，降低价值\r\n        foreach (string dep in node.dependencies)\r\n        {\r\n            if (!builtNodes.ContainsKey(dep) || !builtNodes[dep])\r\n                value *= 0.5f;  // 降低50%价值\r\n        }\r\n        \r\n        return value;\r\n    }\r\n}\r\n```\r\n\r\n## Unity应用示例\r\n\r\n```csharp\r\n/// <summary>\r\n/// Unity中使用策略评估\r\n/// </summary>\r\npublic class StrategyEvaluatorUnity : MonoBehaviour\r\n{\r\n    private StrategyEvaluator evaluator;\r\n    \r\n    void Start()\r\n    {\r\n        evaluator = new StrategyEvaluator();\r\n        // 初始化资源树和依存图\r\n    }\r\n    \r\n    void Update()\r\n    {\r\n        // 每帧评估资源分配\r\n        float allocationScore = evaluator.EvaluateResourceAllocation();\r\n        \r\n        // 如果资源分配不理想，调整策略\r\n        if (allocationScore < 0.5f)\r\n        {\r\n            List<string> buildOrder = evaluator.GetOptimalBuildOrder();\r\n            ExecuteBuildOrder(buildOrder);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n"
        }
    ]
}