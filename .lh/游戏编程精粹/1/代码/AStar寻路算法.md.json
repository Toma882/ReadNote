{
    "sourceFile": "游戏编程精粹/1/代码/AStar寻路算法.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764867852432,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764867852432,
            "name": "Commit-0",
            "content": "# A*寻路算法 - C#实现\r\n\r\n## 核心概念\r\n\r\n- **定义**：A*是一种启发式搜索算法，用于在图形和网格中找到最短路径\r\n- **核心思想**：使用启发式函数估算到目标的距离，优先探索最有希望的节点\r\n- **公式**：`f(n) = g(n) + h(n)`\r\n  - `g(n)`：从起点到当前节点的实际代价\r\n  - `h(n)`：从当前节点到目标的启发式估算代价\r\n  - `f(n)`：节点的总代价\r\n\r\n## 基础数据结构\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// A*节点：表示搜索空间中的一个节点\r\n/// </summary>\r\npublic class AStarNode\r\n{\r\n    public Vector2Int position;      // 节点位置（网格坐标）\r\n    public AStarNode parent;         // 父节点（用于回溯路径）\r\n    public float gCost;              // 从起点到当前节点的实际代价\r\n    public float hCost;              // 从当前节点到目标的启发式估算代价\r\n    public float fCost => gCost + hCost;  // 总代价\r\n    \r\n    public AStarNode(Vector2Int pos)\r\n    {\r\n        position = pos;\r\n        parent = null;\r\n        gCost = 0f;\r\n        hCost = 0f;\r\n    }\r\n}\r\n```\r\n\r\n## 核心算法实现\r\n\r\n```csharp\r\n/// <summary>\r\n/// A*寻路算法核心实现\r\n/// </summary>\r\npublic class AStarPathfinding\r\n{\r\n    private GridMap gridMap;  // 网格地图\r\n    \r\n    /// <summary>\r\n    /// A*寻路主函数\r\n    /// </summary>\r\n    public List<Vector2Int> FindPath(Vector2Int start, Vector2Int end)\r\n    {\r\n        // 1. 初始化\r\n        List<AStarNode> openList = new List<AStarNode>();  // 待探索节点\r\n        HashSet<Vector2Int> closedSet = new HashSet<Vector2Int>();  // 已探索节点\r\n        \r\n        AStarNode startNode = new AStarNode(start);\r\n        startNode.gCost = 0f;\r\n        startNode.hCost = Heuristic(start, end);\r\n        openList.Add(startNode);\r\n        \r\n        // 2. 主循环\r\n        while (openList.Count > 0)\r\n        {\r\n            // 2.1 从开放列表中选择f值最小的节点\r\n            AStarNode currentNode = GetLowestFCostNode(openList);\r\n            openList.Remove(currentNode);\r\n            closedSet.Add(currentNode.position);\r\n            \r\n            // 2.2 如果到达目标，回溯路径\r\n            if (currentNode.position.Equals(end))\r\n            {\r\n                return RetracePath(startNode, currentNode);\r\n            }\r\n            \r\n            // 2.3 探索邻居节点\r\n            foreach (Vector2Int neighbor in GetNeighbors(currentNode.position))\r\n            {\r\n                // 跳过已探索或不可行走的节点\r\n                if (closedSet.Contains(neighbor) || !gridMap.IsWalkable(neighbor))\r\n                    continue;\r\n                \r\n                // 计算到邻居的新代价\r\n                float newGCost = currentNode.gCost + GetDistance(currentNode.position, neighbor);\r\n                \r\n                // 检查是否在开放列表中\r\n                AStarNode neighborNode = openList.Find(n => n.position.Equals(neighbor));\r\n                \r\n                if (neighborNode == null)\r\n                {\r\n                    // 新节点，添加到开放列表\r\n                    neighborNode = new AStarNode(neighbor);\r\n                    neighborNode.parent = currentNode;\r\n                    neighborNode.gCost = newGCost;\r\n                    neighborNode.hCost = Heuristic(neighbor, end);\r\n                    openList.Add(neighborNode);\r\n                }\r\n                else if (newGCost < neighborNode.gCost)\r\n                {\r\n                    // 找到更优路径，更新节点\r\n                    neighborNode.parent = currentNode;\r\n                    neighborNode.gCost = newGCost;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // 3. 未找到路径\r\n        return null;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 启发式函数：估算从A到B的距离（欧氏距离）\r\n    /// </summary>\r\n    private float Heuristic(Vector2Int a, Vector2Int b)\r\n    {\r\n        float dx = Mathf.Abs(a.x - b.x);\r\n        float dy = Mathf.Abs(a.y - b.y);\r\n        return Mathf.Sqrt(dx * dx + dy * dy);\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取f值最小的节点\r\n    /// </summary>\r\n    private AStarNode GetLowestFCostNode(List<AStarNode> nodes)\r\n    {\r\n        AStarNode lowest = nodes[0];\r\n        for (int i = 1; i < nodes.Count; i++)\r\n        {\r\n            if (nodes[i].fCost < lowest.fCost)\r\n                lowest = nodes[i];\r\n        }\r\n        return lowest;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 回溯路径：从终点回溯到起点\r\n    /// </summary>\r\n    private List<Vector2Int> RetracePath(AStarNode startNode, AStarNode endNode)\r\n    {\r\n        List<Vector2Int> path = new List<Vector2Int>();\r\n        AStarNode currentNode = endNode;\r\n        \r\n        while (currentNode != null)\r\n        {\r\n            path.Add(currentNode.position);\r\n            currentNode = currentNode.parent;\r\n        }\r\n        \r\n        path.Reverse();  // 反转路径，从起点到终点\r\n        return path;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取邻居节点（4方向或8方向）\r\n    /// </summary>\r\n    private List<Vector2Int> GetNeighbors(Vector2Int pos)\r\n    {\r\n        List<Vector2Int> neighbors = new List<Vector2Int>();\r\n        \r\n        // 4方向移动\r\n        neighbors.Add(new Vector2Int(pos.x + 1, pos.y));\r\n        neighbors.Add(new Vector2Int(pos.x - 1, pos.y));\r\n        neighbors.Add(new Vector2Int(pos.x, pos.y + 1));\r\n        neighbors.Add(new Vector2Int(pos.x, pos.y - 1));\r\n        \r\n        // 可选：8方向移动（包含对角线）\r\n        // neighbors.Add(new Vector2Int(pos.x + 1, pos.y + 1));\r\n        // neighbors.Add(new Vector2Int(pos.x + 1, pos.y - 1));\r\n        // neighbors.Add(new Vector2Int(pos.x - 1, pos.y + 1));\r\n        // neighbors.Add(new Vector2Int(pos.x - 1, pos.y - 1));\r\n        \r\n        return neighbors;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 计算两个节点之间的距离\r\n    /// </summary>\r\n    private float GetDistance(Vector2Int a, Vector2Int b)\r\n    {\r\n        float dx = Mathf.Abs(a.x - b.x);\r\n        float dy = Mathf.Abs(a.y - b.y);\r\n        \r\n        // 4方向移动：使用曼哈顿距离\r\n        return dx + dy;\r\n        \r\n        // 8方向移动：使用对角线距离\r\n        // if (dx > dy)\r\n        //     return 14 * dy + 10 * (dx - dy);\r\n        // return 14 * dx + 10 * (dy - dx);\r\n    }\r\n}\r\n```\r\n\r\n## 性能优化实现\r\n\r\n### 使用优先队列优化Open表\r\n\r\n```csharp\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// 使用优先队列（堆）优化Open表\r\n/// </summary>\r\npublic class AStarPathfindingOptimized\r\n{\r\n    // 使用.NET 6+的PriorityQueue，或自己实现最小堆\r\n    private PriorityQueue<AStarNode, float> openQueue;\r\n    \r\n    // 或者使用List配合堆操作\r\n    private List<AStarNode> openList;\r\n    \r\n    /// <summary>\r\n    /// 使用堆优化的节点插入\r\n    /// </summary>\r\n    private void AddToOpenList(AStarNode node)\r\n    {\r\n        openList.Add(node);\r\n        // 上浮操作，维护堆性质\r\n        HeapifyUp(openList.Count - 1);\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 提取f值最小的节点\r\n    /// </summary>\r\n    private AStarNode ExtractMin()\r\n    {\r\n        if (openList.Count == 0) return null;\r\n        \r\n        AStarNode min = openList[0];\r\n        openList[0] = openList[openList.Count - 1];\r\n        openList.RemoveAt(openList.Count - 1);\r\n        \r\n        if (openList.Count > 0)\r\n            HeapifyDown(0);\r\n        \r\n        return min;\r\n    }\r\n    \r\n    private void HeapifyUp(int index)\r\n    {\r\n        while (index > 0)\r\n        {\r\n            int parent = (index - 1) / 2;\r\n            if (openList[index].fCost >= openList[parent].fCost)\r\n                break;\r\n            \r\n            Swap(index, parent);\r\n            index = parent;\r\n        }\r\n    }\r\n    \r\n    private void HeapifyDown(int index)\r\n    {\r\n        while (true)\r\n        {\r\n            int left = 2 * index + 1;\r\n            int right = 2 * index + 2;\r\n            int smallest = index;\r\n            \r\n            if (left < openList.Count && openList[left].fCost < openList[smallest].fCost)\r\n                smallest = left;\r\n            if (right < openList.Count && openList[right].fCost < openList[smallest].fCost)\r\n                smallest = right;\r\n            \r\n            if (smallest == index) break;\r\n            \r\n            Swap(index, smallest);\r\n            index = smallest;\r\n        }\r\n    }\r\n    \r\n    private void Swap(int a, int b)\r\n    {\r\n        AStarNode temp = openList[a];\r\n        openList[a] = openList[b];\r\n        openList[b] = temp;\r\n    }\r\n}\r\n```\r\n\r\n### 节点银行（预分配优化）\r\n\r\n```csharp\r\n/// <summary>\r\n/// 节点银行：预分配节点，避免频繁GC\r\n/// </summary>\r\npublic class NodeBank\r\n{\r\n    private Queue<AStarNode> nodePool;\r\n    private int poolSize;\r\n    \r\n    public NodeBank(int size = 1000)\r\n    {\r\n        poolSize = size;\r\n        nodePool = new Queue<AStarNode>();\r\n        \r\n        // 预分配节点\r\n        for (int i = 0; i < poolSize; i++)\r\n        {\r\n            nodePool.Enqueue(new AStarNode(Vector2Int.zero));\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 从节点银行获取节点\r\n    /// </summary>\r\n    public AStarNode GetNode(Vector2Int position)\r\n    {\r\n        AStarNode node;\r\n        \r\n        if (nodePool.Count > 0)\r\n        {\r\n            node = nodePool.Dequeue();\r\n        }\r\n        else\r\n        {\r\n            // 池用尽，创建新节点\r\n            node = new AStarNode(Vector2Int.zero);\r\n        }\r\n        \r\n        // 重置节点状态\r\n        node.position = position;\r\n        node.parent = null;\r\n        node.gCost = 0f;\r\n        node.hCost = 0f;\r\n        \r\n        return node;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 归还节点到银行\r\n    /// </summary>\r\n    public void ReturnNode(AStarNode node)\r\n    {\r\n        if (nodePool.Count < poolSize)\r\n        {\r\n            nodePool.Enqueue(node);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Unity应用\r\n\r\n```csharp\r\n/// <summary>\r\n/// Unity中使用A*寻路\r\n/// </summary>\r\npublic class AStarPathfindingUnity : MonoBehaviour\r\n{\r\n    public GridMap gridMap;\r\n    public Transform startPoint;\r\n    public Transform endPoint;\r\n    \r\n    private AStarPathfinding pathfinding;\r\n    \r\n    void Start()\r\n    {\r\n        pathfinding = new AStarPathfinding();\r\n        pathfinding.gridMap = gridMap;\r\n    }\r\n    \r\n    void Update()\r\n    {\r\n        if (Input.GetKeyDown(KeyCode.Space))\r\n        {\r\n            Vector2Int start = WorldToGrid(startPoint.position);\r\n            Vector2Int end = WorldToGrid(endPoint.position);\r\n            \r\n            List<Vector2Int> path = pathfinding.FindPath(start, end);\r\n            \r\n            if (path != null)\r\n            {\r\n                Debug.Log($\"找到路径，共{path.Count}个节点\");\r\n                // 可视化路径\r\n                VisualizePath(path);\r\n            }\r\n            else\r\n            {\r\n                Debug.Log(\"未找到路径\");\r\n            }\r\n        }\r\n    }\r\n    \r\n    private Vector2Int WorldToGrid(Vector3 worldPos)\r\n    {\r\n        // 将世界坐标转换为网格坐标\r\n        return new Vector2Int(\r\n            Mathf.FloorToInt(worldPos.x),\r\n            Mathf.FloorToInt(worldPos.z)\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n## 路径平滑\r\n\r\nA*算法找到的路径通常是锯齿状的，需要进行平滑处理。参考：\r\n- `PathFollow.cs` - 基础路径跟随实现\r\n- `PathFollow_Optimized.cs` - Catmull-Rom插值优化版本\r\n\r\n**平滑方法**：\r\n1. **Catmull-Rom插值**：预生成平滑路径点\r\n2. **分级路径点**：动态调整路径点，总是寻找下一个关键点\r\n\r\n"
        }
    ]
}