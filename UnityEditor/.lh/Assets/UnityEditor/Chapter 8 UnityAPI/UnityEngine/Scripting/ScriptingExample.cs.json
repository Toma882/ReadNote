{
    "sourceFile": "Assets/UnityEditor/Chapter 8 UnityAPI/UnityEngine/Scripting/ScriptingExample.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1750931853539,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1750931853539,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing UnityEngine.Scripting;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Reflection;\r\n\r\n/// <summary>\r\n/// UnityEngine.Scripting 命名空间案例演示\r\n/// 展示脚本系统的核心功能\r\n/// </summary>\r\npublic class ScriptingExample : MonoBehaviour\r\n{\r\n    [Header(\"脚本系统设置\")]\r\n    [SerializeField] private bool enableScriptingSystem = true;\r\n    [SerializeField] private bool enableReflection = true;\r\n    [SerializeField] private bool enableAttributeProcessing = true;\r\n    [SerializeField] private bool enableAssemblyLoading = true;\r\n    \r\n    [Header(\"脚本状态\")]\r\n    [SerializeField] private bool isScriptingSystemActive = false;\r\n    [SerializeField] private int totalAssemblies = 0;\r\n    [SerializeField] private int loadedAssemblies = 0;\r\n    [SerializeField] private int totalTypes = 0;\r\n    [SerializeField] private int totalMethods = 0;\r\n    [SerializeField] private List<string> assemblyList = new List<string>();\r\n    \r\n    [Header(\"反射信息\")]\r\n    [SerializeField] private string targetTypeName = \"UnityEngine.GameObject\";\r\n    [SerializeField] private string targetMethodName = \"Find\";\r\n    [SerializeField] private bool showPrivateMembers = false;\r\n    [SerializeField] private bool showStaticMembers = true;\r\n    \r\n    [Header(\"属性处理\")]\r\n    [SerializeField] private bool processCustomAttributes = true;\r\n    [SerializeField] private bool processBuiltinAttributes = true;\r\n    [SerializeField] private List<string> attributeList = new List<string>();\r\n    \r\n    // 脚本系统事件\r\n    private System.Action<string> onAssemblyLoaded;\r\n    private System.Action<string> onTypeDiscovered;\r\n    private System.Action<string> onMethodInvoked;\r\n    private System.Action<string> onAttributeProcessed;\r\n    \r\n    // 缓存\r\n    private Dictionary<string, Type> typeCache = new Dictionary<string, Type>();\r\n    private Dictionary<string, MethodInfo> methodCache = new Dictionary<string, MethodInfo>();\r\n    private List<Assembly> loadedAssemblyList = new List<Assembly>();\r\n    \r\n    private void Start()\r\n    {\r\n        InitializeScriptingSystem();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 初始化脚本系统\r\n    /// </summary>\r\n    private void InitializeScriptingSystem()\r\n    {\r\n        // 获取程序集信息\r\n        GetAssemblyInformation();\r\n        \r\n        // 设置脚本系统事件\r\n        SetupScriptingSystemEvents();\r\n        \r\n        // 初始化类型缓存\r\n        InitializeTypeCache();\r\n        \r\n        // 初始化方法缓存\r\n        InitializeMethodCache();\r\n        \r\n        isScriptingSystemActive = true;\r\n        Debug.Log(\"脚本系统初始化完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取程序集信息\r\n    /// </summary>\r\n    private void GetAssemblyInformation()\r\n    {\r\n        // 获取所有已加载的程序集\r\n        Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();\r\n        loadedAssemblies = assemblies.Length;\r\n        totalAssemblies = assemblies.Length;\r\n        \r\n        // 统计类型和方法数量\r\n        totalTypes = 0;\r\n        totalMethods = 0;\r\n        assemblyList.Clear();\r\n        loadedAssemblyList.Clear();\r\n        \r\n        foreach (Assembly assembly in assemblies)\r\n        {\r\n            try\r\n            {\r\n                assemblyList.Add(assembly.FullName);\r\n                loadedAssemblyList.Add(assembly);\r\n                \r\n                Type[] types = assembly.GetTypes();\r\n                totalTypes += types.Length;\r\n                \r\n                foreach (Type type in types)\r\n                {\r\n                    MethodInfo[] methods = type.GetMethods();\r\n                    totalMethods += methods.Length;\r\n                }\r\n                \r\n                onAssemblyLoaded?.Invoke(assembly.FullName);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogWarning($\"无法处理程序集 {assembly.FullName}: {ex.Message}\");\r\n            }\r\n        }\r\n        \r\n        Debug.Log($\"发现 {loadedAssemblies} 个程序集，{totalTypes} 个类型，{totalMethods} 个方法\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 设置脚本系统事件\r\n    /// </summary>\r\n    private void SetupScriptingSystemEvents()\r\n    {\r\n        // 注册程序集加载事件\r\n        AppDomain.CurrentDomain.AssemblyLoad += OnAssemblyLoaded;\r\n        \r\n        Debug.Log(\"脚本系统事件设置完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 初始化类型缓存\r\n    /// </summary>\r\n    private void InitializeTypeCache()\r\n    {\r\n        typeCache.Clear();\r\n        \r\n        foreach (Assembly assembly in loadedAssemblyList)\r\n        {\r\n            try\r\n            {\r\n                Type[] types = assembly.GetTypes();\r\n                foreach (Type type in types)\r\n                {\r\n                    string typeKey = $\"{assembly.GetName().Name}.{type.Name}\";\r\n                    if (!typeCache.ContainsKey(typeKey))\r\n                    {\r\n                        typeCache[typeKey] = type;\r\n                        onTypeDiscovered?.Invoke(typeKey);\r\n                    }\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogWarning($\"无法缓存程序集 {assembly.FullName} 中的类型: {ex.Message}\");\r\n            }\r\n        }\r\n        \r\n        Debug.Log($\"缓存了 {typeCache.Count} 个类型\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 初始化方法缓存\r\n    /// </summary>\r\n    private void InitializeMethodCache()\r\n    {\r\n        methodCache.Clear();\r\n        \r\n        foreach (var kvp in typeCache)\r\n        {\r\n            Type type = kvp.Value;\r\n            try\r\n            {\r\n                MethodInfo[] methods = type.GetMethods();\r\n                foreach (MethodInfo method in methods)\r\n                {\r\n                    string methodKey = $\"{kvp.Key}.{method.Name}\";\r\n                    if (!methodCache.ContainsKey(methodKey))\r\n                    {\r\n                        methodCache[methodKey] = method;\r\n                    }\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogWarning($\"无法缓存类型 {type.Name} 中的方法: {ex.Message}\");\r\n            }\r\n        }\r\n        \r\n        Debug.Log($\"缓存了 {methodCache.Count} 个方法\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取类型信息\r\n    /// </summary>\r\n    /// <param name=\"typeName\">类型名称</param>\r\n    /// <returns>类型信息</returns>\r\n    public Type GetTypeInfo(string typeName)\r\n    {\r\n        if (string.IsNullOrEmpty(typeName))\r\n        {\r\n            Debug.LogError(\"类型名称不能为空\");\r\n            return null;\r\n        }\r\n        \r\n        // 首先尝试从缓存中获取\r\n        if (typeCache.ContainsKey(typeName))\r\n        {\r\n            return typeCache[typeName];\r\n        }\r\n        \r\n        // 尝试从所有程序集中查找\r\n        foreach (Assembly assembly in loadedAssemblyList)\r\n        {\r\n            try\r\n            {\r\n                Type type = assembly.GetType(typeName);\r\n                if (type != null)\r\n                {\r\n                    typeCache[typeName] = type;\r\n                    return type;\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogWarning($\"在程序集 {assembly.FullName} 中查找类型 {typeName} 时出错: {ex.Message}\");\r\n            }\r\n        }\r\n        \r\n        Debug.LogWarning($\"未找到类型: {typeName}\");\r\n        return null;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取方法信息\r\n    /// </summary>\r\n    /// <param name=\"typeName\">类型名称</param>\r\n    /// <param name=\"methodName\">方法名称</param>\r\n    /// <returns>方法信息</returns>\r\n    public MethodInfo GetMethodInfo(string typeName, string methodName)\r\n    {\r\n        if (string.IsNullOrEmpty(typeName) || string.IsNullOrEmpty(methodName))\r\n        {\r\n            Debug.LogError(\"类型名称和方法名称不能为空\");\r\n            return null;\r\n        }\r\n        \r\n        string methodKey = $\"{typeName}.{methodName}\";\r\n        \r\n        // 首先尝试从缓存中获取\r\n        if (methodCache.ContainsKey(methodKey))\r\n        {\r\n            return methodCache[methodKey];\r\n        }\r\n        \r\n        // 获取类型信息\r\n        Type type = GetTypeInfo(typeName);\r\n        if (type == null)\r\n        {\r\n            return null;\r\n        }\r\n        \r\n        // 查找方法\r\n        MethodInfo method = type.GetMethod(methodName);\r\n        if (method != null)\r\n        {\r\n            methodCache[methodKey] = method;\r\n            return method;\r\n        }\r\n        \r\n        Debug.LogWarning($\"在类型 {typeName} 中未找到方法: {methodName}\");\r\n        return null;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 通过反射调用方法\r\n    /// </summary>\r\n    /// <param name=\"typeName\">类型名称</param>\r\n    /// <param name=\"methodName\">方法名称</param>\r\n    /// <param name=\"parameters\">参数</param>\r\n    /// <returns>方法返回值</returns>\r\n    public object InvokeMethod(string typeName, string methodName, params object[] parameters)\r\n    {\r\n        if (!enableReflection)\r\n        {\r\n            Debug.LogWarning(\"反射功能已禁用\");\r\n            return null;\r\n        }\r\n        \r\n        MethodInfo method = GetMethodInfo(typeName, methodName);\r\n        if (method == null)\r\n        {\r\n            return null;\r\n        }\r\n        \r\n        try\r\n        {\r\n            object instance = null;\r\n            \r\n            // 如果是静态方法，不需要实例\r\n            if (!method.IsStatic)\r\n            {\r\n                // 尝试创建实例\r\n                Type type = GetTypeInfo(typeName);\r\n                if (type != null)\r\n                {\r\n                    instance = Activator.CreateInstance(type);\r\n                }\r\n            }\r\n            \r\n            object result = method.Invoke(instance, parameters);\r\n            onMethodInvoked?.Invoke($\"{typeName}.{methodName}\");\r\n            \r\n            Debug.Log($\"成功调用方法: {typeName}.{methodName}\");\r\n            return result;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Debug.LogError($\"调用方法 {typeName}.{methodName} 时出错: {ex.Message}\");\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取类型的所有成员\r\n    /// </summary>\r\n    /// <param name=\"typeName\">类型名称</param>\r\n    /// <returns>成员信息列表</returns>\r\n    public List<MemberInfo> GetTypeMembers(string typeName)\r\n    {\r\n        Type type = GetTypeInfo(typeName);\r\n        if (type == null)\r\n        {\r\n            return new List<MemberInfo>();\r\n        }\r\n        \r\n        List<MemberInfo> members = new List<MemberInfo>();\r\n        \r\n        try\r\n        {\r\n            BindingFlags flags = BindingFlags.Public | BindingFlags.Instance;\r\n            \r\n            if (showPrivateMembers)\r\n            {\r\n                flags |= BindingFlags.NonPublic;\r\n            }\r\n            \r\n            if (showStaticMembers)\r\n            {\r\n                flags |= BindingFlags.Static;\r\n            }\r\n            \r\n            // 获取方法\r\n            MethodInfo[] methods = type.GetMethods(flags);\r\n            members.AddRange(methods);\r\n            \r\n            // 获取属性\r\n            PropertyInfo[] properties = type.GetProperties(flags);\r\n            members.AddRange(properties);\r\n            \r\n            // 获取字段\r\n            FieldInfo[] fields = type.GetFields(flags);\r\n            members.AddRange(fields);\r\n            \r\n            // 获取事件\r\n            EventInfo[] events = type.GetEvents(flags);\r\n            members.AddRange(events);\r\n            \r\n            // 获取构造函数\r\n            ConstructorInfo[] constructors = type.GetConstructors(flags);\r\n            members.AddRange(constructors);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Debug.LogError($\"获取类型 {typeName} 的成员时出错: {ex.Message}\");\r\n        }\r\n        \r\n        return members;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取类型的属性\r\n    /// </summary>\r\n    /// <param name=\"typeName\">类型名称</param>\r\n    /// <returns>属性信息列表</returns>\r\n    public List<Attribute> GetTypeAttributes(string typeName)\r\n    {\r\n        if (!enableAttributeProcessing)\r\n        {\r\n            Debug.LogWarning(\"属性处理功能已禁用\");\r\n            return new List<Attribute>();\r\n        }\r\n        \r\n        Type type = GetTypeInfo(typeName);\r\n        if (type == null)\r\n        {\r\n            return new List<Attribute>();\r\n        }\r\n        \r\n        List<Attribute> attributes = new List<Attribute>();\r\n        \r\n        try\r\n        {\r\n            // 获取类型属性\r\n            Attribute[] typeAttributes = Attribute.GetCustomAttributes(type);\r\n            attributes.AddRange(typeAttributes);\r\n            \r\n            // 获取方法属性\r\n            MethodInfo[] methods = type.GetMethods();\r\n            foreach (MethodInfo method in methods)\r\n            {\r\n                Attribute[] methodAttributes = Attribute.GetCustomAttributes(method);\r\n                attributes.AddRange(methodAttributes);\r\n            }\r\n            \r\n            // 获取属性属性\r\n            PropertyInfo[] properties = type.GetProperties();\r\n            foreach (PropertyInfo property in properties)\r\n            {\r\n                Attribute[] propertyAttributes = Attribute.GetCustomAttributes(property);\r\n                attributes.AddRange(propertyAttributes);\r\n            }\r\n            \r\n            // 获取字段属性\r\n            FieldInfo[] fields = type.GetFields();\r\n            foreach (FieldInfo field in fields)\r\n            {\r\n                Attribute[] fieldAttributes = Attribute.GetCustomAttributes(field);\r\n                attributes.AddRange(fieldAttributes);\r\n            }\r\n            \r\n            // 更新属性列表\r\n            attributeList.Clear();\r\n            foreach (Attribute attribute in attributes)\r\n            {\r\n                string attributeName = attribute.GetType().Name;\r\n                if (!attributeList.Contains(attributeName))\r\n                {\r\n                    attributeList.Add(attributeName);\r\n                    onAttributeProcessed?.Invoke(attributeName);\r\n                }\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Debug.LogError($\"获取类型 {typeName} 的属性时出错: {ex.Message}\");\r\n        }\r\n        \r\n        return attributes;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 创建类型实例\r\n    /// </summary>\r\n    /// <param name=\"typeName\">类型名称</param>\r\n    /// <param name=\"parameters\">构造函数参数</param>\r\n    /// <returns>实例对象</returns>\r\n    public object CreateInstance(string typeName, params object[] parameters)\r\n    {\r\n        Type type = GetTypeInfo(typeName);\r\n        if (type == null)\r\n        {\r\n            return null;\r\n        }\r\n        \r\n        try\r\n        {\r\n            object instance = Activator.CreateInstance(type, parameters);\r\n            Debug.Log($\"成功创建类型 {typeName} 的实例\");\r\n            return instance;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Debug.LogError($\"创建类型 {typeName} 的实例时出错: {ex.Message}\");\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 检查类型是否实现了指定接口\r\n    /// </summary>\r\n    /// <param name=\"typeName\">类型名称</param>\r\n    /// <param name=\"interfaceName\">接口名称</param>\r\n    /// <returns>是否实现接口</returns>\r\n    public bool ImplementsInterface(string typeName, string interfaceName)\r\n    {\r\n        Type type = GetTypeInfo(typeName);\r\n        Type interfaceType = GetTypeInfo(interfaceName);\r\n        \r\n        if (type == null || interfaceType == null)\r\n        {\r\n            return false;\r\n        }\r\n        \r\n        return interfaceType.IsAssignableFrom(type);\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 检查类型是否继承自指定基类\r\n    /// </summary>\r\n    /// <param name=\"typeName\">类型名称</param>\r\n    /// <param name=\"baseTypeName\">基类名称</param>\r\n    /// <returns>是否继承自基类</returns>\r\n    public bool InheritsFrom(string typeName, string baseTypeName)\r\n    {\r\n        Type type = GetTypeInfo(typeName);\r\n        Type baseType = GetTypeInfo(baseTypeName);\r\n        \r\n        if (type == null || baseType == null)\r\n        {\r\n            return false;\r\n        }\r\n        \r\n        return type.IsSubclassOf(baseType);\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取泛型类型参数\r\n    /// </summary>\r\n    /// <param name=\"typeName\">类型名称</param>\r\n    /// <returns>泛型参数类型数组</returns>\r\n    public Type[] GetGenericArguments(string typeName)\r\n    {\r\n        Type type = GetTypeInfo(typeName);\r\n        if (type == null || !type.IsGenericType)\r\n        {\r\n            return new Type[0];\r\n        }\r\n        \r\n        return type.GetGenericArguments();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取程序集信息\r\n    /// </summary>\r\n    /// <param name=\"assemblyName\">程序集名称</param>\r\n    /// <returns>程序集信息</returns>\r\n    public Assembly GetAssemblyInfo(string assemblyName)\r\n    {\r\n        foreach (Assembly assembly in loadedAssemblyList)\r\n        {\r\n            if (assembly.GetName().Name == assemblyName)\r\n            {\r\n                return assembly;\r\n            }\r\n        }\r\n        \r\n        return null;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取脚本系统信息\r\n    /// </summary>\r\n    public void GetScriptingSystemInfo()\r\n    {\r\n        Debug.Log(\"=== 脚本系统信息 ===\");\r\n        Debug.Log($\"脚本系统启用: {enableScriptingSystem}\");\r\n        Debug.Log($\"反射功能启用: {enableReflection}\");\r\n        Debug.Log($\"属性处理启用: {enableAttributeProcessing}\");\r\n        Debug.Log($\"程序集加载启用: {enableAssemblyLoading}\");\r\n        \r\n        Debug.Log($\"脚本系统活跃: {isScriptingSystemActive}\");\r\n        Debug.Log($\"总程序集数: {totalAssemblies}\");\r\n        Debug.Log($\"已加载程序集数: {loadedAssemblies}\");\r\n        Debug.Log($\"总类型数: {totalTypes}\");\r\n        Debug.Log($\"总方法数: {totalMethods}\");\r\n        Debug.Log($\"缓存类型数: {typeCache.Count}\");\r\n        Debug.Log($\"缓存方法数: {methodCache.Count}\");\r\n        Debug.Log($\"发现属性数: {attributeList.Count}\");\r\n        \r\n        Debug.Log(\"已加载的程序集:\");\r\n        for (int i = 0; i < Mathf.Min(assemblyList.Count, 10); i++)\r\n        {\r\n            Debug.Log($\"  {assemblyList[i]}\");\r\n        }\r\n        \r\n        if (assemblyList.Count > 10)\r\n        {\r\n            Debug.Log($\"  ... 还有 {assemblyList.Count - 10} 个程序集\");\r\n        }\r\n        \r\n        Debug.Log(\"发现的属性:\");\r\n        foreach (string attribute in attributeList)\r\n        {\r\n            Debug.Log($\"  {attribute}\");\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 重置脚本系统设置\r\n    /// </summary>\r\n    public void ResetScriptingSystemSettings()\r\n    {\r\n        // 重置设置\r\n        enableScriptingSystem = true;\r\n        enableReflection = true;\r\n        enableAttributeProcessing = true;\r\n        enableAssemblyLoading = true;\r\n        \r\n        // 重置状态\r\n        isScriptingSystemActive = false;\r\n        showPrivateMembers = false;\r\n        showStaticMembers = true;\r\n        processCustomAttributes = true;\r\n        processBuiltinAttributes = true;\r\n        \r\n        Debug.Log(\"脚本系统设置已重置\");\r\n    }\r\n    \r\n    // 事件处理器\r\n    private void OnAssemblyLoaded(object sender, AssemblyLoadEventArgs args)\r\n    {\r\n        Debug.Log($\"程序集已加载: {args.LoadedAssembly.FullName}\");\r\n        onAssemblyLoaded?.Invoke(args.LoadedAssembly.FullName);\r\n        \r\n        // 更新程序集列表\r\n        assemblyList.Add(args.LoadedAssembly.FullName);\r\n        loadedAssemblyList.Add(args.LoadedAssembly);\r\n        loadedAssemblies++;\r\n        totalAssemblies++;\r\n    }\r\n    \r\n    private void Update()\r\n    {\r\n        // 更新脚本系统状态\r\n        if (enableScriptingSystem)\r\n        {\r\n            isScriptingSystemActive = true;\r\n        }\r\n    }\r\n    \r\n    private void OnGUI()\r\n    {\r\n        // 简单的GUI界面用于测试\r\n        GUILayout.BeginArea(new Rect(10, 10, 400, 800));\r\n        GUILayout.Label(\"脚本系统演示\", EditorStyles.boldLabel);\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        // 脚本系统状态\r\n        GUILayout.Label($\"脚本系统活跃: {isScriptingSystemActive}\");\r\n        GUILayout.Label($\"总程序集数: {totalAssemblies}\");\r\n        GUILayout.Label($\"已加载程序集数: {loadedAssemblies}\");\r\n        GUILayout.Label($\"总类型数: {totalTypes}\");\r\n        GUILayout.Label($\"总方法数: {totalMethods}\");\r\n        GUILayout.Label($\"缓存类型数: {typeCache.Count}\");\r\n        GUILayout.Label($\"缓存方法数: {methodCache.Count}\");\r\n        GUILayout.Label($\"发现属性数: {attributeList.Count}\");\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        // 反射操作\r\n        GUILayout.Label(\"反射操作:\", EditorStyles.boldLabel);\r\n        \r\n        targetTypeName = GUILayout.TextField(\"类型名称\", targetTypeName);\r\n        targetMethodName = GUILayout.TextField(\"方法名称\", targetMethodName);\r\n        \r\n        GUILayout.BeginHorizontal();\r\n        if (GUILayout.Button(\"获取类型信息\"))\r\n        {\r\n            Type type = GetTypeInfo(targetTypeName);\r\n            if (type != null)\r\n            {\r\n                Debug.Log($\"类型信息: {type.FullName}\");\r\n            }\r\n        }\r\n        if (GUILayout.Button(\"获取方法信息\"))\r\n        {\r\n            MethodInfo method = GetMethodInfo(targetTypeName, targetMethodName);\r\n            if (method != null)\r\n            {\r\n                Debug.Log($\"方法信息: {method.Name}\");\r\n            }\r\n        }\r\n        GUILayout.EndHorizontal();\r\n        \r\n        if (GUILayout.Button(\"调用方法\"))\r\n        {\r\n            InvokeMethod(targetTypeName, targetMethodName);\r\n        }\r\n        \r\n        if (GUILayout.Button(\"获取类型成员\"))\r\n        {\r\n            List<MemberInfo> members = GetTypeMembers(targetTypeName);\r\n            Debug.Log($\"类型 {targetTypeName} 有 {members.Count} 个成员\");\r\n        }\r\n        \r\n        if (GUILayout.Button(\"获取类型属性\"))\r\n        {\r\n            List<Attribute> attributes = GetTypeAttributes(targetTypeName);\r\n            Debug.Log($\"类型 {targetTypeName} 有 {attributes.Count} 个属性\");\r\n        }\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        // 设置\r\n        GUILayout.Label(\"设置:\", EditorStyles.boldLabel);\r\n        \r\n        showPrivateMembers = GUILayout.Toggle(showPrivateMembers, \"显示私有成员\");\r\n        showStaticMembers = GUILayout.Toggle(showStaticMembers, \"显示静态成员\");\r\n        processCustomAttributes = GUILayout.Toggle(processCustomAttributes, \"处理自定义属性\");\r\n        processBuiltinAttributes = GUILayout.Toggle(processBuiltinAttributes, \"处理内置属性\");\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        if (GUILayout.Button(\"获取脚本系统信息\"))\r\n        {\r\n            GetScriptingSystemInfo();\r\n        }\r\n        \r\n        if (GUILayout.Button(\"重置设置\"))\r\n        {\r\n            ResetScriptingSystemSettings();\r\n        }\r\n        \r\n        GUILayout.EndArea();\r\n    }\r\n    \r\n    private void OnDestroy()\r\n    {\r\n        // 移除事件监听器\r\n        AppDomain.CurrentDomain.AssemblyLoad -= OnAssemblyLoaded;\r\n    }\r\n} "
        }
    ]
}