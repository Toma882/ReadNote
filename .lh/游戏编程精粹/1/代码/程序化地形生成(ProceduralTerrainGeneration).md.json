{
    "sourceFile": "游戏编程精粹/1/代码/程序化地形生成(ProceduralTerrainGeneration).md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1765002977518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1765002977518,
            "name": "Commit-0",
            "content": "# 程序化地形生成（Procedural Terrain Generation）- C#实现\r\n\r\n## 核心概念\r\n\r\n- **定义**：使用算法自动生成地形高度图，实现程序化地形创建\r\n- **核心思想**：通过数学算法模拟自然地形形成过程，生成真实感的地形\r\n- **应用场景**：开放世界游戏、程序化生成游戏、地形编辑器\r\n- **Unity应用**：配合Unity Terrain系统使用，生成高度图数据\r\n\r\n## 基础数据结构\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\n/// <summary>\r\n/// 地形生成器基类：提供统一接口\r\n/// </summary>\r\npublic abstract class TerrainGenerator\r\n{\r\n    protected int width;      // 地形宽度（顶点数）\r\n    protected int height;     // 地形高度（顶点数）\r\n    protected float[,] heightMap;  // 高度图数据\r\n    \r\n    public TerrainGenerator(int width, int height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.heightMap = new float[width, height];\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 生成高度图（子类实现具体算法）\r\n    /// </summary>\r\n    public abstract float[,] Generate();\r\n    \r\n    /// <summary>\r\n    /// 将高度图应用到Unity Terrain\r\n    /// </summary>\r\n    public void ApplyToTerrain(Terrain terrain, float maxHeight = 100f)\r\n    {\r\n        TerrainData terrainData = terrain.terrainData;\r\n        terrainData.heightmapResolution = width;\r\n        terrainData.size = new Vector3(width, maxHeight, height);\r\n        \r\n        // 归一化高度图到0-1范围\r\n        float[,] normalizedHeights = NormalizeHeightMap(heightMap);\r\n        terrainData.SetHeights(0, 0, normalizedHeights);\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 归一化高度图到0-1范围\r\n    /// </summary>\r\n    protected float[,] NormalizeHeightMap(float[,] heights)\r\n    {\r\n        float min = float.MaxValue;\r\n        float max = float.MinValue;\r\n        \r\n        // 找到最小值和最大值\r\n        for (int x = 0; x < width; x++)\r\n        {\r\n            for (int z = 0; z < height; z++)\r\n            {\r\n                if (heights[x, z] < min) min = heights[x, z];\r\n                if (heights[x, z] > max) max = heights[x, z];\r\n            }\r\n        }\r\n        \r\n        // 归一化\r\n        float[,] normalized = new float[width, height];\r\n        float range = max - min;\r\n        if (range > 0)\r\n        {\r\n            for (int x = 0; x < width; x++)\r\n            {\r\n                for (int z = 0; z < height; z++)\r\n                {\r\n                    normalized[x, z] = (heights[x, z] - min) / range;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return normalized;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4.17 断层构造算法（Fault Formation）\r\n\r\n### 核心原理\r\n\r\n- **算法思想**：通过随机生成断层线，抬升/降低断层一侧的地形高度，模拟地质断层形成过程\r\n- **特点**：生成的地形具有明显的断层特征，适合生成山脉、峡谷等地形\r\n- **优点**：算法简单，计算快速\r\n- **缺点**：生成的地形可能过于规则，缺乏细节\r\n\r\n### 实现代码\r\n\r\n```csharp\r\n/// <summary>\r\n/// 断层构造地形生成器\r\n/// </summary>\r\npublic class FaultFormationGenerator : TerrainGenerator\r\n{\r\n    private int faultCount;        // 断层数量\r\n    private float faultHeight;     // 断层高度变化\r\n    private System.Random random;\r\n    \r\n    public FaultFormationGenerator(int width, int height, int faultCount = 100, float faultHeight = 5f) \r\n        : base(width, height)\r\n    {\r\n        this.faultCount = faultCount;\r\n        this.faultHeight = faultHeight;\r\n        this.random = new System.Random();\r\n    }\r\n    \r\n    public override float[,] Generate()\r\n    {\r\n        // 初始化高度图为0\r\n        for (int x = 0; x < width; x++)\r\n        {\r\n            for (int z = 0; z < height; z++)\r\n            {\r\n                heightMap[x, z] = 0f;\r\n            }\r\n        }\r\n        \r\n        // 生成多个断层\r\n        for (int i = 0; i < faultCount; i++)\r\n        {\r\n            GenerateFault();\r\n        }\r\n        \r\n        return heightMap;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 生成单个断层\r\n    /// </summary>\r\n    private void GenerateFault()\r\n    {\r\n        // 随机生成断层线（使用两点定义直线）\r\n        Vector2 point1 = new Vector2(\r\n            random.Next(0, width),\r\n            random.Next(0, height)\r\n        );\r\n        Vector2 point2 = new Vector2(\r\n            random.Next(0, width),\r\n            random.Next(0, height)\r\n        );\r\n        \r\n        // 计算断层线的方向向量\r\n        Vector2 direction = (point2 - point1).normalized;\r\n        Vector2 normal = new Vector2(-direction.y, direction.x);  // 法向量（垂直方向）\r\n        \r\n        // 随机决定抬升方向（正或负）\r\n        float heightChange = (random.Next(0, 2) == 0 ? 1f : -1f) * faultHeight;\r\n        \r\n        // 对每个点判断在断层的哪一侧，并调整高度\r\n        for (int x = 0; x < width; x++)\r\n        {\r\n            for (int z = 0; z < height; z++)\r\n            {\r\n                Vector2 point = new Vector2(x, z);\r\n                Vector2 toPoint = point - point1;\r\n                \r\n                // 使用点积判断点在断层线的哪一侧\r\n                float dot = Vector2.Dot(toPoint, normal);\r\n                \r\n                // 如果点在法向量指向的一侧，抬升高度\r\n                if (dot > 0)\r\n                {\r\n                    heightMap[x, z] += heightChange;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4.18 中点置换算法（Midpoint Displacement / Diamond-Square）\r\n\r\n### 核心原理\r\n\r\n- **算法思想**：递归地将地形分割成更小的区域，在每个区域的中点插入新的高度值，通过插值和随机扰动生成分形地形\r\n- **Diamond-Square算法**：最经典的分形地形生成算法\r\n  - **Diamond步骤**：在正方形中心（菱形）插入高度值\r\n  - **Square步骤**：在正方形边缘中点插入高度值\r\n- **特点**：生成的地形具有分形特征，细节丰富，自然真实\r\n- **优点**：生成的地形自然、细节丰富\r\n- **缺点**：计算复杂度较高，需要递归处理\r\n\r\n### 实现代码\r\n\r\n```csharp\r\n/// <summary>\r\n/// 中点置换（Diamond-Square）地形生成器\r\n/// </summary>\r\npublic class MidpointDisplacementGenerator : TerrainGenerator\r\n{\r\n    private float roughness;      // 粗糙度（控制随机扰动幅度）\r\n    private float initialHeight;  // 初始高度\r\n    private System.Random random;\r\n    \r\n    public MidpointDisplacementGenerator(int width, int height, float roughness = 0.5f, float initialHeight = 0f) \r\n        : base(width, height)\r\n    {\r\n        this.roughness = roughness;\r\n        this.initialHeight = initialHeight;\r\n        this.random = new System.Random();\r\n        \r\n        // 宽度和高度必须是2的幂次+1（如33, 65, 129）\r\n        if (!IsPowerOfTwoPlusOne(width) || !IsPowerOfTwoPlusOne(height))\r\n        {\r\n            Debug.LogWarning(\"Diamond-Square算法要求尺寸为2^n+1，将自动调整\");\r\n        }\r\n    }\r\n    \r\n    public override float[,] Generate()\r\n    {\r\n        // 初始化四个角的高度\r\n        heightMap[0, 0] = initialHeight + RandomOffset();\r\n        heightMap[0, height - 1] = initialHeight + RandomOffset();\r\n        heightMap[width - 1, 0] = initialHeight + RandomOffset();\r\n        heightMap[width - 1, height - 1] = initialHeight + RandomOffset();\r\n        \r\n        // 递归生成\r\n        int size = Mathf.Min(width, height) - 1;\r\n        float currentRoughness = roughness;\r\n        \r\n        while (size > 1)\r\n        {\r\n            DiamondSquare(size, currentRoughness);\r\n            size /= 2;\r\n            currentRoughness *= 0.5f;  // 每次迭代减少粗糙度\r\n        }\r\n        \r\n        return heightMap;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// Diamond-Square算法的核心步骤\r\n    /// </summary>\r\n    private void DiamondSquare(int stepSize, float roughness)\r\n    {\r\n        int halfStep = stepSize / 2;\r\n        \r\n        // Diamond步骤：在正方形中心插入高度值\r\n        for (int x = halfStep; x < width; x += stepSize)\r\n        {\r\n            for (int z = halfStep; z < height; z += stepSize)\r\n            {\r\n                DiamondStep(x, z, halfStep, roughness);\r\n            }\r\n        }\r\n        \r\n        // Square步骤：在正方形边缘中点插入高度值\r\n        for (int x = 0; x < width; x += halfStep)\r\n        {\r\n            for (int z = (x + halfStep) % stepSize; z < height; z += stepSize)\r\n            {\r\n                SquareStep(x, z, halfStep, roughness);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// Diamond步骤：计算正方形中心点的高度\r\n    /// </summary>\r\n    private void DiamondStep(int x, int z, int halfStep, float roughness)\r\n    {\r\n        float average = (\r\n            GetHeight(x - halfStep, z - halfStep) +\r\n            GetHeight(x + halfStep, z - halfStep) +\r\n            GetHeight(x - halfStep, z + halfStep) +\r\n            GetHeight(x + halfStep, z + halfStep)\r\n        ) / 4f;\r\n        \r\n        heightMap[x, z] = average + RandomOffset() * roughness;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// Square步骤：计算正方形边缘中点的高度\r\n    /// </summary>\r\n    private void SquareStep(int x, int z, int halfStep, float roughness)\r\n    {\r\n        float sum = 0f;\r\n        int count = 0;\r\n        \r\n        // 计算四个相邻点的平均值\r\n        if (x - halfStep >= 0)\r\n        {\r\n            sum += GetHeight(x - halfStep, z);\r\n            count++;\r\n        }\r\n        if (x + halfStep < width)\r\n        {\r\n            sum += GetHeight(x + halfStep, z);\r\n            count++;\r\n        }\r\n        if (z - halfStep >= 0)\r\n        {\r\n            sum += GetHeight(x, z - halfStep);\r\n            count++;\r\n        }\r\n        if (z + halfStep < height)\r\n        {\r\n            sum += GetHeight(x, z + halfStep);\r\n            count++;\r\n        }\r\n        \r\n        if (count > 0)\r\n        {\r\n            heightMap[x, z] = (sum / count) + RandomOffset() * roughness;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 安全获取高度值（处理边界）\r\n    /// </summary>\r\n    private float GetHeight(int x, int z)\r\n    {\r\n        if (x < 0 || x >= width || z < 0 || z >= height)\r\n            return 0f;\r\n        return heightMap[x, z];\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 生成随机偏移值\r\n    /// </summary>\r\n    private float RandomOffset()\r\n    {\r\n        return (float)(random.NextDouble() * 2.0 - 1.0);  // -1 到 1\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 检查是否为2的幂次+1\r\n    /// </summary>\r\n    private bool IsPowerOfTwoPlusOne(int n)\r\n    {\r\n        return (n - 1) > 0 && ((n - 1) & (n - 2)) == 0;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4.19 粒子沉积算法（Particle Deposition）\r\n\r\n### 核心原理\r\n\r\n- **算法思想**：模拟自然沉积过程，通过粒子随机落下并堆积来生成地形\r\n- **特点**：生成的地形更自然，具有真实的沉积特征，适合生成沙丘、火山等地形\r\n- **优点**：生成的地形自然真实，适合特定地形类型\r\n- **缺点**：计算复杂度较高，需要多次迭代\r\n\r\n### 实现代码\r\n\r\n```csharp\r\n/// <summary>\r\n/// 粒子沉积地形生成器\r\n/// </summary>\r\npublic class ParticleDepositionGenerator : TerrainGenerator\r\n{\r\n    private int particleCount;     // 粒子数量\r\n    private float particleSize;    // 粒子大小（影响范围）\r\n    private float stabilityThreshold;  // 稳定性阈值\r\n    private System.Random random;\r\n    \r\n    public ParticleDepositionGenerator(int width, int height, int particleCount = 10000, float particleSize = 2f, float stabilityThreshold = 0.5f) \r\n        : base(width, height)\r\n    {\r\n        this.particleCount = particleCount;\r\n        this.particleSize = particleSize;\r\n        this.stabilityThreshold = stabilityThreshold;\r\n        this.random = new System.Random();\r\n    }\r\n    \r\n    public override float[,] Generate()\r\n    {\r\n        // 初始化高度图为0\r\n        for (int x = 0; x < width; x++)\r\n        {\r\n            for (int z = 0; z < height; z++)\r\n            {\r\n                heightMap[x, z] = 0f;\r\n            }\r\n        }\r\n        \r\n        // 沉积粒子\r\n        for (int i = 0; i < particleCount; i++)\r\n        {\r\n            DepositParticle();\r\n        }\r\n        \r\n        return heightMap;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 沉积单个粒子\r\n    /// </summary>\r\n    private void DepositParticle()\r\n    {\r\n        // 随机选择起始位置（从顶部）\r\n        int x = random.Next(0, width);\r\n        int z = random.Next(0, height);\r\n        \r\n        // 粒子下落，直到找到稳定位置\r\n        while (true)\r\n        {\r\n            // 检查当前位置是否稳定\r\n            if (IsStable(x, z))\r\n            {\r\n                // 沉积粒子（增加高度）\r\n                DepositAt(x, z);\r\n                break;\r\n            }\r\n            \r\n            // 如果不稳定，粒子向下移动（选择最低的邻居）\r\n            Vector2Int nextPos = FindLowestNeighbor(x, z);\r\n            if (nextPos.x == x && nextPos.y == z)\r\n            {\r\n                // 无法继续移动，直接沉积\r\n                DepositAt(x, z);\r\n                break;\r\n            }\r\n            \r\n            x = nextPos.x;\r\n            z = nextPos.y;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 检查位置是否稳定（高度差小于阈值）\r\n    /// </summary>\r\n    private bool IsStable(int x, int z)\r\n    {\r\n        float currentHeight = GetHeight(x, z);\r\n        \r\n        // 检查所有邻居\r\n        for (int dx = -1; dx <= 1; dx++)\r\n        {\r\n            for (int dz = -1; dz <= 1; dz++)\r\n            {\r\n                if (dx == 0 && dz == 0) continue;\r\n                \r\n                int nx = x + dx;\r\n                int nz = z + dz;\r\n                \r\n                if (IsValidPosition(nx, nz))\r\n                {\r\n                    float neighborHeight = GetHeight(nx, nz);\r\n                    float heightDiff = currentHeight - neighborHeight;\r\n                    \r\n                    // 如果高度差大于阈值，不稳定\r\n                    if (heightDiff > stabilityThreshold)\r\n                    {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 找到最低的邻居位置\r\n    /// </summary>\r\n    private Vector2Int FindLowestNeighbor(int x, int z)\r\n    {\r\n        float minHeight = GetHeight(x, z);\r\n        Vector2Int lowestPos = new Vector2Int(x, z);\r\n        \r\n        // 检查所有邻居\r\n        for (int dx = -1; dx <= 1; dx++)\r\n        {\r\n            for (int dz = -1; dz <= 1; dz++)\r\n            {\r\n                if (dx == 0 && dz == 0) continue;\r\n                \r\n                int nx = x + dx;\r\n                int nz = z + dz;\r\n                \r\n                if (IsValidPosition(nx, nz))\r\n                {\r\n                    float neighborHeight = GetHeight(nx, nz);\r\n                    if (neighborHeight < minHeight)\r\n                    {\r\n                        minHeight = neighborHeight;\r\n                        lowestPos = new Vector2Int(nx, nz);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return lowestPos;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 在指定位置沉积粒子\r\n    /// </summary>\r\n    private void DepositAt(int x, int z)\r\n    {\r\n        // 在粒子大小范围内增加高度\r\n        int radius = Mathf.CeilToInt(particleSize);\r\n        for (int dx = -radius; dx <= radius; dx++)\r\n        {\r\n            for (int dz = -radius; dz <= radius; dz++)\r\n            {\r\n                int nx = x + dx;\r\n                int nz = z + dz;\r\n                \r\n                if (IsValidPosition(nx, nz))\r\n                {\r\n                    float distance = Mathf.Sqrt(dx * dx + dz * dz);\r\n                    if (distance <= particleSize)\r\n                    {\r\n                        // 使用距离衰减函数，中心影响最大\r\n                        float influence = 1f - (distance / particleSize);\r\n                        heightMap[nx, nz] += influence * 0.1f;  // 沉积高度\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 安全获取高度值\r\n    /// </summary>\r\n    private float GetHeight(int x, int z)\r\n    {\r\n        if (x < 0 || x >= width || z < 0 || z >= height)\r\n            return float.MaxValue;  // 边界外视为无限高\r\n        return heightMap[x, z];\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 检查位置是否有效\r\n    /// </summary>\r\n    private bool IsValidPosition(int x, int z)\r\n    {\r\n        return x >= 0 && x < width && z >= 0 && z < height;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 4.16 实时真实地形生成（综合应用）\r\n\r\n### 核心概念\r\n\r\n- **定义**：结合多种算法和技术，实现完整的程序化地形生成系统\r\n- **主要内容**：\r\n  - 基础地形生成（使用上述算法）\r\n  - 风景设计（植被、水体、道路等）\r\n  - 建筑物生成\r\n  - 命名算法\r\n\r\n### 综合应用示例\r\n\r\n```csharp\r\n/// <summary>\r\n/// 综合地形生成系统\r\n/// </summary>\r\npublic class ProceduralTerrainSystem : MonoBehaviour\r\n{\r\n    public Terrain terrain;\r\n    public int terrainWidth = 513;\r\n    public int terrainHeight = 513;\r\n    public float maxHeight = 100f;\r\n    \r\n    [Header(\"地形生成算法\")]\r\n    public TerrainGenerationMethod method = TerrainGenerationMethod.MidpointDisplacement;\r\n    \r\n    [Header(\"断层构造参数\")]\r\n    public int faultCount = 100;\r\n    public float faultHeight = 5f;\r\n    \r\n    [Header(\"中点置换参数\")]\r\n    public float roughness = 0.5f;\r\n    \r\n    [Header(\"粒子沉积参数\")]\r\n    public int particleCount = 10000;\r\n    public float particleSize = 2f;\r\n    \r\n    public enum TerrainGenerationMethod\r\n    {\r\n        FaultFormation,\r\n        MidpointDisplacement,\r\n        ParticleDeposition\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 生成地形\r\n    /// </summary>\r\n    public void GenerateTerrain()\r\n    {\r\n        TerrainGenerator generator = null;\r\n        \r\n        // 根据选择的方法创建生成器\r\n        switch (method)\r\n        {\r\n            case TerrainGenerationMethod.FaultFormation:\r\n                generator = new FaultFormationGenerator(terrainWidth, terrainHeight, faultCount, faultHeight);\r\n                break;\r\n            case TerrainGenerationMethod.MidpointDisplacement:\r\n                generator = new MidpointDisplacementGenerator(terrainWidth, terrainHeight, roughness);\r\n                break;\r\n            case TerrainGenerationMethod.ParticleDeposition:\r\n                generator = new ParticleDepositionGenerator(terrainWidth, terrainHeight, particleCount, particleSize);\r\n                break;\r\n        }\r\n        \r\n        if (generator != null)\r\n        {\r\n            // 生成高度图\r\n            float[,] heightMap = generator.Generate();\r\n            \r\n            // 应用到Unity Terrain\r\n            generator.ApplyToTerrain(terrain, maxHeight);\r\n            \r\n            Debug.Log(\"地形生成完成！\");\r\n        }\r\n    }\r\n    \r\n    // Unity Editor中调用\r\n    [ContextMenu(\"生成地形\")]\r\n    private void GenerateTerrainContextMenu()\r\n    {\r\n        GenerateTerrain();\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 算法对比\r\n\r\n| 算法 | 优点 | 缺点 | 适用场景 |\r\n|------|------|------|---------|\r\n| **断层构造** | 简单快速，生成明显的地形特征 | 地形可能过于规则 | 山脉、峡谷 |\r\n| **中点置换** | 自然真实，细节丰富，经典算法 | 计算复杂度较高 | 通用地形生成 |\r\n| **粒子沉积** | 自然真实，具有沉积特征 | 计算复杂度高 | 沙丘、火山 |\r\n\r\n---\r\n\r\n## Unity应用建议\r\n\r\n1. **使用Unity Terrain系统**：\r\n   - 使用`TerrainData.SetHeights()`应用高度图\r\n   - 配合`TerrainData.alphamapTextures`添加纹理\r\n   - 使用`TreeInstance`和`DetailPrototype`添加植被\r\n\r\n2. **性能优化**：\r\n   - 使用协程分帧生成，避免卡顿\r\n   - 使用Job System并行计算\r\n   - 缓存高度图数据，避免重复计算\r\n\r\n3. **扩展功能**：\r\n   - 添加噪声函数（Perlin Noise）增加细节\r\n   - 使用多层算法组合生成复杂地形\r\n   - 实现动态加载/卸载系统\r\n\r\n---\r\n\r\n## 参考文献\r\n\r\n- 《游戏编程精粹1》- 4.16 实时真实地形生成\r\n- 《游戏编程精粹1》- 4.17 分形地形生成 - 断层构造\r\n- 《游戏编程精粹1》- 4.18 分形地形生成 - 中点置换\r\n- 《游戏编程精粹1》- 4.19 分形地形生成 - 粒子沉积\r\n\r\n"
        }
    ]
}