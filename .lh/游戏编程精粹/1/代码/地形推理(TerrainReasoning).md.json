{
    "sourceFile": "游戏编程精粹/1/代码/地形推理(TerrainReasoning).md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764867947124,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764867947124,
            "name": "Commit-0",
            "content": "# 地形推理 - C#实现\r\n\r\n## 核心概念\r\n\r\n- **定义**：中继点（Waypoint）、战术分析等地形推理技术\r\n- **核心思想**：分析地形的战术价值，为AI提供决策依据\r\n- **应用场景**：3D游戏中的战术位置选择、伏击点识别、防御点评估\r\n\r\n## 中继点系统\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// 中继点（Waypoint）：路径上的关键点\r\n/// </summary>\r\npublic class Waypoint\r\n{\r\n    public Vector3 position;        // 位置\r\n    public float tacticalValue;     // 战术价值\r\n    public WaypointType type;        // 类型（伏击点、防御点、观察点等）\r\n    public List<Waypoint> connections;  // 连接的中继点\r\n    \r\n    public Waypoint(Vector3 pos)\r\n    {\r\n        position = pos;\r\n        tacticalValue = 0f;\r\n        type = WaypointType.Normal;\r\n        connections = new List<Waypoint>();\r\n    }\r\n}\r\n\r\npublic enum WaypointType\r\n{\r\n    Normal,      // 普通点\r\n    Ambush,      // 伏击点\r\n    Defense,     // 防御点\r\n    Observation, // 观察点\r\n    Cover        // 掩体点\r\n}\r\n```\r\n\r\n## 战术分析\r\n\r\n```csharp\r\n/// <summary>\r\n/// 战术分析器：评估地形的战术价值\r\n/// </summary>\r\npublic class TacticalAnalyzer\r\n{\r\n    /// <summary>\r\n    /// 计算中继点的战术价值\r\n    /// </summary>\r\n    public float CalculateTacticalValue(Waypoint waypoint, List<Vector3> enemyPositions)\r\n    {\r\n        float value = 0f;\r\n        \r\n        // 1. 视野价值（能看到多少敌人）\r\n        int visibleEnemies = CountVisibleEnemies(waypoint.position, enemyPositions);\r\n        value += visibleEnemies * 10f;\r\n        \r\n        // 2. 掩体价值（有多少掩体保护）\r\n        float coverValue = CalculateCoverValue(waypoint.position);\r\n        value += coverValue * 5f;\r\n        \r\n        // 3. 高度优势（高度越高，价值越高）\r\n        float heightAdvantage = CalculateHeightAdvantage(waypoint.position);\r\n        value += heightAdvantage * 3f;\r\n        \r\n        // 4. 可达性（是否容易到达）\r\n        float accessibility = CalculateAccessibility(waypoint.position);\r\n        value += accessibility * 2f;\r\n        \r\n        return value;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 识别伏击点\r\n    /// </summary>\r\n    public bool IsAmbushPoint(Vector3 position, List<Vector3> enemyPositions)\r\n    {\r\n        // 伏击点特征：\r\n        // 1. 有掩体保护\r\n        // 2. 能看到敌人\r\n        // 3. 敌人不容易发现\r\n        // 4. 容易撤退\r\n        \r\n        bool hasCover = HasCover(position);\r\n        bool canSeeEnemy = CanSeeAnyEnemy(position, enemyPositions);\r\n        bool hiddenFromEnemy = IsHiddenFromEnemy(position, enemyPositions);\r\n        bool easyRetreat = HasRetreatPath(position);\r\n        \r\n        return hasCover && canSeeEnemy && hiddenFromEnemy && easyRetreat;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 识别防御点\r\n    /// </summary>\r\n    public bool IsDefensePoint(Vector3 position)\r\n    {\r\n        // 防御点特征：\r\n        // 1. 有良好的掩体\r\n        // 2. 视野开阔\r\n        // 3. 不易被包围\r\n        // 4. 有撤退路径\r\n        \r\n        bool hasGoodCover = HasGoodCover(position);\r\n        bool hasWideView = HasWideView(position);\r\n        bool notSurrounded = !IsSurrounded(position);\r\n        bool hasRetreatPath = HasRetreatPath(position);\r\n        \r\n        return hasGoodCover && hasWideView && notSurrounded && hasRetreatPath;\r\n    }\r\n}\r\n```\r\n\r\n## 从经验中学习\r\n\r\n```csharp\r\n/// <summary>\r\n/// 经验学习系统：从战斗经验中学习地形的战术价值\r\n/// </summary>\r\npublic class ExperienceLearning\r\n{\r\n    private Dictionary<Vector3, float> learnedValues;  // 学习到的战术价值\r\n    \r\n    public ExperienceLearning()\r\n    {\r\n        learnedValues = new Dictionary<Vector3, float>();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 记录战斗经验\r\n    /// </summary>\r\n    public void RecordExperience(Vector3 position, bool success, float outcome)\r\n    {\r\n        if (!learnedValues.ContainsKey(position))\r\n        {\r\n            learnedValues[position] = 0.5f;  // 初始值\r\n        }\r\n        \r\n        // 根据战斗结果更新价值\r\n        float learningRate = 0.1f;\r\n        if (success)\r\n        {\r\n            learnedValues[position] += learningRate * outcome;\r\n        }\r\n        else\r\n        {\r\n            learnedValues[position] -= learningRate * (1f - outcome);\r\n        }\r\n        \r\n        // 限制在[0, 1]范围内\r\n        learnedValues[position] = Mathf.Clamp01(learnedValues[position]);\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取学习到的战术价值\r\n    /// </summary>\r\n    public float GetLearnedValue(Vector3 position)\r\n    {\r\n        if (learnedValues.ContainsKey(position))\r\n        {\r\n            return learnedValues[position];\r\n        }\r\n        return 0.5f;  // 默认值\r\n    }\r\n}\r\n```\r\n\r\n## Unity应用\r\n\r\n```csharp\r\n/// <summary>\r\n/// Unity中使用地形推理\r\n/// </summary>\r\npublic class TerrainReasoningUnity : MonoBehaviour\r\n{\r\n    private TacticalAnalyzer analyzer;\r\n    private ExperienceLearning learning;\r\n    private List<Waypoint> waypoints;\r\n    \r\n    void Start()\r\n    {\r\n        analyzer = new TacticalAnalyzer();\r\n        learning = new ExperienceLearning();\r\n        waypoints = new List<Waypoint>();\r\n        \r\n        // 生成中继点网络\r\n        GenerateWaypointNetwork();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 找到最佳战术位置\r\n    /// </summary>\r\n    public Vector3 FindBestTacticalPosition(List<Vector3> enemyPositions)\r\n    {\r\n        Waypoint bestWaypoint = null;\r\n        float bestValue = float.MinValue;\r\n        \r\n        foreach (var waypoint in waypoints)\r\n        {\r\n            // 计算战术价值（结合分析和经验）\r\n            float analyticalValue = analyzer.CalculateTacticalValue(waypoint, enemyPositions);\r\n            float learnedValue = learning.GetLearnedValue(waypoint.position);\r\n            float totalValue = analyticalValue * 0.7f + learnedValue * 100f * 0.3f;\r\n            \r\n            if (totalValue > bestValue)\r\n            {\r\n                bestValue = totalValue;\r\n                bestWaypoint = waypoint;\r\n            }\r\n        }\r\n        \r\n        return bestWaypoint != null ? bestWaypoint.position : Vector3.zero;\r\n    }\r\n}\r\n```\r\n\r\n## 与Unity NavMesh的关系\r\n\r\n- Unity NavMesh提供基础导航功能\r\n- 地形推理在此基础上添加战术分析\r\n- 可以结合使用：NavMesh用于路径查找，地形推理用于位置选择\r\n\r\n"
        }
    ]
}