{
    "sourceFile": "游戏编程精粹/1/代码/反向弹道计算(InverseBallistics).md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1765005744507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1765005744506,
            "name": "Commit-0",
            "content": "# 反向弹道计算（Inverse Ballistics）- C#实现\r\n\r\n## 核心概念\r\n\r\n- **定义**：计算发射角度，使弹道能够命中指定目标位置\r\n- **核心思想**：基于物理运动学公式，考虑重力、初速度、目标位置，通过数学计算求解发射角度\r\n- **应用场景**：弹道类游戏、塔防游戏、射击游戏的AI瞄准系统、投掷物轨迹计算\r\n- **Unity应用**：Unity没有直接提供，需要自己实现或使用第三方插件\r\n\r\n---\r\n\r\n## 核心原理\r\n\r\n### 物理公式\r\n\r\n**抛体运动方程**：\r\n```\r\nx(t) = v₀ * cos(θ) * t\r\ny(t) = v₀ * sin(θ) * t - 0.5 * g * t²\r\n```\r\n\r\n其中：\r\n- `v₀`：初速度\r\n- `θ`：发射角度\r\n- `t`：时间\r\n- `g`：重力加速度\r\n\r\n### 求解方法\r\n\r\n给定目标位置 `(x, y)` 和初速度 `v₀`，求解发射角度 `θ`：\r\n\r\n1. **从x方向方程**：`t = x / (v₀ * cos(θ))`\r\n2. **代入y方向方程**：`y = x * tan(θ) - (g * x²) / (2 * v₀² * cos²(θ))`\r\n3. **使用三角恒等式**：`1 + tan²(θ) = 1 / cos²(θ)`\r\n4. **得到二次方程**：`tan²(θ) - (2 * v₀² / (g * x)) * tan(θ) + (2 * v₀² * y / (g * x²) + 1) = 0`\r\n\r\n### 解的情况\r\n\r\n- **两个解**：高抛（高角度）和低抛（低角度）\r\n- **一个解**：目标刚好在最大射程\r\n- **无解**：目标超出射程\r\n\r\n---\r\n\r\n## 实现代码\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// 反向弹道计算结果\r\n/// </summary>\r\npublic struct BallisticSolution\r\n{\r\n    public bool isValid;           // 是否有解\r\n    public float angle1;           // 第一个角度（低抛）\r\n    public float angle2;           // 第二个角度（高抛）\r\n    public float flightTime1;      // 第一个角度的飞行时间\r\n    public float flightTime2;      // 第二个角度的飞行时间\r\n    public Vector3 velocity1;       // 第一个角度的初速度\r\n    public Vector3 velocity2;       // 第二个角度的初速度\r\n    \r\n    public BallisticSolution(bool valid)\r\n    {\r\n        isValid = valid;\r\n        angle1 = 0f;\r\n        angle2 = 0f;\r\n        flightTime1 = 0f;\r\n        flightTime2 = 0f;\r\n        velocity1 = Vector3.zero;\r\n        velocity2 = Vector3.zero;\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 反向弹道计算工具类\r\n/// </summary>\r\npublic static class InverseBallistics\r\n{\r\n    /// <summary>\r\n    /// 计算2D反向弹道（在XZ平面上，Y为高度）\r\n    /// </summary>\r\n    /// <param name=\"startPos\">起始位置</param>\r\n    /// <param name=\"targetPos\">目标位置</param>\r\n    /// <param name=\"initialSpeed\">初速度</param>\r\n    /// <param name=\"gravity\">重力加速度（通常为Physics.gravity.y的绝对值）</param>\r\n    /// <returns>弹道解</returns>\r\n    public static BallisticSolution Calculate2D(Vector3 startPos, Vector3 targetPos, float initialSpeed, float gravity = 9.81f)\r\n    {\r\n        BallisticSolution solution = new BallisticSolution(false);\r\n        \r\n        // 计算相对位置\r\n        Vector3 displacement = targetPos - startPos;\r\n        float x = displacement.x;\r\n        float y = displacement.y;\r\n        float z = displacement.z;\r\n        \r\n        // 计算水平距离（在XZ平面上）\r\n        float horizontalDistance = Mathf.Sqrt(x * x + z * z);\r\n        \r\n        // 如果水平距离太小，无法计算\r\n        if (horizontalDistance < 0.01f)\r\n        {\r\n            return solution;\r\n        }\r\n        \r\n        // 计算角度（使用2D公式）\r\n        float angle1, angle2;\r\n        bool hasSolution = CalculateAngle2D(horizontalDistance, y, initialSpeed, gravity, out angle1, out angle2);\r\n        \r\n        if (!hasSolution)\r\n        {\r\n            return solution;\r\n        }\r\n        \r\n        solution.isValid = true;\r\n        solution.angle1 = angle1;\r\n        solution.angle2 = angle2;\r\n        \r\n        // 计算飞行时间\r\n        solution.flightTime1 = CalculateFlightTime(horizontalDistance, angle1, initialSpeed);\r\n        solution.flightTime2 = CalculateFlightTime(horizontalDistance, angle2, initialSpeed);\r\n        \r\n        // 计算初速度向量\r\n        Vector3 horizontalDirection = new Vector3(x, 0, z).normalized;\r\n        solution.velocity1 = CalculateVelocity(horizontalDirection, angle1, initialSpeed);\r\n        solution.velocity2 = CalculateVelocity(horizontalDirection, angle2, initialSpeed);\r\n        \r\n        return solution;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 计算发射角度（2D）\r\n    /// </summary>\r\n    private static bool CalculateAngle2D(float horizontalDistance, float height, float initialSpeed, float gravity, \r\n        out float angle1, out float angle2)\r\n    {\r\n        angle1 = 0f;\r\n        angle2 = 0f;\r\n        \r\n        // 计算二次方程的系数\r\n        float a = gravity * horizontalDistance * horizontalDistance / (2 * initialSpeed * initialSpeed);\r\n        float b = -horizontalDistance;\r\n        float c = a - height;\r\n        \r\n        // 判别式\r\n        float discriminant = b * b - 4 * a * c;\r\n        \r\n        // 如果判别式小于0，无解\r\n        if (discriminant < 0)\r\n        {\r\n            return false;\r\n        }\r\n        \r\n        // 计算两个解\r\n        float sqrtDiscriminant = Mathf.Sqrt(discriminant);\r\n        float tan1 = (-b - sqrtDiscriminant) / (2 * a);\r\n        float tan2 = (-b + sqrtDiscriminant) / (2 * a);\r\n        \r\n        angle1 = Mathf.Atan(tan1) * Mathf.Rad2Deg;\r\n        angle2 = Mathf.Atan(tan2) * Mathf.Rad2Deg;\r\n        \r\n        // 确保角度在合理范围内（0-90度）\r\n        if (angle1 < 0 || angle1 > 90)\r\n        {\r\n            angle1 = -1;\r\n        }\r\n        if (angle2 < 0 || angle2 > 90)\r\n        {\r\n            angle2 = -1;\r\n        }\r\n        \r\n        return angle1 >= 0 || angle2 >= 0;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 计算飞行时间\r\n    /// </summary>\r\n    private static float CalculateFlightTime(float horizontalDistance, float angle, float initialSpeed)\r\n    {\r\n        if (angle < 0)\r\n        {\r\n            return 0f;\r\n        }\r\n        \r\n        float angleRad = angle * Mathf.Deg2Rad;\r\n        float horizontalSpeed = initialSpeed * Mathf.Cos(angleRad);\r\n        \r\n        if (horizontalSpeed < 0.001f)\r\n        {\r\n            return 0f;\r\n        }\r\n        \r\n        return horizontalDistance / horizontalSpeed;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 计算初速度向量\r\n    /// </summary>\r\n    private static Vector3 CalculateVelocity(Vector3 horizontalDirection, float angle, float initialSpeed)\r\n    {\r\n        float angleRad = angle * Mathf.Deg2Rad;\r\n        float horizontalSpeed = initialSpeed * Mathf.Cos(angleRad);\r\n        float verticalSpeed = initialSpeed * Mathf.Sin(angleRad);\r\n        \r\n        return horizontalDirection * horizontalSpeed + Vector3.up * verticalSpeed;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 计算3D反向弹道（考虑所有方向）\r\n    /// </summary>\r\n    public static BallisticSolution Calculate3D(Vector3 startPos, Vector3 targetPos, float initialSpeed, float gravity = 9.81f)\r\n    {\r\n        // 3D情况可以简化为2D（在包含起始点和目标点的垂直平面上）\r\n        return Calculate2D(startPos, targetPos, initialSpeed, gravity);\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 验证弹道解（通过正向模拟）\r\n    /// </summary>\r\n    public static bool ValidateSolution(Vector3 startPos, Vector3 targetPos, Vector3 initialVelocity, float gravity, float tolerance = 0.5f)\r\n    {\r\n        // 使用正向弹道模拟验证\r\n        Vector3 pos = startPos;\r\n        Vector3 velocity = initialVelocity;\r\n        float timeStep = 0.02f;\r\n        float maxTime = 10f;\r\n        float elapsedTime = 0f;\r\n        \r\n        while (elapsedTime < maxTime)\r\n        {\r\n            // 更新位置\r\n            pos += velocity * timeStep;\r\n            \r\n            // 更新速度（考虑重力）\r\n            velocity += Vector3.down * gravity * timeStep;\r\n            \r\n            // 检查是否到达目标\r\n            if (Vector3.Distance(pos, targetPos) < tolerance)\r\n            {\r\n                return true;\r\n            }\r\n            \r\n            // 如果已经超过目标（在目标下方），失败\r\n            if (pos.y < targetPos.y && Vector3.Distance(new Vector3(pos.x, 0, pos.z), new Vector3(targetPos.x, 0, targetPos.z)) < tolerance)\r\n            {\r\n                return false;\r\n            }\r\n            \r\n            elapsedTime += timeStep;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 反向弹道计算器组件\r\n/// </summary>\r\npublic class InverseBallisticsCalculator : MonoBehaviour\r\n{\r\n    [Header(\"弹道参数\")]\r\n    public float initialSpeed = 20f;\r\n    public float gravity = 9.81f;\r\n    public bool useLowAngle = true;  // 使用低角度还是高角度\r\n    \r\n    [Header(\"调试\")]\r\n    public bool showTrajectory = true;\r\n    public int trajectoryPoints = 50;\r\n    public Color trajectoryColor = Color.red;\r\n    \r\n    private LineRenderer trajectoryLine;\r\n    \r\n    void Start()\r\n    {\r\n        // 创建轨迹线\r\n        if (showTrajectory)\r\n        {\r\n            GameObject lineObj = new GameObject(\"TrajectoryLine\");\r\n            lineObj.transform.SetParent(transform);\r\n            trajectoryLine = lineObj.AddComponent<LineRenderer>();\r\n            trajectoryLine.material = new Material(Shader.Find(\"Sprites/Default\"));\r\n            trajectoryLine.color = trajectoryColor;\r\n            trajectoryLine.width = 0.1f;\r\n            trajectoryLine.positionCount = trajectoryPoints;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 计算并应用弹道\r\n    /// </summary>\r\n    public bool CalculateAndApply(Vector3 targetPos)\r\n    {\r\n        Vector3 startPos = transform.position;\r\n        BallisticSolution solution = InverseBallistics.Calculate2D(startPos, targetPos, initialSpeed, gravity);\r\n        \r\n        if (!solution.isValid)\r\n        {\r\n            Debug.LogWarning(\"无法计算弹道：目标超出射程\");\r\n            return false;\r\n        }\r\n        \r\n        // 选择角度（低角度或高角度）\r\n        float angle = useLowAngle ? solution.angle1 : solution.angle2;\r\n        Vector3 velocity = useLowAngle ? solution.velocity1 : solution.velocity2;\r\n        float flightTime = useLowAngle ? solution.flightTime1 : solution.flightTime2;\r\n        \r\n        if (angle < 0)\r\n        {\r\n            Debug.LogWarning(\"所选角度无效，尝试使用另一个角度\");\r\n            angle = useLowAngle ? solution.angle2 : solution.angle1;\r\n            velocity = useLowAngle ? solution.velocity2 : solution.velocity1;\r\n            flightTime = useLowAngle ? solution.flightTime2 : solution.flightTime1;\r\n        }\r\n        \r\n        if (angle < 0)\r\n        {\r\n            Debug.LogError(\"两个角度都无效\");\r\n            return false;\r\n        }\r\n        \r\n        Debug.Log($\"弹道计算成功：角度={angle:F2}°, 飞行时间={flightTime:F2}s\");\r\n        \r\n        // 可视化轨迹\r\n        if (showTrajectory && trajectoryLine != null)\r\n        {\r\n            DrawTrajectory(startPos, velocity, gravity);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 绘制轨迹\r\n    /// </summary>\r\n    private void DrawTrajectory(Vector3 startPos, Vector3 initialVelocity, float gravity)\r\n    {\r\n        Vector3 pos = startPos;\r\n        Vector3 velocity = initialVelocity;\r\n        float timeStep = 0.1f;\r\n        float maxTime = 10f;\r\n        float elapsedTime = 0f;\r\n        \r\n        List<Vector3> points = new List<Vector3>();\r\n        points.Add(startPos);\r\n        \r\n        while (elapsedTime < maxTime && points.Count < trajectoryPoints)\r\n        {\r\n            pos += velocity * timeStep;\r\n            velocity += Vector3.down * gravity * timeStep;\r\n            points.Add(pos);\r\n            elapsedTime += timeStep;\r\n            \r\n            // 如果到达地面，停止\r\n            if (pos.y < startPos.y - 10f)\r\n            {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        trajectoryLine.positionCount = points.Count;\r\n        for (int i = 0; i < points.Count; i++)\r\n        {\r\n            trajectoryLine.SetPosition(i, points[i]);\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取弹道解（不应用）\r\n    /// </summary>\r\n    public BallisticSolution GetSolution(Vector3 targetPos)\r\n    {\r\n        return InverseBallistics.Calculate2D(transform.position, targetPos, initialSpeed, gravity);\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 弹道预测器（用于AI瞄准）\r\n/// </summary>\r\npublic class BallisticPredictor : MonoBehaviour\r\n{\r\n    public float projectileSpeed = 20f;\r\n    public float gravity = 9.81f;\r\n    public Transform target;\r\n    \r\n    void Update()\r\n    {\r\n        if (target == null)\r\n            return;\r\n        \r\n        // 计算反向弹道\r\n        BallisticSolution solution = InverseBallistics.Calculate2D(\r\n            transform.position,\r\n            target.position,\r\n            projectileSpeed,\r\n            gravity\r\n        );\r\n        \r\n        if (solution.isValid)\r\n        {\r\n            // 使用低角度（更直接）\r\n            float angle = solution.angle1 >= 0 ? solution.angle1 : solution.angle2;\r\n            Vector3 velocity = solution.angle1 >= 0 ? solution.velocity1 : solution.velocity2;\r\n            \r\n            // 应用瞄准（例如：旋转炮台）\r\n            if (angle >= 0)\r\n            {\r\n                Vector3 direction = velocity.normalized;\r\n                transform.rotation = Quaternion.LookRotation(direction);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 使用示例\r\n\r\n### 示例1：基础使用\r\n\r\n```csharp\r\n// 计算从A点到B点的弹道\r\nVector3 startPos = new Vector3(0, 0, 0);\r\nVector3 targetPos = new Vector3(10, 5, 0);\r\nfloat initialSpeed = 20f;\r\nfloat gravity = 9.81f;\r\n\r\nBallisticSolution solution = InverseBallistics.Calculate2D(startPos, targetPos, initialSpeed, gravity);\r\n\r\nif (solution.isValid)\r\n{\r\n    // 使用低角度（更直接）\r\n    float angle = solution.angle1;\r\n    Vector3 velocity = solution.velocity1;\r\n    \r\n    // 发射物体\r\n    Rigidbody projectile = GetComponent<Rigidbody>();\r\n    projectile.velocity = velocity;\r\n}\r\n```\r\n\r\n### 示例2：塔防游戏\r\n\r\n```csharp\r\npublic class Tower : MonoBehaviour\r\n{\r\n    public float projectileSpeed = 15f;\r\n    public Transform firePoint;\r\n    public GameObject projectilePrefab;\r\n    \r\n    public void FireAtTarget(Vector3 targetPos)\r\n    {\r\n        BallisticSolution solution = InverseBallistics.Calculate2D(\r\n            firePoint.position,\r\n            targetPos,\r\n            projectileSpeed,\r\n            Physics.gravity.magnitude\r\n        );\r\n        \r\n        if (solution.isValid)\r\n        {\r\n            // 使用低角度\r\n            Vector3 velocity = solution.velocity1;\r\n            \r\n            // 创建并发射弹丸\r\n            GameObject projectile = Instantiate(projectilePrefab, firePoint.position, Quaternion.identity);\r\n            Rigidbody rb = projectile.GetComponent<Rigidbody>();\r\n            rb.velocity = velocity;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Unity应用建议\r\n\r\n1. **使用Unity Physics**：\r\n   - 可以使用`Rigidbody`配合计算出的初速度\r\n   - 设置`Physics.gravity`为实际重力值\r\n   - 使用`Rigidbody.AddForce()`应用初始速度\r\n\r\n2. **性能优化**：\r\n   - 缓存计算结果\r\n   - 使用对象池管理弹丸\r\n   - 分帧计算（如果有很多目标）\r\n\r\n3. **特殊情况处理**：\r\n   - 目标移动：需要预测目标位置\r\n   - 障碍物：需要检查弹道是否被阻挡\r\n   - 风力影响：需要额外考虑风力因素\r\n\r\n---\r\n\r\n## 参考文献\r\n\r\n- 《游戏编程精粹2》- 2.4 反向弹道计算\r\n\r\n"
        }
    ]
}