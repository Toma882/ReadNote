{
    "sourceFile": "游戏编程精粹/1/代码/Steering Behaviors（定向行为系统）.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764427095830,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764427095830,
            "name": "Commit-0",
            "content": "## Steering Behaviors（定向行为系统）- C#实现\r\n\r\n### 核心概念\r\n\r\n- **定义**：Reynolds提出的基础行为系统，用于实现各种移动行为\r\n- **核心思想**：每个行为返回一个Steering（转向）矢量，多个行为可以组合，最终矢量决定Agent的移动方向\r\n- **优势**：模块化设计，可以灵活组合多个行为\r\n\r\n### 基础数据结构\r\n\r\n```csharp\r\nusing UnityEngine;\r\n\r\n/// <summary>\r\n/// Steering（转向）数据结构：包含线性和角速度\r\n/// </summary>\r\npublic struct Steering\r\n{\r\n    public Vector3 linear;   // 线性转向力（移动方向）\r\n    public float angular;    // 角转向力（旋转方向）\r\n    \r\n    public Steering(Vector3 linear, float angular)\r\n    {\r\n        this.linear = linear;\r\n        this.angular = angular;\r\n    }\r\n    \r\n    public static Steering operator +(Steering a, Steering b)\r\n    {\r\n        return new Steering(a.linear + b.linear, a.angular + b.angular);\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// Agent基础类：包含位置、速度、朝向等属性\r\n/// </summary>\r\npublic class Agent\r\n{\r\n    public Vector3 position;\r\n    public Vector3 velocity;\r\n    public float orientation;  // 朝向角度（弧度）\r\n    public float maxSpeed;\r\n    public float maxAccel;\r\n    public float maxRotation;\r\n    public float maxAngularAccel;\r\n}\r\n```\r\n\r\n### 基础行为实现\r\n\r\n#### 1. Seek（寻找目标）\r\n\r\n**功能**：朝着目标位置移动\r\n\r\n```csharp\r\npublic class Seek : SteeringBehavior\r\n{\r\n    public Transform target;\r\n    \r\n    public override Steering GetSteering()\r\n    {\r\n        Steering steering = new Steering();\r\n        \r\n        // 计算到目标的方向\r\n        Vector3 direction = target.position - agent.position;\r\n        direction.Normalize();\r\n        \r\n        // 计算期望速度\r\n        Vector3 desiredVelocity = direction * agent.maxSpeed;\r\n        \r\n        // 计算转向力\r\n        steering.linear = desiredVelocity - agent.velocity;\r\n        steering.linear = Vector3.ClampMagnitude(steering.linear, agent.maxAccel);\r\n        \r\n        return steering;\r\n    }\r\n}\r\n```\r\n\r\n#### 2. Flee（逃离目标）\r\n\r\n**功能**：远离目标位置\r\n\r\n```csharp\r\npublic class Flee : SteeringBehavior\r\n{\r\n    public Transform target;\r\n    public float panicDistance = 10f;  // 恐慌距离，超过此距离不再逃离\r\n    \r\n    public override Steering GetSteering()\r\n    {\r\n        Steering steering = new Steering();\r\n        \r\n        // 计算到目标的距离\r\n        Vector3 direction = agent.position - target.position;\r\n        float distance = direction.magnitude;\r\n        \r\n        // 如果距离太远，不逃离\r\n        if (distance > panicDistance)\r\n        {\r\n            return steering;  // 返回零转向\r\n        }\r\n        \r\n        direction.Normalize();\r\n        \r\n        // 计算期望速度（远离目标）\r\n        Vector3 desiredVelocity = direction * agent.maxSpeed;\r\n        \r\n        // 计算转向力\r\n        steering.linear = desiredVelocity - agent.velocity;\r\n        steering.linear = Vector3.ClampMagnitude(steering.linear, agent.maxAccel);\r\n        \r\n        return steering;\r\n    }\r\n}\r\n```\r\n\r\n#### 3. Arrive（到达目标）\r\n\r\n**功能**：到达目标位置，带减速效果\r\n\r\n```csharp\r\npublic class Arrive : SteeringBehavior\r\n{\r\n    public Transform target;\r\n    public float targetRadius = 1f;      // 到达半径\r\n    public float slowRadius = 5f;        // 减速半径\r\n    public float timeToTarget = 0.25f;  // 到达目标的时间\r\n    \r\n    public override Steering GetSteering()\r\n    {\r\n        Steering steering = new Steering();\r\n        \r\n        // 计算到目标的方向和距离\r\n        Vector3 direction = target.position - agent.position;\r\n        float distance = direction.magnitude;\r\n        \r\n        // 如果已经在目标范围内，停止\r\n        if (distance < targetRadius)\r\n        {\r\n            return steering;  // 返回零转向\r\n        }\r\n        \r\n        // 计算目标速度\r\n        float targetSpeed;\r\n        if (distance > slowRadius)\r\n        {\r\n            // 在减速半径外，使用最大速度\r\n            targetSpeed = agent.maxSpeed;\r\n        }\r\n        else\r\n        {\r\n            // 在减速半径内，按比例减速\r\n            targetSpeed = agent.maxSpeed * (distance / slowRadius);\r\n        }\r\n        \r\n        // 计算期望速度\r\n        Vector3 desiredVelocity = direction.normalized * targetSpeed;\r\n        \r\n        // 计算转向力\r\n        steering.linear = desiredVelocity - agent.velocity;\r\n        steering.linear /= timeToTarget;  // 调整加速度\r\n        \r\n        // 限制加速度\r\n        if (steering.linear.magnitude > agent.maxAccel)\r\n        {\r\n            steering.linear = steering.linear.normalized * agent.maxAccel;\r\n        }\r\n        \r\n        return steering;\r\n    }\r\n}\r\n```\r\n\r\n#### 4. Pursue（追逐移动目标）\r\n\r\n**功能**：追逐移动的目标，预测目标未来位置\r\n\r\n```csharp\r\npublic class Pursue : SteeringBehavior\r\n{\r\n    public Agent target;\r\n    public float maxPrediction = 5f;  // 最大预测时间\r\n    \r\n    public override Steering GetSteering()\r\n    {\r\n        // 计算到目标的距离\r\n        Vector3 direction = target.position - agent.position;\r\n        float distance = direction.magnitude;\r\n        \r\n        // 计算当前速度\r\n        float speed = agent.velocity.magnitude;\r\n        \r\n        // 计算预测时间\r\n        float prediction;\r\n        if (speed <= distance / maxPrediction)\r\n        {\r\n            prediction = maxPrediction;\r\n        }\r\n        else\r\n        {\r\n            prediction = distance / speed;\r\n        }\r\n        \r\n        // 预测目标未来位置\r\n        Vector3 targetPosition = target.position + target.velocity * prediction;\r\n        \r\n        // 使用Seek行为朝向预测位置\r\n        Vector3 seekDirection = targetPosition - agent.position;\r\n        seekDirection.Normalize();\r\n        \r\n        Vector3 desiredVelocity = seekDirection * agent.maxSpeed;\r\n        \r\n        Steering steering = new Steering();\r\n        steering.linear = desiredVelocity - agent.velocity;\r\n        steering.linear = Vector3.ClampMagnitude(steering.linear, agent.maxAccel);\r\n        \r\n        return steering;\r\n    }\r\n}\r\n```\r\n\r\n#### 5. Evade（躲避移动目标）\r\n\r\n**功能**：躲避移动的目标，预测目标未来位置\r\n\r\n```csharp\r\npublic class Evade : SteeringBehavior\r\n{\r\n    public Agent target;\r\n    public float maxPrediction = 5f;\r\n    public float panicDistance = 10f;  // 恐慌距离\r\n    \r\n    public override Steering GetSteering()\r\n    {\r\n        // 计算到目标的距离\r\n        Vector3 direction = agent.position - target.position;\r\n        float distance = direction.magnitude;\r\n        \r\n        // 如果距离太远，不躲避\r\n        if (distance > panicDistance)\r\n        {\r\n            return new Steering();\r\n        }\r\n        \r\n        // 计算预测时间\r\n        float speed = agent.velocity.magnitude;\r\n        float prediction;\r\n        if (speed <= distance / maxPrediction)\r\n        {\r\n            prediction = maxPrediction;\r\n        }\r\n        else\r\n        {\r\n            prediction = distance / speed;\r\n        }\r\n        \r\n        // 预测目标未来位置\r\n        Vector3 targetPosition = target.position + target.velocity * prediction;\r\n        \r\n        // 使用Flee行为远离预测位置\r\n        Vector3 fleeDirection = agent.position - targetPosition;\r\n        fleeDirection.Normalize();\r\n        \r\n        Vector3 desiredVelocity = fleeDirection * agent.maxSpeed;\r\n        \r\n        Steering steering = new Steering();\r\n        steering.linear = desiredVelocity - agent.velocity;\r\n        steering.linear = Vector3.ClampMagnitude(steering.linear, agent.maxAccel);\r\n        \r\n        return steering;\r\n    }\r\n}\r\n```\r\n\r\n#### 6. Align（对齐朝向）\r\n\r\n**功能**：对齐到目标朝向\r\n\r\n```csharp\r\npublic class Align : SteeringBehavior\r\n{\r\n    public Agent target;\r\n    public float targetRadius = 0.1f;      // 目标角度范围（弧度）\r\n    public float slowRadius = 0.5f;       // 减速角度范围（弧度）\r\n    public float timeToTarget = 0.1f;     // 到达目标的时间\r\n    \r\n    public override Steering GetSteering()\r\n    {\r\n        Steering steering = new Steering();\r\n        \r\n        // 计算角度差（归一化到-π到π）\r\n        float rotation = target.orientation - agent.orientation;\r\n        rotation = MapToRange(rotation);  // 映射到-π到π范围\r\n        \r\n        float rotationSize = Mathf.Abs(rotation);\r\n        \r\n        // 如果已经在目标范围内，停止\r\n        if (rotationSize < targetRadius)\r\n        {\r\n            return steering;\r\n        }\r\n        \r\n        // 计算目标角速度\r\n        float targetRotation;\r\n        if (rotationSize > slowRadius)\r\n        {\r\n            targetRotation = agent.maxRotation;\r\n        }\r\n        else\r\n        {\r\n            targetRotation = agent.maxRotation * (rotationSize / slowRadius);\r\n        }\r\n        \r\n        // 根据旋转方向设置符号\r\n        targetRotation *= rotation / rotationSize;\r\n        \r\n        // 计算角加速度\r\n        steering.angular = targetRotation - agent.angular;\r\n        steering.angular /= timeToTarget;\r\n        \r\n        // 限制角加速度\r\n        if (Mathf.Abs(steering.angular) > agent.maxAngularAccel)\r\n        {\r\n            steering.angular = Mathf.Sign(steering.angular) * agent.maxAngularAccel;\r\n        }\r\n        \r\n        return steering;\r\n    }\r\n    \r\n    private float MapToRange(float rotation)\r\n    {\r\n        while (rotation > Mathf.PI)\r\n            rotation -= 2f * Mathf.PI;\r\n        while (rotation < -Mathf.PI)\r\n            rotation += 2f * Mathf.PI;\r\n        return rotation;\r\n    }\r\n}\r\n```\r\n\r\n#### 7. VelocityMatch（速度匹配）\r\n\r\n**功能**：匹配目标的速度\r\n\r\n```csharp\r\npublic class VelocityMatch : SteeringBehavior\r\n{\r\n    public Agent target;\r\n    public float timeToTarget = 0.1f;\r\n    \r\n    public override Steering GetSteering()\r\n    {\r\n        Steering steering = new Steering();\r\n        \r\n        // 计算期望速度（目标速度）\r\n        Vector3 desiredVelocity = target.velocity;\r\n        \r\n        // 计算转向力\r\n        steering.linear = desiredVelocity - agent.velocity;\r\n        steering.linear /= timeToTarget;\r\n        \r\n        // 限制加速度\r\n        if (steering.linear.magnitude > agent.maxAccel)\r\n        {\r\n            steering.linear = steering.linear.normalized * agent.maxAccel;\r\n        }\r\n        \r\n        return steering;\r\n    }\r\n}\r\n```\r\n\r\n#### 8. Wander（漫游）\r\n\r\n**功能**：随机漫游行为\r\n\r\n```csharp\r\npublic class Wander : SteeringBehavior\r\n{\r\n    public float wanderOffset = 1.5f;    // 漫游中心点距离\r\n    public float wanderRadius = 1.0f;   // 漫游半径\r\n    public float wanderRate = 0.5f;     // 漫游角度变化率\r\n    \r\n    private float wanderOrientation = 0f;  // 当前漫游角度\r\n    \r\n    public override Steering GetSteering()\r\n    {\r\n        Steering steering = new Steering();\r\n        \r\n        // 更新漫游角度（随机变化）\r\n        wanderOrientation += Random.Range(-1f, 1f) * wanderRate;\r\n        \r\n        // 计算目标朝向（当前朝向 + 漫游角度）\r\n        float targetOrientation = wanderOrientation + agent.orientation;\r\n        \r\n        // 计算漫游中心点（在Agent前方）\r\n        Vector3 wanderCenter = agent.position + \r\n            GetOrientationAsVector(agent.orientation) * wanderOffset;\r\n        \r\n        // 计算目标位置（漫游中心点 + 半径方向）\r\n        Vector3 targetPosition = wanderCenter + \r\n            GetOrientationAsVector(targetOrientation) * wanderRadius;\r\n        \r\n        // 使用Seek行为朝向目标位置\r\n        Vector3 direction = targetPosition - agent.position;\r\n        direction.Normalize();\r\n        \r\n        Vector3 desiredVelocity = direction * agent.maxSpeed;\r\n        steering.linear = desiredVelocity - agent.velocity;\r\n        steering.linear = Vector3.ClampMagnitude(steering.linear, agent.maxAccel);\r\n        \r\n        return steering;\r\n    }\r\n    \r\n    private Vector3 GetOrientationAsVector(float orientation)\r\n    {\r\n        return new Vector3(Mathf.Sin(orientation), 0, Mathf.Cos(orientation));\r\n    }\r\n}\r\n```\r\n\r\n#### 9. AvoidWall（避障）\r\n\r\n**功能**：避开墙壁\r\n\r\n```csharp\r\npublic class AvoidWall : SteeringBehavior\r\n{\r\n    public float avoidDistance = 3f;    // 避障距离\r\n    public float lookAhead = 5f;         // 前瞻距离\r\n    public LayerMask wallLayer;          // 墙壁层\r\n    \r\n    public override Steering GetSteering()\r\n    {\r\n        Steering steering = new Steering();\r\n        \r\n        // 计算前瞻位置（Agent前方）\r\n        Vector3 rayVector = agent.velocity.normalized * lookAhead;\r\n        Vector3 ahead = agent.position + rayVector;\r\n        \r\n        // 检测前方是否有墙壁\r\n        RaycastHit hit;\r\n        if (Physics.Raycast(agent.position, rayVector.normalized, out hit, lookAhead, wallLayer))\r\n        {\r\n            // 计算避障方向（垂直于墙壁法线）\r\n            Vector3 avoidanceDirection = Vector3.Reflect(rayVector.normalized, hit.normal);\r\n            avoidanceDirection.Normalize();\r\n            \r\n            // 计算目标位置（避开墙壁）\r\n            Vector3 targetPosition = hit.point + avoidanceDirection * avoidDistance;\r\n            \r\n            // 使用Seek行为朝向目标位置\r\n            Vector3 direction = targetPosition - agent.position;\r\n            direction.Normalize();\r\n            \r\n            Vector3 desiredVelocity = direction * agent.maxSpeed;\r\n            steering.linear = desiredVelocity - agent.velocity;\r\n            steering.linear = Vector3.ClampMagnitude(steering.linear, agent.maxAccel);\r\n        }\r\n        \r\n        return steering;\r\n    }\r\n}\r\n```\r\n\r\n#### 10. AvoidAgent（避开其他Agent）\r\n\r\n**功能**：避开其他Agent\r\n\r\n```csharp\r\npublic class AvoidAgent : SteeringBehavior\r\n{\r\n    public List<Agent> targets;         // 需要避开的Agent列表\r\n    public float avoidRadius = 2f;      // 避障半径\r\n    public float lookAhead = 3f;        // 前瞻距离\r\n    \r\n    public override Steering GetSteering()\r\n    {\r\n        Steering steering = new Steering();\r\n        \r\n        // 计算前瞻位置\r\n        Vector3 rayVector = agent.velocity.normalized * lookAhead;\r\n        Vector3 ahead = agent.position + rayVector;\r\n        \r\n        // 找到最近的威胁Agent\r\n        Agent closestThreat = null;\r\n        float closestDistance = float.MaxValue;\r\n        \r\n        foreach (Agent target in targets)\r\n        {\r\n            if (target == agent) continue;\r\n            \r\n            // 计算到目标的距离\r\n            float distance = Vector3.Distance(ahead, target.position);\r\n            \r\n            // 如果在前瞻范围内且更近\r\n            if (distance < avoidRadius && distance < closestDistance)\r\n            {\r\n                closestThreat = target;\r\n                closestDistance = distance;\r\n            }\r\n        }\r\n        \r\n        // 如果有威胁，避开它\r\n        if (closestThreat != null)\r\n        {\r\n            // 计算避障方向（远离威胁）\r\n            Vector3 avoidanceDirection = (agent.position - closestThreat.position).normalized;\r\n            \r\n            // 计算目标位置\r\n            Vector3 targetPosition = closestThreat.position + avoidanceDirection * avoidRadius;\r\n            \r\n            // 使用Seek行为朝向目标位置\r\n            Vector3 direction = targetPosition - agent.position;\r\n            direction.Normalize();\r\n            \r\n            Vector3 desiredVelocity = direction * agent.maxSpeed;\r\n            steering.linear = desiredVelocity - agent.velocity;\r\n            steering.linear = Vector3.ClampMagnitude(steering.linear, agent.maxAccel);\r\n        }\r\n        \r\n        return steering;\r\n    }\r\n}\r\n```\r\n\r\n### 行为组合\r\n\r\n**核心思想**：多个行为可以组合，通过加权求和得到最终转向力\r\n\r\n```csharp\r\npublic class BlendedSteering : SteeringBehavior\r\n{\r\n    [System.Serializable]\r\n    public class BehaviorWeight\r\n    {\r\n        public SteeringBehavior behavior;\r\n        public float weight;\r\n    }\r\n    \r\n    public List<BehaviorWeight> behaviors = new List<BehaviorWeight>();\r\n    \r\n    public override Steering GetSteering()\r\n    {\r\n        Steering steering = new Steering();\r\n        \r\n        // 累积所有行为的转向力（加权）\r\n        foreach (var bw in behaviors)\r\n        {\r\n            if (bw.behavior != null)\r\n            {\r\n                Steering behaviorSteering = bw.behavior.GetSteering();\r\n                steering.linear += behaviorSteering.linear * bw.weight;\r\n                steering.angular += behaviorSteering.angular * bw.weight;\r\n            }\r\n        }\r\n        \r\n        // 限制最终转向力\r\n        steering.linear = Vector3.ClampMagnitude(steering.linear, agent.maxAccel);\r\n        if (Mathf.Abs(steering.angular) > agent.maxAngularAccel)\r\n        {\r\n            steering.angular = Mathf.Sign(steering.angular) * agent.maxAngularAccel;\r\n        }\r\n        \r\n        return steering;\r\n    }\r\n}\r\n```\r\n\r\n### 使用示例\r\n\r\n```csharp\r\npublic class AgentController : MonoBehaviour\r\n{\r\n    private Agent agent;\r\n    private BlendedSteering blendedSteering;\r\n    \r\n    void Start()\r\n    {\r\n        agent = new Agent();\r\n        agent.position = transform.position;\r\n        agent.maxSpeed = 5f;\r\n        agent.maxAccel = 10f;\r\n        \r\n        // 创建组合行为\r\n        blendedSteering = new BlendedSteering();\r\n        blendedSteering.agent = agent;\r\n        \r\n        // 添加多个行为\r\n        Seek seek = new Seek();\r\n        seek.agent = agent;\r\n        seek.target = GameObject.Find(\"Target\").transform;\r\n        \r\n        AvoidWall avoidWall = new AvoidWall();\r\n        avoidWall.agent = agent;\r\n        avoidWall.wallLayer = LayerMask.GetMask(\"Wall\");\r\n        \r\n        // 设置权重\r\n        blendedSteering.behaviors.Add(new BlendedSteering.BehaviorWeight \r\n        { \r\n            behavior = seek, \r\n            weight = 1.0f \r\n        });\r\n        blendedSteering.behaviors.Add(new BlendedSteering.BehaviorWeight \r\n        { \r\n            behavior = avoidWall, \r\n            weight = 2.0f  // 避障优先级更高\r\n        });\r\n    }\r\n    \r\n    void Update()\r\n    {\r\n        // 获取组合后的转向力\r\n        Steering steering = blendedSteering.GetSteering();\r\n        \r\n        // 更新Agent状态\r\n        agent.velocity += steering.linear * Time.deltaTime;\r\n        agent.velocity = Vector3.ClampMagnitude(agent.velocity, agent.maxSpeed);\r\n        agent.position += agent.velocity * Time.deltaTime;\r\n        \r\n        // 更新Transform\r\n        transform.position = agent.position;\r\n        if (agent.velocity.magnitude > 0.1f)\r\n        {\r\n            transform.rotation = Quaternion.LookRotation(agent.velocity);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 行为基类\r\n\r\n```csharp\r\npublic abstract class SteeringBehavior\r\n{\r\n    public Agent agent;\r\n    \r\n    public abstract Steering GetSteering();\r\n}\r\n```\r\n\r\n### 总结\r\n\r\n- **模块化**：每个行为独立实现，易于维护\r\n- **可组合**：通过加权求和组合多个行为\r\n- **灵活**：可以根据场景动态调整行为权重\r\n- **扩展性**：可以轻松添加新的行为类型\r\n\r\n"
        }
    ]
}