# 引导框架架构设计

## 设计目标

设计一套完整的新手引导框架架构，支持步骤化引导（点击、对话、拖拽等），实现引导进度管理、中断恢复、健壮性防护，提供数据驱动的配置化引导系统。

---

## 核心设计理念

### 1. Context维护为核心

**本质**：引导系统的核心是Context的维护和管理
- 引导流程 = Context在层间流转并逐步增强
- 引导中断 = Context栈的保存和恢复
- 引导状态 = Context中的状态数据
- 引导恢复 = Context状态的恢复

### 2. 数据驱动架构

**本质**：引导特性通过配置数据实现，无需额外机制
- 引导跳过、分支、依赖 → 通过GuideData/StepData配置
- 引导条件、触发 → 通过数据层配置
- 引导进度 → 通过数据层持久化
- 新增特性 → 扩展配置字段即可

### 3. 管道过滤器模式

**本质**：数据在层间流动，每层作为过滤器处理
- 单Context设计：所有层使用统一的`GuideContext`
- 逐步增强：每层在Context中添加自己的数据
- 数据流循环：感知层 → 决策层 → 执行层 → 管理层 → 感知层

---

## 整体架构设计

### 五层架构 + 管道过滤器

```mermaid
graph TB
    subgraph PerceptionLayer["感知层<br/>PerceptionLayer"]
        TargetRegistry["感知目标注册表"]
        Detectors["触发检测器组"]
        ContextBuilder["上下文构建器"]
    end
    
    subgraph DataLayer["数据层<br/>DataLayer"]
        GuideData["引导数据<br/>GuideData"]
        StepData["引导步骤数据<br/>GuideStepData"]
    end
    
    subgraph DecisionLayer["决策层<br/>DecisionLayer"]
        GuideQuery["引导查询器"]
        ConditionChecker["条件判断器"]
        ContextEnhancer["上下文增强器"]
    end
    
    subgraph ExecutionLayer["执行层<br/>ExecutionLayer"]
        Executors["执行器组"]
        StateUpdater["状态更新器"]
    end
    
    subgraph ManagementLayer["管理层<br/>ManagementLayer"]
        StateManager["状态管理器"]
        StateFuncs["状态函数群"]
        ContextStack["Context栈管理器"]
    end
    
    PerceptionLayer -->|GuideContext<br/>+sensorData| DecisionLayer
    DataLayer -.数据查询.-> DecisionLayer
    DecisionLayer -->|GuideContext<br/>+guideData/stepData/selectedStep| ExecutionLayer
    ExecutionLayer -->|GuideContext<br/>+stepResult| ManagementLayer
    ManagementLayer -->|状态更新| PerceptionLayer
    ManagementLayer -->|数据持久化| DataLayer
    
    style PerceptionLayer fill:#ffebee
    style DataLayer fill:#e1f5ff
    style DecisionLayer fill:#fff4e1
    style ExecutionLayer fill:#c8e6c9
    style ManagementLayer fill:#f3e5f5
```

### 管道过滤器数据流

```mermaid
graph LR
    Start[外部事件] -->|1. 感知事件| PerL[感知层<br/>创建GuideContext<br/>填充sensorData]
    PerL -->|2. GuideContext<br/>+sensorData| DecL[决策层<br/>结合数据层<br/>+guideData/stepData/selectedStep]
    DL[数据层<br/>提供GuideData/GuideStepData] -.数据查询.-> DecL
    DecL -->|3. GuideContext<br/>+决策数据| ExeL[执行层<br/>执行步骤<br/>+stepResult]
    ExeL -->|4. GuideContext<br/>+执行数据| ManL[管理层<br/>更新状态<br/>+guideState/lifecycle]
    ManL -->|5. GuideContext<br/>重复使用| PerL
    PerL -.循环感知.-> Start
    
    style PerL fill:#ffebee
    style DL fill:#e1f5ff
    style DecL fill:#fff4e1
    style ExeL fill:#c8e6c9
    style ManL fill:#f3e5f5
```

**数据流特性**：
- ✅ **单Context设计**：所有层使用统一的`GuideContext`，从感知数据开始逐步增强
- ✅ **逐步增强机制**：每层在Context中添加自己的数据，Context逐步增强
- ✅ **数据流循环性**：感知层创建 → 决策层增强 → 执行层增强 → 管理层增强 → 感知层（形成循环）
- ✅ **完整数据追踪**：Context包含从感知到执行的所有数据，便于日志记录和管理
- ✅ **过滤器独立性**：每层独立处理Context，可替换和扩展
- ✅ **解耦设计**：层间通过GuideContext和CommunicationBus通信，不直接依赖

---

## 通讯总线层：CommunicationBus

### MessageChannel：1对1单向通讯

**设计**：使用CommunicationBus的MessageChannel实现层间通讯

```mermaid
graph LR
    PerceptionLayer[感知层] -->|MessageChannel<br/>1对1单向| DecisionLayer[决策层]
    DecisionLayer -->|MessageChannel<br/>1对1单向| ExecutionLayer[执行层]
    
    style PerceptionLayer fill:#ffebee
    style DecisionLayer fill:#fff4e1
    style ExecutionLayer fill:#c8e6c9
```

**特性**：
- ✅ **1对1通讯**：每层通过MessageChannel进行1对1单向消息传递
- ✅ **解耦设计**：层间不直接依赖，通过MessageChannel解耦
- ✅ **消息传递**：GuideContext作为消息载体在层间传递

---

## 感知层架构设计

### 核心职责
注册感知目标 + 检测触发 + 构建Context

### 架构图

```mermaid
graph TB
    subgraph PerceptionLayer["感知层"]
        TargetRegistry["感知目标注册表<br/>TargetRegistry"]
        TargetManager["感知对象管理器<br/>TargetManager"]
        
        subgraph Detectors["触发检测器组"]
            ClickDetector["点击检测器<br/>ClickDetector"]
            DialogueDetector["对话检测器<br/>DialogueDetector"]
            DragDetector["拖拽检测器<br/>DragDetector"]
            OtherDetector["其他检测器<br/>..."]
        end
        
        ContextBuilder["上下文构建器<br/>ContextBuilder"]
    end
    
    subgraph CommunicationBus["通讯总线层"]
        MessageChannel["MessageChannel<br/>消息频道<br/>1对1单向通讯"]
    end
    
    ExternalEvents[外部事件源<br/>UI点击/对话/拖拽等] --> Detectors
    TargetRegistry -->|注册目标对象| TargetManager
    TargetManager -->|管理目标列表| Detectors
    Detectors -->|检测到触发| ContextBuilder
    ContextBuilder -->|创建GuideContext<br/>填充sensorData| MessageChannel
    MessageChannel -->|1对1消息传递| DecisionLayer[决策层]
    
    ManagementLayer[管理层] -.状态反馈<br/>已完成引导.-> TargetRegistry
    
    style PerceptionLayer fill:#ffebee
    style TargetRegistry fill:#fff4e1
    style Detectors fill:#c8e6c9
    style ContextBuilder fill:#e1f5ff
    style CommunicationBus fill:#c8e6c9
    style MessageChannel fill:#fff4e1
```

### 工作流程

```mermaid
flowchart TD
    Start[引导系统启动] --> Register[注册感知目标<br/>TargetRegistry.Register]
    Register -->|目标对象ID<br/>触发条件| Manager[感知对象管理器<br/>管理目标列表]
    
    UserAction[用户操作<br/>点击/对话/拖拽] --> Detect{检测器检测}
    Manager -.目标列表.-> Detect
    
    Detect -->|匹配到注册目标| Trigger[触发检测成功]
    Detect -->|未匹配| Ignore[忽略事件]
    
    Trigger --> Build[构建GuideContext<br/>填充sensorData]
    Build -->|通过MessageChannel<br/>1对1消息传递| MessageBus[CommunicationBus<br/>MessageChannel]
    MessageBus -->|传递GuideContext| Decision[决策层]
    
    Management[管理层] -.已完成引导列表.-> Register
    
    style Detect fill:#fff4e1,stroke:#333,stroke-width:2px
    style Trigger fill:#c8e6c9
    style Build fill:#e1f5ff
    style MessageBus fill:#fff4e1
```

### 核心组件

1. **感知目标注册表（TargetRegistry）**
   - 注册需要检测的对象（UI按钮、NPC、交互物等）
   - 记录触发条件（点击、对话、拖拽等）
   - 接收管理层反馈，过滤已完成的引导目标

2. **感知对象管理器（TargetManager）**
   - 维护当前活跃的感知目标列表
   - 管理目标对象的生命周期（注册/注销）
   - 提供快速查找接口（按ID、按类型）

3. **触发检测器组（Detectors）**
   - **点击检测器**：检测UI按钮、交互物点击
   - **对话检测器**：检测NPC对话触发
   - **拖拽检测器**：检测拖拽操作
   - **其他检测器**：可扩展的检测器类型

4. **上下文构建器（ContextBuilder）**
   - 接收检测器的触发事件
   - 验证目标是否在注册表中
   - 创建GuideContext并填充sensorData（目标ID、触发类型、时间戳等）
   - 通过CommunicationBus的MessageChannel发送给决策层

---

## 决策层架构设计

### 核心职责
接收感知事件 → 查询引导配置 → 判断是否需要引导 → 选择引导步骤

### 工作流程

```mermaid
flowchart TD
    PerceptionLayer[感知层] --> MessageBus[CommunicationBus<br/>MessageChannel]
    MessageBus --> DecisionLayer[决策层<br/>订阅MessageChannel]
    
    DecisionLayer --> ParseSensorData[解析sensorData<br/>提取目标ID/触发类型]
    ParseSensorData --> QueryGuideData[查询数据层<br/>GuideData/GuideStepData]
    
    QueryGuideData --> CheckTriggerCondition{判断是否需要<br/>触发引导?}
    CheckTriggerCondition -->|否| Ignore[忽略]
    CheckTriggerCondition -->|是| SelectGuide{选择引导<br/>根据优先级/进度}
    
    SelectGuide --> CheckGuideProgress{检查引导进度<br/>未开始/进行中/已完成}
    CheckGuideProgress -->|已完成| Ignore
    CheckGuideProgress -->|未开始/进行中| SelectStep{选择步骤<br/>下一步骤/分支步骤}
    
    SelectStep --> EnhanceContext[增强GuideContext<br/>+guideData/stepData/selectedStep]
    EnhanceContext --> MessageBusToExecution[通过MessageChannel<br/>1对1消息传递]
    MessageBusToExecution --> ExecutionLayer[执行层]
    
    style CheckTriggerCondition fill:#fff4e1,stroke:#333,stroke-width:2px
    style SelectGuide fill:#fff4e1,stroke:#333,stroke-width:2px
    style CheckGuideProgress fill:#fff4e1,stroke:#333,stroke-width:2px
    style SelectStep fill:#fff4e1,stroke:#333,stroke-width:2px
    style DecisionLayer fill:#fff4e1
    style MessageBus fill:#c8e6c9
    style MessageBusToExecution fill:#c8e6c9
```

### 核心组件

1. **消息接收器（MessageReceiver）**
   - 订阅MessageChannel，接收感知层发送的GuideContext
   - 解析sensorData，提取目标ID、触发类型等信息

2. **引导查询器（GuideQuery）**
   - 根据sensorData查询数据层，获取GuideData和GuideStepData
   - 支持按目标ID、触发类型、引导ID查询

3. **条件判断器（ConditionChecker）**
   - 判断是否需要触发引导（是否已完成、是否满足条件）
   - 检查前置引导、等级、任务等条件
   - 过滤已完成的引导

4. **引导选择器（GuideSelector）**
   - 根据sensorData匹配对应的引导ID
   - 支持多个引导同时满足时的优先级选择
   - 检查引导进度（未开始/进行中/已完成）

5. **步骤选择器（StepSelector）**
   - 根据引导进度选择下一步骤
   - 支持步骤依赖关系检查
   - 处理步骤跳转和分支逻辑

6. **上下文增强器（ContextEnhancer）**
   - 将查询到的GuideData、GuideStepData、selectedStep添加到GuideContext
   - 形成完整的执行上下文
   - 通过MessageChannel发送给执行层

### 数据流增强过程

```
GuideContext（感知层）
  + sensorData（目标ID、触发类型、时间戳）
  ↓
  + guideData（引导配置、引导ID、引导状态）
  + stepData（步骤配置、步骤列表）
  + selectedStep（选中的步骤ID、步骤类型）
  ↓
GuideContext（执行层）
```

---

## 执行层架构设计

### 核心职责
接收执行上下文 → 解析步骤类型 → 执行引导步骤 → 更新步骤状态

### 工作流程

```mermaid
flowchart TD
    DecisionLayer[决策层] --> MessageBusFromDecision[CommunicationBus<br/>MessageChannel]
    MessageBusFromDecision --> ExecutionLayer[执行层<br/>持有Context]
    
    ExecutionLayer --> ParseStepData[解析selectedStep<br/>提取步骤类型/参数]
    ParseStepData --> SelectExecutor{选择执行器<br/>根据步骤类型}
    
    SelectExecutor --> ClickExecutor[点击执行器<br/>高亮/引导箭头]
    SelectExecutor --> DialogueExecutor[对话执行器<br/>显示对话/等待确认]
    SelectExecutor --> DragExecutor[拖拽执行器<br/>高亮源/目标/路径]
    SelectExecutor --> OtherExecutor[其他执行器<br/>...]
    
    ClickExecutor --> WaitForUserAction{等待用户操作<br/>异步执行}
    DialogueExecutor --> WaitForUserAction
    DragExecutor --> WaitForUserAction
    OtherExecutor --> WaitForUserAction
    
    WaitForUserAction --> DetectCompletion{检测步骤完成<br/>用户操作/自动完成}
    DetectCompletion -->|步骤完成| UpdateContextState[直接更新Context<br/>步骤状态/stepResult]
    DetectCompletion -->|未完成/超时| HandleError[处理错误/超时]
    
    UpdateContextState --> StateFuncs[Context状态变化<br/>自动触发状态函数群]
    StateFuncs --> Manager[管理层]
    
    style SelectExecutor fill:#fff4e1,stroke:#333,stroke-width:2px
    style WaitForUserAction fill:#fff4e1,stroke:#333,stroke-width:2px
    style DetectCompletion fill:#fff4e1,stroke:#333,stroke-width:2px
    style ExecutionLayer fill:#c8e6c9
    style MessageBusFromDecision fill:#fff4e1
    style UpdateContextState fill:#e1f5ff
```

### 核心组件

1. **消息接收器（MessageReceiver）**
   - 订阅MessageChannel，接收决策层发送的GuideContext
   - 解析guideData、stepData、selectedStep

2. **步骤解析器（StepParser）**
   - 解析selectedStep，提取步骤类型（点击/对话/拖拽等）
   - 提取步骤参数（目标对象、提示文本、操作方式等）

3. **执行器组（Executors）**
   - **点击执行器（ClickExecutor）**：执行点击引导步骤
     - 高亮目标UI按钮
     - 显示引导箭头/遮罩
     - 等待用户点击
     - 检测点击完成
   - **对话执行器（DialogueExecutor）**：执行对话引导步骤
     - 显示对话内容
     - 等待用户确认
     - 检测对话完成
   - **拖拽执行器（DragExecutor）**：执行拖拽引导步骤
     - 高亮拖拽源和目标
     - 显示拖拽路径提示
     - 等待用户拖拽
     - 检测拖拽完成
   - **其他执行器**：可扩展的执行器类型

4. **完成检测器（CompletionDetector）**
   - 检测步骤是否完成（用户操作/自动完成）
   - 支持多种完成条件（点击完成、时间完成、条件满足等）
   - 触发步骤状态更新

5. **状态更新器（StateUpdater）**
   - 步骤完成后直接更新Context中的步骤状态
   - Context状态变化自动触发状态函数群
   - 执行层持有Context，直接修改状态

### 执行层特点

- ✅ **持有Context**：执行层持有GuideContext，可直接更新步骤状态
- ✅ **状态自动触发**：Context状态变化自动触发状态函数群（见状态更新流程）
- ✅ **多类型执行器**：支持点击、对话、拖拽等多种步骤类型
- ✅ **异步执行**：支持等待用户操作的异步执行模式
- ✅ **完成检测**：自动检测步骤完成，无需手动通知

### 数据流增强过程

```
GuideContext（决策层）
  + guideData + stepData + selectedStep
  ↓
  + stepResult（步骤执行结果、完成状态）
  ↓
GuideContext（管理层）
```

---

## 管理层+数据层架构设计

### 核心职责
状态管理 + 数据持久化 + 状态函数触发

### 架构图

```mermaid
graph TB
    subgraph DataLayer["数据层"]
        GuideData["引导数据<br/>GuideData"]
        StepData["引导步骤数据<br/>GuideStepData"]
    end
    
    subgraph ManagementLayer["管理层"]
        StateManager["状态管理器<br/>StateManager"]
        GuideContext["引导上下文<br/>GuideContext<br/>{引导状态, 步骤状态}"]
    end
    
    subgraph StateFuncs["状态函数群"]
        GuideStateFuncs["引导状态函数群<br/>GuideStateFuncs"]
        GuideStepStateFuncs["引导步骤函数群<br/>GuideStepStateFuncs"]
    end
    
    StateManager -->|读取| GuideData
    StateManager -->|读取| StepData
    StateManager -->|轮询检测状态变更| GuideContext
    StateManager -->|写入| GuideData
    StateManager -->|写入| StepData
    
    GuideContext -->|状态变化| StateFuncs
    
    StateFuncs --> |更新最新引导数据|StateManager

    style DataLayer fill:#e1f5ff
    style ManagementLayer fill:#f3e5f5
```

### 状态及数据更新流程

```mermaid
flowchart TD
    ExecutionLayer[执行层<br/>持有Context]
    Context[Context]
    StateFuncs[状态函数群]
    StateFunc[状态函数]
    Decision{判断是否是<br/>引导的最后一步?}
    NextStep[触发下一个步骤]
    NextGuide[触发下一个引导]
    Manager[管理层]
    
    ExecutionLayer -->|步骤完成<br/>直接更新步骤状态| Context
    Context -.状态变化<br/>自动触发.-> StateFuncs
    StateFuncs -->|调用| StateFunc
    StateFunc --> Decision
    Decision -->|是| NextGuide
    Decision -->|否| NextStep
    NextGuide -->|更新最新引导数据| Manager
    NextStep -->|更新最新引导数据| Manager
    
    Manager -.轮询检测.-> Context

    style Decision fill:#fff4e1,stroke:#333,stroke-width:2px
    style ExecutionLayer fill:#c8e6c9
    style Manager fill:#f3e5f5
```

### 核心组件

1. **状态管理器（StateManager）**
   - 读取和写入GuideData、StepData
   - 轮询检测GuideContext的状态变更
   - 管理引导和步骤的状态生命周期

2. **状态函数群（StateFuncs）**
   - **引导状态函数群（GuideStateFuncs）**：处理引导状态变化
   - **引导步骤函数群（GuideStepStateFuncs）**：处理步骤状态变化
   - 使用策略模式：`[State1] = self.State1Func, [State2] = self.State2Func`
   - Context状态变化自动触发对应的状态函数

3. **状态函数（StateFunc）**
   - 判断是否是引导的最后一步
   - 如果是最后一步 → 触发下一个引导
   - 如果不是最后一步 → 触发下一个步骤
   - 更新最新引导数据到StateManager

### 数据层设计

1. **引导数据（GuideData）**
   - 引导ID、引导名称、引导状态
   - 引导优先级、触发条件、依赖关系
   - 引导配置（可跳过、分支条件等）

2. **引导步骤数据（GuideStepData）**
   - 步骤ID、步骤类型、步骤状态
   - 步骤参数（目标对象、提示文本等）
   - 步骤配置（超时时间、恢复策略等）

---

## 高级特性：引导中断与恢复机制

### 核心本质：Context维护

**设计理念**：插入新引导 = 维护Context栈，中断旧引导 = 保存旧Context，恢复旧引导 = 恢复旧Context

### 架构图

```mermaid
graph TB
    subgraph ContextStack["Context栈管理"]
        CurrentContext[当前Context<br/>正在执行的引导]
        ContextStack_Data[Context栈<br/>保存中断的引导]
    end
    
    NewGuide[新引导需要立即执行] --> CheckPriority{检查优先级}
    CheckPriority -->|高优先级| Save[保存当前Context到栈]
    CheckPriority -->|低优先级| Ignore[忽略，继续当前引导]
    
    Save --> Switch[切换到新Context]
    Switch --> Execute[执行新引导]
    
    Execute --> Complete{新引导完成}
    Complete -->|需要恢复| Restore[从栈恢复旧Context]
    Complete -->|不需要恢复| Clear[清空栈，继续新流程]
    
    Restore --> Resume[恢复旧引导执行]
    
    style CheckPriority fill:#fff4e1,stroke:#333,stroke-width:2px
    style Complete fill:#fff4e1,stroke:#333,stroke-width:2px
    style ContextStack_Data fill:#e1f5ff
    style CurrentContext fill:#c8e6c9
```

### 工作流程

```mermaid
flowchart TD
    OldContext[当前Context<br/>旧引导执行中] --> NewTrigger[新引导触发<br/>高优先级]
    
    NewTrigger --> Save[保存当前Context<br/>push到栈]
    Save --> Create[创建新Context<br/>新引导]
    Create --> Switch[切换到新Context]
    
    Switch --> Execute[执行新引导]
    Execute --> Complete{新引导完成}
    
    Complete -->|需要恢复| Pop[从栈pop旧Context]
    Complete -->|不需要恢复| End[结束，清空栈]
    
    Pop --> Restore[恢复旧Context<br/>current = pop的Context]
    Restore --> Resume[继续执行旧引导]
    
    style Complete fill:#fff4e1,stroke:#333,stroke-width:2px
    style Save fill:#c8e6c9
    style Restore fill:#e1f5ff
```

### 核心机制

1. **Context栈（ContextStack）**
   - 保存被中断的引导Context
   - 支持多层中断（引导A → 引导B → 引导C）
   - 栈结构：后进先出（LIFO）

2. **优先级判断**
   - 新引导优先级 > 当前引导优先级 → 中断并保存
   - 新引导优先级 ≤ 当前引导优先级 → 忽略或排队

3. **Context切换**
   - 保存当前Context到栈
   - 创建新Context并切换
   - 执行层持有新Context

4. **Context恢复**
   - 新引导完成后，从栈弹出旧Context
   - 恢复旧引导的执行状态
   - 继续执行旧引导的下一步

### 核心组件

1. **Context栈管理器（ContextStackManager）**
   - 管理Context栈（push/pop/peek）
   - 保存和恢复Context状态
   - 支持多层中断嵌套

2. **优先级判断器（PriorityChecker）**
   - 比较新引导和当前引导的优先级
   - 决定是否中断当前引导
   - 支持优先级配置

3. **Context切换器（ContextSwitcher）**
   - 保存当前Context到栈
   - 创建并切换到新Context
   - 更新执行层持有的Context

4. **Context恢复器（ContextRestorer）**
   - 从栈恢复旧Context
   - 恢复引导执行状态
   - 继续执行旧引导

### 设计优势

- ✅ **本质简单**：核心就是Context的保存和恢复
- ✅ **支持嵌套**：支持多层引导中断（A→B→C）
- ✅ **状态完整**：保存完整的Context状态，恢复时无缝衔接
- ✅ **灵活控制**：通过优先级控制中断行为

---

## 健壮性机制：环境变化与卡死防护

### 核心本质：Context状态监控 + 超时检测

**问题场景**：
- 引导需要UI按钮，但UI未加载完成 → 卡死
- 引导需要NPC，但NPC未生成 → 卡死
- 引导需要场景，但场景未切换完成 → 卡死
- 引导需要功能，但功能被禁用 → 卡死

**设计理念**：Context状态监控 + 超时检测 + 自动恢复

### 工作流程

```mermaid
flowchart TD
    CurrentStep[当前引导步骤执行中] --> EnvCheck{环境是否就绪?<br/>目标/功能/UI}
    EnvCheck -->|未就绪| TimeoutCheck{是否超时?}
    EnvCheck -->|已就绪| Continue[继续执行步骤]
    
    TimeoutCheck -->|未超时| Wait[等待环境就绪<br/>Context记录等待状态]
    TimeoutCheck -->|已超时| RecoveryStrategy{执行恢复策略<br/>Context记录恢复策略}
    
    RecoveryStrategy --> Retry[重试<br/>Context记录重试次数]
    RecoveryStrategy --> Skip[跳过当前步骤<br/>Context更新步骤状态]
    RecoveryStrategy --> Cancel[取消当前引导<br/>Context更新引导状态]
    
    Retry --> EnvCheck
    Skip --> NextStep[触发下一个步骤]
    Cancel --> EndGuide[结束引导]
    
    style EnvCheck fill:#fff4e1,stroke:#333,stroke-width:2px
    style TimeoutCheck fill:#fff4e1,stroke:#333,stroke-width:2px
    style RecoveryStrategy fill:#fff4e1,stroke:#333,stroke-width:2px
    style Wait fill:#e1f5ff
    style Retry fill:#c8e6c9
    style Skip fill:#c8e6c9
    style Cancel fill:#c8e6c9
```

### 详细流程

```mermaid
flowchart TD
    StepStart[步骤开始] --> Init[初始化Context<br/>记录startTime<br/>从StepData读取timeout]
    
    Init --> Check[环境检查器<br/>检查环境需求]
    
    Check -->|满足| Execute[执行步骤]
    Check -->|不满足| Wait[等待环境就绪]
    
    Wait --> Timer[启动超时计时器]
    Timer --> Poll[定期轮询检查环境]
    
    Poll -->|环境就绪| Execute
    Poll -->|仍不满足| CheckTimeout{检查超时}
    
    CheckTimeout -->|未超时| Poll
    CheckTimeout -->|已超时| Strategy[根据恢复策略处理]
    
    Execute --> Monitor[监控执行状态]
    Monitor -->|完成| Success[成功]
    Monitor -->|异常| Handle[异常处理]
    Monitor -->|超时| Strategy
    
    Strategy -->|Retry| Retry[重试<br/>retryCount++]
    Strategy -->|Skip| Skip[跳过步骤]
    Strategy -->|Cancel| Cancel[取消引导]
    
    Retry -->|retryCount < maxRetryCount| Check
    Retry -->|retryCount >= maxRetryCount| Cancel
    
    style CheckTimeout fill:#fff4e1,stroke:#333,stroke-width:2px
    style Strategy fill:#fff4e1,stroke:#333,stroke-width:2px
```

### 核心机制

1. **环境检查器（EnvironmentChecker）**
   - 检查目标对象是否存在（UI按钮、NPC、场景等）
   - 检查功能是否可用（功能解锁状态）
   - 检查场景是否就绪（场景加载完成）
   - 定期轮询检查（避免卡死）

2. **超时检测器（TimeoutDetector）**
   - 从StepData中读取超时时间（stepData.timeout）
   - 执行层启动超时计时器（使用Context中的startTime）
   - 超时后自动触发恢复机制
   - 支持不同步骤设置不同超时时间

3. **状态监控器（StateMonitor）**
   - 监控步骤执行状态
   - 检测异常情况（目标消失、功能禁用等）
   - 触发异常处理机制

4. **恢复策略（RecoveryStrategy）**
   - **重试策略**：重新检查环境，环境就绪后重试
   - **跳过策略**：跳过当前步骤，继续下一步
   - **取消策略**：取消整个引导，清理状态
   - 策略可在StepData中配置

### 数据设计

**静态配置数据（StepData中配置）**：
```lua
-- StepData中的健壮性配置（静态数据）
StepData = {
    -- ... 其他字段
    
    -- 健壮性静态配置
    timeout = 30,              -- 超时时间（秒）
    envRequirements = {        -- 环境需求
        uiId = "BackpackButton",
        npcId = "NPC_001",
        sceneId = "Scene_Town"
    },
    recoveryStrategy = "Retry", -- 恢复策略：Retry/Skip/Cancel
    maxRetryCount = 3          -- 最大重试次数
}
```

**动态执行数据（Context中维护）**：
```lua
-- Context中增加健壮性相关动态字段
GuideContext = {
    -- ... 原有字段
    
    -- 健壮性动态字段（执行过程中维护）
    startTime = os.time(),     -- 开始时间
    retryCount = 0             -- 重试次数
}
```

**数据来源**：
- ✅ **静态配置**：从StepData中读取（timeout、envRequirements、recoveryStrategy、maxRetryCount）
- ✅ **动态数据**：在Context中维护（startTime、retryCount）

### 核心组件

1. **环境检查器（EnvironmentChecker）**
   - 检查目标对象存在性（UI、NPC、场景等）
   - 检查功能可用性（功能解锁、场景就绪等）
   - 支持自定义检查函数

2. **超时检测器（TimeoutDetector）**
   - 从StepData读取超时时间配置
   - 在Context中记录步骤开始时间（startTime）
   - 定期检查是否超时（当前时间 - startTime > timeout）
   - 超时后触发恢复策略

3. **状态监控器（StateMonitor）**
   - 监控步骤执行状态
   - 检测异常情况（目标消失、功能禁用）
   - 触发异常处理

4. **恢复策略处理器（RecoveryStrategyHandler）**
   - 根据配置的恢复策略处理
   - 支持重试、跳过、取消三种策略
   - 重试次数限制，避免无限重试

### 设计优势

- ✅ **防止卡死**：超时检测 + 环境检查，避免无限等待
- ✅ **自动恢复**：多种恢复策略，自动处理异常情况
- ✅ **灵活配置**：超时时间、恢复策略可在StepData中配置
- ✅ **状态完整**：Context记录完整状态，便于调试和恢复

---

## 数据驱动架构下的特性支持

**核心理解**：在数据驱动架构下，以下特性通过配置数据即可实现，无需额外机制：

| 特性 | 实现方式 | 说明 |
|---|---|---|
| **引导跳过** | GuideData中配置`canSkip`字段 | 状态函数判断`canSkip`，标记为已跳过 |
| **引导分支** | StepData中配置分支条件和分支步骤 | 决策层根据条件选择不同的stepData |
| **引导依赖** | GuideData中配置`dependencies`字段 | 决策层检查前置引导是否完成 |
| **进度保存/恢复** | GuideData和StepData本身就是数据 | 管理层负责持久化，无需额外机制 |
| **引导条件** | GuideData中配置触发条件 | 决策层检查条件，决定是否触发 |

**设计优势**：
- ✅ **配置驱动**：所有特性通过配置数据实现，无需额外代码
- ✅ **灵活扩展**：新增特性只需扩展配置字段，无需修改架构
- ✅ **统一管理**：所有引导特性统一在数据层管理

---

## 架构验证

### 流程合理性验证

从架构可验证：
- ✅ **数据流完整**：感知层 → 决策层 → 执行层 → 管理层 → 感知层（循环）
- ✅ **职责清晰**：每层职责明确，无重叠
- ✅ **解耦设计**：通过CommunicationBus和Context实现层间解耦
- ✅ **状态管理**：状态更新流程清晰，无循环依赖

### 卡死问题验证

从架构可验证：
- ✅ **健壮性机制**：环境检查 + 超时检测 + 恢复策略
- ✅ **状态监控**：Context状态监控，异常自动处理
- ✅ **恢复机制**：重试/跳过/取消，避免无限等待
- ✅ **环境检查**：定期轮询检查环境，避免卡死

### 扩展性验证

从架构可验证：
- ✅ **数据驱动**：新特性通过配置数据扩展
- ✅ **策略模式**：状态函数群支持灵活扩展
- ✅ **管道过滤器**：每层可独立替换和扩展
- ✅ **执行器扩展**：支持新增执行器类型

### 完整性验证

从架构可验证：
- ✅ **五层架构**：覆盖引导全流程
- ✅ **高级特性**：引导中断与恢复（Context栈）
- ✅ **健壮性**：环境变化和卡死防护
- ✅ **数据驱动**：引导特性通过配置实现

---

## 总结

### 架构设计价值

该架构设计文档的价值在于：
- ✅ **思路解构**：完整解构引导系统的搭建思路
- ✅ **流程验证**：从架构层面验证流程合理性
- ✅ **问题识别**：提前识别潜在的卡死和异常问题
- ✅ **开发指导**：为后续详细设计和实现提供清晰指导

### 设计原则

- ✅ **Context维护为核心**：引导系统的核心是Context的维护和管理
- ✅ **数据驱动架构**：引导特性通过配置数据实现，无需额外机制
- ✅ **管道过滤器模式**：数据在层间流动，每层作为过滤器处理
- ✅ **解耦设计**：层间通过CommunicationBus和Context通信，不直接依赖

### 架构特点

- ✅ **单Context设计**：所有层使用统一的`GuideContext`，逐步增强
- ✅ **1对1通讯**：使用MessageChannel实现层间1对1单向通讯
- ✅ **状态自动触发**：Context状态变化自动触发状态函数群
- ✅ **健壮性防护**：环境检查 + 超时检测 + 恢复策略，避免卡死

细节实现是后续开发阶段的工作，当前架构设计已足够指导整个引导系统的开发。
