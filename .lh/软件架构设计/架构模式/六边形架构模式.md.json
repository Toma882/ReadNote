{
    "sourceFile": "软件架构设计/架构模式/六边形架构模式.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1764235325902,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764235415535,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,153 +1,1 @@\n-# 六边形架构模式（Hexagonal Architecture / Ports & Adapters）\r\n-\r\n-## 目录\r\n-\r\n-- [六边形架构模式（Hexagonal Architecture / Ports \\& Adapters）](#六边形架构模式hexagonal-architecture--ports--adapters)\r\n-  - [目录](#目录)\r\n-  - [概述](#概述)\r\n-  - [核心概念](#核心概念)\r\n-  - [架构结构](#架构结构)\r\n-  - [交互流程](#交互流程)\r\n-  - [优缺点分析](#优缺点分析)\r\n-    - [优点](#优点)\r\n-    - [缺点](#缺点)\r\n-  - [应用场景](#应用场景)\r\n-  - [实践建议](#实践建议)\r\n-  - [示例：订单服务](#示例订单服务)\r\n-  - [总结](#总结)\r\n-\r\n----\r\n-\r\n-## 概述\r\n-\r\n-**六边形架构模式**（又称 **Ports & Adapters**）由 Alistair Cockburn 提出，旨在实现“应用核心与外部世界隔离”。它通过一组“端口（Ports）”暴露核心能力，再由“适配器（Adapters）”连接外部接口（UI、DB、消息系统等），让业务核心保持独立与可测试。\r\n-\r\n----\r\n-\r\n-## 核心概念\r\n-\r\n-| 概念 | 说明 |\r\n-|------|------|\r\n-| **应用核心（Application Core）** | 实现领域逻辑、业务规则、用例的纯净层。 |\r\n-| **端口（Ports）** | 抽象接口，定义核心与外部交互的契约。分为驱动端口（Driving Ports）与被驱动端口（Driven Ports）。 |\r\n-| **适配器（Adapters）** | 端口的具体实现，负责对接外部系统，例如 REST 控制器、数据库存储、消息消费者等。 |\r\n-| **外部世界（External Actors）** | 用户、系统、设备、框架等。 |\r\n-\r\n----\r\n-\r\n-## 架构结构\r\n-\r\n-```\r\n-                ┌───────────────────────┐\r\n-                │   驱动适配器 (UI/API) │\r\n-                └──────────┬────────────┘\r\n-                           │ 驱动端口\r\n-┌──────────────────────────┴───────────────────────────┐\r\n-│                    应用核心（Use Case + Domain）      │\r\n-└──────────────────────────┬───────────────────────────┘\r\n-                           │ 被驱动端口\r\n-                ┌──────────┴─────────┐\r\n-                │  被驱动适配器      │\r\n-                │  (DB、消息、外服)  │\r\n-                └────────────────────┘\r\n-```\r\n-\r\n-- **驱动端口（输入端口）**：上层调用（例如 Controller 调用 Use Case）。\r\n-- **被驱动端口（输出端口）**：核心调用外部（例如 Use Case 调用 Repository 接口）。\r\n-- 适配器负责端口与外部技术细节的转换。\r\n-\r\n----\r\n-\r\n-## 交互流程\r\n-\r\n-1. **驱动适配器接收请求**（REST、CLI、消息等）。\r\n-2. 适配器调用 **驱动端口** 暴露的 Use Case。\r\n-3. 核心逻辑处理过程中需要外部数据时，调用 **被驱动端口**。\r\n-4. 被驱动端口由对应适配器实现，与数据库/服务交互并返回。\r\n-5. Use Case 完成后将结果返回给驱动适配器，再响应外部世界。\r\n-\r\n----\r\n-\r\n-## 优缺点分析\r\n-\r\n-### 优点\r\n-- **业务核心独立**：不依赖具体框架或技术。\r\n-- **测试友好**：核心可用内存假实现、Mock 快速测试。\r\n-- **易于替换技术栈**：新增 UI/DB 只需添加适配器。\r\n-- **接口清晰**：端口定义契约，利于协作。\r\n-\r\n-### 缺点\r\n-- **学习成本**：需要团队理解端口与适配器划分。\r\n-- **代码量增加**：大量接口与适配器实现。\r\n-- **过度抽象风险**：小型系统可能显得复杂。\r\n-\r\n----\r\n-\r\n-## 应用场景\r\n-\r\n-| 适用 | 说明 |\r\n-|------|------|\r\n-| ✅ 业务核心需要长期演进 | 业务稳定，周边技术多变（UI、DB、消息系统频繁变化）。 |\r\n-| ✅ 多接口/多终端接入 | 需要同时支持 Web、Mobile、CLI、消息接口。 |\r\n-| ✅ 强测试需求 | 需要对业务用例做大量自动化测试。 |\r\n-| ❌ 过小/一次性项目 | 架构成本高于收益。 |\r\n-\r\n----\r\n-\r\n-## 实践建议\r\n-\r\n-1. **从用例拆分端口**：每个 Use Case 暴露驱动端口接口。\r\n-2. **接口命名明确**：如 `PlaceOrderUseCase`、`PaymentGatewayPort`。\r\n-3. **适配器职责单一**：一个适配器只处理一种外部协议/渠道。\r\n-4. **依赖注入**：通过 IoC/DI 管理端口与适配器绑定。\r\n-5. **测试优先**：为端口提供内存实现，方便核心层单测。\r\n-\r\n----\r\n-\r\n-## 示例：订单服务\r\n-\r\n-```\r\n-订单核心 (Application Core)\r\n-├─ OrderUseCase (驱动端口实现)\r\n-├─ OrderService (用例逻辑)\r\n-└─ OrderRepositoryPort (被驱动端口)\r\n-\r\n-驱动适配器\r\n-├─ REST Controller → 调用 OrderUseCase\r\n-└─ CLI Command → 调用 OrderUseCase\r\n-\r\n-被驱动适配器\r\n-├─ JpaOrderRepository (DB)\r\n-└─ MessageOrderPublisher (事件总线)\r\n-```\r\n-\r\n-```java\r\n-// 驱动端口\r\n-public interface PlaceOrderUseCase {\r\n-    OrderResult placeOrder(PlaceOrderCommand command);\r\n-}\r\n-\r\n-// 被驱动端口\r\n-public interface OrderRepositoryPort {\r\n-    Order save(Order order);\r\n-    Optional<Order> findById(String id);\r\n-}\r\n-\r\n-// Use Case 实现\r\n-public class PlaceOrderService implements PlaceOrderUseCase {\r\n-    private final OrderRepositoryPort repository;\r\n-\r\n-    public OrderResult placeOrder(PlaceOrderCommand cmd) {\r\n-        Order order = Order.create(cmd);\r\n-        repository.save(order);\r\n-        return OrderResult.from(order);\r\n-    }\r\n-}\r\n-```\r\n-\r\n----\r\n-\r\n-## 总结\r\n-\r\n-六边形架构通过“端口 + 适配器”策略，让业务核心与外界解耦，既保留面向对象的灵活性，也兼容多种技术栈。搭配自动化测试、依赖注入与持续集成，可以在保持核心稳定的同时灵活扩展外围能力。\r\n-\r\n+ \n\\ No newline at end of file\n"
                }
            ],
            "date": 1764235325902,
            "name": "Commit-0",
            "content": "# 六边形架构模式（Hexagonal Architecture / Ports & Adapters）\r\n\r\n## 目录\r\n\r\n- [六边形架构模式（Hexagonal Architecture / Ports \\& Adapters）](#六边形架构模式hexagonal-architecture--ports--adapters)\r\n  - [目录](#目录)\r\n  - [概述](#概述)\r\n  - [核心概念](#核心概念)\r\n  - [架构结构](#架构结构)\r\n  - [交互流程](#交互流程)\r\n  - [优缺点分析](#优缺点分析)\r\n    - [优点](#优点)\r\n    - [缺点](#缺点)\r\n  - [应用场景](#应用场景)\r\n  - [实践建议](#实践建议)\r\n  - [示例：订单服务](#示例订单服务)\r\n  - [总结](#总结)\r\n\r\n---\r\n\r\n## 概述\r\n\r\n**六边形架构模式**（又称 **Ports & Adapters**）由 Alistair Cockburn 提出，旨在实现“应用核心与外部世界隔离”。它通过一组“端口（Ports）”暴露核心能力，再由“适配器（Adapters）”连接外部接口（UI、DB、消息系统等），让业务核心保持独立与可测试。\r\n\r\n---\r\n\r\n## 核心概念\r\n\r\n| 概念 | 说明 |\r\n|------|------|\r\n| **应用核心（Application Core）** | 实现领域逻辑、业务规则、用例的纯净层。 |\r\n| **端口（Ports）** | 抽象接口，定义核心与外部交互的契约。分为驱动端口（Driving Ports）与被驱动端口（Driven Ports）。 |\r\n| **适配器（Adapters）** | 端口的具体实现，负责对接外部系统，例如 REST 控制器、数据库存储、消息消费者等。 |\r\n| **外部世界（External Actors）** | 用户、系统、设备、框架等。 |\r\n\r\n---\r\n\r\n## 架构结构\r\n\r\n```\r\n                ┌───────────────────────┐\r\n                │   驱动适配器 (UI/API) │\r\n                └──────────┬────────────┘\r\n                           │ 驱动端口\r\n┌──────────────────────────┴───────────────────────────┐\r\n│                    应用核心（Use Case + Domain）      │\r\n└──────────────────────────┬───────────────────────────┘\r\n                           │ 被驱动端口\r\n                ┌──────────┴─────────┐\r\n                │  被驱动适配器      │\r\n                │  (DB、消息、外服)  │\r\n                └────────────────────┘\r\n```\r\n\r\n- **驱动端口（输入端口）**：上层调用（例如 Controller 调用 Use Case）。\r\n- **被驱动端口（输出端口）**：核心调用外部（例如 Use Case 调用 Repository 接口）。\r\n- 适配器负责端口与外部技术细节的转换。\r\n\r\n---\r\n\r\n## 交互流程\r\n\r\n1. **驱动适配器接收请求**（REST、CLI、消息等）。\r\n2. 适配器调用 **驱动端口** 暴露的 Use Case。\r\n3. 核心逻辑处理过程中需要外部数据时，调用 **被驱动端口**。\r\n4. 被驱动端口由对应适配器实现，与数据库/服务交互并返回。\r\n5. Use Case 完成后将结果返回给驱动适配器，再响应外部世界。\r\n\r\n---\r\n\r\n## 优缺点分析\r\n\r\n### 优点\r\n- **业务核心独立**：不依赖具体框架或技术。\r\n- **测试友好**：核心可用内存假实现、Mock 快速测试。\r\n- **易于替换技术栈**：新增 UI/DB 只需添加适配器。\r\n- **接口清晰**：端口定义契约，利于协作。\r\n\r\n### 缺点\r\n- **学习成本**：需要团队理解端口与适配器划分。\r\n- **代码量增加**：大量接口与适配器实现。\r\n- **过度抽象风险**：小型系统可能显得复杂。\r\n\r\n---\r\n\r\n## 应用场景\r\n\r\n| 适用 | 说明 |\r\n|------|------|\r\n| ✅ 业务核心需要长期演进 | 业务稳定，周边技术多变（UI、DB、消息系统频繁变化）。 |\r\n| ✅ 多接口/多终端接入 | 需要同时支持 Web、Mobile、CLI、消息接口。 |\r\n| ✅ 强测试需求 | 需要对业务用例做大量自动化测试。 |\r\n| ❌ 过小/一次性项目 | 架构成本高于收益。 |\r\n\r\n---\r\n\r\n## 实践建议\r\n\r\n1. **从用例拆分端口**：每个 Use Case 暴露驱动端口接口。\r\n2. **接口命名明确**：如 `PlaceOrderUseCase`、`PaymentGatewayPort`。\r\n3. **适配器职责单一**：一个适配器只处理一种外部协议/渠道。\r\n4. **依赖注入**：通过 IoC/DI 管理端口与适配器绑定。\r\n5. **测试优先**：为端口提供内存实现，方便核心层单测。\r\n\r\n---\r\n\r\n## 示例：订单服务\r\n\r\n```\r\n订单核心 (Application Core)\r\n├─ OrderUseCase (驱动端口实现)\r\n├─ OrderService (用例逻辑)\r\n└─ OrderRepositoryPort (被驱动端口)\r\n\r\n驱动适配器\r\n├─ REST Controller → 调用 OrderUseCase\r\n└─ CLI Command → 调用 OrderUseCase\r\n\r\n被驱动适配器\r\n├─ JpaOrderRepository (DB)\r\n└─ MessageOrderPublisher (事件总线)\r\n```\r\n\r\n```java\r\n// 驱动端口\r\npublic interface PlaceOrderUseCase {\r\n    OrderResult placeOrder(PlaceOrderCommand command);\r\n}\r\n\r\n// 被驱动端口\r\npublic interface OrderRepositoryPort {\r\n    Order save(Order order);\r\n    Optional<Order> findById(String id);\r\n}\r\n\r\n// Use Case 实现\r\npublic class PlaceOrderService implements PlaceOrderUseCase {\r\n    private final OrderRepositoryPort repository;\r\n\r\n    public OrderResult placeOrder(PlaceOrderCommand cmd) {\r\n        Order order = Order.create(cmd);\r\n        repository.save(order);\r\n        return OrderResult.from(order);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## 总结\r\n\r\n六边形架构通过“端口 + 适配器”策略，让业务核心与外界解耦，既保留面向对象的灵活性，也兼容多种技术栈。搭配自动化测试、依赖注入与持续集成，可以在保持核心稳定的同时灵活扩展外围能力。\r\n\r\n"
        }
    ]
}