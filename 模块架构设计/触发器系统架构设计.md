# 触发器系统 (Trigger System)

## 概述 (Overview)

触发器系统用于管理游戏中的事件触发和响应逻辑，使用对象池技术提高性能。该系统支持自定义触发条件、动作和事件类型，具有良好的可扩展性。

## 系统架构 (System Architecture)

```
TriggerKit       - 触发器核心类，负责触发器对象的创建和管理
TriggerKitFactory - 触发器工厂类，实现了ObjFactory接口，负责创建触发器实例
TriggerDefine    - 触发器相关枚举定义，包括触发器类型、条件、动作和事件类型
TriggerUtil      - 触发器工具类，提供注册触发器类型、条件、动作和事件的工具方法
```

## 主要功能 (Main Features)

### 对象池集成
- 使用对象池技术管理触发器实例，提高性能和减少内存碎片
- 支持自动缓存和复用触发器对象

### 多类型触发器
- 支持多种触发器类型，每种类型可以有独立的条件和动作定义
- 通过`TriggerType`枚举定义不同的触发器类型

### 条件与动作系统
- 使用`TriggerConditionType`定义条件类型，用于检查触发器是否满足激活条件
- 使用`TriggerActionType`定义动作类型，用于触发器激活时执行的操作

### 事件驱动机制
- 通过`TriggerEventType`定义事件类型，用于游戏系统向触发器系统发送事件
- 支持事件分发和观察者模式，触发器可以订阅特定事件类型

## 使用示例 (Usage Examples)

### 初始化触发器系统

```lua
-- 初始化触发器系统
TriggerKit.Initialize()
```

### 创建和使用触发器

```lua
-- 从对象池获取触发器实例
local trigger = TriggerKit.Pop(ETrigger.ExampleModule)

-- 设置触发器类型已经在Pop方法中处理
-- 添加条件和动作
trigger:BindCA(
    ETC.ExampleModule.Condition1, 
    function() return true end,
    ETA.ExampleModule.Action1, 
    function() LogInfo("执行动作1") end
)

-- 执行触发器并检查条件
trigger:ExecuteActions(ETC.ExampleModule.Condition1, ETA.ExampleModule.Action1)

-- 当不再需要时，将触发器推入对象池
TriggerKit.Push(ETrigger.ExampleModule)
```

### 多条件多动作示例

```lua
-- 获取触发器
local trigger = TriggerKit.Pop(ETrigger.ExampleModule)

-- 1对多：一个条件对应多个动作
local conditionId = ETC.ExampleModule.Condition1
local actionIds = {
    ETA.ExampleModule.Action1,
    ETA.ExampleModule.Action2
}
local actions = {
    function() LogInfo("执行动作1") end,
    function() LogInfo("执行动作2") end
}

-- 绑定一个条件到多个动作
trigger:MultiA2F(conditionId, actionIds, actions)
-- 执行所有与条件关联的动作
trigger:ExecuteActions(conditionId)

-- 多对1：多个条件对应一个动作
local conditionIds = {
    ETC.ExampleModule.Condition1,
    ETC.ExampleModule.Condition2
}
local conditions = {
    function() return true end,
    function() return not false end
}
local actionId = ETA.ExampleModule.Action1
local action = function() LogInfo("执行动作1") end

-- 注册多个条件
trigger:MultiC2F(conditionIds, conditions)
-- 绑定多个条件到一个动作
trigger:MultiC2A(conditionIds, actionId, action)
-- 检查并执行多条件动作
trigger:CheckMultiC2A(actionId)
```

### 事件系统使用

```lua
-- 获取触发器
local trigger = TriggerKit.Pop(ETrigger.ExampleModule)

-- 注册事件监听
trigger:SetEventListener(ETE.ExampleModule.Hit, function()
    LogInfo("触发Hit事件")
end)

-- 触发事件
trigger:Broadcast(ETE.ExampleModule.Hit)
```

### 定义自定义触发器类型

```lua
-- 维护时，这部分由对应模块管理
-- 先注册到触发器类型枚举
ETrigger["CustomModule"] = "CustomModule"

-- 注册条件枚举
ETC["CustomModule"] = {
    Condition1 = 1,
    Condition2 = 2,
}

-- 注册动作枚举
ETA["CustomModule"] = {
    Action1 = 1,
    Action2 = 2,
}

-- 注册事件枚举
ETE["CustomModule"] = {
    Event1 = "CustomModule_Event1",
    Event2 = "CustomModule_Event2",
}
```

### 子类扩展

```lua
-- 创建TriggerKit的子类
---@class CustomTriggerKit:TriggerKit
CustomTriggerKit = BaseClass(TriggerKit)

-- 重写Pop方法以注册子类到对象池
---@return CustomTriggerKit
function CustomTriggerKit.Pop(...)
    -- 注入该类到工厂
    local factory = TriggerKit.GetFactory()
    if factory then
        factory:AddObjClass(ETrigger.CustomModule, CustomTriggerKit)
    end
    
    return TriggerKit._Pop(ETrigger.CustomModule, ...)
end

-- 构造函数
function CustomTriggerKit:ctor()
    self.name = "CustomTriggerKit"
end

-- 重写或添加自定义方法
function CustomTriggerKit:Enable()
    TriggerKit.Enable(self) -- 先调用父类方法
    LogInfo("子类覆盖Enable方法")
end

-- 添加自定义方法
function CustomTriggerKit:CustomMethod()
    LogInfo("子类自定义方法")
end
```

### 使用装饰器扩展功能

```lua
-- 创建一个装饰器继承IDecorator接口
---@class CustomDecorator:IDecorator
local CustomDecorator = BaseClass(IDecorator)

function CustomDecorator:ctor()
    self.name = "CustomDecorator"
    ---@type TriggerKit
    self.beDecoratorObj = nil
end

function CustomDecorator:Enable()
    LogInfo(self.name .. "装饰器激活", self.beDecoratorObj.enabled)
end

function CustomDecorator:CustomMethod(isOverride)
    LogInfo("执行装饰器自定义方法", "是否覆盖型装饰器", isOverride)
end

-- 使用装饰器
local trigger = TriggerKit.Pop(ETrigger.ExampleModule)
local decorator = CustomDecorator.New()

-- 作为覆盖装饰器
trigger:SetOverrideDecorator(decorator)
trigger:Enable() -- 会调用装饰器的Enable方法
trigger:ExecuteDecoratorMethod("CustomMethod", true)
trigger:RemoveOverrideDecorator()

-- 作为扩展装饰器
trigger:AddExtendDecorator(decorator, 1)
trigger:Enable() -- 会调用原始方法和装饰器的Enable方法
trigger:ExecuteDecoratorMethod("CustomMethod", false)
trigger:RemoveExtendDecorator(decorator)
```

## 扩展指南 (Extension Guide)

### 添加新的触发器类型

1. 在`TriggerDefine.lua`中的`TriggerType`枚举中添加新的触发器类型
2. 在系统初始化时，新的触发器类型会自动被初始化

### 添加新的条件类型

1. 在`TriggerDefine.lua`中的`TriggerConditionType`枚举中添加新的条件类型
2. 使用`TriggerUtil.RegisterConditionType`注册条件实现

### 添加新的动作类型

1. 在`TriggerDefine.lua`中的`TriggerActionType`枚举中添加新的动作类型
2. 使用`TriggerUtil.RegisterActionType`注册动作实现

### 添加新的事件类型

1. 在`TriggerDefine.lua`中的`TriggerEventType`枚举中添加新的事件类型
2. 使用`TriggerUtil.RegisterEventType`注册事件处理器

## 注意事项 (Notes)

- 触发器系统需要在游戏启动时初始化
- 所有从对象池获取的触发器在使用完毕后必须回收
- 条件和动作函数应保持轻量，避免在其中执行耗时操作
- 事件触发频率较高时应考虑性能影响
- 使用`TriggerKit.Logger()`可以查看触发器池状态
