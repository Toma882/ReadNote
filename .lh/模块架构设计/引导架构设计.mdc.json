{
    "sourceFile": "模块架构设计/引导架构设计.mdc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1767014222679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1767014222679,
            "name": "Commit-0",
            "content": "# 引导框架架构设计\n\n## 设计目标\n\n设计一套完整的新手引导框架架构，支持步骤化引导（点击、对话、拖拽等），实现引导进度管理、中断恢复、健壮性防护，提供数据驱动的配置化引导系统。\n\n---\n\n## 核心设计理念\n\n### 1. Context维护为核心\n\n**本质**：引导系统的核心是Context的维护和管理\n- 引导流程 = Context在层间流转并逐步增强\n- 引导中断 = Context栈的保存和恢复\n- 引导状态 = Context中的状态数据\n- 引导恢复 = Context状态的恢复\n\n### 2. 数据驱动架构\n\n**本质**：引导特性通过配置数据实现，无需额外机制\n- 引导跳过、分支、依赖 → 通过GuideData/StepData配置\n- 引导条件、触发 → 通过数据层配置\n- 引导进度 → 通过数据层持久化\n- 新增特性 → 扩展配置字段即可\n\n### 3. 管道过滤器模式\n\n**本质**：数据在层间流动，每层作为过滤器处理\n- 单Context设计：所有层使用统一的`GuideContext`\n- 逐步增强：每层在Context中添加自己的数据\n- 数据流循环：感知层 → 决策层 → 执行层 → 管理层 → 感知层\n\n---\n\n## 整体架构设计\n\n### 五层架构 + 管道过滤器\n\n```mermaid\ngraph TB\n    subgraph PerceptionLayer[\"感知层<br/>PerceptionLayer\"]\n        TargetRegistry[\"感知目标注册表\"]\n        Detectors[\"触发检测器组\"]\n        ContextBuilder[\"上下文构建器\"]\n    end\n    \n    subgraph DataLayer[\"数据层<br/>DataLayer\"]\n        GuideData[\"引导数据<br/>GuideData\"]\n        StepData[\"引导步骤数据<br/>GuideStepData\"]\n    end\n    \n    subgraph DecisionLayer[\"决策层<br/>DecisionLayer\"]\n        GuideQuery[\"引导查询器\"]\n        ConditionChecker[\"条件判断器\"]\n        ContextEnhancer[\"上下文增强器\"]\n    end\n    \n    subgraph ExecutionLayer[\"执行层<br/>ExecutionLayer\"]\n        Executors[\"执行器组\"]\n        StateUpdater[\"状态更新器\"]\n    end\n    \n    subgraph ManagementLayer[\"管理层<br/>ManagementLayer\"]\n        StateManager[\"状态管理器\"]\n        StateFuncs[\"状态函数群\"]\n        ContextStack[\"Context栈管理器\"]\n    end\n    \n    PerceptionLayer -->|GuideContext<br/>+sensorData| DecisionLayer\n    DataLayer -.数据查询.-> DecisionLayer\n    DecisionLayer -->|GuideContext<br/>+guideData/stepData/selectedStep| ExecutionLayer\n    ExecutionLayer -->|GuideContext<br/>+stepResult| ManagementLayer\n    ManagementLayer -->|状态更新| PerceptionLayer\n    ManagementLayer -->|数据持久化| DataLayer\n    \n    style PerceptionLayer fill:#ffebee\n    style DataLayer fill:#e1f5ff\n    style DecisionLayer fill:#fff4e1\n    style ExecutionLayer fill:#c8e6c9\n    style ManagementLayer fill:#f3e5f5\n```\n\n### 管道过滤器数据流\n\n```mermaid\ngraph LR\n    Start[外部事件] -->|1. 感知事件| PerL[感知层<br/>创建GuideContext<br/>填充sensorData]\n    PerL -->|2. GuideContext<br/>+sensorData| DecL[决策层<br/>结合数据层<br/>+guideData/stepData/selectedStep]\n    DL[数据层<br/>提供GuideData/GuideStepData] -.数据查询.-> DecL\n    DecL -->|3. GuideContext<br/>+决策数据| ExeL[执行层<br/>执行步骤<br/>+stepResult]\n    ExeL -->|4. GuideContext<br/>+执行数据| ManL[管理层<br/>更新状态<br/>+guideState/lifecycle]\n    ManL -->|5. GuideContext<br/>重复使用| PerL\n    PerL -.循环感知.-> Start\n    \n    style PerL fill:#ffebee\n    style DL fill:#e1f5ff\n    style DecL fill:#fff4e1\n    style ExeL fill:#c8e6c9\n    style ManL fill:#f3e5f5\n```\n\n**数据流特性**：\n- ✅ **单Context设计**：所有层使用统一的`GuideContext`，从感知数据开始逐步增强\n- ✅ **逐步增强机制**：每层在Context中添加自己的数据，Context逐步增强\n- ✅ **数据流循环性**：感知层创建 → 决策层增强 → 执行层增强 → 管理层增强 → 感知层（形成循环）\n- ✅ **完整数据追踪**：Context包含从感知到执行的所有数据，便于日志记录和管理\n- ✅ **过滤器独立性**：每层独立处理Context，可替换和扩展\n- ✅ **解耦设计**：层间通过GuideContext和CommunicationBus通信，不直接依赖\n\n---\n\n## 通讯总线层：CommunicationBus\n\n### MessageChannel：1对1单向通讯\n\n**设计**：使用CommunicationBus的MessageChannel实现层间通讯\n\n```mermaid\ngraph LR\n    PerceptionLayer[感知层] -->|MessageChannel<br/>1对1单向| DecisionLayer[决策层]\n    DecisionLayer -->|MessageChannel<br/>1对1单向| ExecutionLayer[执行层]\n    \n    style PerceptionLayer fill:#ffebee\n    style DecisionLayer fill:#fff4e1\n    style ExecutionLayer fill:#c8e6c9\n```\n\n**特性**：\n- ✅ **1对1通讯**：每层通过MessageChannel进行1对1单向消息传递\n- ✅ **解耦设计**：层间不直接依赖，通过MessageChannel解耦\n- ✅ **消息传递**：GuideContext作为消息载体在层间传递\n\n---\n\n## 感知层架构设计\n\n### 核心职责\n注册感知目标 + 检测触发 + 构建Context\n\n### 架构图\n\n```mermaid\ngraph TB\n    subgraph PerceptionLayer[\"感知层\"]\n        TargetRegistry[\"感知目标注册表<br/>TargetRegistry\"]\n        TargetManager[\"感知对象管理器<br/>TargetManager\"]\n        \n        subgraph Detectors[\"触发检测器组\"]\n            ClickDetector[\"点击检测器<br/>ClickDetector\"]\n            DialogueDetector[\"对话检测器<br/>DialogueDetector\"]\n            DragDetector[\"拖拽检测器<br/>DragDetector\"]\n            OtherDetector[\"其他检测器<br/>...\"]\n        end\n        \n        ContextBuilder[\"上下文构建器<br/>ContextBuilder\"]\n    end\n    \n    subgraph CommunicationBus[\"通讯总线层\"]\n        MessageChannel[\"MessageChannel<br/>消息频道<br/>1对1单向通讯\"]\n    end\n    \n    ExternalEvents[外部事件源<br/>UI点击/对话/拖拽等] --> Detectors\n    TargetRegistry -->|注册目标对象| TargetManager\n    TargetManager -->|管理目标列表| Detectors\n    Detectors -->|检测到触发| ContextBuilder\n    ContextBuilder -->|创建GuideContext<br/>填充sensorData| MessageChannel\n    MessageChannel -->|1对1消息传递| DecisionLayer[决策层]\n    \n    ManagementLayer[管理层] -.状态反馈<br/>已完成引导.-> TargetRegistry\n    \n    style PerceptionLayer fill:#ffebee\n    style TargetRegistry fill:#fff4e1\n    style Detectors fill:#c8e6c9\n    style ContextBuilder fill:#e1f5ff\n    style CommunicationBus fill:#c8e6c9\n    style MessageChannel fill:#fff4e1\n```\n\n### 工作流程\n\n```mermaid\nflowchart TD\n    Start[引导系统启动] --> Register[注册感知目标<br/>TargetRegistry.Register]\n    Register -->|目标对象ID<br/>触发条件| Manager[感知对象管理器<br/>管理目标列表]\n    \n    UserAction[用户操作<br/>点击/对话/拖拽] --> Detect{检测器检测}\n    Manager -.目标列表.-> Detect\n    \n    Detect -->|匹配到注册目标| Trigger[触发检测成功]\n    Detect -->|未匹配| Ignore[忽略事件]\n    \n    Trigger --> Build[构建GuideContext<br/>填充sensorData]\n    Build -->|通过MessageChannel<br/>1对1消息传递| MessageBus[CommunicationBus<br/>MessageChannel]\n    MessageBus -->|传递GuideContext| Decision[决策层]\n    \n    Management[管理层] -.已完成引导列表.-> Register\n    \n    style Detect fill:#fff4e1,stroke:#333,stroke-width:2px\n    style Trigger fill:#c8e6c9\n    style Build fill:#e1f5ff\n    style MessageBus fill:#fff4e1\n```\n\n### 核心组件\n\n1. **感知目标注册表（TargetRegistry）**\n   - 注册需要检测的对象（UI按钮、NPC、交互物等）\n   - 记录触发条件（点击、对话、拖拽等）\n   - 接收管理层反馈，过滤已完成的引导目标\n\n2. **感知对象管理器（TargetManager）**\n   - 维护当前活跃的感知目标列表\n   - 管理目标对象的生命周期（注册/注销）\n   - 提供快速查找接口（按ID、按类型）\n\n3. **触发检测器组（Detectors）**\n   - **点击检测器**：检测UI按钮、交互物点击\n   - **对话检测器**：检测NPC对话触发\n   - **拖拽检测器**：检测拖拽操作\n   - **其他检测器**：可扩展的检测器类型\n\n4. **上下文构建器（ContextBuilder）**\n   - 接收检测器的触发事件\n   - 验证目标是否在注册表中\n   - 创建GuideContext并填充sensorData（目标ID、触发类型、时间戳等）\n   - 通过CommunicationBus的MessageChannel发送给决策层\n\n---\n\n## 决策层架构设计\n\n### 核心职责\n接收感知事件 → 查询引导配置 → 判断是否需要引导 → 选择引导步骤\n\n### 工作流程\n\n```mermaid\nflowchart TD\n    PerceptionLayer[感知层] --> MessageBus[CommunicationBus<br/>MessageChannel]\n    MessageBus --> DecisionLayer[决策层<br/>订阅MessageChannel]\n    \n    DecisionLayer --> ParseSensorData[解析sensorData<br/>提取目标ID/触发类型]\n    ParseSensorData --> QueryGuideData[查询数据层<br/>GuideData/GuideStepData]\n    \n    QueryGuideData --> CheckTriggerCondition{判断是否需要<br/>触发引导?}\n    CheckTriggerCondition -->|否| Ignore[忽略]\n    CheckTriggerCondition -->|是| SelectGuide{选择引导<br/>根据优先级/进度}\n    \n    SelectGuide --> CheckGuideProgress{检查引导进度<br/>未开始/进行中/已完成}\n    CheckGuideProgress -->|已完成| Ignore\n    CheckGuideProgress -->|未开始/进行中| SelectStep{选择步骤<br/>下一步骤/分支步骤}\n    \n    SelectStep --> EnhanceContext[增强GuideContext<br/>+guideData/stepData/selectedStep]\n    EnhanceContext --> MessageBusToExecution[通过MessageChannel<br/>1对1消息传递]\n    MessageBusToExecution --> ExecutionLayer[执行层]\n    \n    style CheckTriggerCondition fill:#fff4e1,stroke:#333,stroke-width:2px\n    style SelectGuide fill:#fff4e1,stroke:#333,stroke-width:2px\n    style CheckGuideProgress fill:#fff4e1,stroke:#333,stroke-width:2px\n    style SelectStep fill:#fff4e1,stroke:#333,stroke-width:2px\n    style DecisionLayer fill:#fff4e1\n    style MessageBus fill:#c8e6c9\n    style MessageBusToExecution fill:#c8e6c9\n```\n\n### 核心组件\n\n1. **消息接收器（MessageReceiver）**\n   - 订阅MessageChannel，接收感知层发送的GuideContext\n   - 解析sensorData，提取目标ID、触发类型等信息\n\n2. **引导查询器（GuideQuery）**\n   - 根据sensorData查询数据层，获取GuideData和GuideStepData\n   - 支持按目标ID、触发类型、引导ID查询\n\n3. **条件判断器（ConditionChecker）**\n   - 判断是否需要触发引导（是否已完成、是否满足条件）\n   - 检查前置引导、等级、任务等条件\n   - 过滤已完成的引导\n\n4. **引导选择器（GuideSelector）**\n   - 根据sensorData匹配对应的引导ID\n   - 支持多个引导同时满足时的优先级选择\n   - 检查引导进度（未开始/进行中/已完成）\n\n5. **步骤选择器（StepSelector）**\n   - 根据引导进度选择下一步骤\n   - 支持步骤依赖关系检查\n   - 处理步骤跳转和分支逻辑\n\n6. **上下文增强器（ContextEnhancer）**\n   - 将查询到的GuideData、GuideStepData、selectedStep添加到GuideContext\n   - 形成完整的执行上下文\n   - 通过MessageChannel发送给执行层\n\n### 数据流增强过程\n\n```\nGuideContext（感知层）\n  + sensorData（目标ID、触发类型、时间戳）\n  ↓\n  + guideData（引导配置、引导ID、引导状态）\n  + stepData（步骤配置、步骤列表）\n  + selectedStep（选中的步骤ID、步骤类型）\n  ↓\nGuideContext（执行层）\n```\n\n---\n\n## 执行层架构设计\n\n### 核心职责\n接收执行上下文 → 解析步骤类型 → 执行引导步骤 → 更新步骤状态\n\n### 工作流程\n\n```mermaid\nflowchart TD\n    DecisionLayer[决策层] --> MessageBusFromDecision[CommunicationBus<br/>MessageChannel]\n    MessageBusFromDecision --> ExecutionLayer[执行层<br/>持有Context]\n    \n    ExecutionLayer --> ParseStepData[解析selectedStep<br/>提取步骤类型/参数]\n    ParseStepData --> SelectExecutor{选择执行器<br/>根据步骤类型}\n    \n    SelectExecutor --> ClickExecutor[点击执行器<br/>高亮/引导箭头]\n    SelectExecutor --> DialogueExecutor[对话执行器<br/>显示对话/等待确认]\n    SelectExecutor --> DragExecutor[拖拽执行器<br/>高亮源/目标/路径]\n    SelectExecutor --> OtherExecutor[其他执行器<br/>...]\n    \n    ClickExecutor --> WaitForUserAction{等待用户操作<br/>异步执行}\n    DialogueExecutor --> WaitForUserAction\n    DragExecutor --> WaitForUserAction\n    OtherExecutor --> WaitForUserAction\n    \n    WaitForUserAction --> DetectCompletion{检测步骤完成<br/>用户操作/自动完成}\n    DetectCompletion -->|步骤完成| UpdateContextState[直接更新Context<br/>步骤状态/stepResult]\n    DetectCompletion -->|未完成/超时| HandleError[处理错误/超时]\n    \n    UpdateContextState --> StateFuncs[Context状态变化<br/>自动触发状态函数群]\n    StateFuncs --> Manager[管理层]\n    \n    style SelectExecutor fill:#fff4e1,stroke:#333,stroke-width:2px\n    style WaitForUserAction fill:#fff4e1,stroke:#333,stroke-width:2px\n    style DetectCompletion fill:#fff4e1,stroke:#333,stroke-width:2px\n    style ExecutionLayer fill:#c8e6c9\n    style MessageBusFromDecision fill:#fff4e1\n    style UpdateContextState fill:#e1f5ff\n```\n\n### 核心组件\n\n1. **消息接收器（MessageReceiver）**\n   - 订阅MessageChannel，接收决策层发送的GuideContext\n   - 解析guideData、stepData、selectedStep\n\n2. **步骤解析器（StepParser）**\n   - 解析selectedStep，提取步骤类型（点击/对话/拖拽等）\n   - 提取步骤参数（目标对象、提示文本、操作方式等）\n\n3. **执行器组（Executors）**\n   - **点击执行器（ClickExecutor）**：执行点击引导步骤\n     - 高亮目标UI按钮\n     - 显示引导箭头/遮罩\n     - 等待用户点击\n     - 检测点击完成\n   - **对话执行器（DialogueExecutor）**：执行对话引导步骤\n     - 显示对话内容\n     - 等待用户确认\n     - 检测对话完成\n   - **拖拽执行器（DragExecutor）**：执行拖拽引导步骤\n     - 高亮拖拽源和目标\n     - 显示拖拽路径提示\n     - 等待用户拖拽\n     - 检测拖拽完成\n   - **其他执行器**：可扩展的执行器类型\n\n4. **完成检测器（CompletionDetector）**\n   - 检测步骤是否完成（用户操作/自动完成）\n   - 支持多种完成条件（点击完成、时间完成、条件满足等）\n   - 触发步骤状态更新\n\n5. **状态更新器（StateUpdater）**\n   - 步骤完成后直接更新Context中的步骤状态\n   - Context状态变化自动触发状态函数群\n   - 执行层持有Context，直接修改状态\n\n### 执行层特点\n\n- ✅ **持有Context**：执行层持有GuideContext，可直接更新步骤状态\n- ✅ **状态自动触发**：Context状态变化自动触发状态函数群（见状态更新流程）\n- ✅ **多类型执行器**：支持点击、对话、拖拽等多种步骤类型\n- ✅ **异步执行**：支持等待用户操作的异步执行模式\n- ✅ **完成检测**：自动检测步骤完成，无需手动通知\n\n### 数据流增强过程\n\n```\nGuideContext（决策层）\n  + guideData + stepData + selectedStep\n  ↓\n  + stepResult（步骤执行结果、完成状态）\n  ↓\nGuideContext（管理层）\n```\n\n---\n\n## 管理层+数据层架构设计\n\n### 核心职责\n状态管理 + 数据持久化 + 状态函数触发\n\n### 架构图\n\n```mermaid\ngraph TB\n    subgraph DataLayer[\"数据层\"]\n        GuideData[\"引导数据<br/>GuideData\"]\n        StepData[\"引导步骤数据<br/>GuideStepData\"]\n    end\n    \n    subgraph ManagementLayer[\"管理层\"]\n        StateManager[\"状态管理器<br/>StateManager\"]\n        GuideContext[\"引导上下文<br/>GuideContext<br/>{引导状态, 步骤状态}\"]\n    end\n    \n    subgraph StateFuncs[\"状态函数群\"]\n        GuideStateFuncs[\"引导状态函数群<br/>GuideStateFuncs\"]\n        GuideStepStateFuncs[\"引导步骤函数群<br/>GuideStepStateFuncs\"]\n    end\n    \n    StateManager -->|读取| GuideData\n    StateManager -->|读取| StepData\n    StateManager -->|轮询检测状态变更| GuideContext\n    StateManager -->|写入| GuideData\n    StateManager -->|写入| StepData\n    \n    GuideContext -->|状态变化| StateFuncs\n    \n    StateFuncs --> |更新最新引导数据|StateManager\n\n    style DataLayer fill:#e1f5ff\n    style ManagementLayer fill:#f3e5f5\n```\n\n### 状态及数据更新流程\n\n```mermaid\nflowchart TD\n    ExecutionLayer[执行层<br/>持有Context]\n    Context[Context]\n    StateFuncs[状态函数群]\n    StateFunc[状态函数]\n    Decision{判断是否是<br/>引导的最后一步?}\n    NextStep[触发下一个步骤]\n    NextGuide[触发下一个引导]\n    Manager[管理层]\n    \n    ExecutionLayer -->|步骤完成<br/>直接更新步骤状态| Context\n    Context -.状态变化<br/>自动触发.-> StateFuncs\n    StateFuncs -->|调用| StateFunc\n    StateFunc --> Decision\n    Decision -->|是| NextGuide\n    Decision -->|否| NextStep\n    NextGuide -->|更新最新引导数据| Manager\n    NextStep -->|更新最新引导数据| Manager\n    \n    Manager -.轮询检测.-> Context\n\n    style Decision fill:#fff4e1,stroke:#333,stroke-width:2px\n    style ExecutionLayer fill:#c8e6c9\n    style Manager fill:#f3e5f5\n```\n\n### 核心组件\n\n1. **状态管理器（StateManager）**\n   - 读取和写入GuideData、StepData\n   - 轮询检测GuideContext的状态变更\n   - 管理引导和步骤的状态生命周期\n\n2. **状态函数群（StateFuncs）**\n   - **引导状态函数群（GuideStateFuncs）**：处理引导状态变化\n   - **引导步骤函数群（GuideStepStateFuncs）**：处理步骤状态变化\n   - 使用策略模式：`[State1] = self.State1Func, [State2] = self.State2Func`\n   - Context状态变化自动触发对应的状态函数\n\n3. **状态函数（StateFunc）**\n   - 判断是否是引导的最后一步\n   - 如果是最后一步 → 触发下一个引导\n   - 如果不是最后一步 → 触发下一个步骤\n   - 更新最新引导数据到StateManager\n\n### 数据层设计\n\n1. **引导数据（GuideData）**\n   - 引导ID、引导名称、引导状态\n   - 引导优先级、触发条件、依赖关系\n   - 引导配置（可跳过、分支条件等）\n\n2. **引导步骤数据（GuideStepData）**\n   - 步骤ID、步骤类型、步骤状态\n   - 步骤参数（目标对象、提示文本等）\n   - 步骤配置（超时时间、恢复策略等）\n\n---\n\n## 高级特性：引导中断与恢复机制\n\n### 核心本质：Context维护\n\n**设计理念**：插入新引导 = 维护Context栈，中断旧引导 = 保存旧Context，恢复旧引导 = 恢复旧Context\n\n### 架构图\n\n```mermaid\ngraph TB\n    subgraph ContextStack[\"Context栈管理\"]\n        CurrentContext[当前Context<br/>正在执行的引导]\n        ContextStack_Data[Context栈<br/>保存中断的引导]\n    end\n    \n    NewGuide[新引导需要立即执行] --> CheckPriority{检查优先级}\n    CheckPriority -->|高优先级| Save[保存当前Context到栈]\n    CheckPriority -->|低优先级| Ignore[忽略，继续当前引导]\n    \n    Save --> Switch[切换到新Context]\n    Switch --> Execute[执行新引导]\n    \n    Execute --> Complete{新引导完成}\n    Complete -->|需要恢复| Restore[从栈恢复旧Context]\n    Complete -->|不需要恢复| Clear[清空栈，继续新流程]\n    \n    Restore --> Resume[恢复旧引导执行]\n    \n    style CheckPriority fill:#fff4e1,stroke:#333,stroke-width:2px\n    style Complete fill:#fff4e1,stroke:#333,stroke-width:2px\n    style ContextStack_Data fill:#e1f5ff\n    style CurrentContext fill:#c8e6c9\n```\n\n### 工作流程\n\n```mermaid\nflowchart TD\n    OldContext[当前Context<br/>旧引导执行中] --> NewTrigger[新引导触发<br/>高优先级]\n    \n    NewTrigger --> Save[保存当前Context<br/>push到栈]\n    Save --> Create[创建新Context<br/>新引导]\n    Create --> Switch[切换到新Context]\n    \n    Switch --> Execute[执行新引导]\n    Execute --> Complete{新引导完成}\n    \n    Complete -->|需要恢复| Pop[从栈pop旧Context]\n    Complete -->|不需要恢复| End[结束，清空栈]\n    \n    Pop --> Restore[恢复旧Context<br/>current = pop的Context]\n    Restore --> Resume[继续执行旧引导]\n    \n    style Complete fill:#fff4e1,stroke:#333,stroke-width:2px\n    style Save fill:#c8e6c9\n    style Restore fill:#e1f5ff\n```\n\n### 核心机制\n\n1. **Context栈（ContextStack）**\n   - 保存被中断的引导Context\n   - 支持多层中断（引导A → 引导B → 引导C）\n   - 栈结构：后进先出（LIFO）\n\n2. **优先级判断**\n   - 新引导优先级 > 当前引导优先级 → 中断并保存\n   - 新引导优先级 ≤ 当前引导优先级 → 忽略或排队\n\n3. **Context切换**\n   - 保存当前Context到栈\n   - 创建新Context并切换\n   - 执行层持有新Context\n\n4. **Context恢复**\n   - 新引导完成后，从栈弹出旧Context\n   - 恢复旧引导的执行状态\n   - 继续执行旧引导的下一步\n\n### 核心组件\n\n1. **Context栈管理器（ContextStackManager）**\n   - 管理Context栈（push/pop/peek）\n   - 保存和恢复Context状态\n   - 支持多层中断嵌套\n\n2. **优先级判断器（PriorityChecker）**\n   - 比较新引导和当前引导的优先级\n   - 决定是否中断当前引导\n   - 支持优先级配置\n\n3. **Context切换器（ContextSwitcher）**\n   - 保存当前Context到栈\n   - 创建并切换到新Context\n   - 更新执行层持有的Context\n\n4. **Context恢复器（ContextRestorer）**\n   - 从栈恢复旧Context\n   - 恢复引导执行状态\n   - 继续执行旧引导\n\n### 设计优势\n\n- ✅ **本质简单**：核心就是Context的保存和恢复\n- ✅ **支持嵌套**：支持多层引导中断（A→B→C）\n- ✅ **状态完整**：保存完整的Context状态，恢复时无缝衔接\n- ✅ **灵活控制**：通过优先级控制中断行为\n\n---\n\n## 健壮性机制：环境变化与卡死防护\n\n### 核心本质：Context状态监控 + 超时检测\n\n**问题场景**：\n- 引导需要UI按钮，但UI未加载完成 → 卡死\n- 引导需要NPC，但NPC未生成 → 卡死\n- 引导需要场景，但场景未切换完成 → 卡死\n- 引导需要功能，但功能被禁用 → 卡死\n\n**设计理念**：Context状态监控 + 超时检测 + 自动恢复\n\n### 工作流程\n\n```mermaid\nflowchart TD\n    CurrentStep[当前引导步骤执行中] --> EnvCheck{环境是否就绪?<br/>目标/功能/UI}\n    EnvCheck -->|未就绪| TimeoutCheck{是否超时?}\n    EnvCheck -->|已就绪| Continue[继续执行步骤]\n    \n    TimeoutCheck -->|未超时| Wait[等待环境就绪<br/>Context记录等待状态]\n    TimeoutCheck -->|已超时| RecoveryStrategy{执行恢复策略<br/>Context记录恢复策略}\n    \n    RecoveryStrategy --> Retry[重试<br/>Context记录重试次数]\n    RecoveryStrategy --> Skip[跳过当前步骤<br/>Context更新步骤状态]\n    RecoveryStrategy --> Cancel[取消当前引导<br/>Context更新引导状态]\n    \n    Retry --> EnvCheck\n    Skip --> NextStep[触发下一个步骤]\n    Cancel --> EndGuide[结束引导]\n    \n    style EnvCheck fill:#fff4e1,stroke:#333,stroke-width:2px\n    style TimeoutCheck fill:#fff4e1,stroke:#333,stroke-width:2px\n    style RecoveryStrategy fill:#fff4e1,stroke:#333,stroke-width:2px\n    style Wait fill:#e1f5ff\n    style Retry fill:#c8e6c9\n    style Skip fill:#c8e6c9\n    style Cancel fill:#c8e6c9\n```\n\n### 详细流程\n\n```mermaid\nflowchart TD\n    StepStart[步骤开始] --> Init[初始化Context<br/>记录startTime<br/>从StepData读取timeout]\n    \n    Init --> Check[环境检查器<br/>检查环境需求]\n    \n    Check -->|满足| Execute[执行步骤]\n    Check -->|不满足| Wait[等待环境就绪]\n    \n    Wait --> Timer[启动超时计时器]\n    Timer --> Poll[定期轮询检查环境]\n    \n    Poll -->|环境就绪| Execute\n    Poll -->|仍不满足| CheckTimeout{检查超时}\n    \n    CheckTimeout -->|未超时| Poll\n    CheckTimeout -->|已超时| Strategy[根据恢复策略处理]\n    \n    Execute --> Monitor[监控执行状态]\n    Monitor -->|完成| Success[成功]\n    Monitor -->|异常| Handle[异常处理]\n    Monitor -->|超时| Strategy\n    \n    Strategy -->|Retry| Retry[重试<br/>retryCount++]\n    Strategy -->|Skip| Skip[跳过步骤]\n    Strategy -->|Cancel| Cancel[取消引导]\n    \n    Retry -->|retryCount < maxRetryCount| Check\n    Retry -->|retryCount >= maxRetryCount| Cancel\n    \n    style CheckTimeout fill:#fff4e1,stroke:#333,stroke-width:2px\n    style Strategy fill:#fff4e1,stroke:#333,stroke-width:2px\n```\n\n### 核心机制\n\n1. **环境检查器（EnvironmentChecker）**\n   - 检查目标对象是否存在（UI按钮、NPC、场景等）\n   - 检查功能是否可用（功能解锁状态）\n   - 检查场景是否就绪（场景加载完成）\n   - 定期轮询检查（避免卡死）\n\n2. **超时检测器（TimeoutDetector）**\n   - 从StepData中读取超时时间（stepData.timeout）\n   - 执行层启动超时计时器（使用Context中的startTime）\n   - 超时后自动触发恢复机制\n   - 支持不同步骤设置不同超时时间\n\n3. **状态监控器（StateMonitor）**\n   - 监控步骤执行状态\n   - 检测异常情况（目标消失、功能禁用等）\n   - 触发异常处理机制\n\n4. **恢复策略（RecoveryStrategy）**\n   - **重试策略**：重新检查环境，环境就绪后重试\n   - **跳过策略**：跳过当前步骤，继续下一步\n   - **取消策略**：取消整个引导，清理状态\n   - 策略可在StepData中配置\n\n### 数据设计\n\n**静态配置数据（StepData中配置）**：\n```lua\n-- StepData中的健壮性配置（静态数据）\nStepData = {\n    -- ... 其他字段\n    \n    -- 健壮性静态配置\n    timeout = 30,              -- 超时时间（秒）\n    envRequirements = {        -- 环境需求\n        uiId = \"BackpackButton\",\n        npcId = \"NPC_001\",\n        sceneId = \"Scene_Town\"\n    },\n    recoveryStrategy = \"Retry\", -- 恢复策略：Retry/Skip/Cancel\n    maxRetryCount = 3          -- 最大重试次数\n}\n```\n\n**动态执行数据（Context中维护）**：\n```lua\n-- Context中增加健壮性相关动态字段\nGuideContext = {\n    -- ... 原有字段\n    \n    -- 健壮性动态字段（执行过程中维护）\n    startTime = os.time(),     -- 开始时间\n    retryCount = 0             -- 重试次数\n}\n```\n\n**数据来源**：\n- ✅ **静态配置**：从StepData中读取（timeout、envRequirements、recoveryStrategy、maxRetryCount）\n- ✅ **动态数据**：在Context中维护（startTime、retryCount）\n\n### 核心组件\n\n1. **环境检查器（EnvironmentChecker）**\n   - 检查目标对象存在性（UI、NPC、场景等）\n   - 检查功能可用性（功能解锁、场景就绪等）\n   - 支持自定义检查函数\n\n2. **超时检测器（TimeoutDetector）**\n   - 从StepData读取超时时间配置\n   - 在Context中记录步骤开始时间（startTime）\n   - 定期检查是否超时（当前时间 - startTime > timeout）\n   - 超时后触发恢复策略\n\n3. **状态监控器（StateMonitor）**\n   - 监控步骤执行状态\n   - 检测异常情况（目标消失、功能禁用）\n   - 触发异常处理\n\n4. **恢复策略处理器（RecoveryStrategyHandler）**\n   - 根据配置的恢复策略处理\n   - 支持重试、跳过、取消三种策略\n   - 重试次数限制，避免无限重试\n\n### 设计优势\n\n- ✅ **防止卡死**：超时检测 + 环境检查，避免无限等待\n- ✅ **自动恢复**：多种恢复策略，自动处理异常情况\n- ✅ **灵活配置**：超时时间、恢复策略可在StepData中配置\n- ✅ **状态完整**：Context记录完整状态，便于调试和恢复\n\n---\n\n## 数据驱动架构下的特性支持\n\n**核心理解**：在数据驱动架构下，以下特性通过配置数据即可实现，无需额外机制：\n\n| 特性 | 实现方式 | 说明 |\n|---|---|---|\n| **引导跳过** | GuideData中配置`canSkip`字段 | 状态函数判断`canSkip`，标记为已跳过 |\n| **引导分支** | StepData中配置分支条件和分支步骤 | 决策层根据条件选择不同的stepData |\n| **引导依赖** | GuideData中配置`dependencies`字段 | 决策层检查前置引导是否完成 |\n| **进度保存/恢复** | GuideData和StepData本身就是数据 | 管理层负责持久化，无需额外机制 |\n| **引导条件** | GuideData中配置触发条件 | 决策层检查条件，决定是否触发 |\n\n**设计优势**：\n- ✅ **配置驱动**：所有特性通过配置数据实现，无需额外代码\n- ✅ **灵活扩展**：新增特性只需扩展配置字段，无需修改架构\n- ✅ **统一管理**：所有引导特性统一在数据层管理\n\n---\n\n## 架构验证\n\n### 流程合理性验证\n\n从架构可验证：\n- ✅ **数据流完整**：感知层 → 决策层 → 执行层 → 管理层 → 感知层（循环）\n- ✅ **职责清晰**：每层职责明确，无重叠\n- ✅ **解耦设计**：通过CommunicationBus和Context实现层间解耦\n- ✅ **状态管理**：状态更新流程清晰，无循环依赖\n\n### 卡死问题验证\n\n从架构可验证：\n- ✅ **健壮性机制**：环境检查 + 超时检测 + 恢复策略\n- ✅ **状态监控**：Context状态监控，异常自动处理\n- ✅ **恢复机制**：重试/跳过/取消，避免无限等待\n- ✅ **环境检查**：定期轮询检查环境，避免卡死\n\n### 扩展性验证\n\n从架构可验证：\n- ✅ **数据驱动**：新特性通过配置数据扩展\n- ✅ **策略模式**：状态函数群支持灵活扩展\n- ✅ **管道过滤器**：每层可独立替换和扩展\n- ✅ **执行器扩展**：支持新增执行器类型\n\n### 完整性验证\n\n从架构可验证：\n- ✅ **五层架构**：覆盖引导全流程\n- ✅ **高级特性**：引导中断与恢复（Context栈）\n- ✅ **健壮性**：环境变化和卡死防护\n- ✅ **数据驱动**：引导特性通过配置实现\n\n---\n\n## 总结\n\n### 架构设计价值\n\n该架构设计文档的价值在于：\n- ✅ **思路解构**：完整解构引导系统的搭建思路\n- ✅ **流程验证**：从架构层面验证流程合理性\n- ✅ **问题识别**：提前识别潜在的卡死和异常问题\n- ✅ **开发指导**：为后续详细设计和实现提供清晰指导\n\n### 设计原则\n\n- ✅ **Context维护为核心**：引导系统的核心是Context的维护和管理\n- ✅ **数据驱动架构**：引导特性通过配置数据实现，无需额外机制\n- ✅ **管道过滤器模式**：数据在层间流动，每层作为过滤器处理\n- ✅ **解耦设计**：层间通过CommunicationBus和Context通信，不直接依赖\n\n### 架构特点\n\n- ✅ **单Context设计**：所有层使用统一的`GuideContext`，逐步增强\n- ✅ **1对1通讯**：使用MessageChannel实现层间1对1单向通讯\n- ✅ **状态自动触发**：Context状态变化自动触发状态函数群\n- ✅ **健壮性防护**：环境检查 + 超时检测 + 恢复策略，避免卡死\n\n细节实现是后续开发阶段的工作，当前架构设计已足够指导整个引导系统的开发。\n"
        }
    ]
}