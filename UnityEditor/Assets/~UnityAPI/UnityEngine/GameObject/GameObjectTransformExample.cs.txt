using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Unity GameObject 和 Transform 完整 API 示例
/// GameObject 是 Unity 场景中的基本对象，Transform 是 GameObject 的位置、旋转和缩放组件
/// </summary>
public class GameObjectTransformExample : MonoBehaviour
{
    [Header("查找设置")]
    [SerializeField] private string targetName = "Target";
    [SerializeField] private string targetTag = "Player";
    [SerializeField] private GameObject targetPrefab;
    
    [Header("Transform 设置")]
    [SerializeField] private Vector3 targetPosition = Vector3.zero;
    [SerializeField] private Vector3 targetRotation = Vector3.zero;
    [SerializeField] private Vector3 targetScale = Vector3.one;
    
    [Header("实例化设置")]
    [SerializeField] private int instantiateCount = 5;
    [SerializeField] private Vector3 spawnOffset = new Vector3(2, 0, 0);
    
    private List<GameObject> instantiatedObjects = new List<GameObject>();
    
    private void Start()
    {
        Debug.Log("=== Unity GameObject 和 Transform 完整 API 示例 ===");
        
        TestAllGameObjectFeatures();
        TestAllTransformFeatures();
    }
    
    #region 1. GameObject 查找操作
    
    /// <summary>
    /// 测试所有 GameObject 功能
    /// </summary>
    private void TestAllGameObjectFeatures()
    {
        Debug.Log("\n--- 1. GameObject 查找操作 ---");
        
        // 1.1 Find 查找
        TestGameObjectFind();
        
        // 1.2 FindWithTag 查找
        TestGameObjectFindWithTag();
        
        // 1.3 FindGameObjectsWithTag 查找多个
        TestGameObjectFindGameObjectsWithTag();
        
        Debug.Log("\n--- 2. GameObject 创建和销毁 ---");
        
        // 2.1 Instantiate 实例化
        TestInstantiate();
        
        // 2.2 Destroy 销毁
        TestDestroy();
        
        // 2.3 DestroyImmediate 立即销毁
        TestDestroyImmediate();
        
        Debug.Log("\n--- 3. GameObject 激活状态 ---");
        
        // 3.1 SetActive 激活/禁用
        TestSetActive();
        
        // 3.2 activeSelf / activeInHierarchy
        TestActiveState();
        
        Debug.Log("\n--- 4. GameObject 其他操作 ---");
        
        // 4.1 DontDestroyOnLoad
        TestDontDestroyOnLoad();
        
        // 4.2 name / tag / layer
        TestGameObjectProperties();
    }
    
    /// <summary>
    /// 1.1 GameObject.Find - 按名称查找
    /// 注意：性能较差，建议缓存结果或使用其他查找方式
    /// </summary>
    private void TestGameObjectFind()
    {
        Debug.Log("1.1 GameObject.Find - 按名称查找");
        
        // 查找指定名称的 GameObject
        GameObject found = GameObject.Find(targetName);
        
        if (found != null)
        {
            Debug.Log($"找到 GameObject: {found.name}");
        }
        else
        {
            Debug.Log($"未找到名称为 '{targetName}' 的 GameObject");
        }
        
        // 查找路径（使用 / 分隔）
        GameObject foundByPath = GameObject.Find("Parent/Child");
        if (foundByPath != null)
        {
            Debug.Log($"通过路径找到: {foundByPath.name}");
        }
        
        // 性能警告：GameObject.Find 会遍历场景中所有对象，性能较差
        // 建议：在 Start 中查找并缓存，或使用其他查找方式
    }
    
    /// <summary>
    /// 1.2 GameObject.FindWithTag - 按标签查找单个对象
    /// </summary>
    private void TestGameObjectFindWithTag()
    {
        Debug.Log("1.2 GameObject.FindWithTag - 按标签查找");
        
        GameObject found = GameObject.FindWithTag(targetTag);
        
        if (found != null)
        {
            Debug.Log($"找到标签为 '{targetTag}' 的 GameObject: {found.name}");
        }
        else
        {
            Debug.Log($"未找到标签为 '{targetTag}' 的 GameObject");
        }
    }
    
    /// <summary>
    /// 1.3 GameObject.FindGameObjectsWithTag - 按标签查找多个对象
    /// </summary>
    private void TestGameObjectFindGameObjectsWithTag()
    {
        Debug.Log("1.3 GameObject.FindGameObjectsWithTag - 按标签查找多个");
        
        GameObject[] foundObjects = GameObject.FindGameObjectsWithTag(targetTag);
        
        Debug.Log($"找到 {foundObjects.Length} 个标签为 '{targetTag}' 的 GameObject");
        
        foreach (GameObject obj in foundObjects)
        {
            Debug.Log($"  - {obj.name}");
        }
    }
    
    #endregion
    
    #region 2. GameObject 创建和销毁
    
    /// <summary>
    /// 2.1 Instantiate - 实例化 GameObject
    /// 可以实例化 Prefab、GameObject 或其他 Object
    /// </summary>
    private void TestInstantiate()
    {
        Debug.Log("2.1 Instantiate - 实例化 GameObject");
        
        if (targetPrefab != null)
        {
            // 方式1：基本实例化
            GameObject instance1 = Instantiate(targetPrefab);
            instantiatedObjects.Add(instance1);
            Debug.Log($"实例化 GameObject: {instance1.name}");
            
            // 方式2：指定位置和旋转
            Vector3 position = transform.position + spawnOffset;
            Quaternion rotation = Quaternion.identity;
            GameObject instance2 = Instantiate(targetPrefab, position, rotation);
            instantiatedObjects.Add(instance2);
            Debug.Log($"在位置 {position} 实例化 GameObject");
            
            // 方式3：指定父对象
            GameObject instance3 = Instantiate(targetPrefab, transform);
            instantiatedObjects.Add(instance3);
            Debug.Log($"作为子对象实例化");
            
            // 方式4：指定位置、旋转和父对象
            GameObject instance4 = Instantiate(targetPrefab, position, rotation, transform);
            instantiatedObjects.Add(instance4);
            Debug.Log($"完整参数实例化");
        }
        else
        {
            // 创建空的 GameObject
            GameObject newObject = new GameObject("NewGameObject");
            instantiatedObjects.Add(newObject);
            Debug.Log("创建新的空 GameObject");
        }
    }
    
    /// <summary>
    /// 2.2 Destroy - 销毁 GameObject
    /// 在帧结束时销毁，可以指定延迟时间
    /// </summary>
    private void TestDestroy()
    {
        Debug.Log("2.2 Destroy - 销毁 GameObject");
        
        if (instantiatedObjects.Count > 0)
        {
            GameObject toDestroy = instantiatedObjects[0];
            
            // 立即销毁（在帧结束时）
            Destroy(toDestroy);
            instantiatedObjects.Remove(toDestroy);
            Debug.Log($"销毁 GameObject: {toDestroy.name}");
            
            // 延迟销毁
            if (instantiatedObjects.Count > 0)
            {
                GameObject toDestroyDelayed = instantiatedObjects[0];
                Destroy(toDestroyDelayed, 2.0f); // 2秒后销毁
                instantiatedObjects.Remove(toDestroyDelayed);
                Debug.Log($"将在 2 秒后销毁: {toDestroyDelayed.name}");
            }
        }
    }
    
    /// <summary>
    /// 2.3 DestroyImmediate - 立即销毁
    /// 注意：只能在编辑器中或 Destroy 不可用时使用
    /// </summary>
    private void TestDestroyImmediate()
    {
        Debug.Log("2.3 DestroyImmediate - 立即销毁");
        
        // DestroyImmediate 会立即销毁对象，不等待帧结束
        // 注意：运行时使用 Destroy，编辑器中可以使用 DestroyImmediate
        
        #if UNITY_EDITOR
        if (instantiatedObjects.Count > 0)
        {
            GameObject toDestroy = instantiatedObjects[0];
            DestroyImmediate(toDestroy);
            instantiatedObjects.Remove(toDestroy);
            Debug.Log($"立即销毁 GameObject: {toDestroy.name}");
        }
        #endif
    }
    
    #endregion
    
    #region 3. GameObject 激活状态
    
    /// <summary>
    /// 3.1 SetActive - 激活/禁用 GameObject
    /// </summary>
    private void TestSetActive()
    {
        Debug.Log("3.1 SetActive - 激活/禁用");
        
        if (instantiatedObjects.Count > 0)
        {
            GameObject obj = instantiatedObjects[0];
            
            // 禁用
            obj.SetActive(false);
            Debug.Log($"禁用 GameObject: {obj.name}, activeSelf: {obj.activeSelf}");
            
            // 激活
            obj.SetActive(true);
            Debug.Log($"激活 GameObject: {obj.name}, activeSelf: {obj.activeSelf}");
        }
    }
    
    /// <summary>
    /// 3.2 activeSelf / activeInHierarchy
    /// activeSelf: 对象自身的激活状态
    /// activeInHierarchy: 对象在层级中的实际激活状态（考虑父对象）
    /// </summary>
    private void TestActiveState()
    {
        Debug.Log("3.2 activeSelf / activeInHierarchy");
        
        if (instantiatedObjects.Count > 0)
        {
            GameObject obj = instantiatedObjects[0];
            
            Debug.Log($"activeSelf: {obj.activeSelf}"); // 自身状态
            Debug.Log($"activeInHierarchy: {obj.activeInHierarchy}"); // 层级中的实际状态
            
            // 如果父对象被禁用，即使子对象 activeSelf = true，activeInHierarchy 也会是 false
            if (obj.transform.parent != null)
            {
                obj.transform.parent.gameObject.SetActive(false);
                Debug.Log($"父对象禁用后 - activeSelf: {obj.activeSelf}, activeInHierarchy: {obj.activeInHierarchy}");
                obj.transform.parent.gameObject.SetActive(true);
            }
        }
    }
    
    #endregion
    
    #region 4. GameObject 其他操作
    
    /// <summary>
    /// 4.1 DontDestroyOnLoad - 场景切换时不销毁
    /// 常用于单例对象、游戏管理器等
    /// </summary>
    private void TestDontDestroyOnLoad()
    {
        Debug.Log("4.1 DontDestroyOnLoad - 场景切换不销毁");
        
        GameObject persistentObject = new GameObject("PersistentObject");
        DontDestroyOnLoad(persistentObject);
        Debug.Log("设置 GameObject 在场景切换时不销毁");
        
        // 注意：DontDestroyOnLoad 的对象会保留到新场景中
        // 常用于：游戏管理器、音频管理器、数据管理器等
    }
    
    /// <summary>
    /// 4.2 GameObject 属性：name / tag / layer
    /// </summary>
    private void TestGameObjectProperties()
    {
        Debug.Log("4.2 GameObject 属性");
        
        Debug.Log($"当前 GameObject 名称: {gameObject.name}");
        Debug.Log($"当前 GameObject 标签: {gameObject.tag}");
        Debug.Log($"当前 GameObject 层级: {gameObject.layer}");
        
        // 修改属性
        gameObject.name = "RenamedObject";
        // gameObject.tag = "NewTag"; // 需要先在 Tag Manager 中定义
        // gameObject.layer = 5; // 设置层级
        
        Debug.Log($"修改后的名称: {gameObject.name}");
    }
    
    #endregion
    
    #region 5. Transform 位置操作
    
    /// <summary>
    /// 测试所有 Transform 功能
    /// </summary>
    private void TestAllTransformFeatures()
    {
        Debug.Log("\n--- 5. Transform 位置操作 ---");
        
        // 5.1 position / localPosition
        TestTransformPosition();
        
        // 5.2 rotation / localRotation
        TestTransformRotation();
        
        // 5.3 scale / localScale
        TestTransformScale();
        
        Debug.Log("\n--- 6. Transform 父子关系 ---");
        
        // 6.1 parent / root
        TestTransformParent();
        
        // 6.2 childCount / GetChild
        TestTransformChildren();
        
        Debug.Log("\n--- 7. Transform 变换方法 ---");
        
        // 7.1 Translate / Rotate / LookAt
        TestTransformMethods();
        
        Debug.Log("\n--- 8. Transform 其他操作 ---");
        
        // 8.1 SetParent
        TestSetParent();
        
        // 8.2 Find
        TestTransformFind();
    }
    
    /// <summary>
    /// 5.1 position / localPosition
    /// position: 世界坐标位置
    /// localPosition: 相对于父对象的本地位置
    /// </summary>
    private void TestTransformPosition()
    {
        Debug.Log("5.1 position / localPosition");
        
        Transform t = transform;
        
        // 获取世界坐标位置
        Vector3 worldPos = t.position;
        Debug.Log($"世界坐标位置: {worldPos}");
        
        // 获取本地坐标位置
        Vector3 localPos = t.localPosition;
        Debug.Log($"本地坐标位置: {localPos}");
        
        // 设置世界坐标位置
        t.position = targetPosition;
        Debug.Log($"设置世界坐标位置: {targetPosition}");
        
        // 设置本地坐标位置
        t.localPosition = Vector3.zero;
        Debug.Log("设置本地坐标位置为原点");
    }
    
    /// <summary>
    /// 5.2 rotation / localRotation
    /// rotation: 世界坐标旋转（Quaternion）
    /// localRotation: 相对于父对象的本地旋转
    /// eulerAngles: 欧拉角（Vector3，用于显示和设置）
    /// </summary>
    private void TestTransformRotation()
    {
        Debug.Log("5.2 rotation / localRotation");
        
        Transform t = transform;
        
        // 获取旋转（Quaternion）
        Quaternion worldRot = t.rotation;
        Debug.Log($"世界坐标旋转（Quaternion）: {worldRot}");
        
        // 获取欧拉角
        Vector3 eulerAngles = t.eulerAngles;
        Debug.Log($"欧拉角: {eulerAngles}");
        
        // 设置旋转（使用欧拉角）
        t.eulerAngles = targetRotation;
        Debug.Log($"设置欧拉角: {targetRotation}");
        
        // 设置旋转（使用 Quaternion）
        t.rotation = Quaternion.Euler(targetRotation);
        Debug.Log("使用 Quaternion 设置旋转");
        
        // 本地旋转
        t.localRotation = Quaternion.identity;
        Debug.Log("设置本地旋转为单位旋转");
    }
    
    /// <summary>
    /// 5.3 scale / localScale
    /// scale: 世界坐标缩放（只读，通过 localScale 设置）
    /// localScale: 相对于父对象的本地缩放
    /// </summary>
    private void TestTransformScale()
    {
        Debug.Log("5.3 scale / localScale");
        
        Transform t = transform;
        
        // 获取世界坐标缩放（只读）
        Vector3 worldScale = t.lossyScale;
        Debug.Log($"世界坐标缩放: {worldScale}");
        
        // 获取本地缩放
        Vector3 localScale = t.localScale;
        Debug.Log($"本地缩放: {localScale}");
        
        // 设置本地缩放
        t.localScale = targetScale;
        Debug.Log($"设置本地缩放: {targetScale}");
    }
    
    #endregion
    
    #region 6. Transform 父子关系
    
    /// <summary>
    /// 6.1 parent / root
    /// parent: 父对象 Transform
    /// root: 根对象 Transform
    /// </summary>
    private void TestTransformParent()
    {
        Debug.Log("6.1 parent / root");
        
        Transform t = transform;
        
        // 获取父对象
        Transform parent = t.parent;
        if (parent != null)
        {
            Debug.Log($"父对象: {parent.name}");
        }
        else
        {
            Debug.Log("没有父对象（根对象）");
        }
        
        // 获取根对象
        Transform root = t.root;
        Debug.Log($"根对象: {root.name}");
    }
    
    /// <summary>
    /// 6.2 childCount / GetChild
    /// childCount: 子对象数量
    /// GetChild: 获取指定索引的子对象
    /// </summary>
    private void TestTransformChildren()
    {
        Debug.Log("6.2 childCount / GetChild");
        
        Transform t = transform;
        
        int childCount = t.childCount;
        Debug.Log($"子对象数量: {childCount}");
        
        // 遍历所有子对象
        for (int i = 0; i < childCount; i++)
        {
            Transform child = t.GetChild(i);
            Debug.Log($"子对象 {i}: {child.name}");
        }
        
        // 获取第一个子对象
        if (childCount > 0)
        {
            Transform firstChild = t.GetChild(0);
            Debug.Log($"第一个子对象: {firstChild.name}");
        }
    }
    
    #endregion
    
    #region 7. Transform 变换方法
    
    /// <summary>
    /// 7.1 Translate / Rotate / LookAt
    /// Translate: 平移
    /// Rotate: 旋转
    /// LookAt: 看向目标
    /// </summary>
    private void TestTransformMethods()
    {
        Debug.Log("7.1 Translate / Rotate / LookAt");
        
        Transform t = transform;
        
        // Translate - 平移
        t.Translate(Vector3.forward * 2.0f);
        Debug.Log("向前平移 2 个单位");
        
        // Translate - 相对自身坐标系
        t.Translate(Vector3.right * 1.0f, Space.Self);
        Debug.Log("相对自身向右平移 1 个单位");
        
        // Translate - 世界坐标系
        t.Translate(Vector3.up * 1.0f, Space.World);
        Debug.Log("世界坐标系向上平移 1 个单位");
        
        // Rotate - 旋转
        t.Rotate(Vector3.up, 90.0f);
        Debug.Log("绕 Y 轴旋转 90 度");
        
        // Rotate - 相对自身
        t.Rotate(Vector3.forward, 45.0f, Space.Self);
        Debug.Log("相对自身绕 Z 轴旋转 45 度");
        
        // LookAt - 看向目标
        if (Camera.main != null)
        {
            t.LookAt(Camera.main.transform);
            Debug.Log("看向主相机");
        }
        
        // LookAt - 指定位置
        t.LookAt(targetPosition);
        Debug.Log($"看向位置: {targetPosition}");
    }
    
    #endregion
    
    #region 8. Transform 其他操作
    
    /// <summary>
    /// 8.1 SetParent - 设置父对象
    /// </summary>
    private void TestSetParent()
    {
        Debug.Log("8.1 SetParent - 设置父对象");
        
        if (instantiatedObjects.Count > 1)
        {
            GameObject child = instantiatedObjects[0];
            GameObject parent = instantiatedObjects[1];
            
            // 设置父对象
            child.transform.SetParent(parent.transform);
            Debug.Log($"设置 {child.name} 的父对象为 {parent.name}");
            
            // 设置父对象并保持世界坐标
            child.transform.SetParent(parent.transform, true);
            Debug.Log("设置父对象并保持世界坐标");
            
            // 移除父对象
            child.transform.SetParent(null);
            Debug.Log("移除父对象");
        }
    }
    
    /// <summary>
    /// 8.2 Transform.Find - 查找子对象
    /// </summary>
    private void TestTransformFind()
    {
        Debug.Log("8.2 Transform.Find - 查找子对象");
        
        Transform t = transform;
        
        // 查找直接子对象
        Transform found = t.Find("ChildName");
        if (found != null)
        {
            Debug.Log($"找到子对象: {found.name}");
        }
        
        // 查找路径（使用 / 分隔）
        Transform foundByPath = t.Find("Parent/Child");
        if (foundByPath != null)
        {
            Debug.Log($"通过路径找到: {foundByPath.name}");
        }
    }
    
    #endregion
    
    private void OnDestroy()
    {
        // 清理实例化的对象
        foreach (GameObject obj in instantiatedObjects)
        {
            if (obj != null)
            {
                Destroy(obj);
            }
        }
        instantiatedObjects.Clear();
    }
}

#region 最佳实践总结

/*
 * Unity GameObject 和 Transform 最佳实践：
 * 
 * 1. GameObject 查找：
 *    - GameObject.Find: 性能较差，建议缓存结果
 *    - FindWithTag: 比 Find 稍好，但仍需遍历
 *    - 最佳实践：在 Start 中查找并缓存，或使用引用
 * 
 * 2. 实例化和销毁：
 *    - Instantiate: 运行时创建对象
 *    - Destroy: 在帧结束时销毁（推荐）
 *    - DestroyImmediate: 立即销毁（仅编辑器）
 *    - 注意：频繁创建销毁会产生 GC，使用对象池优化
 * 
 * 3. 激活状态：
 *    - SetActive(false): 禁用对象（仍占用内存）
 *    - activeSelf: 自身激活状态
 *    - activeInHierarchy: 层级中的实际激活状态
 *    - 注意：禁用对象不会执行 Update，但仍占用内存
 * 
 * 4. Transform 位置：
 *    - position: 世界坐标（推荐用于移动）
 *    - localPosition: 本地坐标（相对于父对象）
 *    - 注意：修改 position 会触发物理更新
 * 
 * 5. Transform 旋转：
 *    - rotation: Quaternion（推荐，无万向锁）
 *    - eulerAngles: Vector3（易读，但有万向锁问题）
 *    - 注意：优先使用 Quaternion 进行旋转计算
 * 
 * 6. Transform 缩放：
 *    - localScale: 本地缩放
 *    - lossyScale: 世界缩放（只读）
 *    - 注意：缩放会影响碰撞体大小
 * 
 * 7. 父子关系：
 *    - SetParent: 设置父对象
 *    - parent: 获取父对象
 *    - root: 获取根对象
 *    - 注意：子对象会跟随父对象变换
 * 
 * 8. 性能优化：
 *    - 缓存 Transform 引用（transform 是属性，有开销）
 *    - 避免频繁查找 GameObject
 *    - 使用对象池减少 Instantiate/Destroy
 *    - 批量操作时使用 Transform.SetParent(null, false)
 * 
 * 9. DontDestroyOnLoad：
 *    - 场景切换时不销毁
 *    - 常用于：单例、管理器、持久化数据
 *    - 注意：需要手动管理生命周期
 */

#endregion

