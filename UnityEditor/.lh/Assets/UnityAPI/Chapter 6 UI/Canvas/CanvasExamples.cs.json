{
    "sourceFile": "Assets/UnityAPI/Chapter 6 UI/Canvas/CanvasExamples.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1750928568375,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750928655766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,9 @@\n using UnityEngine;\r\n using UnityEngine.UI;\r\n+using UnityEngine.EventSystems;\r\n using System.Collections;\r\n+using System.Collections.Generic;\r\n \r\n /// <summary>\r\n /// Canvas API使用案例\r\n /// 演示Canvas组件的各种功能\r\n"
                }
            ],
            "date": 1750928568375,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing UnityEngine.UI;\r\nusing System.Collections;\r\n\r\n/// <summary>\r\n/// Canvas API使用案例\r\n/// 演示Canvas组件的各种功能\r\n/// </summary>\r\npublic class CanvasExamples : MonoBehaviour\r\n{\r\n    [Header(\"Canvas设置\")]\r\n    [SerializeField] private Canvas targetCanvas;\r\n    [SerializeField] private Canvas[] additionalCanvases;\r\n    \r\n    [Header(\"渲染模式\")]\r\n    [SerializeField] private RenderMode renderMode = RenderMode.ScreenSpaceOverlay;\r\n    [SerializeField] private Camera renderCamera;\r\n    [SerializeField] private int sortingOrder = 0;\r\n    [SerializeField] private int targetDisplay = 0;\r\n    \r\n    [Header(\"缩放设置\")]\r\n    [SerializeField] private CanvasScaler.ScaleMode scaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;\r\n    [SerializeField] private Vector2 referenceResolution = new Vector2(1920, 1080);\r\n    [SerializeField] private float matchWidthOrHeight = 0.5f;\r\n    [SerializeField] private float scaleFactor = 1f;\r\n    \r\n    [Header(\"UI元素\")]\r\n    [SerializeField] private GameObject[] uiElements;\r\n    [SerializeField] private Button[] buttons;\r\n    [SerializeField] private Text[] texts;\r\n    [SerializeField] private Image[] images;\r\n    \r\n    [Header(\"动态创建\")]\r\n    [SerializeField] private bool createDynamicUI = true;\r\n    [SerializeField] private GameObject uiPrefab;\r\n    [SerializeField] private int dynamicElementCount = 5;\r\n    \r\n    [Header(\"动画效果\")]\r\n    [SerializeField] private bool enableAnimations = true;\r\n    [SerializeField] private float animationDuration = 1f;\r\n    [SerializeField] private AnimationCurve animationCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);\r\n    \r\n    [Header(\"交互设置\")]\r\n    [SerializeField] private bool enableRaycast = true;\r\n    [SerializeField] private bool enableInput = true;\r\n    [SerializeField] private bool enableKeyboardNavigation = true;\r\n    \r\n    private bool isInitialized = false;\r\n    private CanvasScaler canvasScaler;\r\n    private GraphicRaycaster graphicRaycaster;\r\n    private List<GameObject> dynamicElements = new List<GameObject>();\r\n    private Vector3[] originalPositions;\r\n    private Vector3[] originalScales;\r\n    \r\n    private void Start()\r\n    {\r\n        InitializeCanvas();\r\n        DemonstrateCanvasBasics();\r\n        DemonstrateCanvasRendering();\r\n        DemonstrateCanvasScaling();\r\n        DemonstrateCanvasInteraction();\r\n        DemonstrateDynamicUI();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 初始化Canvas\r\n    /// </summary>\r\n    private void InitializeCanvas()\r\n    {\r\n        // 如果没有指定目标Canvas，使用自身的Canvas\r\n        if (targetCanvas == null)\r\n        {\r\n            targetCanvas = GetComponent<Canvas>();\r\n            \r\n            if (targetCanvas == null)\r\n            {\r\n                targetCanvas = gameObject.AddComponent<Canvas>();\r\n            }\r\n        }\r\n        \r\n        // 获取或添加CanvasScaler\r\n        canvasScaler = targetCanvas.GetComponent<CanvasScaler>();\r\n        if (canvasScaler == null)\r\n        {\r\n            canvasScaler = targetCanvas.gameObject.AddComponent<CanvasScaler>();\r\n        }\r\n        \r\n        // 获取或添加GraphicRaycaster\r\n        graphicRaycaster = targetCanvas.GetComponent<GraphicRaycaster>();\r\n        if (graphicRaycaster == null)\r\n        {\r\n            graphicRaycaster = targetCanvas.gameObject.AddComponent<GraphicRaycaster>();\r\n        }\r\n        \r\n        // 配置Canvas\r\n        ConfigureCanvas();\r\n        \r\n        // 保存原始变换\r\n        SaveOriginalTransforms();\r\n        \r\n        isInitialized = true;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 配置Canvas\r\n    /// </summary>\r\n    private void ConfigureCanvas()\r\n    {\r\n        // 渲染模式设置\r\n        targetCanvas.renderMode = renderMode;\r\n        targetCanvas.worldCamera = renderCamera;\r\n        targetCanvas.sortingOrder = sortingOrder;\r\n        targetCanvas.targetDisplay = targetDisplay;\r\n        \r\n        // 缩放设置\r\n        canvasScaler.uiScaleMode = scaleMode;\r\n        canvasScaler.referenceResolution = referenceResolution;\r\n        canvasScaler.matchWidthOrHeight = matchWidthOrHeight;\r\n        canvasScaler.scaleFactor = scaleFactor;\r\n        \r\n        // 交互设置\r\n        graphicRaycaster.enabled = enableRaycast;\r\n        \r\n        // 设置渲染相机\r\n        if (renderCamera == null && renderMode == RenderMode.ScreenSpaceCamera)\r\n        {\r\n            renderCamera = Camera.main;\r\n            targetCanvas.worldCamera = renderCamera;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 保存原始变换\r\n    /// </summary>\r\n    private void SaveOriginalTransforms()\r\n    {\r\n        if (uiElements != null && uiElements.Length > 0)\r\n        {\r\n            originalPositions = new Vector3[uiElements.Length];\r\n            originalScales = new Vector3[uiElements.Length];\r\n            \r\n            for (int i = 0; i < uiElements.Length; i++)\r\n            {\r\n                if (uiElements[i] != null)\r\n                {\r\n                    originalPositions[i] = uiElements[i].transform.localPosition;\r\n                    originalScales[i] = uiElements[i].transform.localScale;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示Canvas基础功能\r\n    /// </summary>\r\n    private void DemonstrateCanvasBasics()\r\n    {\r\n        Debug.Log(\"=== Canvas基础功能示例 ===\");\r\n        \r\n        // 1. 基础属性\r\n        Debug.Log($\"Canvas名称: {targetCanvas.name}\");\r\n        Debug.Log($\"渲染模式: {targetCanvas.renderMode}\");\r\n        Debug.Log($\"排序顺序: {targetCanvas.sortingOrder}\");\r\n        Debug.Log($\"目标显示器: {targetCanvas.targetDisplay}\");\r\n        Debug.Log($\"是否启用: {targetCanvas.enabled}\");\r\n        \r\n        // 2. 渲染相机\r\n        if (targetCanvas.worldCamera != null)\r\n        {\r\n            Debug.Log($\"渲染相机: {targetCanvas.worldCamera.name}\");\r\n        }\r\n        else\r\n        {\r\n            Debug.Log(\"渲染相机: 无\");\r\n        }\r\n        \r\n        // 3. 缩放设置\r\n        Debug.Log($\"缩放模式: {canvasScaler.uiScaleMode}\");\r\n        Debug.Log($\"参考分辨率: {canvasScaler.referenceResolution}\");\r\n        Debug.Log($\"匹配宽高比: {canvasScaler.matchWidthOrHeight}\");\r\n        Debug.Log($\"缩放因子: {canvasScaler.scaleFactor}\");\r\n        \r\n        // 4. 射线投射\r\n        Debug.Log($\"图形射线投射器启用: {graphicRaycaster.enabled}\");\r\n        Debug.Log($\"射线投射器优先级: {graphicRaycaster.sortOrderPriority}\");\r\n        Debug.Log($\"射线投射器渲染顺序: {graphicRaycaster.renderOrderPriority}\");\r\n        \r\n        // 5. 子对象数量\r\n        int childCount = targetCanvas.transform.childCount;\r\n        Debug.Log($\"Canvas子对象数量: {childCount}\");\r\n        \r\n        // 6. 根Canvas\r\n        Canvas rootCanvas = targetCanvas.rootCanvas;\r\n        Debug.Log($\"根Canvas: {rootCanvas.name}\");\r\n        \r\n        // 7. 是否为根Canvas\r\n        bool isRootCanvas = targetCanvas.isRootCanvas;\r\n        Debug.Log($\"是否为根Canvas: {isRootCanvas}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示Canvas渲染\r\n    /// </summary>\r\n    private void DemonstrateCanvasRendering()\r\n    {\r\n        Debug.Log(\"=== Canvas渲染示例 ===\");\r\n        \r\n        // 1. 渲染模式切换\r\n        Debug.Log(\"当前渲染模式: \" + targetCanvas.renderMode);\r\n        \r\n        // 2. 排序顺序\r\n        Debug.Log($\"当前排序顺序: {targetCanvas.sortingOrder}\");\r\n        \r\n        // 3. 像素完美\r\n        bool pixelPerfect = targetCanvas.pixelPerfect;\r\n        Debug.Log($\"像素完美: {pixelPerfect}\");\r\n        \r\n        // 4. 平面距离\r\n        float planeDistance = targetCanvas.planeDistance;\r\n        Debug.Log($\"平面距离: {planeDistance}\");\r\n        \r\n        // 5. 像素单位\r\n        float pixelsPerUnit = targetCanvas.pixelsPerUnit;\r\n        Debug.Log($\"像素单位: {pixelsPerUnit}\");\r\n        \r\n        // 6. 参考像素单位\r\n        float referencePixelsPerUnit = targetCanvas.referencePixelsPerUnit;\r\n        Debug.Log($\"参考像素单位: {referencePixelsPerUnit}\");\r\n        \r\n        // 7. 额外着色器通道\r\n        AdditionalCanvasShaderChannels additionalChannels = targetCanvas.additionalShaderChannels;\r\n        Debug.Log($\"额外着色器通道: {additionalChannels}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示Canvas缩放\r\n    /// </summary>\r\n    private void DemonstrateCanvasScaling()\r\n    {\r\n        Debug.Log(\"=== Canvas缩放示例 ===\");\r\n        \r\n        // 1. 缩放模式\r\n        Debug.Log($\"缩放模式: {canvasScaler.uiScaleMode}\");\r\n        \r\n        // 2. 参考分辨率\r\n        Debug.Log($\"参考分辨率: {canvasScaler.referenceResolution}\");\r\n        \r\n        // 3. 屏幕尺寸\r\n        Vector2 screenSize = new Vector2(Screen.width, Screen.height);\r\n        Debug.Log($\"当前屏幕尺寸: {screenSize}\");\r\n        \r\n        // 4. 缩放因子\r\n        Debug.Log($\"当前缩放因子: {canvasScaler.scaleFactor}\");\r\n        \r\n        // 5. 动态DPI缩放\r\n        bool dynamicDPI = canvasScaler.dynamicPixelsPerUnit;\r\n        Debug.Log($\"动态DPI缩放: {dynamicDPI}\");\r\n        \r\n        // 6. 参考像素单位\r\n        Debug.Log($\"参考像素单位: {canvasScaler.referencePixelsPerUnit}\");\r\n        \r\n        // 7. 计算缩放\r\n        float calculatedScale = CalculateScaleFactor();\r\n        Debug.Log($\"计算得出的缩放因子: {calculatedScale}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示Canvas交互\r\n    /// </summary>\r\n    private void DemonstrateCanvasInteraction()\r\n    {\r\n        Debug.Log(\"=== Canvas交互示例 ===\");\r\n        \r\n        // 1. 射线投射设置\r\n        Debug.Log($\"射线投射启用: {graphicRaycaster.enabled}\");\r\n        Debug.Log($\"射线投射优先级: {graphicRaycaster.sortOrderPriority}\");\r\n        Debug.Log($\"渲染顺序优先级: {graphicRaycaster.renderOrderPriority}\");\r\n        \r\n        // 2. 阻塞对象\r\n        bool blockingObjects = graphicRaycaster.blockingObjects;\r\n        Debug.Log($\"阻塞对象: {blockingObjects}\");\r\n        \r\n        // 3. 阻塞遮罩\r\n        LayerMask blockingMask = graphicRaycaster.blockingMask;\r\n        Debug.Log($\"阻塞遮罩: {blockingMask.value}\");\r\n        \r\n        // 4. 事件相机\r\n        Camera eventCamera = graphicRaycaster.eventCamera;\r\n        if (eventCamera != null)\r\n        {\r\n            Debug.Log($\"事件相机: {eventCamera.name}\");\r\n        }\r\n        \r\n        // 5. 射线投射测试\r\n        TestRaycast();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示动态UI\r\n    /// </summary>\r\n    private void DemonstrateDynamicUI()\r\n    {\r\n        Debug.Log(\"=== Canvas动态UI示例 ===\");\r\n        \r\n        if (createDynamicUI)\r\n        {\r\n            // 创建动态UI元素\r\n            CreateDynamicUIElements();\r\n            \r\n            // 设置按钮事件\r\n            SetupButtonEvents();\r\n            \r\n            // 创建动画效果\r\n            if (enableAnimations)\r\n            {\r\n                StartCoroutine(AnimateUIElements());\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 创建动态UI元素\r\n    /// </summary>\r\n    private void CreateDynamicUIElements()\r\n    {\r\n        for (int i = 0; i < dynamicElementCount; i++)\r\n        {\r\n            GameObject uiElement;\r\n            \r\n            if (uiPrefab != null)\r\n            {\r\n                uiElement = Instantiate(uiPrefab, targetCanvas.transform);\r\n            }\r\n            else\r\n            {\r\n                uiElement = CreateDefaultUIElement(i);\r\n            }\r\n            \r\n            uiElement.name = $\"DynamicUI_{i}\";\r\n            uiElement.transform.localPosition = new Vector3(\r\n                Random.Range(-200f, 200f),\r\n                Random.Range(-100f, 100f),\r\n                0f\r\n            );\r\n            \r\n            dynamicElements.Add(uiElement);\r\n        }\r\n        \r\n        Debug.Log($\"创建了 {dynamicElementCount} 个动态UI元素\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 创建默认UI元素\r\n    /// </summary>\r\n    private GameObject CreateDefaultUIElement(int index)\r\n    {\r\n        GameObject uiElement = new GameObject($\"UIElement_{index}\");\r\n        uiElement.transform.SetParent(targetCanvas.transform, false);\r\n        \r\n        // 添加Image组件\r\n        Image image = uiElement.AddComponent<Image>();\r\n        image.color = new Color(\r\n            Random.Range(0f, 1f),\r\n            Random.Range(0f, 1f),\r\n            Random.Range(0f, 1f),\r\n            0.8f\r\n        );\r\n        \r\n        // 设置RectTransform\r\n        RectTransform rectTransform = uiElement.GetComponent<RectTransform>();\r\n        rectTransform.sizeDelta = new Vector2(100f, 50f);\r\n        \r\n        // 添加Text组件\r\n        GameObject textObj = new GameObject(\"Text\");\r\n        textObj.transform.SetParent(uiElement.transform, false);\r\n        \r\n        Text text = textObj.AddComponent<Text>();\r\n        text.text = $\"Element {index}\";\r\n        text.font = Resources.GetBuiltinResource<Font>(\"Arial.ttf\");\r\n        text.fontSize = 14;\r\n        text.color = Color.white;\r\n        text.alignment = TextAnchor.MiddleCenter;\r\n        \r\n        RectTransform textRect = textObj.GetComponent<RectTransform>();\r\n        textRect.anchorMin = Vector2.zero;\r\n        textRect.anchorMax = Vector2.one;\r\n        textRect.offsetMin = Vector2.zero;\r\n        textRect.offsetMax = Vector2.zero;\r\n        \r\n        return uiElement;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 设置按钮事件\r\n    /// </summary>\r\n    private void SetupButtonEvents()\r\n    {\r\n        if (buttons != null)\r\n        {\r\n            for (int i = 0; i < buttons.Length; i++)\r\n            {\r\n                if (buttons[i] != null)\r\n                {\r\n                    int buttonIndex = i; // 捕获变量\r\n                    buttons[i].onClick.AddListener(() => OnButtonClicked(buttonIndex));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 按钮点击事件\r\n    /// </summary>\r\n    private void OnButtonClicked(int buttonIndex)\r\n    {\r\n        Debug.Log($\"按钮 {buttonIndex} 被点击\");\r\n        \r\n        // 执行按钮特定的操作\r\n        switch (buttonIndex)\r\n        {\r\n            case 0:\r\n                ChangeCanvasRenderMode();\r\n                break;\r\n            case 1:\r\n                ToggleCanvasScaleMode();\r\n                break;\r\n            case 2:\r\n                CreateRandomUIElement();\r\n                break;\r\n            case 3:\r\n                ClearDynamicElements();\r\n                break;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 改变Canvas渲染模式\r\n    /// </summary>\r\n    private void ChangeCanvasRenderMode()\r\n    {\r\n        RenderMode[] modes = { RenderMode.ScreenSpaceOverlay, RenderMode.ScreenSpaceCamera, RenderMode.WorldSpace };\r\n        int currentIndex = System.Array.IndexOf(modes, targetCanvas.renderMode);\r\n        int nextIndex = (currentIndex + 1) % modes.Length;\r\n        \r\n        targetCanvas.renderMode = modes[nextIndex];\r\n        Debug.Log($\"Canvas渲染模式切换为: {targetCanvas.renderMode}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 切换Canvas缩放模式\r\n    /// </summary>\r\n    private void ToggleCanvasScaleMode()\r\n    {\r\n        CanvasScaler.ScaleMode[] modes = { \r\n            CanvasScaler.ScaleMode.ConstantPixelSize, \r\n            CanvasScaler.ScaleMode.ScaleWithScreenSize, \r\n            CanvasScaler.ScaleMode.ConstantPhysicalSize \r\n        };\r\n        \r\n        int currentIndex = System.Array.IndexOf(modes, canvasScaler.uiScaleMode);\r\n        int nextIndex = (currentIndex + 1) % modes.Length;\r\n        \r\n        canvasScaler.uiScaleMode = modes[nextIndex];\r\n        Debug.Log($\"Canvas缩放模式切换为: {canvasScaler.uiScaleMode}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 创建随机UI元素\r\n    /// </summary>\r\n    private void CreateRandomUIElement()\r\n    {\r\n        GameObject randomElement = CreateDefaultUIElement(dynamicElements.Count);\r\n        randomElement.transform.localPosition = new Vector3(\r\n            Random.Range(-300f, 300f),\r\n            Random.Range(-200f, 200f),\r\n            0f\r\n        );\r\n        \r\n        dynamicElements.Add(randomElement);\r\n        Debug.Log(\"创建了新的随机UI元素\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 清除动态元素\r\n    /// </summary>\r\n    private void ClearDynamicElements()\r\n    {\r\n        foreach (GameObject element in dynamicElements)\r\n        {\r\n            if (element != null)\r\n            {\r\n                DestroyImmediate(element);\r\n            }\r\n        }\r\n        \r\n        dynamicElements.Clear();\r\n        Debug.Log(\"清除了所有动态UI元素\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 测试射线投射\r\n    /// </summary>\r\n    private void TestRaycast()\r\n    {\r\n        Vector2 screenPoint = Input.mousePosition;\r\n        PointerEventData eventData = new PointerEventData(EventSystem.current);\r\n        eventData.position = screenPoint;\r\n        \r\n        List<RaycastResult> results = new List<RaycastResult>();\r\n        graphicRaycaster.Raycast(eventData, results);\r\n        \r\n        if (results.Count > 0)\r\n        {\r\n            Debug.Log($\"射线投射命中: {results[0].gameObject.name}\");\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 计算缩放因子\r\n    /// </summary>\r\n    private float CalculateScaleFactor()\r\n    {\r\n        Vector2 screenSize = new Vector2(Screen.width, Screen.height);\r\n        Vector2 referenceSize = canvasScaler.referenceResolution;\r\n        \r\n        float scaleX = screenSize.x / referenceSize.x;\r\n        float scaleY = screenSize.y / referenceSize.y;\r\n        \r\n        return Mathf.Lerp(scaleX, scaleY, canvasScaler.matchWidthOrHeight);\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 动画UI元素\r\n    /// </summary>\r\n    private IEnumerator AnimateUIElements()\r\n    {\r\n        while (enableAnimations)\r\n        {\r\n            foreach (GameObject element in dynamicElements)\r\n            {\r\n                if (element != null)\r\n                {\r\n                    StartCoroutine(AnimateElement(element));\r\n                }\r\n            }\r\n            \r\n            yield return new WaitForSeconds(animationDuration * 2f);\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 动画单个元素\r\n    /// </summary>\r\n    private IEnumerator AnimateElement(GameObject element)\r\n    {\r\n        Vector3 startScale = element.transform.localScale;\r\n        Vector3 endScale = startScale * 1.2f;\r\n        \r\n        float elapsedTime = 0f;\r\n        while (elapsedTime < animationDuration)\r\n        {\r\n            elapsedTime += Time.deltaTime;\r\n            float t = animationCurve.Evaluate(elapsedTime / animationDuration);\r\n            \r\n            element.transform.localScale = Vector3.Lerp(startScale, endScale, t);\r\n            yield return null;\r\n        }\r\n        \r\n        elapsedTime = 0f;\r\n        while (elapsedTime < animationDuration)\r\n        {\r\n            elapsedTime += Time.deltaTime;\r\n            float t = animationCurve.Evaluate(elapsedTime / animationDuration);\r\n            \r\n            element.transform.localScale = Vector3.Lerp(endScale, startScale, t);\r\n            yield return null;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 在Update中处理输入\r\n    /// </summary>\r\n    private void Update()\r\n    {\r\n        if (!isInitialized) return;\r\n        \r\n        HandleInput();\r\n        UpdateCanvasInfo();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 处理输入\r\n    /// </summary>\r\n    private void HandleInput()\r\n    {\r\n        // 数字键切换渲染模式\r\n        if (Input.GetKeyDown(KeyCode.Alpha1))\r\n        {\r\n            targetCanvas.renderMode = RenderMode.ScreenSpaceOverlay;\r\n            Debug.Log(\"切换到ScreenSpaceOverlay模式\");\r\n        }\r\n        else if (Input.GetKeyDown(KeyCode.Alpha2))\r\n        {\r\n            targetCanvas.renderMode = RenderMode.ScreenSpaceCamera;\r\n            Debug.Log(\"切换到ScreenSpaceCamera模式\");\r\n        }\r\n        else if (Input.GetKeyDown(KeyCode.Alpha3))\r\n        {\r\n            targetCanvas.renderMode = RenderMode.WorldSpace;\r\n            Debug.Log(\"切换到WorldSpace模式\");\r\n        }\r\n        \r\n        // R键重置Canvas\r\n        if (Input.GetKeyDown(KeyCode.R))\r\n        {\r\n            ResetCanvas();\r\n        }\r\n        \r\n        // S键切换缩放模式\r\n        if (Input.GetKeyDown(KeyCode.S))\r\n        {\r\n            ToggleCanvasScaleMode();\r\n        }\r\n        \r\n        // A键切换动画\r\n        if (Input.GetKeyDown(KeyCode.A))\r\n        {\r\n            enableAnimations = !enableAnimations;\r\n            Debug.Log($\"动画效果: {(enableAnimations ? \"开启\" : \"关闭\")}\");\r\n        }\r\n        \r\n        // C键创建新元素\r\n        if (Input.GetKeyDown(KeyCode.C))\r\n        {\r\n            CreateRandomUIElement();\r\n        }\r\n        \r\n        // D键删除元素\r\n        if (Input.GetKeyDown(KeyCode.D))\r\n        {\r\n            ClearDynamicElements();\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 更新Canvas信息\r\n    /// </summary>\r\n    private void UpdateCanvasInfo()\r\n    {\r\n        // 更新缩放信息\r\n        if (canvasScaler != null)\r\n        {\r\n            canvasScaler.scaleFactor = CalculateScaleFactor();\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 重置Canvas\r\n    /// </summary>\r\n    private void ResetCanvas()\r\n    {\r\n        targetCanvas.renderMode = renderMode;\r\n        targetCanvas.worldCamera = renderCamera;\r\n        targetCanvas.sortingOrder = sortingOrder;\r\n        \r\n        canvasScaler.uiScaleMode = scaleMode;\r\n        canvasScaler.referenceResolution = referenceResolution;\r\n        canvasScaler.matchWidthOrHeight = matchWidthOrHeight;\r\n        \r\n        Debug.Log(\"Canvas已重置\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取Canvas信息\r\n    /// </summary>\r\n    public CanvasInfo GetCanvasInfo()\r\n    {\r\n        return new CanvasInfo\r\n        {\r\n            name = targetCanvas.name,\r\n            renderMode = targetCanvas.renderMode,\r\n            sortingOrder = targetCanvas.sortingOrder,\r\n            scaleMode = canvasScaler.uiScaleMode,\r\n            referenceResolution = canvasScaler.referenceResolution,\r\n            scaleFactor = canvasScaler.scaleFactor,\r\n            childCount = targetCanvas.transform.childCount,\r\n            isRootCanvas = targetCanvas.isRootCanvas\r\n        };\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 设置Canvas缩放\r\n    /// </summary>\r\n    public void SetCanvasScale(float scale)\r\n    {\r\n        if (canvasScaler != null)\r\n        {\r\n            canvasScaler.scaleFactor = scale;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 设置Canvas排序顺序\r\n    /// </summary>\r\n    public void SetCanvasSortingOrder(int order)\r\n    {\r\n        targetCanvas.sortingOrder = order;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 在OnGUI中显示Canvas信息\r\n    /// </summary>\r\n    private void OnGUI()\r\n    {\r\n        if (!isInitialized) return;\r\n        \r\n        GUILayout.BeginArea(new Rect(10, 10, 400, 500));\r\n        \r\n        GUILayout.Label(\"Canvas信息\", EditorStyles.boldLabel);\r\n        GUILayout.Space(5);\r\n        \r\n        // 基础信息\r\n        GUILayout.Label($\"Canvas名称: {targetCanvas.name}\");\r\n        GUILayout.Label($\"渲染模式: {targetCanvas.renderMode}\");\r\n        GUILayout.Label($\"排序顺序: {targetCanvas.sortingOrder}\");\r\n        GUILayout.Label($\"目标显示器: {targetCanvas.targetDisplay}\");\r\n        GUILayout.Label($\"子对象数量: {targetCanvas.transform.childCount}\");\r\n        GUILayout.Label($\"是否为根Canvas: {targetCanvas.isRootCanvas}\");\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        // 缩放信息\r\n        GUILayout.Label(\"缩放设置\", EditorStyles.boldLabel);\r\n        GUILayout.Label($\"缩放模式: {canvasScaler.uiScaleMode}\");\r\n        GUILayout.Label($\"参考分辨率: {canvasScaler.referenceResolution}\");\r\n        GUILayout.Label($\"匹配宽高比: {canvasScaler.matchWidthOrHeight:F2}\");\r\n        GUILayout.Label($\"缩放因子: {canvasScaler.scaleFactor:F2}\");\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        // 屏幕信息\r\n        GUILayout.Label(\"屏幕信息\", EditorStyles.boldLabel);\r\n        GUILayout.Label($\"屏幕尺寸: {Screen.width}x{Screen.height}\");\r\n        GUILayout.Label($\"DPI: {Screen.dpi}\");\r\n        GUILayout.Label($\"分辨率: {Screen.currentResolution}\");\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        // 动态元素信息\r\n        GUILayout.Label(\"动态元素\", EditorStyles.boldLabel);\r\n        GUILayout.Label($\"动态元素数量: {dynamicElements.Count}\");\r\n        GUILayout.Label($\"动画效果: {(enableAnimations ? \"开启\" : \"关闭\")}\");\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        // 控制说明\r\n        GUILayout.Label(\"控制说明:\", EditorStyles.boldLabel);\r\n        GUILayout.Label(\"1/2/3 - 切换渲染模式\");\r\n        GUILayout.Label(\"R - 重置Canvas\");\r\n        GUILayout.Label(\"S - 切换缩放模式\");\r\n        GUILayout.Label(\"A - 切换动画\");\r\n        GUILayout.Label(\"C - 创建元素\");\r\n        GUILayout.Label(\"D - 删除元素\");\r\n        \r\n        GUILayout.EndArea();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// Canvas信息结构\r\n    /// </summary>\r\n    [System.Serializable]\r\n    public struct CanvasInfo\r\n    {\r\n        public string name;\r\n        public RenderMode renderMode;\r\n        public int sortingOrder;\r\n        public CanvasScaler.ScaleMode scaleMode;\r\n        public Vector2 referenceResolution;\r\n        public float scaleFactor;\r\n        public int childCount;\r\n        public bool isRootCanvas;\r\n    }\r\n} "
        }
    ]
}