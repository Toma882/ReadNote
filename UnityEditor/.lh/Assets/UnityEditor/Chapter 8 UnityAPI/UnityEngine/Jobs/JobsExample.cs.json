{
    "sourceFile": "Assets/UnityEditor/Chapter 8 UnityAPI/UnityEngine/Jobs/JobsExample.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1750932409514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750932541415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,9 @@\n using Unity.Mathematics;\r\n \r\n /// <summary>\r\n /// UnityEngine.Jobs 命名空间案例演示\r\n+/// ，主要用于实现高性能的​​多线程并行计算​​，尤其适用于需要处理大规模数据或计算密集型任务的场景。以下是其核心用途及技术细节：\r\n /// 展示IJob、IJobParallelFor、JobHandle等核心功能\r\n /// </summary>\r\n public class JobsExample : MonoBehaviour\r\n {\r\n"
                },
                {
                    "date": 1750932550517,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n using Unity.Mathematics;\r\n \r\n /// <summary>\r\n /// UnityEngine.Jobs 命名空间案例演示\r\n-/// ，主要用于实现高性能的​​多线程并行计算​​，尤其适用于需要处理大规模数据或计算密集型任务的场景。以下是其核心用途及技术细节：\r\n+/// 主要用于实现高性能的​​多线程并行计算​​，尤其适用于需要处理大规模数据或计算密集型任务的场景。以下是其核心用途及技术细节：\r\n /// 展示IJob、IJobParallelFor、JobHandle等核心功能\r\n /// </summary>\r\n public class JobsExample : MonoBehaviour\r\n {\r\n"
                }
            ],
            "date": 1750932409514,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing Unity.Jobs;\r\nusing Unity.Collections;\r\nusing Unity.Mathematics;\r\n\r\n/// <summary>\r\n/// UnityEngine.Jobs 命名空间案例演示\r\n/// 展示IJob、IJobParallelFor、JobHandle等核心功能\r\n/// </summary>\r\npublic class JobsExample : MonoBehaviour\r\n{\r\n    [Header(\"Jobs 设置\")]\r\n    [SerializeField] private int arraySize = 10000; //数组大小\r\n    [SerializeField] private bool useJobs = true; //是否使用Jobs\r\n    [SerializeField] private bool useParallelJobs = false; //是否使用并行Jobs\r\n    [SerializeField] private float jobTime = 0f; //Job执行时间\r\n\r\n    private NativeArray<float> inputArray;\r\n    private NativeArray<float> outputArray;\r\n    private JobHandle jobHandle;\r\n\r\n    private void Start()\r\n    {\r\n        // 初始化数组\r\n        inputArray = new NativeArray<float>(arraySize, Allocator.Persistent);\r\n        outputArray = new NativeArray<float>(arraySize, Allocator.Persistent);\r\n        \r\n        for (int i = 0; i < arraySize; i++)\r\n        {\r\n            inputArray[i] = i;\r\n        }\r\n    }\r\n\r\n    private void Update()\r\n    {\r\n        if (useJobs)\r\n        {\r\n            if (useParallelJobs)\r\n            {\r\n                ExecuteParallelJob();\r\n            }\r\n            else\r\n            {\r\n                ExecuteSimpleJob();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            ExecuteMainThread();\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 执行简单Job\r\n    /// </summary>\r\n    private void ExecuteSimpleJob()\r\n    {\r\n        var job = new SimpleJob\r\n        {\r\n            input = inputArray,\r\n            output = outputArray,\r\n            multiplier = Time.time\r\n        };\r\n\r\n        var startTime = Time.realtimeSinceStartup;\r\n        jobHandle = job.Schedule();\r\n        jobHandle.Complete();\r\n        jobTime = Time.realtimeSinceStartup - startTime;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 执行并行Job\r\n    /// </summary>\r\n    private void ExecuteParallelJob()\r\n    {\r\n        var job = new ParallelJob\r\n        {\r\n            input = inputArray,\r\n            output = outputArray,\r\n            multiplier = Time.time\r\n        };\r\n\r\n        var startTime = Time.realtimeSinceStartup;\r\n        jobHandle = job.Schedule(arraySize, 64);\r\n        jobHandle.Complete();\r\n        jobTime = Time.realtimeSinceStartup - startTime;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 主线程执行\r\n    /// </summary>\r\n    private void ExecuteMainThread()\r\n    {\r\n        var startTime = Time.realtimeSinceStartup;\r\n        for (int i = 0; i < arraySize; i++)\r\n        {\r\n            outputArray[i] = inputArray[i] * Time.time;\r\n        }\r\n        jobTime = Time.realtimeSinceStartup - startTime;\r\n    }\r\n\r\n    private void OnDestroy()\r\n    {\r\n        if (inputArray.IsCreated)\r\n            inputArray.Dispose();\r\n        if (outputArray.IsCreated)\r\n            outputArray.Dispose();\r\n    }\r\n\r\n    private void OnGUI()\r\n    {\r\n        GUILayout.BeginArea(new Rect(10, 10, 350, 250));\r\n        GUILayout.Label(\"Jobs 作业系统演示\", UnityEditor.EditorStyles.boldLabel);\r\n        arraySize = int.TryParse(GUILayout.TextField(arraySize.ToString()), out var size) ? size : arraySize;\r\n        useJobs = GUILayout.Toggle(useJobs, \"使用Jobs\");\r\n        useParallelJobs = GUILayout.Toggle(useParallelJobs, \"使用并行Jobs\");\r\n        GUILayout.Label($\"执行时间: {jobTime:F4}s\");\r\n        GUILayout.Label($\"数组大小: {arraySize}\");\r\n        if (GUILayout.Button(\"重新初始化数组\"))\r\n        {\r\n            if (inputArray.IsCreated)\r\n                inputArray.Dispose();\r\n            if (outputArray.IsCreated)\r\n                outputArray.Dispose();\r\n            \r\n            inputArray = new NativeArray<float>(arraySize, Allocator.Persistent);\r\n            outputArray = new NativeArray<float>(arraySize, Allocator.Persistent);\r\n            \r\n            for (int i = 0; i < arraySize; i++)\r\n            {\r\n                inputArray[i] = i;\r\n            }\r\n        }\r\n        GUILayout.EndArea();\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 简单Job结构\r\n/// </summary>\r\npublic struct SimpleJob : IJob\r\n{\r\n    [ReadOnly] public NativeArray<float> input;\r\n    public NativeArray<float> output;\r\n    public float multiplier;\r\n\r\n    public void Execute()\r\n    {\r\n        for (int i = 0; i < input.Length; i++)\r\n        {\r\n            output[i] = input[i] * multiplier;\r\n        }\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 并行Job结构\r\n/// </summary>\r\npublic struct ParallelJob : IJobParallelFor\r\n{\r\n    [ReadOnly] public NativeArray<float> input;\r\n    public NativeArray<float> output;\r\n    public float multiplier;\r\n\r\n    public void Execute(int index)\r\n    {\r\n        output[index] = input[index] * multiplier;\r\n    }\r\n} "
        }
    ]
}