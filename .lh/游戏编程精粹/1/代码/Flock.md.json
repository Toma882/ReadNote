{
    "sourceFile": "游戏编程精粹/1/代码/Flock.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1764412421526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764412426840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-﻿# Flocking算法实现\r\n+# Flocking算法实现\r\n ```csharp\r\n public class Boid\r\n {\r\n     public Vector3 Position { get; set; }\r\n"
                },
                {
                    "date": 1764412443113,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,12 @@\n-﻿# Flocking \r\n+## Flocking（群集行为）\r\n \r\n+### 核心概念\r\n+\r\n+- **定义**：Craig Reynolds于1987年提出的分布式行为模型，模拟鸟群、鱼群等生物群体行为\r\n+- **特点**：通过简单规则组合产生复杂的群体运动，展现涌现行为（emergent behavior）\r\n+- **应用场景**：Unreal、Half-Life中的怪物和生物，Enemy Nations的部队队形，RTS/RPG中的群体动画\r\n+\r\n ```csharp\r\n public class Boid\r\n {\r\n     public Vector3 Position { get; set; }\r\n"
                }
            ],
            "date": 1764412421526,
            "name": "Commit-0",
            "content": "\r\n```csharp\r\npublic class Boid\r\n{\r\n    public Vector3 Position { get; set; }\r\n    public Vector3 Velocity { get; set; }\r\n    public Vector3 Orientation { get; set; }\r\n    \r\n    public float PerceptionRange { get; set; } = 10f;\r\n    public float MaxSpeed { get; set; } = 5f;\r\n    public float MaxVelocityChange { get; set; } = 2f;\r\n    \r\n    private List<Boid> visibleFriends = new List<Boid>();\r\n    private List<Boid> visibleEnemies = new List<Boid>();\r\n    \r\n    // 四个定向行为规则\r\n    public void FlockIt(List<Boid> allBoids, List<Boid> enemies)\r\n    {\r\n        // 1. 检测可见的同伴和敌人\r\n        SeeFriends(allBoids);\r\n        SeeEnemies(enemies);\r\n        \r\n        // 2. 累积所有定向行为的矢量变化\r\n        Vector3 changeVector = Vector3.zero;\r\n        \r\n        changeVector += KeepDistance() * 1.5f;      // 分离（权重1.5）\r\n        changeVector += MatchHeading() * 1.0f;      // 对齐（权重1.0）\r\n        changeVector += SteerToCenter() * 1.0f;     // 聚集（权重1.0）\r\n        changeVector += FleeEnemies() * 2.0f;      // 躲避（权重2.0，优先级高）\r\n        \r\n        // 3. 单位化并应用变化\r\n        if (changeVector.magnitude > 0)\r\n        {\r\n            changeVector.Normalize();\r\n            Velocity += changeVector * MaxVelocityChange;\r\n            \r\n            // 限制最大速度\r\n            if (Velocity.magnitude > MaxSpeed)\r\n                Velocity = Velocity.normalized * MaxSpeed;\r\n        }\r\n        \r\n        // 4. 更新位置和朝向\r\n        Position += Velocity * Time.deltaTime;\r\n        ComputeRPY();\r\n        WorldBound();\r\n    }\r\n    \r\n    // 分离：避免与邻近个体过于接近\r\n    private Vector3 KeepDistance()\r\n    {\r\n        if (visibleFriends.Count == 0) return Vector3.zero;\r\n        \r\n        Vector3 steer = Vector3.zero;\r\n        int count = 0;\r\n        \r\n        foreach (var friend in visibleFriends)\r\n        {\r\n            float distance = Vector3.Distance(Position, friend.Position);\r\n            if (distance > 0 && distance < PerceptionRange)\r\n            {\r\n                Vector3 diff = Position - friend.Position;\r\n                diff.Normalize();\r\n                diff /= distance; // 距离越近，影响越大\r\n                steer += diff;\r\n                count++;\r\n            }\r\n        }\r\n        \r\n        if (count > 0)\r\n            steer /= count;\r\n        \r\n        return steer;\r\n    }\r\n    \r\n    // 对齐：与邻近个体的平均航向对齐\r\n    private Vector3 MatchHeading()\r\n    {\r\n        if (visibleFriends.Count == 0) return Vector3.zero;\r\n        \r\n        Vector3 averageVelocity = Vector3.zero;\r\n        foreach (var friend in visibleFriends)\r\n        {\r\n            averageVelocity += friend.Velocity;\r\n        }\r\n        averageVelocity /= visibleFriends.Count;\r\n        \r\n        return (averageVelocity - Velocity).normalized;\r\n    }\r\n    \r\n    // 聚集：向邻近个体的平均位置移动\r\n    private Vector3 SteerToCenter()\r\n    {\r\n        if (visibleFriends.Count == 0) return Vector3.zero;\r\n        \r\n        Vector3 centerOfMass = Vector3.zero;\r\n        foreach (var friend in visibleFriends)\r\n        {\r\n            centerOfMass += friend.Position;\r\n        }\r\n        centerOfMass /= visibleFriends.Count;\r\n        \r\n        return (centerOfMass - Position).normalized;\r\n    }\r\n    \r\n    // 躲避：避开敌人\r\n    private Vector3 FleeEnemies()\r\n    {\r\n        if (visibleEnemies.Count == 0) return Vector3.zero;\r\n        \r\n        Vector3 fleeVector = Vector3.zero;\r\n        foreach (var enemy in visibleEnemies)\r\n        {\r\n            Vector3 away = Position - enemy.Position;\r\n            float distance = away.magnitude;\r\n            if (distance > 0)\r\n            {\r\n                away.Normalize();\r\n                away /= distance; // 距离越近，逃离越急\r\n                fleeVector += away;\r\n            }\r\n        }\r\n        \r\n        return fleeVector.normalized;\r\n    }\r\n    \r\n    // 检测可见的同伴\r\n    private void SeeFriends(List<Boid> allBoids)\r\n    {\r\n        visibleFriends.Clear();\r\n        foreach (var boid in allBoids)\r\n        {\r\n            if (boid != this && CanISee(boid))\r\n                visibleFriends.Add(boid);\r\n        }\r\n    }\r\n    \r\n    // 检测可见的敌人\r\n    private void SeeEnemies(List<Boid> enemies)\r\n    {\r\n        visibleEnemies.Clear();\r\n        foreach (var enemy in enemies)\r\n        {\r\n            if (CanISee(enemy))\r\n                visibleEnemies.Add(enemy);\r\n        }\r\n    }\r\n    \r\n    // 判断是否可见\r\n    private bool CanISee(Boid other)\r\n    {\r\n        float distance = Vector3.Distance(Position, other.Position);\r\n        return distance <= PerceptionRange;\r\n    }\r\n    \r\n    // 计算Roll/Pitch/Yaw朝向\r\n    private void ComputeRPY()\r\n    {\r\n        if (Velocity.magnitude > 0.1f)\r\n        {\r\n            Quaternion targetRotation = Quaternion.LookRotation(Velocity.normalized);\r\n            Orientation = targetRotation.eulerAngles;\r\n        }\r\n    }\r\n    \r\n    // 边界处理（环绕）\r\n    private void WorldBound()\r\n    {\r\n        // 假设世界边界为Box，超出边界则环绕到对面\r\n        // 可根据需要实现反弹或其他行为\r\n    }\r\n}\r\n```\r\n\r\n#### Flock类（群体管理）\r\n\r\n```csharp\r\npublic class Flock\r\n{\r\n    private List<Boid> members = new List<Boid>();\r\n    public int Count => members.Count;\r\n    \r\n    public void AddBoid(Boid boid)\r\n    {\r\n        if (!members.Contains(boid))\r\n            members.Add(boid);\r\n    }\r\n    \r\n    public void RemoveBoid(Boid boid)\r\n    {\r\n        members.Remove(boid);\r\n    }\r\n    \r\n    public void Update(List<Boid> enemies)\r\n    {\r\n        foreach (var boid in members)\r\n        {\r\n            boid.FlockIt(members, enemies);\r\n        }\r\n    }\r\n    \r\n    public List<Boid> GetAllMembers()\r\n    {\r\n        return new List<Boid>(members); // 返回副本，避免外部修改\r\n    }\r\n    \r\n    public Boid GetFirstMember()\r\n    {\r\n        return members.Count > 0 ? members[0] : null;\r\n    }\r\n}\r\n```\r\n\r\n#### FlockManager类（全局管理）\r\n\r\n```csharp\r\npublic class FlockManager : MonoBehaviour\r\n{\r\n    private List<Flock> flocks = new List<Flock>();\r\n    \r\n    public void AddFlock(Flock flock)\r\n    {\r\n        flocks.Add(flock);\r\n    }\r\n    \r\n    void Update()\r\n    {\r\n        // 更新所有flock\r\n        foreach (var currentFlock in flocks)\r\n        {\r\n            // 收集当前flock的敌人（其他flock的所有成员）\r\n            List<Boid> enemies = new List<Boid>();\r\n            foreach (var otherFlock in flocks)\r\n            {\r\n                if (otherFlock != currentFlock)\r\n                {\r\n                    // 获取其他flock的所有成员作为敌人\r\n                    enemies.AddRange(otherFlock.GetAllMembers());\r\n                }\r\n            }\r\n            \r\n            // 更新当前flock，传入敌人列表\r\n            currentFlock.Update(enemies);\r\n        }\r\n    }\r\n}\r\n```"
        }
    ]
}