# Unity 面试题总结

> **整理时间**：2025年  
> **用途**：面试准备 + Unity基础知识复习  
> **重点**：Unity生命周期、物理系统、渲染优化、UI系统等核心知识点

---

## 目录

1. [Unity生命周期](#1-unity3d脚本从唤醒到销毁有着一套比较完整的生命周期列出系统自带的几个重要的方法)
2. [碰撞器和触发器](#2-unity3d中的碰撞器和触发器的区别)
3. [碰撞必要条件](#3-物体发生碰撞的必要条件)
4. [脚本语言](#4-简述unity3d支持的作为脚本的语言的名称)
5. [.NET与Mono](#5-net与mono的关系)
6. [生命周期顺序](#6-onenableawake-start运行时的发生顺序哪些可能在同一个对象周期中反复的发生)
7. [相机移动](#7-移动相机动作在哪个函数里为什么在这个函数里)
8. [物理更新](#8-物理更新一般放在哪个系统函数里)
9. [光源类型](#9-unity提供了几种光源分别是什么)
10. [四元数](#10-简述四元数quaternion的作用四元数对欧拉角的优点)
11. [CharacterController和Rigidbody](#11-charactercontroller和rigidbody的区别)
12. [坐标系统](#12-localposition-与-position-的使用区别)
13. [Prefab](#13-简述prefab的用处)
14. [进程线程协程](#14-简述进程线程协程的概念)
15. [协程作用](#15-简述协程的作用)
16. [协程原理](#16-简述协程的底层原理)
17. [线程与协程](#17-线程与协程的区别)
18. [Invoke](#18-简述invoke与invokerepeating)
19. [Invoke与协程](#19-简述invoke与协程的区别)
20. [OnDisable时的Invoke和协程](#20-正在运行的脚本隐藏物体与禁止脚本导致触发ondisable时invoke与coroutine是否正常运行)
21. [碰撞阶段](#21-在物体发生碰撞的整个过程中有几个阶段分别列出对应的函数-三个阶段)
22. [施加力的方式](#22-unity3d的物理引擎中有几种施加力的方式分别描述出来)
23. [旋转函数](#23-物体自身旋转使用的函数物体绕某点旋转使用函数叫什么)
24. [PlayerPrefs](#24-unity3d提供了一个用于保存和读取数据的类playerprefs请列出保存和读取整形数据的函数)
25. [Image和RawImage](#25-image和rawimage的区别)
26. [TCP/IP协议栈](#26-tcpip协议栈各个层次及分别的功能)
27. [多摄像机](#27-在场景中放置多个camera并同时处于活动状态会发生什么)
28. [销毁对象](#28-如何销毁一个unityengineobject及其子类)
29. [游戏动画](#29-请描述游戏动画有哪几种以及其原理)
30. [组件数据丢失](#30-请描述为什么unity3d中会发生在组件上出现数据丢失的情况)
31. [Alpha Blend](#31-alpha-blend工作原理)
32. [Diffuse计算公式](#32-写出光照计算中的diffuse的计算公式)
33. [LOD](#33-lod是什么优缺点是什么)
34. [阴影判断](#33-两种阴影判断的方法工作原理)
35. [Vertex Shader](#34-vertex-shader是什么怎么计算)
36. [MipMap](#35-mipmap是什么作用)
37. [Interface与抽象类](#36-请描述interface与抽象类之间的不同)
38. [资源迁移](#37-如何安全的在不同工程间安全地迁移asset数据三种方法)
39. [对象池](#38-简述一下对象池你觉得在fps里哪些东西适合使用对象池)
40. [多线程](#39-unity3d是否支持写成多线程程序如果支持的话需要注意什么)
41. [DontDestroyOnLoad](#40-如何让已经存在的gameobject在loadlevel后不被卸载掉)
42. [Transform组件](#41-u3d中用于记录节点空间几何信息的组件名称及其父类名称)
43. [向量运算](#42-向量的点乘叉乘以及归一化的意义)
44. [矩阵相乘](#43-矩阵相乘的意义及注意点)
45. [高速碰撞](#44-当一个细小的高速物体撞向另一个较大的物体时会出现什么情况如何避免)
46. [Dynamic Font](#45-为什么dynamic-font-in-unicode环境下优于static-font)
47. [UI适配](#46-请简述如何在不同分辨率下保持ui的一致性)
48. [OnBecameVisible](#47-请简述onbecamevisible及onbecameinvisible的发生时机以及这一对回调函数的意义)
49. [动态合批](#48-什么叫动态合批跟静态合批有什么区别)
50. [动态加载资源](#49-动态加载资源的方式)
51. [LightMap](#50-什么是lightmap)
52. [Unity和Cocos2d](#51-unity和cocos2d的区别)
53. [Shader类型](#52-unity3d-shader分哪几种有什么区别)
54. [组件操作](#53-获取增加删除组件的命令分别是什么)
55. [Clipping Planes](#54-unity中照相机的clipping-planes的作用是什么调整-nearfar两个值时应该注意什么)
56. [GPU工作原理](#55-gpu的工作原理)
57. [渲染管道](#56-什么是渲染管道)
58. [内存优化](#57-unity中如何优化内存简述一些常用的方法)
59. [2D游戏实现](#58-使用unity3d实现2d游戏有几种方式)
60. [Alpha Test](#59-请问alpha-test在何时使用能达到什么效果)
61. [Depth Only](#61-将camera组件的clearflags选项选成depth-only是什么意思有何用处)
62. [链条关节](#62-什么叫做链条关节)
63. [Static对象](#63-在编辑场景时将gameobject设置为static有何作用)
64. [渲染顺序](#64-有a和b两组物体有什么办法能够保证a组物体永远比b组物体先渲染)
65. [Texture和Sprite](#65-将图片的texturetype选项分别选为texture和sprite有什么区别)
66. [Terrain贴图](#66-问一个terrain分别贴3张4张5张地表贴图渲染速度有什么区别为什么)
67. [DrawCall](#67-什么是drawcalldrawcall高了又什么影响如何降低drawcall)
68. [实时点光源](#68-实时点光源的优缺点是什么)
69. [查看性能数据](#69-如何在unity3d中查看场景的面数顶点数和draw-call数)
70. [AddComponent生命周期](#70-addcomponent后哪个生命周期函数会被调用)
72. [层剔除](#72-层剔除)
73. [着色器](#73-分别解释顶点着色器和像素着色器是什么)
74. [Canvas模式](#74-画布的三种模式缩放模式)
75. [FSM有限状态机](#75-fsm有限状态机)
76. [行为树与FSM](#76-行为树与有限状态机)
77. [行为树概念](#77-简述行为树的概念及优缺点)
78. [Text和TMPText](#78-text-和-tmptext的区别-优缺点)
79. [红点系统](#79-红点系统的实现)
80. [Animation和Animator](#80-animation和animator的区别)
81. [SkinnedMesh](#81-简述skinnedmesh的实现原理)
82. [Material和SharedMaterial](#82-meshrender中material和sharedmaterial的区别)
83. [ScriptableObject](#83-scriptableobejct)
84. [资源路径](#84-unity常用资源路径有哪些)
85. [Unity插件](#85-使用过哪些unity插件)

---

## 1. Unity3d脚本从唤醒到销毁有着一套比较完整的生命周期，列出系统自带的几个重要的方法。

**答**：`Awake` → `OnEnable` → `Start` → `FixedUpdate` → `Update` → `LateUpdate` → `OnGUI` → `OnDisable` → `OnDestroy`

### 主要执行顺序

编辑器 → 初始化 → 物理系统 → 输入事件 → 游戏逻辑 → 场景渲染 → GUI渲染 → 物体激活或禁用 → 销毁物体 → 应用结束

### 主要函数介绍

- **Reset**：在用户点击检视面板的Reset按钮或者首次添加该组件时被调用。此函数只在编辑模式下被调用。Reset最常用于在检视面板中给定一个最常用的默认值。

- **Awake**：用于在游戏开始之前初始化变量或游戏状态。在脚本整个生命周期内它仅被调用一次，当脚本设置为不可用时，运行时Awake方法仍然会执行一次。Awake在所有对象被初始化之后调用，所以你可以安全的与其他对象对话或用诸如 `GameObject.FindWithTag` 这样的函数搜索它们。每个游戏物体上的Awake以随机的顺序被调用。因此，你应该用Awake来设置脚本间的引用，并用Start来传递信息，Awake总是在Start之前被调用。它不能用来执行协同程序。

- **OnEnable**：当对象变为可用或激活状态时被调用事件监听。

- **Start**：在behaviour的生命周期中只被调用一次。它和Awake的不同是Start只在脚本实例被启用时调用。你可以按需调整延迟初始化代码。Awake总是在Start之前执行。这允许你协调初始化顺序。

- **FixedUpdate**：当MonoBehaviour启用时，其在每一帧被调用。处理Rigidbody时，需要用FixedUpdate代替Update。例如：给刚体加一个作用力时，你必须应用作用力在FixedUpdate里的固定帧，而不是Update中的帧。(两者帧长不同)。

- **Update**：是实现各种游戏行为最常用的函数。

- **LateUpdate**：每帧调用一次（在所有Update函数调用后被调用）用于更新游戏场景和状态，和摄像机相关的更新。官网上例子是摄像机的跟随，都是所有的Update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。

- **OnGUI**：渲染和处理GUI事件时调用。这意味着你的OnGUI程序将会在每一帧被调用。要得到更多的GUI事件的信息查阅Event手册。如果Monobehaviour的enabled属性设为false，OnGUI()将不会被调用。

- **OnDisable**：不能用于协同程序。当对象变为不可用或非激活状态时此函数被调用。

- **OnDestroy**：当对象被销毁时调用。

- **OnApplicationQuit**：当用户停止运行模式时在编辑器中调用。当web被关闭时在网络播放器中被调用。

---

## 2. Unity3D中的碰撞器和触发器的区别？

**答**：碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性。

- **当Is Trigger=false时**：碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用`OnCollisionEnter/Stay/Exit`函数；

- **当Is Trigger=true时**：碰撞器被物理引擎所忽略，没有碰撞效果，可以调用`OnTriggerEnter/Stay/Exit`函数。

如果既要检测到物体的接触又不想让碰撞检测影响物体移动或要检测一个物件是否经过空间中的某个区域这时就可以用到触发器。

---

## 3. 物体发生碰撞的必要条件？

**答**：两个物体都必须带有碰撞器Collider，其中一个物体还必须带有Rigidbody刚体。

---

## 4. 简述Unity3D支持的作为脚本的语言的名称？

Unity的脚本语言基于Mono的.Net平台上运行，可以使用.NET库，这也为XML、数据库、正则表达式等问题提供了很好的解决方案。

Unity里的脚本都会经过编译，他们的运行速度也很快。这三种语言实际上的功能和运行速度是一样的，区别主要体现在语言特性上。

**Unity支持的语言**：C#，JavaScript（不再使用）

---

## 5. .Net与Mono的关系？

- **Mono**：是.NET的一个开源跨平台工具，就类似Java虚拟机，Java本身不是跨平台语言，但运行在虚拟机上就能够实现了跨平台。
- **.NET**：只能在Windows下运行
- **Mono**：可以实现跨平台编译运行，可以运行于Linux，Unix，Mac OS等。

---

## 6. OnEnable、Awake、Start运行时的发生顺序？哪些可能在同一个对象周期中反复的发生？

**答**：`Awake` → `OnEnable` → `Start`

**OnEnable在同一周期中可以反复地发生！**

---

## 7. 移动相机动作在哪个函数里，为什么在这个函数里？

**LateUpdate**，是在所有的Update结束后才调用，比较适合用于命令脚本的执行。

官网上例子是摄像机的跟随，都是所有的Update操作完才进行摄像机的跟进，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。

---

## 8. 物理更新一般放在哪个系统函数里？

在Unity中，物理更新通常放在**FixedUpdate**函数中，而不是放在Update函数中。

Update函数是每一帧都会调用的函数，用于处理物体的位置、旋转和缩放等变换，但它不适用于物理计算，因为它的执行频率高于FixedUpdate。

FixedUpdate函数在每一帧的固定时间间隔内调用，用于执行物理模拟和碰撞检测。因此，如果你的代码涉及到物理模拟或碰撞检测，应该放在FixedUpdate函数中。

**示例代码**：
```csharp
using UnityEngine;

public class MyRigidbodyComponent : MonoBehaviour
{
    void FixedUpdate()
    {
        // 更新物理状态
        Rigidbody rb = GetComponent<Rigidbody>();
        if (rb != null)
        {
            // 更新刚体的速度和位置
            rb.velocity = transform.right * speed;
            rb.MovePosition(rb.position + rb.velocity * Time.fixedDeltaTime);
        }
    }
}
```

注意使用`Time.fixedDeltaTime`来确保物理更新的帧率是固定的，以获得更准确的模拟效果。

---

## 9. Unity提供了几种光源，分别是什么？

**四种**：

1. **平行光**：Directional Light
2. **点光源**：Point Light
3. **聚光灯**：Spot Light
4. **区域光源**：Area Light

---

## 10. 简述四元数Quaternion的作用，四元数对欧拉角的优点？

**答**：四元数用于表示旋转，对旋转角度进行计算时用到四元数

**相对欧拉角的优点**：
1. 能进行增量旋转
2. 避免万向锁
3. 给定方位的表达方式有两种，互为负（欧拉角有无数种表达方式）

---

## 11. CharacterController和Rigidbody的区别？

Rigidbody具有完全真实物理的特性，而CharacterController可以说是受限的的Rigidbody，具有一定的物理效果但不是完全真实的。

---

## 12. localPosition 与 Position 的使用区别？

- **localPosition**：自身坐标系，相对于父级的位置
- **Position**：世界坐标系中的位置

---

## 13. 简述prefab的用处

在游戏运行时实例化，prefab相当于一个模板，对你已经有的素材、脚本、参数做一个默认的配置，主要用于经常会用到的物体做成一个集合方便反复使用，以便于以后的修改，同时prefab打包的内容简化了导出的操作，便于团队的交流。

---

## 14. 简述进程、线程、协程的概念

### 进程

保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，不同进程间可以进行进程间通信，上级挂靠单位是操作系统。一个应用程序相当于一个进程，操作系统会以进程为单位，分配系统资源（CPU 时间片、内存等资源），进程是资源分配的最小单位。

### 线程

线程从属于进程，也被称为轻量级进程，是程序的实际执行者。线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个线程只有一个进程。

每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。

### 协程

协程是伴随着主线程一起运行的一段程序。

协程与协程之间是并行执行，与主线程也是并行执行，同一时间只能执行一个协程提起协程，自然是要想到线程，因为协程的定义就是伴随主线程来运行的。

一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。

协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

协成是单线程下由应用程序级别实现的并发。

---

## 15. 简述协程的作用

在Unity中，协程是一种轻量级的线程，用于在单一线程上执行多个任务，实现异步等待和延迟执行等效果。协程不是取代线程，而是抽象于线程之上，同一时间只有一个协程拥有运行权，相当于单线程的能力。协程的执行基于迭代器，通过yield语句来实现暂停和恢复执行，从而更加灵活地控制协程的执行过程。

协程可以在不创建新线程的情况下实现异步等待和延迟执行，避免了线程切换和同步等问题，从而提高了程序的性能和效率。在Unity中，协程通常用于处理一些异步任务，比如等待一段时间、播放动画、加载资源等。协程的执行过程可以通过yield语句来控制，比如`yield return new WaitForSeconds(5)`可以让协程等待5秒钟后再继续执行。此外，协程还可以通过`yield return null`等方式来控制协程的执行过程。

**需要注意**：协程并不是多线程，协程的执行是在主线程上进行的，因此协程中的操作不应该阻塞主线程的执行。如果协程需要执行一些耗时的操作，可以将其放到后台线程中执行，然后通过`yield return null`等方式来控制协程的执行过程。

在Unity中只有主线程才能访问Unity3D的对象、方法、组件。当主线程在执行一个对资源消耗很大的操作时，在这一帧我们的程序就会出现帧率下降，画面卡顿的现象！

那这个时候我们就可以利用协程来做这件事，因为协程是伴随着主线程运行的，主线程依旧可以丝滑轻松的工作，把脏活累活交给协程处理就好了！简单来说：协程是辅助主线程的操作，避免游戏卡顿。

---

## 16. 简述协程的底层原理

协程是通过迭代器来实现功能的，通过关键字`IEnumerator`来定义一个迭代方法。

- `StartCoroutine` 接受到的是一个 `IEnumerator`，这是个接口，并且是枚举器或迭代器的意思。
- `yield` 是 C#的一个关键字，也是一个语法糖，背后的原理会生成一个类，并且也是一个枚举器，而且不同于 return，yield 可以出现多次。
- `yield` 实际上就是返回一次结果，因为我们要一次一次枚举一个值出来，所以多个 yield 其实是个状态模式，第一个 yield 是状态 1，第二个 yield 是状态 2，每次访问时会基于状态知道当前应该执行哪一个 yield，取得哪一个值。

从程序的角度讲，协程的核心就是迭代器。

想要定义一个协程方法有两个因素：
1. 方法的返回值为 `IEnumerator`
2. 方法中有 `yield`关键字

当代码满足以上两个条件时，此方法的执行就具有了迭代器的特质，其核心就是 `MoveNext`方法。

方法内的内容将会被分成两部分：yield 之前的代码和 yield 之后的代码。yield之前的代码会在第一次执行MoveNext时执行，yield之后的代码会在第二次执行MoveNext方法时执行。

而在Unity中，MoveNext的执行时机是以帧为单位的，无论你是设置了延迟时间，还是通过按钮调用MoveNext，亦或是根本没有设置执行条件，Unity都会在每一帧的生命周期中判断当前帧是否满足当前协程所定义的条件，一旦满足，当前帧就会抽出CPU时间执行你所定义的协程迭代器的MoveNext。

**注意**：只要方法中有yield语句，那么方法的返回值就必须是 `IEnumerator`，不然无法通过编译。

---

## 17. 线程与协程的区别

| 特性 | 协程 | 线程 |
|------|------|------|
| 执行方式 | 协作式程序，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协程处于休眠状态 | 多线程是阻塞式的，每个IO都必须开启一个新的线程 |
| Unity对象访问 | 协程可以访问和使用unity的所有方法和component | thread中不能操作unity的很多方法和component |
| 执行数量 | 同一时间只能执行某个协程 | 同一时间可以同时执行多个线程 |
| 开销 | 开辟多个协程开销不大 | 开辟多条线程开销很大 |
| 适用场景 | 协程适合对某任务进行分时处理 | 对于多CPU的系统应该使用thread，尤其是有大量数据运算的时刻，但是IO密集型就不适合 |
| 本质 | 协程是通过协作来完成，在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只在必要时才会被挂起 | 在多处理器情况下，从概念上来讲多线程程序同时运行多个线程 |

---

## 18. 简述Invoke与InvokeRepeating

### Invoke

`Invoke()` 方法是 Unity3D 的一种委托机制

如： `Invoke("Test", 3);` 它的意思是：3 秒之后调用 `Test()` 方法；

**使用 Invoke() 方法需要注意以下3点**：
1. 它应该在脚本的生命周期里的（Start、Update、OnGUI、FixedUpdate、LateUpdate）中被调用；
2. `Invoke()` 不能接受含有参数的方法；
3. 在 `Time.ScaleTime = 0;` 时， `Invoke()` 无效，因为它不会被调用。

### InvokeRepeating

`InvokeRepeating("Test", 3 , 5);`

这个方法的意思是指：3 秒后调用 `Test()` 方法，并且之后每隔 5 秒调用一次 `Test()` 方法。

---

## 19. 简述Invoke与协程的区别

| 特性 | Invoke方法 | Coroutine方法 |
|------|-----------|---------------|
| 执行方式 | 执行没有被挂起，相当于设置完被调用函数的执行时间后即时向下执行 | 新开一条执行序列（跟新建线程差不多）并挂起，等待中断指令结束 |
| 开销 | - | 开销不大 |
| 适用场景 | 应用到每隔一段时间执行某个函数很方便 | 当需要挂起当前执行时使用 |
| 效率 | - | 协程的效率比Invoke高 |

---

## 20. 正在运行的脚本，隐藏物体与禁止脚本导致触发OnDisable时，Invoke与coroutine是否正常运行？

- **只将脚本禁止**：都会正常运行。
- **如果把物体直接隐藏**：Invoke正常运行，coroutine不会正常运行。

**原因**：因为游戏物体隐藏了，一切与游戏物体相关的脚本生命周期都会停止，协程自然也会停止；如果游戏对象没有隐藏，只是将脚本隐藏，游戏对象照样可以通过反射获取协程迭代器对象继续协程的执行。

---

## 21. 在物体发生碰撞的整个过程中，有几个阶段，分别列出对应的函数 三个阶段

**答**：`OnCollisionEnter`、 `OnCollisionStay`、 `OnCollisionExit`

---

## 22. Unity3d的物理引擎中，有几种施加力的方式，分别描述出来

1. `rigidbody.AddForce`
2. `rigidbody.AddForceAtPosition`

---

## 23. 物体自身旋转使用的函数？物体绕某点旋转使用函数叫什么？

- **自身旋转**：`transform.Rotate()`
- **绕某点旋转**：`transform.RotateAround`

---

## 24. Unity3d提供了一个用于保存和读取数据的类(PlayerPrefs)，请列出保存和读取整形数据的函数

PlayerPrefs类是一个本地持久化保存与读取数据的类

PlayerPrefs类支持3中数据类型的保存和读取，浮点型，整形，和字符串型。

分别对应的函数为：

- `SetInt()`：保存整型数据；`GetInt()`：读取整形数据；
- `SetFloat()`：保存浮点型数据； `GetFlost()`：读取浮点型数据；
- `SetString()`：保存字符串型数据； `GetString()`：读取字符串型数据；

---

## 25. Image和RawImage的区别

| 特性 | Image | RawImage |
|------|-------|----------|
| 性能 | Image比RawImage更消耗性能 | 性能会比Image好很多 |
| 图片类型 | Image只能使用Sprite属性的图片 | RawImage什么样的都可以使用 |
| 适用场景 | Image适合放一些有操作的图片，裁剪平铺旋转什么的，针对Image Type属性 | RawImage就放单独展示的图片就可以 |

---

## 26. TCP/IP协议栈各个层次及分别的功能？

1. **网络接口层**：这是协议栈的最低层，对应OSI的物理层和数据链路层，主要完成数据帧的实际发送和接收。
2. **网络层**：处理分组在网络中的活动，例如路由选择和转发等，这一层主要包括IP协议、ARP、ICMP协议等。
3. **传输层**：主要功能是提供应用程序之间的通信，这一层主要是TCP/UDP协议。
4. **应用层**：用来处理特定的应用，针对不同的应用提供了不同的协议，例如进行文件传输时用到的FTP协议，发送email用到的SMTP等。

---

## 27. 在场景中放置多个Camera并同时处于活动状态会发生什么？

受Camera覆盖各场景物件均同时实时绘制，主Camera视场里有多个Camera的渲染合集。可以用depth（深度），Layer（层）+ Culling Mask，enable = false/true来控制，或者调整Viewport Rect可以调整不同摄像机的显示内容。

---

## 28. 如何销毁一个UnityEngine.Object及其子类？

使用`Destroy()`方法;

---

## 29. 请描述游戏动画有哪几种，以及其原理？

主要有关节动画、骨骼动画、单一网格模型动画(关键帧动画)。

1. **关节动画**：把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活，Quake2中使用这种动画；

2. **骨骼动画**：广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，有关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观；

3. **单一网格模型动画**：由一个完整的网格模型构成，在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。

---

## 30. 请描述为什么Unity3d中会发生在组件上出现数据丢失的情况

一般是组件上绑定的对象被删除了，导致组件找不到该对象了而出现数据丢失现象。或者对象在Editor外部被删除和移动位置。

---

## 31. alpha blend工作原理?

Alpha Blend 实现透明效果，不过只能针对某块区域进行alpha操作，透明度可设。

---

## 32. 写出光照计算中的diffuse的计算公式？

`diffuse = Kd x colorLight x max(N*L,0)`

- **Kd**：漫反射系数
- **colorLight**：光的颜色
- **N**：单位法线向量
- **L**：由点指向光源的单位向量
- 其中N与L点乘，如果结果小于等于0，则漫反射为0。

---

## 33. LOD是什么，优缺点是什么？

**LOD(Level of detail)**：多层次细节，是最常用的游戏优化技术。

它按照模型的位置和重要程度决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。

**缺点**：增加了内存

---

## 33. 两种阴影判断的方法、工作原理？

**本影和半影**：

- **本影**：景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域）。
- **半影**：景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域）

**工作原理**：从光源处向物体的所有可见面投射光线，将这些面投影到场景中得到投影面，再将这些投影面与场景中的其他平面求交得出阴影多边形，保存这些阴影多边形信息，然后再按视点位置对场景进行相应处理得到所要求的视图（利用空间换时间，每次只需依据视点位置进行一次阴影计算即可，省去了一次消隐过程）

---

## 34. Vertex Shader是什么，怎么计算？

顶点着色器是一段执行在GPU上的程序，用来取代fixed pipeline中的transformation和lighting，Vertex Shader主要操作顶点。

Vertex Shader对输入顶点完成了从local space到homogeneous space（齐次空间）的变换过程，homogeneous space即projection space的下一个space。在这其间共有world transformation, view transformation和projection transformation及lighting几个过程。

---

## 35. MipMap是什么，作用？

**MipMapping**：在三维计算机图形的贴图渲染中有常用的技术，为加快渲染进度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为MipMap。

---

## 36. 请描述Interface与抽象类之间的不同

### 语法不同处：

1. 抽象类中可以有字段，接口没有。
2. 抽象类中可以有实现成员，接口只能包含抽象成员。
3. 抽象类中所有成员修饰符都可以使用，接口中所有的成员都是对外的，所以不需要修饰符修饰。

### 用法不同处：

1. 抽象类是概念的抽象，接口关注于行为。
2. 抽象类的子类与父类的关系是泛化关系，耦合度较高，而实现类和接口之间是实现的关系，耦合度比泛化低。
3. 一个类只能继承一个类，但是可以实现多个接口。

---

## 37. 如何安全的在不同工程间安全地迁移asset数据？三种方法

1. 将Assets和Library一起迁移
2. 导出包package
3. 用unity自带的assets Server功能

---

## 38. 简述一下对象池，你觉得在FPS里哪些东西适合使用对象池？

对象池就存放需要被反复调用资源的一个空间。

比如游戏中要常被大量复制的对象，子弹，敌人，以及任何重复出现的对象。

**特点**：用内存换取CPU的优化

---

## 39. Unity3D是否支持写成多线程程序？如果支持的话需要注意什么？

**支持**：如果同时你要处理很多事情或者与Unity的对象互动小可以用thread，否则使用coroutine。

Unity3d没有多线程的概念，不过unity也给我们提供了StartCoroutine（协同程序）和LoadLevelAsync（异步加载关卡）后台加载场景的方法。

**注意**：仅能从主线程中访问Unity3D的组件，对象和Unity3D系统调用。C#中有lock这个关键字，以确保只有一个线程可以在特定时间内访问特定的对象

---

## 40. 如何让已经存在的GameObject在LoadLevel后不被卸载掉？

```csharp
DontDestroyOnLoad(transform.gameObject);
```

---

## 41. U3D中用于记录节点空间几何信息的组件名称，及其父类名称

**Transform** 父类是 **Component**

---

## 42. 向量的点乘、叉乘以及归一化的意义？

- **叉乘几何意义**：得到一个与这两个向量都垂直的向量，这个向量的模是以两个向量为边的平行四边形的面积
- **点乘几何意义**：可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影
- **点乘**：描述了两个向量的相似程度，结果越大两向量越相似，还可表示投影
- **叉乘**：得到的向量垂直于原来的两个向量
- **标准化向量**：用在只关系方向，不关心大小的时候

---

## 43. 矩阵相乘的意义及注意点？

用于表示线性变换：旋转、缩放、投影、平移、仿射

**注意矩阵的蠕变**：误差的积累

---

## 44. 当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？

**穿透（碰撞检测失败）**（例如CS射击游戏，可以使用开枪时发射射线，射线碰撞到则掉血击中）

---

## 45. 为什么dynamic font在unicode环境下优于static font

使用动态字体时，Unity将不会预先生成一个与所有字体的字符纹理，静态字体体积会很大。

---

## 46. 请简述如何在不同分辨率下保持UI的一致性

多屏幕分辨率下的UI布局一般考虑两个问题：

1. **布局元素的位置**：即屏幕分辨率变化的情况下，布局元素的位置可能固定不动，导致布局元素可能超出边界；
2. **布局元素的尺寸**：即在屏幕分辨率变化的情况下，布局元素的大小尺寸可能会固定不变，导致布局元素之间出现重叠等功能。

为了解决这两个问题，在Unity UGUI体系中有两个组件可以来解决问题，分别是布局元素的Rect Transform和Canvas的Canvas Scaler组件。

CanvasScaler中UI Scale Mode有三种模式：
- **Constant Pixel Size**：使UI保持自己的尺寸，与屏幕尺寸无关
- **Scale With Screen Size**：根据屏幕分辨率来进行缩放适配（推荐）
- **Constant Physical Size**：使UI元素保持相同的物理大小，与屏幕尺寸无关

在这个模式下，有两个参数，一个是我们在开发过程中的标准分辨率，一个是屏幕的匹配模式，通过这里面的设置，就可以完成多分辨率下的适配问题。

---

## 47. 请简述OnBecameVisible及OnBecameInvisible的发生时机，以及这一对回调函数的意义？

当物体是否可见切换之时。可以用于只需要在物体可见时才进行的计算。

---

## 48. 什么叫动态合批？跟静态合批有什么区别？

如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。

动态批处理操作是自动完成的，并不需要你进行额外的操作。

**区别**：
- **动态批处理**：一切都是自动的，不需要做任何操作，而且物体是可以移动的，但是限制很多。
- **静态批处理**：自由度很高，限制很少，缺点可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了。

---

## 49. 动态加载资源的方式?

1. **Instantiate**：最简单的一种方式，以实例化的方式动态生成一个物体。
2. **AssetsBundle**：即将资源打成 asset bundle 放在服务器或本地磁盘，然后使用WWW模块get下来，然后从这个bundle中load某个object，unity官方推荐也是绝大多数商业化项目使用的一种方式。
3. **Resource.Load**：可以直接load并返回某个类型的Object，前提是要把这个资源放在Resource命名的文件夹下，Unity不管有没有场景引用，都会将其全部打入到安装包中
4. **AssetDatabase.loadasset**：这种方式只在editor范围内有效，游戏运行时没有这个函数，它通常是在开发中调试用的。

---

## 50. 什么是LightMap？

**LightMap**：就是指在三维软件里实现打好光，然后渲染把场景各表面的光照输出到贴图上，最后又通过引擎贴到场景上，这样就使物体有了光照的感觉。

---

## 51. Unity和cocos2d的区别

| 特性 | Unity3D | Cocos2d-x |
|------|---------|-----------|
| 支持语言 | 支持C#、javascript等 | 支持c++、Html5、Lua等 |
| 开源 | - | cocos2d 开源并且免费 |
| 支持平台 | 支持iOS、Android、Flash、Windows、Mac、Wii等平台的游戏开发 | 支持iOS、Android、WP等 |

---

## 52. Unity3D Shader分哪几种，有什么区别？

1. **表面着色器**：表面着色器的抽象层次比较高，它可以轻松地以简洁方式实现复杂着色。表面着色器可同时在前向渲染及延迟渲染模式下正常工作。
2. **顶点片段着色器**：可以非常灵活地实现需要的效果，但是需要编写更多的代码，并且很难与Unity的渲染管线完美集成。
3. **固定功能管线着色器**：可以作为前两种着色器的备用选择，当硬件无法运行那些酷炫Shader的时，还可以通过固定功能管线着色器来绘制出一些基本的内容。

---

## 53. 获取、增加、删除组件的命令分别是什么？

- **获取**：`GetComponent`
- **增加**：`AddComponent`
- **删除**：`Destroy`

---

## 54. Unity中，照相机的Clipping Planes的作用是什么?调整 Near、Far两个值时，应该注意什么?

**剪裁平面**。从相机到开始渲染和停止渲染之间的距离。

---

## 55. GPU的工作原理？

简而言之，GPU的图形（处理）流水线完成如下的工作：（并不一定是按照如下顺序）。

1. **顶点处理**：这阶段GPU读取描述3D图形外观的顶点数据并根据顶点数据确定3D图形的形状及位置关系，建立起3D图形的骨架。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Vertex Shader（定点着色器）完成。

2. **光栅化计算**：显示器实际显示的图像是由像素组成的，我们需要将上面生成的图形上的点和线通过一定的算法转换到相应的像素点。把一个矢量图形转换为一系列像素点的过程就称为光栅化。例如，一条数学表示的斜线段，最终被转化成阶梯状的连续像素点。

3. **纹理帖图**：顶点单元生成的多边形只构成了3D物体的轮廓，而纹理映射（texture mapping）工作完成对多变形表面的帖图，通俗的说，就是将多边形的表面贴上相应的图片，从而生成"真实"的图形。TMU（Texture mapping unit）即是用来完成此项工作。

4. **像素处理**：这阶段（在对每个像素进行光栅化处理期间）GPU完成对像素的计算和处理，从而确定每个像素的最终属性。在支持DX8和DX9规格的GPU中，这些工作由硬件实现的Pixel Shader（像素着色器）完成。

5. **最终输出**：由ROP（光栅化引擎）最终完成像素的输出，1帧渲染完毕后，被送到显存帧缓冲区。

**总结**：GPU的工作通俗的来说就是完成3D图形的生成，将图形映射到相应的像素点上，对每个像素进行计算确定最终颜色并完成输出。

---

## 56. 什么是渲染管道？

是指在显示器上为了显示出图像而经过的一系列必要操作。渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。

**主要步骤有**：本地坐标 → 视图坐标 → 背面裁剪 → 光照 → 裁剪 → 投影 → 视图变换 → 光栅化。

---

## 57. Unity中如何优化内存，简述一些常用的方法。

1. **避免频繁的内存分配**：频繁的内存分配和释放会导致内存碎片化，影响性能。尽量重用对象，而不是每次需要时都创建新的对象。
2. **使用Pooling（对象池）**：对象池是一种预先创建并保留对象的集合的技术，这样就可以重复使用它们，而不是每次需要时都创建新的对象。这大大减少了内存分配和垃圾收集的频率。
3. **及时删除不再使用的对象**：当你完成一个对象的所有工作，或者确定不再需要它时，删除或置空该对象可以立即释放其占用的内存。
4. **合理使用动态数组和静态数组**：动态数组会在运行时调整大小，这会导致额外的内存分配和数据复制。在知道数组的大致大小的情况下，使用静态数组可能会更高效。
5. **优化字符串的使用**：字符串是不可变的，这意味着每次对字符串进行操作（例如连接或替换）时，都会创建一个新的字符串对象。如果可能，尽量避免频繁操作字符串，或者考虑使用其他数据结构。
6. **减少全局变量的使用**：全局变量会在程序的整个生命周期中一直存在，这会导致大量的内存占用。尽可能地减少全局变量的使用，或者考虑使用单例模式来限制变量的数量。
7. **优化数据结构**：根据应用的需求选择合适的数据结构。例如，如果你经常需要快速查找元素，哈希表可能是一个更好的选择。
8. **合理使用引用类型和值类型**：在C#中，引用类型和值类型在内存中有着不同的处理方式。理解它们的差异并根据实际情况选择合适的类型可以有效地减少内存使用。
9. **优化纹理和图片资源**：大型纹理和图片会占用大量内存。尽可能地减小图片的大小，并使用合适的格式来存储它们。对于纹理，考虑使用合适的纹理压缩格式。
10. **避免频繁的磁盘I/O操作**：频繁的磁盘I/O操作会导致大量的CPU时间被占用，影响程序的性能。尽可能地缓存数据，减少磁盘操作的频率。
11. **优化Profiler的使用**：Unity的Profiler可以帮助你找出内存使用的热点。通过Profiler，你可以找到哪些部分在消耗大量的内存，并据此进行优化。
12. **代码审查和性能分析**：定期进行代码审查和性能分析可以帮助你找到内存使用的瓶颈并进行优化。

记住，优化是一个持续的过程，需要根据项目需求和资源进行不断的调整和优化。

---

## 58. 使用Unity3d实现2d游戏，有几种方式？

1. 使用本身的GUI、UGUI
2. 把摄像机的Projection(投影)值调为Orthographic(正交投影)，不考虑z轴；
3. 使用2d插件，如：2DToolKit、NGUI

---

## 59. 请问alpha test在何时使用？能达到什么效果？

**Alpha Test**，中文就是透明度测试。

简而言之就是V&F shader中最后fragment函数输出的该点颜色值（即上一讲frag的输出half4）的alpha值与固定值进行比较。Alpha Test语句通常于Pass{}中的起始位置。Alpha Test产生的效果也很极端，要么完全透明，即看不到，要么完全不透明。

---

## 61. 将Camera组件的ClearFlags选项选成Depth only是什么意思？有何用处？

**仅深度**，该模式用于对象不被裁剪。

---

## 62. 什么叫做链条关节？

**Hinge Joint**，可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力。

---

## 63. 在编辑场景时将GameObject设置为Static有何作用？

设置游戏对象为Static将会剔除（或禁用）网格对象当这些部分被静态物体挡住而不可见时。因此，在你的场景中的所有不会动的物体都应该标记为Static。

---

## 64. 有A和B两组物体，有什么办法能够保证A组物体永远比B组物体先渲染？

把A组物体的渲染队列大于B物体的渲染队列

---

## 65. 将图片的TextureType选项分别选为Texture和Sprite有什么区别

- **Sprite**：作为UI精灵使用
- **Texture**：作用模型贴图使用

---

## 66. 问一个Terrain，分别贴3张，4张，5张地表贴图，渲染速度有什么区别？为什么？

**答**：没有区别，因为不管几张贴图只渲染一次。

---

## 67. 什么是DrawCall？DrawCall高了又什么影响？如何降低DrawCall？

**Unity中**，每次引擎准备数据并通知GPU的过程称为一次Draw Call。DrawCall越高对显卡的消耗就越大。

**降低DrawCall的方法**：

1. Dynamic Batching
2. Static Batching
3. 高级特性Shader降级为统一的低级特性的Shader

---

## 68. 实时点光源的优缺点是什么？

可以有cookies – 带有 alpha通道的立方图(Cubemap )纹理。点光源是最耗费资源的。

---

## 69. 如何在Unity3D中查看场景的面数，顶点数和Draw Call数？

在Game视图右上角点击**Stats**。降低Draw Call 的技术是Draw Call Batching

---

## 70. Addcomponent后哪个生命周期函数会被调用

对于AddComponent添加的脚本，其Awake，Start，OnEnable是在Add的当前帧被调用的

其中Awake，OnEnable与AddComponent处于同一调用链上

Start会在当前帧稍晚一些的时候被调用，Update则是根据Add调用时机决定何时调用：如果Add是在当前帧的Update前调用，那么新脚本的Update也会在当前帧被调用，否则会被延迟到下一帧调用。

---

## 72. 层剔除

用layermask，通过位运算的方式去设置

在代码中使用时如何开启某个Layers？

```csharp
LayerMask mask = 1 << 你需要开启的Layers层;

LayerMask mask = 0 << 你需要关闭的Layers层;

// 举几个例子：
LayerMask mask = 1 << 2;  // 表示开启Layer2
LayerMask mask = 0 << 5;  // 表示关闭Layer5
LayerMask mask = 1<<2|1<<8;  // 表示开启Layer2和Layer8
LayerMask mask = 0<<3|0<<7;  // 表示关闭Layer3和Layer7
```

---

## 73. 分别解释顶点着色器和像素着色器是什么

**顶点着色器**：是一段执行在GPU上的程序，用来取代 fixed pipeline中的transformation和lighting，Vertex Shader主要操作顶点。

**像素着色器**：实际上就是对每一个像素进行光栅化的处理期间，在GPU上运算的一段程序。

不同与顶点着色器，像素着色器不会以软件的形式来模拟像素着色器。

像素着色器实质上是取代了固定功能流水线中多重纹理的环节，而且赋予了我们访问单个像素以及访问每一个像素纹理坐标的能力

---

## 74. 画布的三种模式.缩放模式

### 三种模式

1. **屏幕空间-覆盖模式(Screen Space-Overlay)**：Canvas创建出来后，默认就是该模式，该模式和摄像机无关，即使场景内没有摄像机，UI游戏物体照样渲染
   - 屏幕空间：电脑或者手机显示屏的2D空间，只有x轴和y轴
   - 覆盖模式：UI元素永远在3D元素的前面

2. **屏幕空间-摄像机模式(Screen Space-Camera)**：设置成该模式后需要指定一个摄像机游戏物体，指定后UGUI就会自动出现在该摄像机的"投射范围"内，和NGUI的默认UI Root效果一致，如果隐藏掉摄像机，UGUI当然就无法渲染

3. **世界空间模式(WorldSpace)**：设置成该模式后UGUI就相当于是场景内的一个普通的"Cube 游戏模型"，可以在场景内任意的移动UGUI元素的位置，通常用于怪物血条显示和VR开发

### 缩放模式

| Property | Function |
|----------|----------|
| UI Scale Mode | Canvas中UI元素的缩放模式 |
| Constant Pixel Size | 使UI保持自己的尺寸，与屏幕尺寸无关 |
| Scale With Screen Size | 屏幕尺寸越大，UI越大 |
| Constant Physical Size | 使UI元素保持相同的物理大小，与屏幕尺寸无关 |

**注意**：Constant Pixel Size、Constant Physical Size实际上他们本质是一样的，只不过 Constant Pixel Size 通过逻辑像素大小调节来维持缩放，而 Constant Physical Size 通过物理大小调节来维持缩放。

---

## 75. FSM有限状态机

FSM是一种数据结构，它由以下几个部分组成：

- 内在的所有状态（必须是有限个）
- 输入条件
- 状态之间起到连接性作用的转换函数

### 为什么要用FSM？

因为它编程快速简单，易于调试，性能高，与人类思维相似从而便于梳理，灵活且容易修改

### FSM的描述性定义：

一个有限状态机是一个设备，或是一个模型，具有有限数量的状态。它可以在任何给定时间根据输入进行操作，使得系统从一个状态转换到另一个状态，或者是使一个输出或者一种行为的发生，一个有限状态机在任何瞬间只能处于一种状态。

### 基本结构

- **State 状态基类**：定义了基本的Enter，Update，Exit三种状态行为，通常在这三种状态行为的方法里会写一些逻辑。每个State都会有StateID（状态id，可以是枚举等），FSMControl（控制该状态的状态控制器的引用），Check方法（用来进行状态判断，并返回StateID，通过FSMControl驱动）

- **FSMControl**：包含了一下FSMMachine，封装层。

- **FSMMachine**：驱动它的State列表，Update方法调用当前State的Check方法来获得StateID，当currentState的Check方法返回的StateID和当前StateID不同，则切换状态。

这是一个简单的FSM状态机系统，根据需要自己写个Control继承FSMControl来驱动状态。因为Check是State的职责，所以每一个不同对象的行为如Human的Idle和Dog的Idel区分肯定也不同。因此需要分别去写HumanIdleState和DogIdleState。如果还有Cat，Fish，可想而知代码量会有多么庞大。

因此我将FSMControl抽象为一个公共基类，把State的Check具体实现作为FSMControl的Virtual方法。这样在IdleState里的Check方法就不用写具体的状态切换判断逻辑，而是调用它FSMControl子类（自己写的继承自FSMControl的Control类）的重写方法

这样每次添加的新对象只要有Idle这个状态，就可以用一个公用的StateIdle，状态切换的逻辑差异放在Control层

---

## 76. 行为树与有限状态机

### 有限状态机系统

是指在不同阶段会呈现出不同的运行状态的系统，这些状态是有限的、不重叠的。这样的系统在某一时刻一定会处于其所有状态中的一个状态，此时它接收一部分允许的输入，产生一部分可能的响应，并且迁移到一部分可能的状态。

- **基本节点是状态**：他包含了一系列运行在该状态的行为以及离开这个状态的条件。
- **状态可以任意跳转**：实现简单，但是对于大的状态机很难维护，状态逻辑的重用性低。
- **每一个状态的逻辑会随着一些新状态的增加而越来越复杂**：维持状态的数量和状态逻辑复杂性是一个很大的难点。需要合理的分割以及重用状态。
- **状态机状态的复用性很差**：一旦一些因素变化导致这个环境发生变化。你只能新增一个状态，并且给这个新状态添加连接他以及其他状态的跳转逻辑。
- **状态机的跳转条件一旦不满足，就会一直卡在某一个状态**。

### 行为树

一个流行的AI技术，涵盖了层次状态机，事件调度，事件计划，行为等一系列技术。实现AI的过程更加得有技巧，框架设计者较为全面考虑了我们可能会遇到的种种情况，把每种情况都抽象成了一个类型的节点，而我们要做的就是按照规范去写节点，然后把节点连接成一颗行为树。更加得具有面向对象的味道，行为模块间的藕合度相对较低。

- **高度模块化状态**：去掉状态中的跳转逻辑，使得状态变成一个"行为"。
- **"行为"和"行为"之间的跳转是通过父节点的类型来决定的**：比如并行处理两个行为，在状态机里面无法同时处理两个状态。
- **通过增加控制节点的类型，可以达到复用行为的目的**。
- **可视化编辑**。

---

## 77. 简述行为树的概念及优缺点

### 概念

- 对于有限状态机而言，必须明确状态的转换方式；对于行为树，必须明确状态前提：前提条件。
- 每一个行为必须有"前提条件"，这决定了该行为是否被选择。
- 行为树的运算也是通过帧循环的update来驱动，不一定是每帧都update，但是要周期性update。
- 每一次run从根节点(root)开始，每一运行都会选择一个可行的子节点运行，这种选择可以是随机方式，也可以是预设好优先条件。
- 行为树由叶子节点和中间节点组成，叶子节点是最基本的行为(如跑动，攻击)，中间节点代表逻辑单元(巡逻，逃跑)。
- 当一个叶子节点被选择后，就会激活其对应的基本的行为。
- 最基本的行为可能执行成功也可能失败。
- 高等级的行为（中间节点）是否执行成功依赖于他们的孩子节点是否执行成功。
- 一个子节点失败可能导致父母节点选择另外一个孩子。
- 除了选择(selector)一个单独的子节点行为，一个节点还可能顺序(sequence)or并行(concurrent)得运行他的所有子节点。
- 一个行为除了有前提条件，可能还有上下文条件(父节点or孩子节点可能存储一定的状态变量)。
- 高优先级的行为可能抢占低优先级的行为。

### 优点

- 行为逻辑和状态数据分离，任何节点写好以后可以反复利用。
- 重用性高，可用通过重组不同的节点来实现不同的行为树。
- 呈线性的方式扩展，易于扩展。
- 可配置，把工作交给designer。
- 能够胜任"AI" "掉宝"等等场景。

### 缺点

- 每一帧都从root开始，有可能会访问到所以的节点，相对State Machine消耗更多的cpu。
- 任何一个简单的操作都必须要使用节点。

---

## 78. Text 和 TMPText的区别 优缺点

| 特性 | Text | TMPText |
|------|------|---------|
| 渲染方式 | 像素渲染，放大之后就会模糊 | 网格渲染，不会模糊 |
| 父物体影响 | 使用Text父物体的放大缩小会影响子物体Text的清晰度 | TMPText不会 |
| 实现原理 | - | TMPText会把字体生成一个类似于贴图的东西然后读取贴图的坐标来获取对应的文字 |
| 更换文字消耗 | - | 更换文字的消耗会比Text大 |
| 适用场景 | 需要经常变动的文字用Text好点 | TMPText更适用于不会变动的文字，特别是在量大的情况下，性能比Text高一些 |
| 字体库 | - | TMPText在字体库很大的情况下查找更换会比较慢 |

---

## 79. 红点系统的实现

### 思路

红点系统基于MVC的思想，将分为三层：数据层，驱动层，显示层。

1. **数据层中的数据结构**：考虑到需要层级的联系，所以以结点为核心，每个结点会持有其父结点和子结点，有点像双向链表的前驱后继，但是它构成的不是链表而是树。
2. **状态变化通知**：当一个结点状态发生变化，它会通知到其父结点，父节点会自行处理变化去通知它自己的父结点，有点递归的意思，如果是数量通知，子节点的消息会以此累计到自己的父节点中，以此类推，具体看需求。
3. **观察者模式**：整个系统数据层驱动层与展示层是剥离的，展示层需要显示什么结点的内容，以该结点的key去注册，数据层与显示层实现了观察者模式，即可收到每次该结点状态变化的通知，并实时更新界面。

---

## 80. Animation和Animator的区别

Animation和Animator 虽然都是控制动画的播放，但是它们的用法和相关语法都是大有不同的。

- **Animation**：控制一个动画的播放
- **Animator**：多个动画之间相互切换，并且Animator有一个动画控制器，俗称动画状态机

Animator利用它做动画的切换是很方便的，但是它有一个缺点就是占用内存比Animation大。

---

## 81. 简述SkinnedMesh的实现原理

根据骨骼，动态整体实现表层Mesh，相对普通mesh由不同面片堆砌，根据骨骼结构，对顶点的变换计算出不同的蒙皮，最终进行模型的渲染

---

## 82. MeshRender中material和sharedmaterial的区别？

**答**：修改sharedMaterial将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。不推荐修改由sharedMaterial返回的材质。如果你想修改渲染器的材质，使用material替代。

---

## 83. ScriptableObejct

ScriptableObject是一个数据容器，它可以用来保存大量数据。

**主要的用处**：就是在项目中通过将数据存储在ScriptableObject对象，避免值拷贝来减少游戏运行中的内存占用。

当你有一个预制体，上面挂了一个存有不变数据的MonoBehaviour 脚本时，每次我们实例化预制体时都将产生一次数据拷贝，这时我们可以使用ScriptableObject对象来存储数据，然后通过引用来访问预制体中的数据。这样可以避免在内存中产生一份拷贝数据。

与MonoBehaviour 一样，ScriptableObject也继承自Unity基类object，但是与MonoBehaviour不同的是，ScriptableObject不能和GameObject对相关联，相反，通常我们会将它保存为Assets资源。

在编辑器模式下，我们可以在编辑和运行时将数据保存到ScriptableObject，因为保存ScriptableObject需要用到编辑器空间个脚本，但是在开发模式下不能使用ScriptableObject来保存数据，但是你可以使用ScriptableObject资源中已保存的数据。

---

## 84. unity常用资源路径有哪些

```csharp
//获取的目录路径最后不包含  /
//获得的文件路径开头包含 /
Application.dataPath; //Asset文件夹的绝对路径
//只读
Application.streamingAssetsPath;  //StreamingAssets文件夹的绝对路径（要先判断是否存在这个文件夹路径）
Application.persistentData; //可读写

//资源数据库 (AssetDatabase) 是允许您访问工程中的资源的 API
AssetDatabase.GetAllAssetPaths; //获取所有的资源文件（不包含meta文件）
AssetDatabase.GetAssetPath(object) //获取object对象的相对路径
AssetDatabase.Refresh(); //刷新
AssetDatabase.GetDependencies(string); //获取依赖项文件

Directory.Delete(p, true); //删除P路径目录
Directory.Exists(p);  //是否存在P路径目录
Directory.CreateDirectory(p); //创建P路径目录

// AssetDatabase //类库，对Asset文件夹下的文件进行操作，获取相对路径，获取所有文件，获取相对依赖项
// Directory //类库，相关文件夹路径目录进行操作，是否存在，创建目录，删除等操作
```

---

## 85. 使用过哪些Unity插件

因人而异，可以去简单了解一下要说的插件，没用过也可以，至少你知道这个插件了！

| 插件名 | 作用 |
|--------|------|
| shader graph | 制作shader光影效果 |
| cinemachine+timeline+postprocessingstack | 制作过场动画 |
| nodecanvas | 制作怪物ai |
| easytouch | 手游触摸控制 |
| DoTween | 动画插件 |
| Fungus | 对话插件 |
| 3D WebView | 浏览器插件 |
| Vectrosity | 划线插件 |
| AVPro Video | 视频播放插件 |
| Feel | 受击插件 |
| Device Simulator | 移动设备模拟器 |
| StateMachine | 状态机插件 |

---

## 总结

这份Unity面试题总结涵盖了以下核心知识点：

1. **Unity生命周期**：Awake、Start、Update、FixedUpdate等
2. **物理系统**：碰撞器、触发器、刚体、物理更新
3. **协程系统**：协程原理、线程与协程的区别
4. **渲染系统**：DrawCall、合批、LOD、Shader
5. **UI系统**：Canvas模式、Image与RawImage、Text与TMPText
6. **资源管理**：Prefab、资源加载、对象池
7. **性能优化**：内存优化、DrawCall优化、渲染优化
8. **AI系统**：FSM有限状态机、行为树
9. **其他**：四元数、向量运算、矩阵运算等

这些知识点是Unity开发中的核心内容，掌握这些内容对于面试和实际开发都非常重要。

---

**参考来源**：CSDN博客 - 呆呆敲代码的小Y

