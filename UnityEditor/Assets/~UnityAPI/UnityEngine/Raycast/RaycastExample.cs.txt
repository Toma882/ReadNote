using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Unity Raycast（射线检测）完整 API 示例
/// Raycast 是 Unity 中用于检测碰撞的核心系统，常用于点击检测、视线检测等
/// </summary>
public class RaycastExample : MonoBehaviour
{
    [Header("射线设置")]
    [SerializeField] private float rayDistance = 100f;
    [SerializeField] private LayerMask layerMask = -1;
    [SerializeField] private QueryTriggerInteraction queryTriggers = QueryTriggerInteraction.UseGlobal;
    
    [Header("检测设置")]
    [SerializeField] private bool showRay = true;
    [SerializeField] private Color rayColor = Color.red;
    
    private Camera mainCamera;
    private List<RaycastHit> hitResults = new List<RaycastHit>();
    private RaycastHit[] hitArray = new RaycastHit[10];
    
    private void Start()
    {
        Debug.Log("=== Unity Raycast（射线检测）完整 API 示例 ===");
        
        mainCamera = Camera.main;
        if (mainCamera == null)
        {
            mainCamera = FindObjectOfType<Camera>();
        }
        
        TestAllRaycastFeatures();
    }
    
    private void Update()
    {
        TestMouseRaycast();
    }
    
    private void OnDrawGizmos()
    {
        if (showRay && mainCamera != null)
        {
            Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);
            Gizmos.color = rayColor;
            Gizmos.DrawRay(ray.origin, ray.direction * rayDistance);
        }
    }
    
    #region 1. 基础射线检测
    
    /// <summary>
    /// 测试所有 Raycast 功能
    /// </summary>
    private void TestAllRaycastFeatures()
    {
        Debug.Log("\n--- 1. 基础射线检测 ---");
        
        // 1.1 Physics.Raycast
        TestPhysicsRaycast();
        
        // 1.2 Physics.RaycastAll
        TestPhysicsRaycastAll();
        
        // 1.3 Physics.RaycastNonAlloc
        TestPhysicsRaycastNonAlloc();
        
        Debug.Log("\n--- 2. 其他检测方法 ---");
        
        // 2.1 Physics.Linecast
        TestLinecast();
        
        // 2.2 Physics.OverlapSphere
        TestOverlapSphere();
        
        // 2.3 Physics.OverlapBox
        TestOverlapBox();
        
        Debug.Log("\n--- 3. 2D 射线检测 ---");
        
        // 3.1 Physics2D.Raycast
        TestPhysics2DRaycast();
    }
    
    /// <summary>
    /// 1.1 Physics.Raycast - 单次射线检测
    /// 检测射线是否与碰撞体相交，返回第一个碰撞点
    /// </summary>
    private void TestPhysicsRaycast()
    {
        Debug.Log("1.1 Physics.Raycast - 单次射线检测");
        
        // 方式1：使用 Ray 结构
        Ray ray = new Ray(transform.position, transform.forward);
        RaycastHit hit;
        
        if (Physics.Raycast(ray, out hit, rayDistance, layerMask, queryTriggers))
        {
            Debug.Log($"射线命中: {hit.collider.name}");
            Debug.Log($"命中点: {hit.point}");
            Debug.Log($"距离: {hit.distance}");
            Debug.Log($"法线: {hit.normal}");
        }
        
        // 方式2：使用起点和方向
        Vector3 origin = transform.position;
        Vector3 direction = transform.forward;
        
        if (Physics.Raycast(origin, direction, out hit, rayDistance, layerMask, queryTriggers))
        {
            Debug.Log($"射线命中: {hit.collider.name}");
        }
        
        // 方式3：简化版本（使用默认参数）
        if (Physics.Raycast(origin, direction, out hit))
        {
            Debug.Log($"射线命中: {hit.collider.name}");
        }
        
        // 方式4：只检测是否命中（不获取详细信息）
        bool hasHit = Physics.Raycast(ray, rayDistance, layerMask);
        if (hasHit)
        {
            Debug.Log("射线命中某个物体");
        }
    }
    
    /// <summary>
    /// 1.2 Physics.RaycastAll - 检测所有碰撞
    /// 返回所有与射线相交的碰撞体
    /// </summary>
    private void TestPhysicsRaycastAll()
    {
        Debug.Log("1.2 Physics.RaycastAll - 检测所有碰撞");
        
        Ray ray = new Ray(transform.position, transform.forward);
        
        // 检测所有碰撞
        RaycastHit[] hits = Physics.RaycastAll(ray, rayDistance, layerMask, queryTriggers);
        
        Debug.Log($"射线命中了 {hits.Length} 个物体");
        
        // 按距离排序
        System.Array.Sort(hits, (a, b) => a.distance.CompareTo(b.distance));
        
        foreach (RaycastHit hit in hits)
        {
            Debug.Log($"  - {hit.collider.name}, 距离: {hit.distance}");
        }
        
        // 注意：RaycastAll 会分配新数组，可能产生 GC
        // 推荐使用 RaycastNonAlloc
    }
    
    /// <summary>
    /// 1.3 Physics.RaycastNonAlloc - 无 GC 分配检测
    /// 使用预分配的数组，避免 GC 分配（推荐）
    /// </summary>
    private void TestPhysicsRaycastNonAlloc()
    {
        Debug.Log("1.3 Physics.RaycastNonAlloc - 无 GC 分配检测");
        
        Ray ray = new Ray(transform.position, transform.forward);
        
        // 使用预分配的数组
        int hitCount = Physics.RaycastNonAlloc(ray, hitArray, rayDistance, layerMask, queryTriggers);
        
        Debug.Log($"射线命中了 {hitCount} 个物体（无 GC 分配）");
        
        for (int i = 0; i < hitCount; i++)
        {
            RaycastHit hit = hitArray[i];
            Debug.Log($"  - {hit.collider.name}, 距离: {hit.distance}");
        }
        
        // 性能优势：避免每次调用分配新数组
        // 适用场景：频繁调用的检测（如 Update 中）
    }
    
    #endregion
    
    #region 2. 其他检测方法
    
    /// <summary>
    /// 2.1 Physics.Linecast - 线段检测
    /// 检测两点之间的线段是否与碰撞体相交
    /// </summary>
    private void TestLinecast()
    {
        Debug.Log("2.1 Physics.Linecast - 线段检测");
        
        Vector3 start = transform.position;
        Vector3 end = start + transform.forward * rayDistance;
        
        RaycastHit hit;
        if (Physics.Linecast(start, end, out hit, layerMask, queryTriggers))
        {
            Debug.Log($"线段命中: {hit.collider.name}");
            Debug.Log($"命中点: {hit.point}");
        }
        
        // Linecast 等价于从 start 到 end 的 Raycast
        // 但更简洁，不需要计算方向
    }
    
    /// <summary>
    /// 2.2 Physics.OverlapSphere - 球形检测
    /// 检测指定球形范围内的所有碰撞体
    /// </summary>
    private void TestOverlapSphere()
    {
        Debug.Log("2.2 Physics.OverlapSphere - 球形检测");
        
        Vector3 center = transform.position;
        float radius = 5f;
        
        // 检测所有碰撞体
        Collider[] colliders = Physics.OverlapSphere(center, radius, layerMask, queryTriggers);
        
        Debug.Log($"球形范围内有 {colliders.Length} 个碰撞体");
        
        foreach (Collider col in colliders)
        {
            Debug.Log($"  - {col.name}");
        }
        
        // OverlapSphereNonAlloc - 无 GC 分配版本
        Collider[] colliderArray = new Collider[10];
        int count = Physics.OverlapSphereNonAlloc(center, radius, colliderArray, layerMask, queryTriggers);
        Debug.Log($"无 GC 分配检测到 {count} 个碰撞体");
    }
    
    /// <summary>
    /// 2.3 Physics.OverlapBox - 盒形检测
    /// 检测指定盒形范围内的所有碰撞体
    /// </summary>
    private void TestOverlapBox()
    {
        Debug.Log("2.3 Physics.OverlapBox - 盒形检测");
        
        Vector3 center = transform.position;
        Vector3 halfExtents = new Vector3(2f, 2f, 2f);
        Quaternion orientation = transform.rotation;
        
        // 检测所有碰撞体
        Collider[] colliders = Physics.OverlapBox(center, halfExtents, orientation, layerMask, queryTriggers);
        
        Debug.Log($"盒形范围内有 {colliders.Length} 个碰撞体");
        
        foreach (Collider col in colliders)
        {
            Debug.Log($"  - {col.name}");
        }
        
        // OverlapBoxNonAlloc - 无 GC 分配版本
        Collider[] colliderArray = new Collider[10];
        int count = Physics.OverlapBoxNonAlloc(center, halfExtents, colliderArray, orientation, layerMask, queryTriggers);
        Debug.Log($"无 GC 分配检测到 {count} 个碰撞体");
    }
    
    #endregion
    
    #region 3. 2D 射线检测
    
    /// <summary>
    /// 3.1 Physics2D.Raycast - 2D 射线检测
    /// </summary>
    private void TestPhysics2DRaycast()
    {
        Debug.Log("3.1 Physics2D.Raycast - 2D 射线检测");
        
        Vector2 origin = transform.position;
        Vector2 direction = transform.right;
        
        // 2D 射线检测
        RaycastHit2D hit = Physics2D.Raycast(origin, direction, rayDistance, layerMask);
        
        if (hit.collider != null)
        {
            Debug.Log($"2D 射线命中: {hit.collider.name}");
            Debug.Log($"命中点: {hit.point}");
            Debug.Log($"距离: {hit.distance}");
        }
        
        // 2D 检测所有碰撞
        RaycastHit2D[] hits2D = Physics2D.RaycastAll(origin, direction, rayDistance, layerMask);
        Debug.Log($"2D 射线命中了 {hits2D.Length} 个物体");
        
        // 2D 无 GC 分配检测
        RaycastHit2D[] hitArray2D = new RaycastHit2D[10];
        int count = Physics2D.RaycastNonAlloc(origin, direction, hitArray2D, rayDistance, layerMask);
        Debug.Log($"2D 无 GC 分配检测到 {count} 个碰撞");
    }
    
    #endregion
    
    #region 4. LayerMask 使用
    
    /// <summary>
    /// 4.1 LayerMask 使用示例
    /// </summary>
    private void TestLayerMask()
    {
        Debug.Log("4.1 LayerMask 使用示例");
        
        // 方式1：在 Inspector 中设置
        // layerMask = -1; // 所有层
        
        // 方式2：通过代码设置
        int layer = LayerMask.NameToLayer("Default");
        LayerMask mask = 1 << layer; // 只检测 Default 层
        
        // 方式3：检测多个层
        int layer1 = LayerMask.NameToLayer("Default");
        int layer2 = LayerMask.NameToLayer("UI");
        LayerMask multiMask = (1 << layer1) | (1 << layer2);
        
        // 方式4：排除某些层
        LayerMask excludeMask = ~(1 << LayerMask.NameToLayer("Ignore Raycast"));
        
        Ray ray = new Ray(transform.position, transform.forward);
        RaycastHit hit;
        
        if (Physics.Raycast(ray, out hit, rayDistance, mask))
        {
            Debug.Log($"使用 LayerMask 检测到: {hit.collider.name}");
        }
    }
    
    #endregion
    
    #region 5. 实际应用场景
    
    /// <summary>
    /// 5.1 鼠标点击检测
    /// </summary>
    private void TestMouseRaycast()
    {
        if (Input.GetMouseButtonDown(0) && mainCamera != null)
        {
            // 从鼠标位置发射射线
            Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);
            RaycastHit hit;
            
            if (Physics.Raycast(ray, out hit, rayDistance, layerMask))
            {
                Debug.Log($"点击了: {hit.collider.name}");
                Debug.Log($"点击位置: {hit.point}");
                
                // 可以获取点击的对象并执行操作
                GameObject clickedObject = hit.collider.gameObject;
                // 执行点击操作...
            }
        }
    }
    
    /// <summary>
    /// 5.2 视线检测
    /// </summary>
    public bool CanSeeTarget(Transform target)
    {
        Vector3 direction = (target.position - transform.position).normalized;
        Ray ray = new Ray(transform.position, direction);
        RaycastHit hit;
        
        if (Physics.Raycast(ray, out hit, Vector3.Distance(transform.position, target.position)))
        {
            // 检查是否命中目标
            return hit.collider.transform == target;
        }
        
        return false;
    }
    
    /// <summary>
    /// 5.3 地面检测
    /// </summary>
    public bool IsGrounded(float groundDistance = 0.1f)
    {
        RaycastHit hit;
        Vector3 origin = transform.position;
        Vector3 direction = Vector3.down;
        
        if (Physics.Raycast(origin, direction, out hit, groundDistance + 0.1f))
        {
            float distance = hit.distance;
            return distance <= groundDistance;
        }
        
        return false;
    }
    
    /// <summary>
    /// 5.4 范围检测（敌人检测）
    /// </summary>
    public List<GameObject> FindEnemiesInRange(float range)
    {
        List<GameObject> enemies = new List<GameObject>();
        
        Collider[] colliders = Physics.OverlapSphere(transform.position, range, layerMask);
        
        foreach (Collider col in colliders)
        {
            if (col.CompareTag("Enemy"))
            {
                enemies.Add(col.gameObject);
            }
        }
        
        return enemies;
    }
    
    #endregion
}

#region 最佳实践总结

/*
 * Unity Raycast 最佳实践：
 * 
 * 1. 射线检测方法选择：
 *    - Raycast: 单次检测，获取第一个碰撞（最常用）
 *    - RaycastAll: 检测所有碰撞（会产生 GC）
 *    - RaycastNonAlloc: 无 GC 分配检测（推荐，频繁调用时）
 * 
 * 2. 性能优化：
 *    - 使用 RaycastNonAlloc 代替 RaycastAll（避免 GC）
 *    - 使用 OverlapSphereNonAlloc 代替 OverlapSphere
 *    - 合理设置 LayerMask 减少检测范围
 *    - 避免在 Update 中频繁调用（考虑缓存或分帧）
 * 
 * 3. LayerMask 使用：
 *    - 在 Inspector 中设置（方便调试）
 *    - 使用位运算组合多个层
 *    - 使用 ~ 排除某些层
 *    - 避免检测所有层（layerMask = -1）
 * 
 * 4. QueryTriggerInteraction：
 *    - UseGlobal: 使用全局设置
 *    - Ignore: 忽略触发器
 *    - Collide: 检测触发器
 * 
 * 5. RaycastHit 信息：
 *    - point: 碰撞点
 *    - distance: 距离
 *    - normal: 法线
 *    - collider: 碰撞体
 *    - transform: Transform 组件
 *    - rigidbody: Rigidbody 组件
 * 
 * 6. 常见应用场景：
 *    - 鼠标点击检测
 *    - 视线检测（AI）
 *    - 地面检测
 *    - 范围检测（敌人、物品）
 *    - 武器瞄准
 * 
 * 7. 注意事项：
 *    - 射线检测需要碰撞体（Collider）
 *    - 2D 和 3D 使用不同的 API
 *    - 注意射线方向（forward 是正方向）
 *    - 检查返回值是否为 null（2D）或有效（3D）
 * 
 * 8. 性能对比：
 *    - Raycast: 最快，单次检测
 *    - RaycastAll: 较慢，产生 GC
 *    - RaycastNonAlloc: 快，无 GC（推荐）
 *    - OverlapSphere: 较慢，产生 GC
 *    - OverlapSphereNonAlloc: 快，无 GC（推荐）
 */

#endregion

