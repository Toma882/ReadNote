# 对象池系统架构设计

## 设计目标

设计一套完整的对象池系统，支持多种对象类型（游戏对象、Lua对象等），实现对象复用、性能监控、智能扩容、预热机制，提供高性能的对象生命周期管理系统。

---

## 核心设计理念

### 1. 对象复用为核心

**本质**：对象池系统的核心是对象复用机制
- 对象获取 = 从池中获取，而非创建新对象
- 对象释放 = 归还到池中，而非销毁对象
- 性能优化 = 减少对象创建和销毁的开销
- GC优化 = 减少垃圾回收压力

### 2. 分层架构 + 策略模式

**本质**：分层架构实现职责分离，策略模式实现灵活扩展
- 三层架构：基础层、类型层、应用层
- 策略模式：不同类型的对象池使用不同的策略
- 接口统一：所有对象池通过统一接口管理
- 可扩展性：可以轻松添加新的对象池类型

### 3. 数据驱动架构

**本质**：对象池特性通过配置数据实现，无需修改代码
- 容量控制、扩容策略 → 通过配置数据定义
- 预热机制、清理策略 → 通过配置数据调整
- 新增对象类型 → 扩展配置数据即可
- 性能调优 → 调整配置参数即可

---

## 整体架构设计

### 三层架构 + 策略模式

```mermaid
graph TB
    subgraph BaseLayer["基础层<br/>PoolBase"]
        PoolCore["池核心<br/>对象存储/获取/释放"]
        CapacityControl["容量控制<br/>容量管理/扩容策略"]
        LifecycleManager["生命周期管理<br/>创建/销毁/清理"]
    end
    
    subgraph TypeLayer["类型层<br/>TypePool/GameObjectPool"]
        TypePool["类型对象池<br/>TypePool<br/>Lua对象池化"]
        GameObjectPool["游戏对象池<br/>GameObjectPool<br/>Unity对象池化"]
        CustomPool["自定义对象池<br/>可扩展的池类型"]
    end
    
    subgraph ApplicationLayer["应用层<br/>业务使用"]
        BulletPool["子弹池<br/>BulletPool"]
        EffectPool["特效池<br/>EffectPool"]
        UIPool["UI元素池<br/>UIPool"]
        AudioPool["音频池<br/>AudioPool"]
    end
    
    BaseLayer -->|继承| TypeLayer
    TypeLayer -->|使用| ApplicationLayer
    
    style BaseLayer fill:#e1f5ff
    style TypeLayer fill:#fff4e1
    style ApplicationLayer fill:#c8e6c9
```

### 对象复用数据流

```mermaid
graph LR
    Start[请求对象<br/>Pop] -->|1. 检查池| CheckPool{池中有对象?}
    CheckPool -->|是| GetFromPool[从池中获取<br/>复用对象]
    CheckPool -->|否| CreateNew[创建新对象<br/>New]
    CreateNew -->|2. 初始化| InitObject[初始化对象<br/>LeavePool]
    GetFromPool -->|2. 初始化| InitObject
    InitObject -->|3. 返回对象| End[返回对象<br/>使用中]
    
    Release[释放对象<br/>Push] -->|1. 清理对象| CleanObject[清理对象<br/>EnterPool]
    CleanObject -->|2. 归还池中| ReturnToPool[归还到池<br/>availableList]
    ReturnToPool -->|3. 完成| End2[释放完成]
    
    style CheckPool fill:#fff4e1,stroke:#333,stroke-width:2px
    style GetFromPool fill:#c8e6c9
    style CreateNew fill:#ffebee
    style ReturnToPool fill:#c8e6c9
```

**数据流特性**：
- ✅ **对象复用**：优先从池中获取，减少创建开销
- ✅ **自动创建**：池为空时自动创建新对象
- ✅ **生命周期管理**：对象进入/离开池时自动调用生命周期方法
- ✅ **容量控制**：支持容量限制和自动扩容
- ✅ **性能优化**：减少GC压力，提高响应速度

---

## 基础层架构设计

### 核心职责

对象存储管理 + 容量控制 + 生命周期管理

### 架构图

```mermaid
graph TB
    subgraph PoolBase["PoolBase基础对象池"]
        ObjectStorage["对象存储<br/>availableList/inUseList"]
        CapacityManager["容量管理器<br/>capacity/maxCapacity"]
        LifecycleManager["生命周期管理器<br/>EnterPool/LeavePool"]
        PerformanceMonitor["性能监控器<br/>命中率/统计信息"]
    end
    
    subgraph CoreMethods["核心方法"]
        Pop["Pop<br/>获取对象"]
        Push["Push<br/>释放对象"]
        Create["Create<br/>创建对象"]
        Destroy["Destroy<br/>销毁对象"]
    end
    
    subgraph AdvancedFeatures["高级功能"]
        AutoResize["自动扩容<br/>SetAutoResize"]
        Prefill["预热机制<br/>Prefill"]
        Cleanup["清理机制<br/>CleanupIdleObjects"]
        Monitor["性能监控<br/>GetPerformanceReport"]
    end
    
    PoolBase --> CoreMethods
    PoolBase --> AdvancedFeatures
    
    style PoolBase fill:#e1f5ff
    style CoreMethods fill:#fff4e1
    style AdvancedFeatures fill:#c8e6c9
```

### 核心组件

1. **对象存储（ObjectStorage）**
   - `availableList`：可用对象列表（池中空闲对象）
   - `inUseList`：使用中对象列表（正在使用的对象）
   - 支持快速获取和释放

2. **容量管理器（CapacityManager）**
   - `capacity`：当前容量
   - `maxCapacity`：最大容量限制
   - 支持自动扩容和容量调整

3. **生命周期管理器（LifecycleManager）**
   - `EnterPool()`：对象进入池时的清理逻辑
   - `LeavePool()`：对象离开池时的初始化逻辑
   - 自动调用对象的生命周期方法

---

## 类型层架构设计

### 核心职责

类型化对象池 + 特殊对象处理

### 架构图

```mermaid
graph TB
    subgraph TypePool["TypePool类型对象池"]
        TypeSafety["类型安全<br/>类型检查"]
        TypeStorage["类型存储<br/>按类型分组"]
        TypeFactory["类型工厂<br/>创建特定类型对象"]
    end
    
    subgraph GameObjectPool["GameObjectPool游戏对象池"]
        GameObjectStorage["GameObject存储<br/>Unity对象管理"]
        GameObjectFactory["GameObject工厂<br/>实例化/销毁"]
        GameObjectLifecycle["GameObject生命周期<br/>SetActive/OnEnable/OnDisable"]
    end
    
    subgraph IPoolable["IPoolable接口"]
        EnterPoolMethod["EnterPool方法<br/>进入池时调用"]
        LeavePoolMethod["LeavePool方法<br/>离开池时调用"]
    end
    
    TypePool -->|实现| IPoolable
    GameObjectPool -->|实现| IPoolable
    
    style TypePool fill:#fff4e1
    style GameObjectPool fill:#fff4e1
    style IPoolable fill:#c8e6c9
```

### 工作流程

```mermaid
flowchart TD
    Start[请求对象<br/>Pop] --> CheckType{检查类型<br/>TypePool}
    CheckType -->|类型匹配| CheckAvailable{池中有可用对象?}
    CheckType -->|类型不匹配| CreateNew[创建新对象<br/>TypeFactory]
    
    CheckAvailable -->|是| GetFromPool[从池中获取<br/>availableList]
    CheckAvailable -->|否| CreateNew
    
    GetFromPool --> CallLeavePool[调用LeavePool<br/>初始化对象]
    CreateNew --> CallLeavePool
    CallLeavePool --> ReturnObject[返回对象<br/>添加到inUseList]
    
    Release[释放对象<br/>Push] --> CallEnterPool[调用EnterPool<br/>清理对象]
    CallEnterPool --> ReturnToPool[归还到池<br/>添加到availableList]
    ReturnToPool --> CheckCapacity{检查容量<br/>是否超过maxCapacity?}
    CheckCapacity -->|是| DestroyObject[销毁对象<br/>释放内存]
    CheckCapacity -->|否| KeepInPool[保留在池中]
    
    style CheckType fill:#fff4e1,stroke:#333,stroke-width:2px
    style CheckAvailable fill:#fff4e1,stroke:#333,stroke-width:2px
    style CheckCapacity fill:#fff4e1,stroke:#333,stroke-width:2px
    style GetFromPool fill:#c8e6c9
    style ReturnToPool fill:#c8e6c9
```

---

## 高级功能架构设计

### 智能扩容机制

**核心思想**：根据使用情况自动调整池大小

```mermaid
graph TB
    Monitor[监控使用情况<br/>命中率/使用量] --> CheckResize{是否需要扩容?<br/>使用率 > 阈值}
    CheckResize -->|是| CheckCooldown{是否在冷却期?}
    CheckResize -->|否| Continue[继续监控]
    
    CheckCooldown -->|否| Resize[执行扩容<br/>capacity *= resizeFactor]
    CheckCooldown -->|是| Wait[等待冷却<br/>cooldownTime]
    Wait --> Continue
    
    Resize --> CreateObjects[创建新对象<br/>填充到池中]
    CreateObjects --> UpdateCooldown[更新冷却时间<br/>lastResizeTime]
    UpdateCooldown --> Continue
    
    style CheckResize fill:#fff4e1,stroke:#333,stroke-width:2px
    style CheckCooldown fill:#fff4e1,stroke:#333,stroke-width:2px
    style Resize fill:#c8e6c9
```

### 预热机制

**核心思想**：提前创建对象，减少首次使用延迟

```mermaid
graph TB
    Prefill[预填充请求<br/>Prefill] --> CreateBatch[批量创建对象<br/>创建count个对象]
    CreateBatch --> InitObjects[初始化对象<br/>调用LeavePool]
    InitObjects --> AddToPool[添加到池<br/>availableList]
    
    SmartWarmup[智能预热<br/>SmartWarmup] --> Analyze[分析使用模式<br/>使用频率/峰值]
    Analyze --> Predict[预测需求<br/>计算预热数量]
    Predict --> Prefill
    
    style Prefill fill:#e1f5ff
    style SmartWarmup fill:#fff4e1
    style CreateBatch fill:#c8e6c9
```

### 性能监控系统

**核心思想**：实时监控对象池使用情况，提供性能报告

```mermaid
graph TB
    subgraph PerformanceMonitor["性能监控器"]
        HitRateTracker["命中率追踪<br/>hitCount/totalCount"]
        TimeTracker["时间追踪<br/>平均获取时间"]
        UsageTracker["使用追踪<br/>总创建/获取/释放"]
    end
    
    Pop[Pop操作] -->|记录| HitRateTracker
    Pop -->|记录时间| TimeTracker
    Pop -->|记录| UsageTracker
    
    Push[Push操作] -->|记录| UsageTracker
    
    HitRateTracker --> Report[性能报告<br/>GetPerformanceReport]
    TimeTracker --> Report
    UsageTracker --> Report
    
    style PerformanceMonitor fill:#e1f5ff
    style Report fill:#c8e6c9
```

---

## 架构模式分析

### 对象池模式（Object Pool Pattern）

**核心思想**：复用对象而非创建新对象

```mermaid
graph LR
    Client[客户端<br/>请求对象] --> Pool[对象池<br/>PoolBase]
    Pool -->|池中有对象| Reuse[复用对象<br/>从availableList获取]
    Pool -->|池中无对象| Create[创建对象<br/>New]
    Create -->|初始化| Init[初始化对象<br/>LeavePool]
    Reuse -->|初始化| Init
    Init -->|返回| Client
    
    Client -->|释放对象| Pool
    Pool -->|清理| Clean[清理对象<br/>EnterPool]
    Clean -->|归还| Return[归还到池<br/>添加到availableList]
    
    style Pool fill:#f3e5f5
    style Reuse fill:#c8e6c9
    style Create fill:#ffebee
```

**优势**：
- ✅ **性能优化**：减少对象创建和销毁开销
- ✅ **GC优化**：减少垃圾回收压力
- ✅ **响应速度**：从池中获取比创建新对象更快
- ✅ **内存控制**：通过容量控制管理内存使用

### 工厂模式（Factory Pattern）

**核心思想**：对象池作为工厂创建和管理对象

```mermaid
graph TB
    Factory[对象池工厂<br/>PoolBase]
    
    Product1[产品1<br/>Bullet对象]
    Product2[产品2<br/>Effect对象]
    Product3[产品3<br/>UI对象]
    
    Factory -->|创建/复用| Product1
    Factory -->|创建/复用| Product2
    Factory -->|创建/复用| Product3
    
    Product1 -->|归还| Factory
    Product2 -->|归还| Factory
    Product3 -->|归还| Factory
    
    style Factory fill:#f3e5f5
    style Product1 fill:#c8e6c9
    style Product2 fill:#c8e6c9
    style Product3 fill:#c8e6c9
```

---

## 数据流设计

### 对象获取流程

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Pool as PoolBase
    participant Storage as ObjectStorage
    participant Factory as ObjectFactory
    participant Object as 对象
    
    Client->>Pool: Pop(type)
    Pool->>Storage: 检查availableList
    Storage-->>Pool: 有可用对象
    Pool->>Storage: 从availableList移除
    Pool->>Object: LeavePool()
    Object-->>Pool: 初始化完成
    Pool->>Storage: 添加到inUseList
    Pool-->>Client: 返回对象
    
    alt 池中无对象
        Pool->>Factory: Create(type)
        Factory-->>Pool: 创建新对象
        Pool->>Object: LeavePool()
        Object-->>Pool: 初始化完成
        Pool->>Storage: 添加到inUseList
        Pool-->>Client: 返回对象
    end
```

### 对象释放流程

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Pool as PoolBase
    participant Storage as ObjectStorage
    participant Object as 对象
    
    Client->>Pool: Push(object)
    Pool->>Object: EnterPool()
    Object-->>Pool: 清理完成
    Pool->>Storage: 从inUseList移除
    Pool->>Storage: 检查容量
    alt 超过容量
        Pool->>Object: Destroy()
        Object-->>Pool: 销毁完成
    else 未超过容量
        Pool->>Storage: 添加到availableList
        Storage-->>Pool: 归还完成
    end
    Pool-->>Client: 释放完成
```

---

## 架构验证

### 流程合理性验证

从架构可验证：
- ✅ **数据流完整**：获取对象 → 使用 → 释放 → 归还（完整流程）
- ✅ **职责清晰**：基础层、类型层、应用层职责明确，无重叠
- ✅ **解耦设计**：通过接口和继承实现层间解耦
- ✅ **生命周期管理**：对象进入/离开池时自动调用生命周期方法

### 扩展性验证

从架构可验证：
- ✅ **策略模式**：新增对象池类型只需继承PoolBase
- ✅ **接口统一**：所有对象池通过统一接口管理
- ✅ **配置驱动**：对象池特性通过配置数据扩展
- ✅ **灵活扩展**：可以轻松添加新的高级功能

### 性能验证

从架构可验证：
- ✅ **对象复用**：优先从池中获取，减少创建开销
- ✅ **自动扩容**：根据使用情况自动调整池大小
- ✅ **预热机制**：提前创建对象，减少首次使用延迟
- ✅ **性能监控**：实时监控使用情况，优化性能

---

## 开发指导原则

### 一、开发约束（什么能做，什么不能做）

#### ✅ 应该做的

1. **对象必须实现IPoolable接口**
   ```
   ✅ 正确：
   对象类实现 EnterPool() 和 LeavePool() 方法
   
   ❌ 错误：
   对象不实现IPoolable接口
   ```

2. **对象获取必须通过Pop**
   ```
   ✅ 正确：
   local obj = pool:Pop(type)
   
   ❌ 错误：
   直接创建对象，不通过池
   ```

3. **对象释放必须通过Push**
   ```
   ✅ 正确：
   pool:Push(obj)
   
   ❌ 错误：
   直接销毁对象，不归还到池
   ```

#### ❌ 不应该做的

1. **禁止直接创建对象**
   - 必须通过对象池获取对象
   - 不能绕过对象池直接创建

2. **禁止直接销毁对象**
   - 必须通过对象池释放对象
   - 不能绕过对象池直接销毁

3. **禁止修改池内部状态**
   - 不能直接操作availableList和inUseList
   - 必须通过Pop和Push接口操作

### 二、开发流程（标准化开发步骤）

#### 使用对象池的标准流程

```
1. 创建对象池
   ↓
   local pool = TypePool.New(ObjectType, initialCapacity)
   
2. 配置对象池（可选）
   ↓
   pool:SetAutoResize(true)
   pool:Prefill(10)
   
3. 获取对象
   ↓
   local obj = pool:Pop(type)
   
4. 使用对象
   ↓
   -- 使用对象...
   
5. 释放对象
   ↓
   pool:Push(obj)
```

---

## 总结

### 架构设计价值

该架构设计文档的价值在于：
- ✅ **思路解构**：完整解构对象池系统的搭建思路
- ✅ **流程验证**：从架构层面验证流程合理性
- ✅ **模式分析**：分析对象池模式、工厂模式的应用
- ✅ **开发指导**：为后续详细设计和实现提供清晰指导

### 设计原则

- ✅ **对象复用为核心**：减少对象创建和销毁开销
- ✅ **分层架构 + 策略模式**：实现职责分离和灵活扩展
- ✅ **数据驱动架构**：对象池特性通过配置数据实现
- ✅ **性能优化**：智能扩容、预热机制、性能监控

### 架构特点

- ✅ **高性能**：对象复用减少创建开销，提升性能
- ✅ **GC优化**：减少垃圾回收压力
- ✅ **智能管理**：自动扩容、预热机制、容量控制
- ✅ **灵活扩展**：可以轻松添加新的对象池类型和高级功能

细节实现是后续开发阶段的工作，当前架构设计已足够指导整个对象池系统的开发。
