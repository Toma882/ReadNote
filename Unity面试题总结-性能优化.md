  # Unity 面试题总结 - 性能优化

> **整理时间**：2025年  
> **用途**：面试准备 + Unity性能优化知识复习  
> **重点**：DrawCall优化、内存优化、CPU/GPU优化、UI优化等核心知识点

---

## 目录

- [Unity 面试题总结 - 性能优化](#unity-面试题总结---性能优化)
  - [目录](#目录)
  - [1. 什么是DrawCall？DrawCall高了又什么影响？如何降低DrawCall？](#1-什么是drawcalldrawcall高了又什么影响如何降低drawcall)
    - [降低DrawCall的方法](#降低drawcall的方法)
  - [2. UI优化小知识](#2-ui优化小知识)
    - [UI动静分离](#ui动静分离)
    - [拆分过重的UI](#拆分过重的ui)
    - [UI预加载](#ui预加载)
    - [UI图集Alpha分离](#ui图集alpha分离)
    - [UI字体拆分](#ui字体拆分)
    - [ScrollView优化](#scrollview优化)
    - [对象池运用](#对象池运用)
    - [UI贴图设置优化](#ui贴图设置优化)
      - [高低端机型画质优化](#高低端机型画质优化)
    - [UI图集拼接优化](#ui图集拼接优化)
  - [3. 层消隐距离技术](#3-层消隐距离技术)
  - [4. LOD是什么，优缺点是什么?](#4-lod是什么优缺点是什么)
  - [5. 合批](#5-合批)
  - [6. 静态合批](#6-静态合批)
    - [原理](#原理)
    - [操作方法](#操作方法)
    - [优点](#优点)
    - [缺点](#缺点)
  - [7. 动态合批](#7-动态合批)
    - [原理](#原理-1)
    - [优点](#优点-1)
    - [限制条件](#限制条件)
  - [8. 动态合批跟静态合批的区别](#8-动态合批跟静态合批的区别)
  - [9. 如何优化内存?](#9-如何优化内存)
  - [10. mask和rectmask2d的区别](#10-mask和rectmask2d的区别)
    - [Mask](#mask)
    - [RectMask2D](#rectmask2d)
  - [11. 贴图透明通道分离，压缩格式设为ETC/PVRTC](#11-贴图透明通道分离压缩格式设为etcpvrtc)
  - [12. 关闭贴图的读写选项](#12-关闭贴图的读写选项)
  - [13. Unity 在移动设备上的一些优化资源的方法](#13-unity-在移动设备上的一些优化资源的方法)
  - [14. CPU端性能优化小知识点](#14-cpu端性能优化小知识点)
  - [15. GPU端性能优化小知识点](#15-gpu端性能优化小知识点)
  - [16. 内存优化小知识点](#16-内存优化小知识点)
  - [17. 简述一下对象池，你觉得在FPS里哪些东西适合使用对象池？](#17-简述一下对象池你觉得在fps里哪些东西适合使用对象池)
  - [18. UI图集的作用](#18-ui图集的作用)
  - [19. 请简述GC（垃圾回收）产生的原因，并描述如何避免？](#19-请简述gc垃圾回收产生的原因并描述如何避免)
    - [避免方法](#避免方法)
  - [20. 简述优化脚本的方法](#20-简述优化脚本的方法)
  - [21. 简述优化内存管理的方向](#21-简述优化内存管理的方向)
    - [按照不同资源、不同设备管理资源生命周期](#按照不同资源不同设备管理资源生命周期)
    - [内存泄漏（减少驻留内存）](#内存泄漏减少驻留内存)
    - [堆内存过大](#堆内存过大)
    - [CPU占用高](#cpu占用高)
    - [资源冗余](#资源冗余)
    - [磁盘空间换内存](#磁盘空间换内存)
  - [22. 简述美术优化的方向](#22-简述美术优化的方向)
    - [建立资源审查规范和审查工具](#建立资源审查规范和审查工具)
    - [资源压缩](#资源压缩)
    - [严格控制资源](#严格控制资源)
    - [粒子优化](#粒子优化)
    - [角色优化](#角色优化)
    - [模型优化](#模型优化)
    - [压缩纹理问题](#压缩纹理问题)
    - [UI优化](#ui优化)
    - [音频优化](#音频优化)
  - [23. 简述优化物理系统的方法](#23-简述优化物理系统的方法)
  - [24. 简述UI资源如何优化](#24-简述ui资源如何优化)
    - [纹理资源优化](#纹理资源优化)
    - [UI纹理图集](#ui纹理图集)
  - [总结](#总结)

---

## 1. 什么是DrawCall？DrawCall高了又什么影响？如何降低DrawCall？

Unity中，CPU准备好需要绘制的元素，对底层图形程序接口进行调用的过程，每次引擎准备数据并通知GPU的过程称为一次**Draw Call**。DrawCall越高对显卡的消耗就越大。

### 降低DrawCall的方法

1. **动态合批**
2. **静态合批**
3. **降低shader的等级特性**
4. **场景优化策略**——遮挡技术
5. **RectMask2D替代Mask**

---

## 2. UI优化小知识

### UI动静分离

以canvas为节点，设置动态canvas和静态canvas，实际项目静态元素较多，动态元素较少，动静分离后，CPU在重绘和合并时消耗就会减少。

### 拆分过重的UI

- 将界面中隐藏的独立界面做一次拆分
- 对二次显示内容，如部分动效图标，小窗口等做二次拆分

### UI预加载

UI实例化到场景中的过程：网格合并，组件初始化，渲染初始化，图片加载，界面逻辑调用等，消耗大量CPU

**预加载**：把资源加载到内存、UI实例化和UI初始化的CPU消耗放在loading等待时间线上

### UI图集Alpha分离

主要是针对NGUI方案，Unity内部已经完成了Alpha分离

1. **首先**：TexturePacker打图集时候，改成打一张RGB888的PNG图和一张Alpha8的PNG图
2. **其次**：修改NGUI的原始着色器，绑定主图和绑定Alpha图
3. **然后**：将NGUI的着色器shader中相应修改为新的颜色通道和透明通道
4. **最后**：NGUI工具类也要相应修改编辑几个类
5. **最终**：主图和Alpha图合成新图片替换原来的图片

### UI字体拆分

- 提取常用字体
- 使用TMP，同样会生成纹理和图集，相比TEXT优势是，TMP是矢量字算法，MESH顶点数少，字体同源，各语言能同屏显示

### ScrollView优化

不停滚动会导致合批网格重构、渲染裁剪

- 使用对象池进行优化
- 网格重构优化
- UI展示与关闭优化
- 对象池运用

### 对象池运用

当程序中有重复实例化并不断摧毁的对象时需要使用对象池进行优化

- 每个需要使用对象池的对象都需要继承对象池的基类对象
- 销毁操作是通过对象池接口提供的回收接口
- 场景结束时要及时销毁整个对象池

### UI贴图设置优化

#### 高低端机型画质优化

- 使用两套UI贴图，高清，低清，两套图，两套Prefab，NGUI和UGUI高清HD和SD切换的流程可以通过编写脚本程序一键搞定
- 模型和特效使用不同质量（三角面数）的预制体，预制体命名后缀做加载区分，区分等级
- 阴影根据使用情况进行区分
- 整体贴图渲染质量进行区别对待
- 使用QualitySetting的API来对阴影和贴图渲染质量做操作
- 通过程序来区分机型，iOS通过机型就能判断`UnityEngine.IOS.Device.generation == XXXX.Iphone6`；安卓通过CPU型号，内存大小，系统，平均帧率等进行综合判断

### UI图集拼接优化

- 充分利用图集空间
- 图集大小控制1024*1024
- 图片的拼接归类

---

## 3. 层消隐距离技术

如果场景中存在大量小"物件"，则可以使用"层消隐距离"来优化场景；"层消隐距离"就是在比较远的距离将小物体剔除以减少绘图调用的数量（比如：可以一个大型场景中，高大型的物体仍然可见，但是一些小装饰内容(小狗、车子之类的)则可以隐藏）

---

## 4. LOD是什么，优缺点是什么?

**LOD(Level of detail)**：多层次细节，是最常用的游戏优化技术。

它按照模型的位置和重要程度决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。

这就是说，根据摄像机与模型的距离，来决定显示哪一个模型，一般距离近的时候显示高精度多细节模型，距离远的时候显示低精度低细节模型，来加快整体场景的渲染速度。

**作用**：优化GPU

**缺点**：同一模型要准备多个模型，消耗内存。

**特点**：以内存做消耗来优化GPU

---

## 5. 合批

一次Draw Call中批量处理多个物体。只要物体的变换和材质引用相同，GPU就可以按完全相同的方式进行处理，即可以把它们放在一个Draw Call中。

**注意**：简单来说在一个Canvas下，需要相同的材质，相同的纹理以及相同的Z值。

例如UI上的字体Texture使用的是字体的图集，往往和我们自己的UI图集不一样，因此无法合批。还有UI的动态更新会影响网格的重绘，因此需要动静分离。

---

## 6. 静态合批

将static的静态物体（永远不会移动、旋转和缩放），如果相同材质球，面数在一定范围之内。unity会自动合并成一个batch送往GPU处理。

### 原理

在开始阶段把需要静态批处理的GameObject进行一次网格合并操作，然后把这个合并之后的大网格保存起来，后续都是用这个网格而不需要再进行合并。

在预处理阶段，把一些材质相同的模型的顶点统一变换到世界空间坐标下，并且新构建一个大的VB把数据保存下来，在绘制时，就会把这个大的VB提交上去，只需要设置一次渲染状态，再进行多次drawcall绘画出每个子模型。所以Static Batching是不会减少drawcall的，但由于只修改了一次渲染状态依然可以减少CPU的消耗。而且在渲染前，也可以进行视锥体剔除，减少顶点着色器对不可见的顶点的处理次数，提交GPU的效率。

### 操作方法

把要进行静态批处理的GameObject在Inspector面板右上角的Static勾选(实际上只需要勾选Batching Static即可)

### 优点

因为只需要进行一次，所以性能会比动态批处理要好。

### 缺点

- 使用静态合批需要额外的内存开销来存储合并后的几何数据
- 因为需要额外维护多一份数据，所以包体会变大，占用的内存也会变多（不能有超级大量的相同模型（如：森林里的树））

---

## 7. 动态合批

如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要进行额外的操作。

### 原理

Unity会检测哪些GameObject使用了同一个共享材质，然后去合并这些使用了同一个共享材质的网格顶点数据，形成一个新的大网格，然后传给显存，直接渲染这个大网格就相当于渲染了所有的被合并的小网格，而这只需要一次DrawCall。

在每一帧运行时，计算相同材质的模型，把他合并批次进行渲染。动态合批只需要设置一次渲染状态，且能减少drawcall次数。

### 优点

不用自己做任何事情，Unity会在游戏中自动进行动态批处理，只要满足下述条件。

### 限制条件

- **顶点属性要小于900**：例如，如果shader中需要使用顶点位置、法线和纹理坐标这三个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300。因此，优化策略就是shader的优化，少使用顶点属性，或者模型顶点数要尽可能少。（这个是《UnityShader入门精要》这本书上说到的，同时书上也说了不一定是900，可能不同版本的Unity会有所区别，这个可以自己在Unity中去手动验证得出）
- **多Pass的shader会中断批处理**
- **使用LightingMap的物体需要小心处理**：为了让这些物体可以被动态批处理，需要保证它们指向LightingMap中的同一位置

---

## 8. 动态合批跟静态合批的区别

| 特性 | 动态合批 | 静态合批 |
|------|----------|----------|
| 操作 | 一切都是自动的，不需要做任何操作 | 自由度很高，限制很少 |
| 物体移动 | 物体是可以移动的 | 经过静态批处理后的所有物体都不可以再移动了 |
| 限制 | 限制很多 | 限制很少 |
| 发生时机 | 发生在游戏运行的时候 | 发生在加载场景的时候 |
| 缺点 | - | 缺点可能会占用更多的内存 |

---

## 9. 如何优化内存?

有很多种方式，例如：

1. **压缩自带类库**
2. **将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉**
3. **释放AssetBundle占用的资源**
4. **降低模型的片面数，降低模型的骨骼数量，降低贴图的大小**
5. **使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)**

---

## 10. mask和rectmask2d的区别

### Mask

- 使用模板缓冲来实现区域切除逻辑（Stencil），会占用两个DC
- 它实现最初设置模板缓存会给Mask添加一个特殊的材质，并且以像素为单位存储是否需要显示最后还原模板缓存，这两次操作各增加一次DC
- 它可以和其他Mask子物体进行合批，如果两个mask重叠了，那就不能进行合批，会产生额外的dc

### RectMask2D

- 继承自IClipper接口，内部主要实现的就是一个方法来实现了区域的切除逻辑，本身是不占用DC的
- 完全遮住的情况下不会绘制顶点和面，不参与深度运算不占用DC（和mask的最大区别）
- **缺点**：它无法和RectMask的子物体进行合批，只能和自身的子物体进行合批（注：如果本身带了Image组件的话是可以进行合批的）
- RectMask2D只能矩形，要不同形状的遮罩还是得mask，所以RectMask2D并不一定完全好，他在特定情况下无法合批

---

## 11. 贴图透明通道分离，压缩格式设为ETC/PVRTC

最初我们使用了DXT5作为贴图压缩格式，希望能减小贴图的内存占用，但很快发现移动平台的显卡是不支持的。因此对于一张1024x1024大小的RGBA32贴图，虽然DXT5可将它从4MB压缩到1MB，但系统将它送进显卡之前，会先用CPU在内存里将它解压成4MB的RGBA32格式（软件解压），然后再将这4MB送进显存。于是在这段时间里，这张贴图就占用了5MB内存和4MB显存；而移动平台往往没有独立显存，需要从内存里抠一块作为显存，于是原以为只占1MB内存的贴图实际却占了9MB！

所有不支持硬件解压的压缩格式都有这个问题。经过一番调研，我们发现安卓上硬件支持最广泛的格式是ETC，苹果上则是PVRTC。但这两种格式都是不带透明（Alpha）通道的。因此我们将每张原始贴图的透明通道都分离了出来，写进另一张贴图的红色通道里。这两张贴图都采用ETC/PVRTC压缩。渲染的时候，将两张贴图都送进显存。同时我们修改了NGUI的shader，在渲染时将第二张贴图的红色通道写到第一张贴图的透明通道里，恢复原来的颜色：

```glsl
fixed4 frag (v2f i) : COLOR
{
    fixed4 col;
    col.rgb = tex2D(_MainTex, i.texcoord).rgb;
    col.a = tex2D(_AlphaTex, i.texcoord).r;
    return col * i.color;
}
```

---

## 12. 关闭贴图的读写选项

Unity中导入的每张贴图都有一个启用可读可写（Read/Write Enabled）的开关，对应的程序参数是`TextureImporter.isReadable`。

选中贴图后可在Import Setting选项卡中看到这个开关。只有打开这个开关，才可以对贴图使用`Texture2D.GetPixel`，读取或改写贴图资源的像素，但这就需要系统在内存里保留一份贴图的拷贝，以供CPU访问。

一般游戏运行时不会有这样的需求，因此我们对所有贴图都关闭了这个开关，只在编辑中做贴图导入后处理（比如对原始贴图分离透明通道）时打开它。

这样，上文提到的1024x1024大小的贴图，其运行时的2MB内存占用又可以少一半，减小到1MB。

---

## 13. Unity 在移动设备上的一些优化资源的方法

1. **使用assetbundle**：实现资源分离和共享，将内存控制到200m之内，同时也可以实现资源的在线更新

2. **顶点数优化**：顶点数对渲染无论是cpu还是gpu都是压力最大的贡献者，降低顶点数到8万以下，fps稳定到了30帧左右

3. **光照优化**：只使用一盏动态光，不是用阴影，不使用光照探头

4. **粒子系统优化**：
   - 粒子系统是cpu上的大头
   - 剪裁粒子系统
   - 合并同时出现的粒子系统
   - 自己实现轻量级的粒子系统

5. **Animator优化**：
   - animator也是一个效率奇差的地方
   - 把不需要跟骨骼动画和动作过渡的地方全部使用animation，控制骨骼数量在30根以下
   - animator出视不更新
   - 删除无意义的animator
   - animator的初始化很耗时（粒子上能不能尽量不用animator）
   - 除主角外都不要跟骨骼运动apply root motion

6. **碰撞体优化**：绝对禁止掉那些不带刚体带包围盒的物体（static collider）运动

7. **NGUI优化**：
   - NUGI的代码效率很差，基本上runtime的时候对cpu的贡献和render不相上下
   - 每帧递归的计算finalalpha改为只有初始化和变动时计算
   - 去掉法线计算
   - 不要每帧计算viewsize和windowsize
   - filldrawcall时构建顶点缓存使用array.copy

8. **代码优化**：
   - 代码剪裁：使用strip level，使用.net2.0 subset
   - 尽量减少smooth group
   - 给美术定一个严格的经过科学验证的美术标准，并在U3D里面配以相应的检查工具

---

## 14. CPU端性能优化小知识点

1. **逻辑和表现尽可能分离开**：这样逻辑层的更新频率可以适当降低些

2. **分帧处理**：对于一些热点函数，如mmo的实体更新、实例化，使用分帧处理，分摊单帧时间消耗

3. **同屏控制**：做好同屏实体数量、特效数量、距离显隐等优化

4. **日志优化**：完善日志输出，避免没必要的日志输出，同时警惕日志字符串拼接

5. **骨骼优化**：使用骨骼烘焙 + GPUSkinning + Instance 降低CPU蒙皮骨骼消耗和drawcall

6. **模型优化**：开启模型的Optimize GameObjects减少节点数量和蒙皮更新消耗

7. **UI优化**：
   - UI拼预制做好动静分离，对于像血条名字这种频繁变动的ui，做好适当的分组

8. **Lua交互优化**：减少C#和lua的频繁交互，尽量精简两者传递的参数结构

9. **字符串优化**：使用stringbuilder优化字符串拼接的gc问题

10. **脚本优化**：
    - 删除非必要的脚本功能函数，特别是Update/LateUpdate类高频执行函数，因为会产生C++到C#层的调用开销
    - 对于Update里需要用到的组件、节点等提前Cache好

11. **资源复用**：场景里频繁使用的资源或数据结构做好资源复用和对象池

12. **UI显示隐藏优化**：对于频繁显示隐藏的UI，可以先移出到屏幕外，如果长时间不显示再进行Deactive

13. **图集优化**：合理拆分UI图集，区分共用图集和非共用图集，共用图集可以常驻内存，非共用图集优先按功能分类，避免资源冗余

14. **编译优化**：使用IL2CPP，编译成C++版本能极大的提升整体性能

15. **材质优化**：
    - 避免直接使用Material.Setxxx/Getxxx等调用，这些调用会触发材质实例化消耗，可以考虑使用SharedMaterial / MaterialPropertyBlock代替
    - 合并Shader里的Uniform变量

---

## 15. GPU端性能优化小知识点

1. **渲染顺序优化**：合理规划好渲染顺序，避免不必要的overdraw，如：地形（容易被其他物件遮挡）、天空盒放到较后渲染

2. **分辨率缩放**：对于填充率出现瓶颈时，这个是最简单高效的

3. **避免GrabPass**：避免使用GrabPass抓屏，不是所有硬件都支持，加之数据回拷和没法控制分辨率性能很差，可考虑使用CommandBuffer.blit去优化

4. **地形优化**：控制好地形的Blend层数，控制在4层以内，考虑到地形一般屏占面积大、贴图采样次数多，对于中低画质考虑不用normalmap

5. **LOD优化**：做好物件、树、角色的LOD

6. **DepthTexture优化**：避免使用RenderWithShader类方式来定制DepthTexture，可以考虑Camera的`public void SetTargetBuffers(RenderBuffer colorBuffer, RenderBuffer depthBuffer);`进行优化

7. **Shader优化**：
    - 检查Shader的VertexInput和VertexOutput是否存在冗余数据。如：顶点色、多套UV
    - 警惕项目里非必要的双面材质，对于需要局部双面的地方通过加面解决
    - Shader里使用fixed、half代替float，理论上除position、uv、一些涉及depth相关计算使用float外，其他都应该使用fixed（主要是颜色值）、half
    - Shader里避免使用分支、循环，sin、tan、pow、log等复杂数学运算

8. **角色皮肤优化**：对于角色皮肤这种不是特别明显的效果，考虑使用预积分这种低成本的方案

9. **计算优化**：对于frag里的计算过程，如果可以抽出来放到CPU应用层、顶点阶段的优先放这里计算。需要注意放到顶点阶段引起的平滑过渡问题。如：eyeVec导致高光过渡问题

10. **反射优化**：镜面反射类效果避免使用反射相机+RT的实现，考虑使用SSR、CubeMap类实现

11. **阴影优化**：避免使用实时阴影，如若使用要合理控制下分辨率和阴影距离。考虑使用Projector

12. **后处理优化**：使用统一的后处理框架代替多个Image Effect，可以共用模糊函数，减少blit操作。另外Unity自带的Postprocessing V2支持Volume，性能还是不错的

13. **遮挡剔除优化**：Unity自带的遮挡剔除因为CPU消耗和内存占用较高，加之不能Instancing，不太适合移动平台，可以考虑静态预计算(缺点是不支持动态物体)、Hi-Z等优化方案

14. **Alpha Test优化**：减少alpha test材质的使用，如若使用注意减小面积、控制渲染顺序

---

## 16. 内存优化小知识点

1. **压缩自带类库**
2. **对象管理**：将暂时不用的以后还需要使用的物体隐藏起来而不是直接Destroy掉
3. **AssetBundle管理**：释放AssetBundle占用的资源
4. **资源优化**：
   - 降低模型的片面数，降低模型的骨骼数量，降低贴图的大小
   - 使用光照贴图，使用多层次细节(LOD)，使用着色器(Shader)，使用预设(Prefab)

5. **配置表优化**：警惕配置表内存占用

6. **Shader优化**：
   - 排查项目冗余的shader
   - 避免使用Standard材质，做好相应的variant skip
   - 排查项目冗余的Shader
   - 使用shader_feature替代multi_compile，这样只会收集项目里真正使用的变体组合，避免变体翻倍

7. **GC优化**：减少容器扩容或者利用string字符串拼接等一系列产生GC的操作

8. **纹理资源检查**：检查纹理资源的尺寸、格式、压缩方式、mipmap、Read & Write选项使用是否合理

9. **Mesh资源检查**：检查Mesh资源的Read & Write选项、顶点属性使用是否合理

10. **代码级别检查**：
    - 如Cache预分配空间、容器的Capacity、GC等
    - 使用Profiler定位下GC，特别是Update类函数里的。如：字符串拼接、滥用容器等

11. **RenderTexture优化**：合理控制RenderTexture的尺寸

12. **动画优化**：优化动画Animation的压缩方式、浮点精度、去除里面的Scale曲线数据

13. **场景优化**：减少场景GameObject节点的数量，最好支持工具监控

---

## 17. 简述一下对象池，你觉得在FPS里哪些东西适合使用对象池？

对象池就存放需要被反复调用资源的一个空间，比如游戏中要常被大量复制的对象，子弹，敌人，以及任何重复出现的对象。

**FPS游戏中适合使用对象池的对象**：
- 子弹
- 敌人
- 特效
- 血条
- 伤害数字
- 拾取物品

---

## 18. UI图集的作用

- **图集就是碎图合成大图**：降低内存，减少DC
- **UI图集有合批没有的优点**：就是热更新的时候因为小文件变少了，所以会快一些
- **UI图集就是UI的动态合批**
- **UI图集完成合批的条件**：深度、贴图、材质 => 排序好的列表当前这个依次和前面对比是否贴图和材质ID相同决定是否合批

---

## 19. 请简述GC（垃圾回收）产生的原因，并描述如何避免？

**GC垃圾回收机制**：避免堆内存溢出，定期回收那些没有有效引用的对象内存

**GC优化**：就是优化堆内存，减少堆内存，即时回收堆内存

**GC归属于CLR**

### 避免方法

1. **减少new的次数**
2. **字符串优化**：
   - 字符串拼接使用stringbuilder
   - 字符串比较先定义一个变量存储，防止产生无效内存
3. **容器优化**：list，new时候，规定内存大小
4. **射线检测优化**：如果要射线检测，应该使用避免GC的方法XXXXNoAlloc函数
5. **循环优化**：foreach迭代器容易导致GC（目前Unity5.5已修复），使用For循环
6. **静态变量**：使用静态变量，GC不会回收存在的对象，但静态变量的引用对象可能被回收
7. **枚举替代字符串**：使用枚举替代字符串变量
8. **Tag比较优化**：调用`gameobject.tag=="XXX"`就会产生内存垃圾；那么采用`GameObject.CompareTag()`可以避免内存垃圾的产生
9. **避免频繁分配**：不要在频繁调用的函数中反复进行堆内存分配，比如OnTriggerXXX，Update等函数
10. **计时器优化**：在Update函数中，运行有规律的但不需要每一帧执行的代码，可以使用计时器，比如1秒执行一次某些代码

---

## 20. 简述优化脚本的方法

1. **减少查找函数调用**：减少GetComponent、find等查找函数在Update等循环函数中的调用
2. **Tag比较优化**：go.CompareTag代替go.tag
3. **减少同步函数调用**：减少SendMessage等同步函数调用
4. **字符串优化**：减少字符串连接
5. **循环优化**：for代替foreach，5.5以后版本foreach已经优化过了
6. **LINQ优化**：少用linq
7. **异步加载**：大资源改为异步加载
8. **协程优化**：合理处理协程调用
9. **多线程**：将AI、网络等放在单独线程
10. **发布优化**：关闭log、剔除代码
11. **随机数优化**：伪随机
12. **架构优化**：脚本挂载类改为Manager等全局类实现
13. **Lua优化**：lua中尽量不实现update、fixedupdate等循环函数，lua和csharp互调用的效率比较低

---

## 21. 简述优化内存管理的方向

### 按照不同资源、不同设备管理资源生命周期

Resources.Load和Assetbundle统一接口，利用引用计数来管理生命周期，并打印和观察生命周期。保证资源随场景而卸载，不常驻内存，确定哪些是预加载，哪些泄漏。

### 内存泄漏（减少驻留内存）

Container内资源不remove掉用Resources.UnloadUnusedAssets是卸载不掉的；对于这种情况，建议直接通过Profiler Memory中的Take Sample来对其进行检测，通过直接查看WebStream或SerializedFile中的AssetBundle名称，即可判断是否存在"泄露"情况；通过Android PSS/iOS Instrument反馈的App线程内存来查看

### 堆内存过大

避免一次性堆内存的过大分配，Mono的堆内存一旦分配，就不会返还给系统，这意味着Mono的堆内存是只升不降的。

**常见原因**：
- 高频调用new
- log输出

### CPU占用高

1. **NGUI的重建网格**：导致UIPanel.LateUpdate（按照静止、移动、高频移动来切分）

2. **NGUI锚点优化**：NGUI锚点自身的更新逻辑也会消耗不少CPU开销。即使是在控件静止不动的情况下，控件的锚点也会每帧更新（见UIWidget.OnUpdate函数），而且它的更新是递归式的，使CPU占用率更高。因此我们修改了NGUI的内部代码，使锚点只在必要时更新。一般只在控件初始化和屏幕大小发生变化时更新即可。不过这个优化的代价是控件的顶点位置发生变化的时候（比如控件在运动，或控件大小改变等），上层逻辑需要自己负责更新锚点。

3. **加载优化**：加载用协程

4. **UIPanel优化**：控制同一个UIPanel中动态UI元素的数量，数量越多，所创建的Mesh越大，从而使得重构的开销显著增加。比如，战斗过程中的HUD血条可能会大量出现，此时，建议研发团队将运动血条分离成不同的UIPanel，每组UIPanel下5~10个动态UI为宜。这种做法，其本质是从概率上尽可能降低单帧中UIPanel的重建开销。

### 资源冗余

- AssetBundle打包打到多份中
- 动态修改资源导致的Instance拷贝多份（比如动态修改材质，Renderer.meterial，Animation.AddClip）

### 磁盘空间换内存

对于占用WebStream较大的AssetBundle文件（如UI Atlas相关的AssetBundle文件等），建议使用LoadFromCacheOrDownLoad或CreateFromFile来进行替换，即将解压后的AssetBundle数据存储于本地Cache中进行使用。这种做法非常适合于内存特别吃紧的项目，即通过本地的磁盘空间来换取内存空间

---

## 22. 简述美术优化的方向

### 建立资源审查规范和审查工具

- PBR材质贴图制作规范
- 场景制作资源控制规范
- 角色制作规范
- 特效制作规范
- 利用AssetPostprocessor建立审查工具

### 资源压缩

- 压缩纹理
- 优化精灵填充率
- 压缩动画
- 压缩声音
- 压缩UI（九宫格优于拉伸）

### 严格控制资源

- 严格控制模型面数、纹理数、角色骨骼数

### 粒子优化

- 录制动画代替粒子
- 减少粒子数量
- 粒子不要碰撞

### 角色优化

- 启用Optimize Game Objects减少节点
- 使用（SimpleLOD、Cruncher）优化面数

### 模型优化

导入检查：
- Read/Write only
- Optimize Mesh
- 法线切线
- color
- 禁用Mipmap

### 压缩纹理问题

- 压缩可能导致色阶不足
- 无透明通道用ETC1，现在安卓不支持ETC2已不足5%，建议放弃分离通道办法

### UI优化

- 尽可能将动态UI元素和静态UI元素分离到不同的UIPanel中（UI的重建以UIPanel为单位），从而尽可能将因为变动的UI元素引起的重构控制在较小的范围内
- 尽可能让动态UI元素按照同步性进行划分，即运动频率不同的UI元素尽可能分离放在不同的UIPanel中
- UGUI：可以充分利用canvas来切分不同元素
- 大贴图会导致卡顿，可以切分为多个加载

### 音频优化

- iOS使用mp3压缩
- Android使用Vorbis压缩

---

## 23. 简述优化物理系统的方法

1. **Static设置**：不需要移动的物体设为Static
2. **碰撞体优化**：不要用Mesh碰撞，角色不用碰撞体
3. **触发器逻辑优化**
4. **频率优化**：
   - 寻路频率
   - AI逻辑频率
   - Fixed Timestep
   - 降帧到30
5. **分帧处理**：出现卡顿的复杂计算，例如寻路、大量资源加载可以用分帧或者协成异步来处理

---

## 24. 简述UI资源如何优化

### 纹理资源优化

1. **单个纹理尺寸**：为2的幂次方，最大尺寸1024*1024（内存优化）
2. **纹理加载方式**：流式纹理加载Texture Streaming
3. **细节优化**：不通过增加纹理大小来增加细节，而是通过增加细节贴图DetailMap或增加高反差保留
4. **纹理压缩**：
   - 可以使用ETC1+Alpha（安卓）
   - ETC2（安卓）
   - PVRTC（ios）
   - ASTC 6x6
   - ASTC更优，内存大小相同的情况下，纹理效果最好，加载速度最快，包体最小
5. **纹理MipMap**：逐级减低分辨率来保存纹理副本，相当于纹理LOD
   - 内存变大1/3，通过Mipmap开启可以限制不同平台加载不同level层级的贴图

### UI纹理图集

1. **UI图集最大尺寸**：1024*1024
2. **重复利用的公用资源**：放common图集（drawcall优化）
3. **同一个界面UI资源**：放一个图集（drawcall优化）
4. **九宫格优化**：使用九宫格来减少原图大小（内存优化）
5. **提高图集利用率**：
   - 原图分辨率需要包含在1024*1024尺寸下，如果原图过大需要进行拆分，放入图集中
   - 图集合并提升利用率，如果图集低于1/3 就要合并图集

---

## 总结

这份Unity性能优化面试题总结涵盖了以下核心知识点：

1. **DrawCall优化**：合批、LOD、遮挡剔除
2. **UI优化**：动静分离、图集、字体、ScrollView
3. **内存优化**：资源管理、GC优化、纹理优化
4. **CPU优化**：分帧处理、逻辑分离、脚本优化
5. **GPU优化**：渲染顺序、Shader优化、后处理
6. **美术优化**：资源规范、压缩、模型优化
7. **物理系统优化**：Static设置、频率优化
8. **资源管理**：对象池、AssetBundle、资源生命周期

这些知识点是Unity性能优化中的核心内容，掌握这些内容对于面试和实际开发都非常重要。

---

**参考来源**：CSDN博客 - 呆呆敲代码的小Y

