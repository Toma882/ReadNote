# 人工智能

## 1.事件驱动与轮询的对比

事件驱动与轮询是两种不同的编程模型，它们在处理异步事件和并发任务时有着不同的实现方式和优缺点。

### 事件驱动（Event-Driven）

**核心思想：** 被动响应，事件发生时立即处理。

**工作原理：**
- 系统注册事件监听器
- 事件发生时，系统主动通知监听器
- 监听器执行相应的处理代码

**优点：**
- 实时响应：事件发生立即处理
- 资源高效：只在事件发生时消耗资源
- 解耦：事件发送者和接收者解耦

**缺点：**
- 事件丢失：如果监听器未注册，事件可能丢失
- 调试困难：事件流难以追踪

**应用场景：**
- UI交互（按钮点击、输入事件）
- 网络消息处理
- 游戏事件系统（伤害、死亡、状态变化）

**代码示例：**
```lua
-- 事件驱动：注册监听器，等待事件触发
EventDispatch:AddListener("OnUnitDamaged", function(unitId, damage)
    -- 事件发生时立即执行
    HandleDamage(unitId, damage)
end)
```

### 轮询（Polling）

**核心思想：** 主动检查，定期查询状态。

**工作原理：**
- 系统定期（每帧/每N秒）检查状态
- 如果状态满足条件，执行相应处理
- 持续循环检查

**优点：**
- 简单直接：逻辑清晰，易于理解
- 可控性强：检查频率可控
- 不会丢失：定期检查，不会遗漏

**缺点：**
- 资源消耗：即使没有事件也要检查
- 延迟：检查间隔导致响应延迟
- CPU占用：频繁检查消耗CPU

**应用场景：**
- AI决策（定期检查条件，做出决策）
- 状态检查（定期检查血量、距离等）
- 定时任务（定期执行某些操作）

**代码示例：**
```lua
-- 轮询：定期检查条件
function Update(dt)
    -- 每帧检查
    if unit:GetHealth() < 0.3 then
        -- 条件满足时执行
        unit:UsePotion()
    end
end
```

### 对比总结

| 特性 | 事件驱动 | 轮询 |
|------|---------|------|
| **响应方式** | 被动响应 | 主动检查 |
| **资源消耗** | 低（事件发生才处理） | 高（持续检查） |
| **实时性** | 高（立即响应） | 中（有延迟） |
| **复杂度** | 中（需要事件系统） | 低（简单循环） |
| **适用场景** | 用户交互、网络消息 | AI决策、状态检查 |

### 实际应用建议

**混合使用：**
- **事件驱动**：用于用户交互、游戏事件（伤害、死亡等）
- **轮询**：用于AI决策、状态检查、定时任务

**你的项目：**
- FSM系统已有事件系统（EventDispatch），适合事件驱动
- AI决策系统适合轮询（定期检查条件，做出决策）
- 两者结合使用，发挥各自优势


## 2.消息概念

消息概念是事件驱动编程的核心概念，它通过消息来传递事件。消息是程序中发生的某种事情，比如用户点击了一个按钮，或者一个网络请求完成了。消息驱动程序会监听这些消息，并在消息发生时执行相应的处理代码。


## 3.状态机

状态机（State Machine）是一种用于管理对象状态和状态转换的计算模型。在游戏开发中，状态机用于管理角色的行为状态、游戏流程、AI状态等。

### 状态机的核心概念

**状态（State）**：对象在某个时刻的特定情况或模式
- 例如：Idle（空闲）、Combat（战斗）、Flee（逃跑）

**转换（Transition）**：从一个状态切换到另一个状态的条件和过程
- 例如：Idle → Combat（发现敌人时）

**事件（Event）**：触发状态转换的外部或内部事件
- 例如：OnEnemySpotted（发现敌人）、OnHealthLow（生命值低）

### 项目中的FSM系统

项目已实现完整的FSM状态机系统，支持四种类型：

**1. 基础状态机（Basic FSM）**
```lua
-- 创建基础状态机
local fsm = FSMKit.Pop(EFSM.Basic, "AI_StateMachine")

-- 添加状态
fsm:AddState(EAIState.Idle, IdleAIState)
fsm:AddState(EAIState.Combat, CombatAIState)

-- 切换状态
fsm:ChangeState(EAIState.Idle)
```

**2. 下推状态机（PDA - Pushdown Automaton）**
- 支持状态栈，可以保存历史状态
- 适用于菜单系统、暂停/恢复场景

**3. 并发状态机（Parallel FSM）**
- 多个子状态机并行运行
- 适用于角色多系统并行控制

**4. 层次状态机（Hierarchical FSM）**
- 支持状态嵌套
- 适用于复杂的状态嵌套管理

### 状态机的优势

- ✅ **逻辑清晰**：状态和转换关系明确
- ✅ **易于维护**：状态变化集中管理
- ✅ **可扩展**：新增状态只需添加新状态类
- ✅ **可调试**：状态变化可追踪

---

## 4.一个使用消息的事件驱动的状态机

结合消息系统和状态机，可以实现消息驱动的状态转换。当收到特定消息时，状态机自动转换到相应状态。

### 核心思想

**消息驱动**：状态转换由消息触发，而非直接调用
**事件驱动**：消息作为事件，状态机作为事件处理器

### 实现方式

```lua
-- 1. 创建消息驱动的状态机
local aiFSM = FSMKit.Pop(EFSM.Basic, "AI_FSM")

-- 2. 定义状态转换规则（消息 → 状态）
aiFSM:AddTransition(EAIState.Idle, EMessageType.EnemySpotted, EAIState.Combat)
aiFSM:AddTransition(EAIState.Combat, EMessageType.HealthLow, EAIState.Flee)
aiFSM:AddTransition(EAIState.Combat, EMessageType.EnemyKilled, EAIState.Idle)

-- 3. 发送消息触发状态转换
MessageSystem:SendMessage(aiFSM, EMessageType.EnemySpotted, {
    enemy = targetUnit
})

-- 4. 状态机自动处理消息并转换状态
function AIFSM:OnMessage(messageType, context)
    local currentState = self.currentState
    local targetState = self:GetTransition(currentState, messageType)
    
    if targetState then
        self:ChangeState(targetState, context)
    end
end
```

### 优势

- ✅ **解耦**：消息发送者不需要知道状态机的具体实现
- ✅ **灵活**：可以动态添加状态转换规则
- ✅ **可配置**：状态转换规则可以从配置表读取

---

## 5.交待时间

"交待时间"（Handoff Time）是指状态转换时的过渡时间，或者消息传递的时间延迟。在游戏AI中，这通常指：

### 时间处理场景

**1. 状态转换延迟**
```lua
-- 延迟状态转换
function AIFSM:ChangeStateWithDelay(newState, delay, context)
    Timer:Delay(delay, function()
        self:ChangeState(newState, context)
    end)
end
```

**2. 消息延迟传递**
```lua
-- 延迟发送消息
MessageSystem:SendDelayedMessage(
    targetFSM,
    EMessageType.EnemySpotted,
    {enemy = targetUnit},
    2.0  -- 延迟2秒
)
```

**3. 状态过渡动画时间**
```lua
-- 状态转换时等待动画完成
function CombatAIState:OnEnter(context)
    -- 播放进入战斗动画
    self:PlayAnimation("CombatEnter", function()
        -- 动画完成后才真正进入战斗状态
        self:OnEnterComplete(context)
    end)
end
```

### 实际应用

- **平滑过渡**：避免状态突然切换，提供视觉过渡
- **时序控制**：确保某些操作在特定时间执行
- **性能优化**：延迟非关键操作，分散计算压力

---

## 6.另一个小交待

"另一个小交待"通常指状态机或消息系统的补充说明，可能包括：

### 边界情况处理

**1. 无效状态转换**
```lua
-- 检查状态转换是否有效
function AIFSM:CanTransition(fromState, toState)
    local validTransitions = self.transitionTable[fromState]
    return validTransitions and validTransitions[toState] ~= nil
end
```

**2. 状态转换失败处理**
```lua
-- 状态转换失败时的回退
function AIFSM:ChangeState(newState, context)
    if not self:CanTransition(self.currentState, newState) then
        LogWarning("无效的状态转换: " .. self.currentState .. " -> " .. newState)
        return false
    end
    
    -- 执行转换
    return self:DoChangeState(newState, context)
end
```

**3. 消息丢失处理**
```lua
-- 消息队列满时的处理
function MessageSystem:SendMessage(targetFSM, messageType, context)
    if self.queue:IsFull() then
        -- 丢弃最旧的消息或拒绝新消息
        self:HandleQueueFull(messageType, context)
        return false
    end
    
    self.queue:Enqueue({targetFSM, messageType, context})
    return true
end
```

---

## 7.状态机构建单元

状态机的构建单元包括状态类、转换规则、消息处理器等基础组件。

### 状态类（State Class）

```lua
-- 基础状态类
local BaseAIState = BaseClass(FSMState)

function BaseAIState:OnEnter(context)
    -- 进入状态时的处理
end

function BaseAIState:OnUpdate(context)
    -- 状态更新逻辑
end

function BaseAIState:OnExit(context)
    -- 退出状态时的处理
end

-- 具体状态实现
local IdleAIState = BaseClass(BaseAIState)

function IdleAIState:OnEnter(context)
    LogInfo("AI进入空闲状态")
    -- 停止移动，播放待机动画
end

function IdleAIState:OnUpdate(context)
    -- 检查是否需要转换状态
    if self:CheckEnemyInRange(context) then
        self:GetFSM():ChangeState(EAIState.Combat, context)
    end
end
```

### 转换规则（Transition Rules）

```lua
-- 转换规则定义
TransitionRules = {
    [EAIState.Idle] = {
        [EMessageType.EnemySpotted] = EAIState.Combat,
        [EMessageType.HealthLow] = EAIState.Flee,
    },
    [EAIState.Combat] = {
        [EMessageType.EnemyKilled] = EAIState.Idle,
        [EMessageType.HealthLow] = EAIState.Flee,
    }
}
```

### 消息处理器（Message Handler）

```lua
-- 状态机的消息处理器
function AIFSM:OnMessage(messageType, context)
    local currentStateId = self.currentState and self.currentState.stateId
    local targetStateId = self:GetTransition(currentStateId, messageType)
    
    if targetStateId then
        self:ChangeState(targetStateId, context)
    end
end
```

---

## 8.状态机消息路由选择

消息路由是指将消息发送到正确的状态机实例。在多个状态机共存时，需要确定消息应该发送给哪个状态机。

### 路由策略

**1. 直接路由（Direct Routing）**
```lua
-- 直接指定目标状态机
MessageSystem:SendMessage(targetFSM, messageType, context)
```

**2. 类型路由（Type-based Routing）**
```lua
-- 根据状态机类型路由
MessageSystem:SendMessageToType(EFSMType.AI, messageType, context)
-- 所有AI类型的状态机都会收到消息
```

**3. 标签路由（Tag-based Routing）**
```lua
-- 根据标签路由
MessageSystem:SendMessageToTag("EnemyAI", messageType, context)
-- 所有带有"EnemyAI"标签的状态机都会收到消息
```

**4. 范围路由（Range-based Routing）**
```lua
-- 根据位置范围路由
MessageSystem:SendMessageInRange(position, range, messageType, context)
-- 范围内的所有状态机都会收到消息
```

### 路由选择器

```lua
-- 消息路由选择器
MessageRouter = {
    -- 根据单位ID路由
    RouteByUnitId = function(unitId, messageType, context)
        local unitData = UnitDataManager:GetUnit(unitId)
        if unitData and unitData.aiData and unitData.aiData.aiFSM then
            MessageSystem:SendMessage(unitData.aiData.aiFSM, messageType, context)
        end
    end,
    
    -- 根据阵营路由
    RouteByFaction = function(factionId, messageType, context)
        local units = UnitDataManager:GetUnitsByFaction(factionId)
        for _, unit in ipairs(units) do
            if unit.aiData and unit.aiData.aiFSM then
                MessageSystem:SendMessage(unit.aiData.aiFSM, messageType, context)
            end
        end
    end
}
```

---

## 9.发送消息

发送消息是消息驱动状态机的核心操作。消息发送后，目标状态机会根据消息类型和当前状态决定是否转换。

### 基本消息发送

```lua
-- 同步发送消息
MessageSystem:SendMessage(targetFSM, EMessageType.EnemySpotted, {
    enemy = targetUnit,
    position = targetUnit:GetPosition()
})

-- 异步发送消息（加入队列）
MessageSystem:QueueMessage(targetFSM, EMessageType.EnemySpotted, {
    enemy = targetUnit
})
```

### 消息结构

```lua
-- 消息结构定义
Message = {
    type = EMessageType.EnemySpotted,  -- 消息类型
    sender = senderUnit,               -- 发送者
    target = targetFSM,                -- 目标状态机
    data = {                           -- 消息数据
        enemy = targetUnit,
        position = Vector3.New(10, 0, 10),
        timestamp = os.time()
    },
    priority = MessagePriority.Normal  -- 消息优先级
}
```

### 批量发送消息

```lua
-- 向多个状态机发送消息
function MessageSystem:BroadcastToFSMs(fsmList, messageType, context)
    for _, fsm in ipairs(fsmList) do
        self:SendMessage(fsm, messageType, context)
    end
end

-- 向所有AI状态机广播
function MessageSystem:BroadcastToAllAI(messageType, context)
    local allAIUnits = UnitDataManager:GetAllAIUnits()
    for _, unit in ipairs(allAIUnits) do
        if unit.aiData and unit.aiData.aiFSM then
            self:SendMessage(unit.aiData.aiFSM, messageType, context)
        end
    end
end
```

---

## 10.发送延迟消息

延迟消息允许在指定时间后发送消息，用于实现定时触发、延迟响应等场景。

### 延迟消息实现

```lua
-- 使用Timer系统实现延迟消息
function MessageSystem:SendDelayedMessage(targetFSM, messageType, context, delay)
    Timer:Delay(delay, function()
        self:SendMessage(targetFSM, messageType, context)
    end)
end

-- 延迟消息示例
-- 2秒后发现敌人
MessageSystem:SendDelayedMessage(
    aiFSM,
    EMessageType.EnemySpotted,
    {enemy = targetUnit},
    2.0
)
```

### 延迟消息队列

```lua
-- 延迟消息队列管理
DelayedMessageQueue = {
    messages = {},
    
    -- 添加延迟消息
    AddDelayedMessage = function(self, targetFSM, messageType, context, delay)
        local message = {
            targetFSM = targetFSM,
            messageType = messageType,
            context = context,
            delay = delay,
            remainingTime = delay
        }
        table.insert(self.messages, message)
    end,
    
    -- 更新延迟消息
    Update = function(self, dt)
        for i = #self.messages, 1, -1 do
            local msg = self.messages[i]
            msg.remainingTime = msg.remainingTime - dt
            
            if msg.remainingTime <= 0 then
                -- 时间到，发送消息
                MessageSystem:SendMessage(msg.targetFSM, msg.messageType, msg.context)
                table.remove(self.messages, i)
            end
        end
    end
}
```

### 应用场景

- **定时触发**：N秒后触发某个状态转换
- **延迟响应**：等待动画或效果完成后再处理
- **缓冲处理**：避免频繁状态切换

---

## 11.定义消息范围

消息范围（Message Scope）定义了消息的作用域，决定哪些状态机可以接收到消息。

### 消息范围类型

**1. 全局范围（Global Scope）**
```lua
-- 所有状态机都能收到
MessageSystem:BroadcastGlobal(EMessageType.BattleStart, {})
```

**2. 局部范围（Local Scope）**
```lua
-- 只发送给指定的状态机
MessageSystem:SendLocal(targetFSM, EMessageType.EnemySpotted, {})
```

**3. 组范围（Group Scope）**
```lua
-- 发送给特定组的所有状态机
MessageSystem:SendToGroup("EnemyAI", EMessageType.Retreat, {})
```

**4. 距离范围（Distance Scope）**
```lua
-- 发送给范围内的所有状态机
MessageSystem:SendInRange(
    centerPosition,
    radius,
    EMessageType.Alarm,
    {}
)
```

### 范围定义

```lua
-- 消息范围枚举
EMessageScope = {
    Global = "Global",      -- 全局
    Local = "Local",        -- 局部（单个状态机）
    Group = "Group",        -- 组（同类型状态机）
    Range = "Range",        -- 距离范围
    Faction = "Faction"     -- 阵营范围
}

-- 带范围的消息发送
function MessageSystem:SendMessageWithScope(scope, scopeParams, messageType, context)
    if scope == EMessageScope.Global then
        self:BroadcastGlobal(messageType, context)
    elseif scope == EMessageScope.Local then
        self:SendMessage(scopeParams.targetFSM, messageType, context)
    elseif scope == EMessageScope.Range then
        self:SendInRange(scopeParams.position, scopeParams.radius, messageType, context)
    end
end
```

---

## 12.记录所有消息活动和状态变迁

记录消息活动和状态变迁对于调试、分析和学习AI行为非常重要。

### 日志记录系统

```lua
-- 消息和状态变迁日志
AILogger = {
    logs = {},
    
    -- 记录消息
    LogMessage = function(self, messageType, sender, target, context)
        table.insert(self.logs, {
            type = "Message",
            timestamp = os.time(),
            messageType = messageType,
            sender = sender,
            target = target,
            context = context
        })
    end,
    
    -- 记录状态变迁
    LogStateTransition = function(self, fsm, fromState, toState, reason)
        table.insert(self.logs, {
            type = "StateTransition",
            timestamp = os.time(),
            fsm = fsm,
            fromState = fromState,
            toState = toState,
            reason = reason
        })
    end,
    
    -- 导出日志
    ExportLogs = function(self, filePath)
        local json = JsonUtility.ToJson(self.logs)
        File.WriteAllText(filePath, json)
    end
}
```

### 状态变迁追踪

```lua
-- 在状态机中记录状态变迁
function AIFSM:ChangeState(newState, context)
    local oldState = self.currentState
    
    -- 记录状态变迁
    AILogger:LogStateTransition(
        self,
        oldState and oldState.stateId or "None",
        newState.stateId,
        context.reason or "Unknown"
    )
    
    -- 执行状态转换
    if oldState then
        oldState:OnExit(context)
    end
    
    self.currentState = newState
    newState:OnEnter(context)
end
```

### 消息活动追踪

```lua
-- 在消息系统中记录消息活动
function MessageSystem:SendMessage(targetFSM, messageType, context)
    -- 记录消息
    AILogger:LogMessage(
        messageType,
        context.sender,
        targetFSM,
        context
    )
    
    -- 发送消息
    if targetFSM and targetFSM.OnMessage then
        targetFSM:OnMessage(messageType, context)
    end
end
```

### 分析工具

```lua
-- 分析AI行为模式
AIAnalyzer = {
    -- 统计状态停留时间
    AnalyzeStateDuration = function(self, logs)
        local stateDurations = {}
        for _, log in ipairs(logs) do
            if log.type == "StateTransition" then
                -- 计算状态持续时间
            end
        end
        return stateDurations
    end,
    
    -- 统计消息频率
    AnalyzeMessageFrequency = function(self, logs)
        local messageCounts = {}
        for _, log in ipairs(logs) do
            if log.type == "Message" then
                messageCounts[log.messageType] = (messageCounts[log.messageType] or 0) + 1
            end
        end
        return messageCounts
    end
}
```

---

## 13.交换状态机

交换状态机（Swapping State Machine）是指在不同状态机之间切换，或者临时替换状态机的行为。

### 状态机交换场景

**1. 临时替换状态机**
```lua
-- 保存当前状态机
local originalFSM = unit.aiData.aiFSM

-- 创建临时状态机（例如：被控制状态）
local controlledFSM = FSMKit.Pop(EFSM.Basic, "Controlled")
controlledFSM:AddState(EControlledState.UnderControl, ControlledState)

-- 交换状态机
unit.aiData.aiFSM = controlledFSM

-- 恢复原状态机
function RestoreOriginalFSM(unit)
    unit.aiData.aiFSM = originalFSM
    FSMKit.Push(controlledFSM)
end
```

**2. 状态机升级/降级**
```lua
-- 根据难度切换不同的状态机
function SwapFSMByDifficulty(unit, difficulty)
    local oldFSM = unit.aiData.aiFSM
    
    -- 创建新难度对应的状态机
    local newFSM = CreateFSMByDifficulty(difficulty)
    
    -- 保存当前状态
    local currentState = oldFSM.currentState
    
    -- 交换状态机
    unit.aiData.aiFSM = newFSM
    
    -- 恢复状态
    newFSM:ChangeState(currentState.stateId)
    
    -- 回收旧状态机
    FSMKit.Push(oldFSM)
end
```

**3. 状态机模板切换**
```lua
-- 根据AI策略切换状态机模板
function SwapFSMByStrategy(unit, strategyId)
    local strategyFSM = FSMTemplateManager:GetFSMTemplate(strategyId)
    local newFSM = strategyFSM:Clone()
    
    -- 交换状态机
    local oldFSM = unit.aiData.aiFSM
    unit.aiData.aiFSM = newFSM
    
    -- 回收旧状态机
    FSMKit.Push(oldFSM)
end
```

---

## 14.多状态机

多状态机（Multiple State Machines）是指一个对象同时拥有多个状态机，每个状态机管理不同的方面。

### 并发状态机

项目已支持并发状态机（Parallel FSM），可以同时运行多个子状态机：

```lua
-- 创建并发状态机
local parallelFSM = FSMKit.Pop(EFSM.Parallel, "Unit_Parallel")

-- 添加子状态机
parallelFSM:AddSubFSM("AI", aiFSM)           -- AI行为状态机
parallelFSM:AddSubFSM("Animation", animFSM)  -- 动画状态机
parallelFSM:AddSubFSM("Movement", moveFSM)   -- 移动状态机

-- 所有子状态机并行更新
parallelFSM:Update(dt)
```

### 多状态机应用场景

**1. 分层状态管理**
```lua
-- 主状态机：管理整体行为（Idle、Combat、Flee）
local mainFSM = FSMKit.Pop(EFSM.Basic, "Main")

-- 子状态机：管理战斗细节（Attack、Defend、Skill）
local combatFSM = FSMKit.Pop(EFSM.Basic, "Combat")
mainFSM:SetSubFSM(EAIState.Combat, combatFSM)
```

**2. 独立系统状态机**
```lua
-- 单位拥有多个独立的状态机
unit.aiData = {
    aiFSM = aiFSM,              -- AI决策状态机
    animationFSM = animFSM,     -- 动画状态机
    skillFSM = skillFSM,        -- 技能状态机
    movementFSM = moveFSM       -- 移动状态机
}

-- 各自独立更新
function UnitAIData:Update(dt)
    self.aiFSM:Update(dt)
    self.animationFSM:Update(dt)
    self.skillFSM:Update(dt)
    self.movementFSM:Update(dt)
end
```

**3. 状态机通信**
```lua
-- 状态机之间通过消息通信
function AnimationFSM:OnAnimationComplete(animName)
    -- 通知AI状态机动画完成
    MessageSystem:SendMessage(
        unit.aiData.aiFSM,
        EMessageType.AnimationComplete,
        {animation = animName}
    )
end
```

---

## 15.消息系统实现

消息系统是连接事件驱动和状态机的桥梁，负责消息的发送、路由、队列管理等。

### 消息系统架构

```lua
-- 消息系统核心实现
MessageSystem = {
    -- 消息队列
    messageQueue = {},
    
    -- 延迟消息队列
    delayedMessages = {},
    
    -- 消息路由表
    routingTable = {},
    
    -- 发送消息
    SendMessage = function(self, targetFSM, messageType, context)
        if not targetFSM then
            LogWarning("消息目标状态机为空")
            return false
        end
        
        -- 记录消息
        AILogger:LogMessage(messageType, context.sender, targetFSM, context)
        
        -- 直接发送或加入队列
        if self:ShouldQueue(messageType) then
            self:EnqueueMessage(targetFSM, messageType, context)
        else
            self:DeliverMessage(targetFSM, messageType, context)
        end
        
        return true
    end,
    
    -- 延迟发送消息
    SendDelayedMessage = function(self, targetFSM, messageType, context, delay)
        table.insert(self.delayedMessages, {
            targetFSM = targetFSM,
            messageType = messageType,
            context = context,
            delay = delay,
            remainingTime = delay
        })
    end,
    
    -- 处理消息队列
    ProcessQueue = function(self, dt)
        -- 处理延迟消息
        for i = #self.delayedMessages, 1, -1 do
            local msg = self.delayedMessages[i]
            msg.remainingTime = msg.remainingTime - dt
            
            if msg.remainingTime <= 0 then
                self:SendMessage(msg.targetFSM, msg.messageType, msg.context)
                table.remove(self.delayedMessages, i)
            end
        end
        
        -- 处理普通消息队列
        while #self.messageQueue > 0 do
            local msg = table.remove(self.messageQueue, 1)
            self:DeliverMessage(msg.targetFSM, msg.messageType, msg.context)
        end
    end,
    
    -- 投递消息
    DeliverMessage = function(self, targetFSM, messageType, context)
        if targetFSM and targetFSM.OnMessage then
            targetFSM:OnMessage(messageType, context)
        end
    end
}
```

### 消息优先级

```lua
-- 消息优先级
EMessagePriority = {
    Low = 1,
    Normal = 2,
    High = 3,
    Critical = 4
}

-- 优先级队列
function MessageSystem:EnqueueMessage(targetFSM, messageType, context)
    local priority = context.priority or EMessagePriority.Normal
    local message = {
        targetFSM = targetFSM,
        messageType = messageType,
        context = context,
        priority = priority
    }
    
    -- 按优先级插入队列
    local inserted = false
    for i = 1, #self.messageQueue do
        if priority > self.messageQueue[i].priority then
            table.insert(self.messageQueue, i, message)
            inserted = true
            break
        end
    end
    
    if not inserted then
        table.insert(self.messageQueue, message)
    end
end
```

---

## 16.一个状态机队列

状态机队列用于管理多个状态机的更新顺序、优先级调度等。

### 状态机队列实现

```lua
-- 状态机队列管理器
FSMQueue = {
    fsmList = {},
    updateOrder = {},  -- 更新顺序
    
    -- 添加状态机
    AddFSM = function(self, fsm, priority)
        table.insert(self.fsmList, {
            fsm = fsm,
            priority = priority or 0,
            enabled = true
        })
        
        -- 按优先级排序
        table.sort(self.fsmList, function(a, b)
            return a.priority > b.priority
        end)
    end,
    
    -- 移除状态机
    RemoveFSM = function(self, fsm)
        for i = #self.fsmList, 1, -1 do
            if self.fsmList[i].fsm == fsm then
                table.remove(self.fsmList, i)
                break
            end
        end
    end,
    
    -- 更新所有状态机
    Update = function(self, dt)
        for _, fsmData in ipairs(self.fsmList) do
            if fsmData.enabled and fsmData.fsm then
                fsmData.fsm:Update(dt)
            end
        end
    end,
    
    -- 暂停/恢复状态机
    SetFSMEnabled = function(self, fsm, enabled)
        for _, fsmData in ipairs(self.fsmList) do
            if fsmData.fsm == fsm then
                fsmData.enabled = enabled
                break
            end
        end
    end
}
```

### 应用场景

```lua
-- 战斗场景中的状态机队列
BattleFSMQueue = FSMQueue.New()

-- 添加各种状态机
BattleFSMQueue:AddFSM(battleFlowFSM, 100)    -- 战斗流程（最高优先级）
BattleFSMQueue:AddFSM(roundFSM, 90)          -- 回合管理
BattleFSMQueue:AddFSM(aiFSM, 80)            -- AI状态机
BattleFSMQueue:AddFSM(animationFSM, 50)      -- 动画状态机

-- 每帧更新
function BattleSystem:Update(dt)
    BattleFSMQueue:Update(dt)
end
```

---

## 17.代码外部脚本化行为

将AI行为配置化、脚本化，允许策划通过配置文件或脚本定义AI行为，而无需修改代码。

### 配置化决策规则

```lua
-- AI决策规则配置（JSON/Excel）
AIDecisionConfig = {
    [EAIStrategy.Aggressive] = {
        rules = {
            {
                priority = 1,
                condition = {
                    type = "health_ratio",
                    operator = "<",
                    value = 0.3
                },
                action = {
                    type = "heal",
                    target = "self"
                }
            },
            {
                priority = 2,
                condition = {
                    type = "has_enemy_in_range",
                    range = 2
                },
                action = {
                    type = "attack",
                    target = "nearest_enemy"
                }
            }
        }
    }
}
```

### Lua脚本化行为

```lua
-- AI行为脚本（Lua文件）
-- AIBehaviors/AggressiveBehavior.lua
local AggressiveBehavior = {}

function AggressiveBehavior:MakeDecision(context)
    local unitData = context.unitData
    local battleData = context.battleData
    
    -- 脚本化的决策逻辑
    if unitData:GetHealthRatio() < 0.3 then
        return {type = "heal", target = unitData}
    end
    
    local nearestEnemy = self:FindNearestEnemy(unitData, battleData)
    if nearestEnemy and self:IsInRange(unitData, nearestEnemy, 2) then
        return {type = "attack", target = nearestEnemy}
    end
    
    return {type = "move_toward_enemy", target = nearestEnemy}
end

return AggressiveBehavior
```

### 动态加载行为脚本

```lua
-- 动态加载AI行为脚本
AIScriptLoader = {
    -- 加载行为脚本
    LoadBehaviorScript = function(self, scriptPath)
        local script = require(scriptPath)
        return script
    end,
    
    -- 从配置加载
    LoadBehaviorFromConfig = function(self, strategyId)
        local cfg = ConfigManager:GetAIStrategy(strategyId)
        if cfg and cfg.scriptPath then
            return self:LoadBehaviorScript(cfg.scriptPath)
        end
        return nil
    end
}

-- 使用脚本化行为
function AIDecisionManager:MakeDecision(context)
    local strategy = context.unitData.aiData:GetAIStrategy()
    local behaviorScript = AIScriptLoader:LoadBehaviorFromConfig(strategy)
    
    if behaviorScript then
        return behaviorScript:MakeDecision(context)
    else
        -- 回退到默认决策
        return self:MakeDefaultDecision(context)
    end
end
```

### 热更新支持

```lua
-- 支持热更新AI行为脚本
function AIScriptLoader:ReloadBehaviorScript(scriptPath)
    -- 清除旧的require缓存
    package.loaded[scriptPath] = nil
    
    -- 重新加载
    return self:LoadBehaviorScript(scriptPath)
end

-- 运行时更新AI行为
function UpdateAIBehavior(unitId, newScriptPath)
    local unit = UnitDataManager:GetUnit(unitId)
    if unit and unit.aiData then
        local newBehavior = AIScriptLoader:ReloadBehaviorScript(newScriptPath)
        unit.aiData.decisionManager.behaviorScript = newBehavior
        LogInfo("AI行为已更新: " .. unitId)
    end
end
```

### 优势

- ✅ **策划友好**：策划可以通过配置表或脚本定义AI行为
- ✅ **无需重新编译**：修改配置或脚本即可改变AI行为
- ✅ **灵活扩展**：可以轻松添加新的AI行为类型
- ✅ **易于调试**：可以单独测试和调试AI行为脚本


# AI 分层架构设计分析

┌─────────────────────────────────────────┐
│          AI 核心三层（业务层）            │
├─────────────────────────────────────────┤
│  1. 数据层 (Data Layer)                  │
│     - AI 状态数据                        │
│     - 感知数据                          │
│     - 记忆数据                          │ 
├─────────────────────────────────────────┤
│  2. 决策层 (Decision Layer)              │
│     - 决策逻辑                          │
│     - 策略选择                          │
│     - 行为规划                          │
├─────────────────────────────────────────┤
│  3. 执行层 (Execution Layer)            │
│     - 动作执行                          │
│     - 状态转换                          │
│     - 反馈处理                          │
└─────────────────────────────────────────┘
         ↕️ 依赖
┌─────────────────────────────────────────┐
│       全局支持层（基础设施层）            │
├─────────────────────────────────────────┤
│  4. 技术层 (Technical Layer)            │
│     - 算法集合（寻路、评估、搜索等）     │
│     - 作为决策层的技术支撑              │
├─────────────────────────────────────────┤
│  5. 管理层 (Management Layer)            │
│     - AI 生命周期管理                    │
│     - 状态管理                          │
│     - 资源管理                          │
├─────────────────────────────────────────┤
│  6. 通讯层 (Communication Layer)        │
│     - AI 间通信                         │
│     - 消息传递                          │
│     - 事件分发                          │
└─────────────────────────────────────────┘

