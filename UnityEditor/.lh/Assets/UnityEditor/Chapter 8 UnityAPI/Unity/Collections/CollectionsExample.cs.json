{
    "sourceFile": "Assets/UnityEditor/Chapter 8 UnityAPI/Unity/Collections/CollectionsExample.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1750929209146,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750929227849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n /// </summary>\r\n public class CollectionsExample : MonoBehaviour\r\n {\r\n     [Header(\"NativeArray 示例\")]\r\n-    [SerializeField] private int arraySize = 1000;\r\n+    [SerializeField] private int arraySize = 1000; //\r\n     [SerializeField] private bool useJobSystem = true;\r\n     \r\n     [Header(\"性能测试\")]\r\n     [SerializeField] private float nativeArrayTime = 0f;\r\n"
                },
                {
                    "date": 1750929233303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,24 +9,24 @@\n /// </summary>\r\n public class CollectionsExample : MonoBehaviour\r\n {\r\n     [Header(\"NativeArray 示例\")]\r\n-    [SerializeField] private int arraySize = 1000; //\r\n-    [SerializeField] private bool useJobSystem = true;\r\n+    [SerializeField] private int arraySize = 1000; //数组大小\r\n+    [SerializeField] private bool useJobSystem = true; //是否使用Job System\r\n     \r\n     [Header(\"性能测试\")]\r\n-    [SerializeField] private float nativeArrayTime = 0f;\r\n-    [SerializeField] private float managedArrayTime = 0f;\r\n-    [SerializeField] private float speedupRatio = 0f;\r\n+    [SerializeField] private float nativeArrayTime = 0f; //NativeArray 时间\r\n+    [SerializeField] private float managedArrayTime = 0f; //托管数组时间\r\n+    [SerializeField] private float speedupRatio = 0f; //加速比\r\n     \r\n     // NativeArray 示例\r\n-    private NativeArray<int> nativeArray;\r\n-    private NativeArray<float> nativeFloatArray;\r\n-    private NativeArray<Vector3> nativeVectorArray;\r\n+    private NativeArray<int> nativeArray; //整数数组\r\n+    private NativeArray<float> nativeFloatArray; //浮点数数组\r\n+    private NativeArray<Vector3> nativeVectorArray; //向量数组\r\n     \r\n     // NativeList 示例\r\n-    private NativeList<int> nativeList;\r\n-    private NativeList<string> nativeStringList;\r\n+    private NativeList<int> nativeList; //整数列表\r\n+    private NativeList<string> nativeStringList; //字符串列表\r\n     \r\n     // NativeHashMap 示例\r\n     private NativeHashMap<int, string> nativeHashMap;\r\n     private NativeHashMap<string, Vector3> nativeVectorMap;\r\n"
                },
                {
                    "date": 1750929240157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,12 +35,12 @@\n     private NativeQueue<int> nativeQueue; //整数队列\r\n     private NativeQueue<GameObject> nativeGameObjectQueue; //游戏对象队列\r\n     \r\n     // NativeStack 示例\r\n-    private NativeStack<int> nativeStack;\r\n+    private NativeStack<int> nativeStack; //整数栈\r\n     \r\n     // 测试数据\r\n-    private int[] managedArray;\r\n+    private int[] managedArray; //托管数组  \r\n     private List<int> managedList;\r\n     private Dictionary<int, string> managedDictionary;\r\n     private Queue<int> managedQueue;\r\n     private Stack<int> managedStack;\r\n"
                },
                {
                    "date": 1750929260533,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,548 @@\n+using UnityEngine;\r\n+using Unity.Collections;\r\n+using Unity.Jobs;\r\n+using System.Collections.Generic;\r\n+\r\n+/// <summary>\r\n+/// Unity.Collections 命名空间案例演示\r\n+/// 展示Unity高性能集合系统的核心功能\r\n+/// </summary>\r\n+public class CollectionsExample : MonoBehaviour\r\n+{\r\n+    [Header(\"NativeArray 示例\")]\r\n+    [SerializeField] private int arraySize = 1000; //数组大小\r\n+    [SerializeField] private bool useJobSystem = true; //是否使用Job System\r\n+    \r\n+    [Header(\"性能测试\")]\r\n+    [SerializeField] private float nativeArrayTime = 0f; //NativeArray 时间\r\n+    [SerializeField] private float managedArrayTime = 0f; //托管数组时间\r\n+    [SerializeField] private float speedupRatio = 0f; //加速比\r\n+    \r\n+    // NativeArray 示例\r\n+    private NativeArray<int> nativeArray; //整数数组\r\n+    private NativeArray<float> nativeFloatArray; //浮点数数组\r\n+    private NativeArray<Vector3> nativeVectorArray; //向量数组\r\n+    \r\n+    // NativeList 示例\r\n+    private NativeList<int> nativeList; //整数列表\r\n+    private NativeList<string> nativeStringList; //字符串列表\r\n+    \r\n+    // NativeHashMap 示例\r\n+    private NativeHashMap<int, string> nativeHashMap; //整数到字符串的映射\r\n+    private NativeHashMap<string, Vector3> nativeVectorMap; //字符串到向量的映射\r\n+    \r\n+    // NativeQueue 示例\r\n+    private NativeQueue<int> nativeQueue; //整数队列\r\n+    private NativeQueue<GameObject> nativeGameObjectQueue; //游戏对象队列\r\n+    \r\n+    // NativeStack 示例\r\n+    private NativeStack<int> nativeStack; //整数栈\r\n+    \r\n+    // 测试数据\r\n+    private int[] managedArray; //托管数组  \r\n+    private List<int> managedList; //托管列表\r\n+    private Dictionary<int, string> managedDictionary; //托管字典\r\n+    private Queue<int> managedQueue; //托管队列\r\n+    private Stack<int> managedStack; //托管栈\r\n+    \r\n+    private void Start()\r\n+    {\r\n+        InitializeCollections();\r\n+        RunPerformanceTest();\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 初始化集合\r\n+    /// </summary>\r\n+    private void InitializeCollections()\r\n+    {\r\n+        // 初始化 NativeArray\r\n+        nativeArray = new NativeArray<int>(arraySize, Allocator.Persistent);\r\n+        nativeFloatArray = new NativeArray<float>(arraySize, Allocator.Persistent);\r\n+        nativeVectorArray = new NativeArray<Vector3>(arraySize, Allocator.Persistent);\r\n+        \r\n+        // 初始化 NativeList\r\n+        nativeList = new NativeList<int>(Allocator.Persistent);\r\n+        nativeStringList = new NativeList<string>(Allocator.Persistent);\r\n+        \r\n+        // 初始化 NativeHashMap\r\n+        nativeHashMap = new NativeHashMap<int, string>(arraySize, Allocator.Persistent);\r\n+        nativeVectorMap = new NativeHashMap<string, Vector3>(arraySize, Allocator.Persistent);\r\n+        \r\n+        // 初始化 NativeQueue\r\n+        nativeQueue = new NativeQueue<int>(Allocator.Persistent);\r\n+        nativeGameObjectQueue = new NativeQueue<GameObject>(Allocator.Persistent);\r\n+        \r\n+        // 初始化 NativeStack\r\n+        nativeStack = new NativeStack<int>(Allocator.Persistent);\r\n+        \r\n+        // 初始化托管集合\r\n+        managedArray = new int[arraySize];\r\n+        managedList = new List<int>();\r\n+        managedDictionary = new Dictionary<int, string>();\r\n+        managedQueue = new Queue<int>();\r\n+        managedStack = new Stack<int>();\r\n+        \r\n+        Debug.Log(\"集合系统初始化完成\");\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 运行性能测试\r\n+    /// </summary>\r\n+    private void RunPerformanceTest()\r\n+    {\r\n+        // 测试 NativeArray 性能\r\n+        float startTime = Time.realtimeSinceStartup;\r\n+        TestNativeArrayPerformance();\r\n+        nativeArrayTime = Time.realtimeSinceStartup - startTime;\r\n+        \r\n+        // 测试托管数组性能\r\n+        startTime = Time.realtimeSinceStartup;\r\n+        TestManagedArrayPerformance();\r\n+        managedArrayTime = Time.realtimeSinceStartup - startTime;\r\n+        \r\n+        // 计算加速比\r\n+        speedupRatio = managedArrayTime / nativeArrayTime;\r\n+        \r\n+        Debug.Log($\"性能测试结果 - NativeArray: {nativeArrayTime:F4}s, ManagedArray: {managedArrayTime:F4}s, 加速比: {speedupRatio:F2}x\");\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 测试 NativeArray 性能\r\n+    /// </summary>\r\n+    private void TestNativeArrayPerformance()\r\n+    {\r\n+        // 填充数据\r\n+        for (int i = 0; i < arraySize; i++)\r\n+        {\r\n+            nativeArray[i] = i;\r\n+            nativeFloatArray[i] = i * 0.1f;\r\n+            nativeVectorArray[i] = new Vector3(i, i * 0.5f, i * 0.25f);\r\n+        }\r\n+        \r\n+        // 执行计算\r\n+        int sum = 0;\r\n+        float floatSum = 0f;\r\n+        Vector3 vectorSum = Vector3.zero;\r\n+        \r\n+        for (int i = 0; i < arraySize; i++)\r\n+        {\r\n+            sum += nativeArray[i];\r\n+            floatSum += nativeFloatArray[i];\r\n+            vectorSum += nativeVectorArray[i];\r\n+        }\r\n+        \r\n+        // 防止编译器优化\r\n+        if (sum > 0 && floatSum > 0 && vectorSum.magnitude > 0)\r\n+        {\r\n+            // 空操作\r\n+        }\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 测试托管数组性能\r\n+    /// </summary>\r\n+    private void TestManagedArrayPerformance()\r\n+    {\r\n+        // 填充数据\r\n+        for (int i = 0; i < arraySize; i++)\r\n+        {\r\n+            managedArray[i] = i;\r\n+        }\r\n+        \r\n+        // 执行计算\r\n+        int sum = 0;\r\n+        for (int i = 0; i < arraySize; i++)\r\n+        {\r\n+            sum += managedArray[i];\r\n+        }\r\n+        \r\n+        // 防止编译器优化\r\n+        if (sum > 0)\r\n+        {\r\n+            // 空操作\r\n+        }\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 演示 NativeArray 操作\r\n+    /// </summary>\r\n+    public void DemonstrateNativeArray()\r\n+    {\r\n+        Debug.Log(\"=== NativeArray 演示 ===\");\r\n+        \r\n+        // 基本操作\r\n+        for (int i = 0; i < 10; i++)\r\n+        {\r\n+            nativeArray[i] = i * i;\r\n+            Debug.Log($\"nativeArray[{i}] = {nativeArray[i]}\");\r\n+        }\r\n+        \r\n+        // 复制操作\r\n+        NativeArray<int> copyArray = new NativeArray<int>(nativeArray, Allocator.Temp);\r\n+        Debug.Log($\"复制数组长度: {copyArray.Length}\");\r\n+        copyArray.Dispose();\r\n+        \r\n+        // 切片操作\r\n+        NativeSlice<int> slice = nativeArray.Slice(5, 5);\r\n+        Debug.Log($\"切片长度: {slice.Length}, 第一个元素: {slice[0]}\");\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 演示 NativeList 操作\r\n+    /// </summary>\r\n+    public void DemonstrateNativeList()\r\n+    {\r\n+        Debug.Log(\"=== NativeList 演示 ===\");\r\n+        \r\n+        // 添加元素\r\n+        nativeList.Add(10);\r\n+        nativeList.Add(20);\r\n+        nativeList.Add(30);\r\n+        \r\n+        Debug.Log($\"NativeList 长度: {nativeList.Length}\");\r\n+        Debug.Log($\"NativeList 容量: {nativeList.Capacity}\");\r\n+        \r\n+        // 访问元素\r\n+        for (int i = 0; i < nativeList.Length; i++)\r\n+        {\r\n+            Debug.Log($\"nativeList[{i}] = {nativeList[i]}\");\r\n+        }\r\n+        \r\n+        // 移除元素\r\n+        nativeList.RemoveAt(1);\r\n+        Debug.Log($\"移除后长度: {nativeList.Length}\");\r\n+        \r\n+        // 清空列表\r\n+        nativeList.Clear();\r\n+        Debug.Log($\"清空后长度: {nativeList.Length}\");\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 演示 NativeHashMap 操作\r\n+    /// </summary>\r\n+    public void DemonstrateNativeHashMap()\r\n+    {\r\n+        Debug.Log(\"=== NativeHashMap 演示 ===\");\r\n+        \r\n+        // 添加键值对\r\n+        nativeHashMap.Add(1, \"One\");\r\n+        nativeHashMap.Add(2, \"Two\");\r\n+        nativeHashMap.Add(3, \"Three\");\r\n+        \r\n+        Debug.Log($\"HashMap 长度: {nativeHashMap.Length()}\");\r\n+        \r\n+        // 访问值\r\n+        if (nativeHashMap.TryGetValue(2, out string value))\r\n+        {\r\n+            Debug.Log($\"Key 2 的值: {value}\");\r\n+        }\r\n+        \r\n+        // 检查键是否存在\r\n+        Debug.Log($\"Key 4 存在: {nativeHashMap.ContainsKey(4)}\");\r\n+        \r\n+        // 移除键值对\r\n+        nativeHashMap.Remove(2);\r\n+        Debug.Log($\"移除后长度: {nativeHashMap.Length()}\");\r\n+        \r\n+        // 遍历所有键值对\r\n+        var keyValueEnumerator = nativeHashMap.GetEnumerator();\r\n+        while (keyValueEnumerator.MoveNext())\r\n+        {\r\n+            var kvp = keyValueEnumerator.Current;\r\n+            Debug.Log($\"Key: {kvp.Key}, Value: {kvp.Value}\");\r\n+        }\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 演示 NativeQueue 操作\r\n+    /// </summary>\r\n+    public void DemonstrateNativeQueue()\r\n+    {\r\n+        Debug.Log(\"=== NativeQueue 演示 ===\");\r\n+        \r\n+        // 入队\r\n+        nativeQueue.Enqueue(100);\r\n+        nativeQueue.Enqueue(200);\r\n+        nativeQueue.Enqueue(300);\r\n+        \r\n+        Debug.Log($\"Queue 长度: {nativeQueue.Count}\");\r\n+        \r\n+        // 出队\r\n+        while (nativeQueue.Count > 0)\r\n+        {\r\n+            int item = nativeQueue.Dequeue();\r\n+            Debug.Log($\"出队: {item}\");\r\n+        }\r\n+        \r\n+        Debug.Log($\"出队后长度: {nativeQueue.Count}\");\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 演示 NativeStack 操作\r\n+    /// </summary>\r\n+    public void DemonstrateNativeStack()\r\n+    {\r\n+        Debug.Log(\"=== NativeStack 演示 ===\");\r\n+        \r\n+        // 压栈\r\n+        nativeStack.Push(1000);\r\n+        nativeStack.Push(2000);\r\n+        nativeStack.Push(3000);\r\n+        \r\n+        Debug.Log($\"Stack 长度: {nativeStack.Count}\");\r\n+        \r\n+        // 出栈\r\n+        while (nativeStack.Count > 0)\r\n+        {\r\n+            int item = nativeStack.Pop();\r\n+            Debug.Log($\"出栈: {item}\");\r\n+        }\r\n+        \r\n+        Debug.Log($\"出栈后长度: {nativeStack.Count}\");\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 演示 Job System 集成\r\n+    /// </summary>\r\n+    public void DemonstrateJobSystem()\r\n+    {\r\n+        if (!useJobSystem) return;\r\n+        \r\n+        Debug.Log(\"=== Job System 集成演示 ===\");\r\n+        \r\n+        // 创建作业\r\n+        var job = new ArrayProcessJob\r\n+        {\r\n+            inputArray = nativeArray,\r\n+            outputArray = new NativeArray<int>(arraySize, Allocator.TempJob)\r\n+        };\r\n+        \r\n+        // 调度作业\r\n+        JobHandle jobHandle = job.Schedule(arraySize, 64);\r\n+        \r\n+        // 等待完成\r\n+        jobHandle.Complete();\r\n+        \r\n+        // 检查结果\r\n+        Debug.Log($\"作业完成，输出数组第一个元素: {job.outputArray[0]}\");\r\n+        \r\n+        // 清理\r\n+        job.outputArray.Dispose();\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 演示并行作业\r\n+    /// </summary>\r\n+    public void DemonstrateParallelJob()\r\n+    {\r\n+        if (!useJobSystem) return;\r\n+        \r\n+        Debug.Log(\"=== 并行作业演示 ===\");\r\n+        \r\n+        // 创建并行作业\r\n+        var parallelJob = new ParallelArrayJob\r\n+        {\r\n+            array = nativeArray\r\n+        };\r\n+        \r\n+        // 调度并行作业\r\n+        JobHandle jobHandle = parallelJob.Schedule(arraySize, 64);\r\n+        jobHandle.Complete();\r\n+        \r\n+        Debug.Log(\"并行作业完成\");\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 演示内存管理\r\n+    /// </summary>\r\n+    public void DemonstrateMemoryManagement()\r\n+    {\r\n+        Debug.Log(\"=== 内存管理演示 ===\");\r\n+        \r\n+        // 使用 Temp 分配器（自动管理）\r\n+        using (var tempArray = new NativeArray<int>(100, Allocator.Temp))\r\n+        {\r\n+            Debug.Log($\"临时数组长度: {tempArray.Length}\");\r\n+            // 离开作用域时自动释放\r\n+        }\r\n+        \r\n+        // 使用 TempJob 分配器（需要手动释放）\r\n+        var jobArray = new NativeArray<int>(100, Allocator.TempJob);\r\n+        Debug.Log($\"作业数组长度: {jobArray.Length}\");\r\n+        jobArray.Dispose(); // 手动释放\r\n+        \r\n+        Debug.Log(\"内存管理演示完成\");\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 比较托管集合和 Native 集合\r\n+    /// </summary>\r\n+    public void CompareCollections()\r\n+    {\r\n+        Debug.Log(\"=== 集合比较 ===\");\r\n+        \r\n+        // 填充托管集合\r\n+        for (int i = 0; i < 100; i++)\r\n+        {\r\n+            managedList.Add(i);\r\n+            managedDictionary[i] = $\"Value_{i}\";\r\n+            managedQueue.Enqueue(i);\r\n+            managedStack.Push(i);\r\n+        }\r\n+        \r\n+        // 填充 Native 集合\r\n+        for (int i = 0; i < 100; i++)\r\n+        {\r\n+            nativeList.Add(i);\r\n+            nativeHashMap.Add(i, $\"Value_{i}\");\r\n+            nativeQueue.Enqueue(i);\r\n+            nativeStack.Push(i);\r\n+        }\r\n+        \r\n+        Debug.Log($\"托管 List 长度: {managedList.Count}\");\r\n+        Debug.Log($\"Native List 长度: {nativeList.Length}\");\r\n+        Debug.Log($\"托管 Dictionary 长度: {managedDictionary.Count}\");\r\n+        Debug.Log($\"Native HashMap 长度: {nativeHashMap.Length()}\");\r\n+        Debug.Log($\"托管 Queue 长度: {managedQueue.Count}\");\r\n+        Debug.Log($\"Native Queue 长度: {nativeQueue.Count}\");\r\n+        Debug.Log($\"托管 Stack 长度: {managedStack.Count}\");\r\n+        Debug.Log($\"Native Stack 长度: {nativeStack.Count}\");\r\n+    }\r\n+    \r\n+    /// <summary>\r\n+    /// 清理所有集合\r\n+    /// </summary>\r\n+    public void ClearAllCollections()\r\n+    {\r\n+        // 清理 Native 集合\r\n+        if (nativeArray.IsCreated) nativeArray.Dispose();\r\n+        if (nativeFloatArray.IsCreated) nativeFloatArray.Dispose();\r\n+        if (nativeVectorArray.IsCreated) nativeVectorArray.Dispose();\r\n+        if (nativeList.IsCreated) nativeList.Dispose();\r\n+        if (nativeStringList.IsCreated) nativeStringList.Dispose();\r\n+        if (nativeHashMap.IsCreated) nativeHashMap.Dispose();\r\n+        if (nativeVectorMap.IsCreated) nativeVectorMap.Dispose();\r\n+        if (nativeQueue.IsCreated) nativeQueue.Dispose();\r\n+        if (nativeGameObjectQueue.IsCreated) nativeGameObjectQueue.Dispose();\r\n+        if (nativeStack.IsCreated) nativeStack.Dispose();\r\n+        \r\n+        // 清理托管集合\r\n+        managedList.Clear();\r\n+        managedDictionary.Clear();\r\n+        managedQueue.Clear();\r\n+        managedStack.Clear();\r\n+        \r\n+        Debug.Log(\"所有集合已清理\");\r\n+    }\r\n+    \r\n+    private void OnDestroy()\r\n+    {\r\n+        // 确保在销毁时释放所有 Native 集合\r\n+        ClearAllCollections();\r\n+    }\r\n+    \r\n+    private void OnGUI()\r\n+    {\r\n+        // 简单的GUI界面用于测试\r\n+        GUILayout.BeginArea(new Rect(10, 10, 400, 600));\r\n+        GUILayout.Label(\"Unity Collections 演示\", EditorStyles.boldLabel);\r\n+        \r\n+        GUILayout.Space(10);\r\n+        \r\n+        // 性能信息\r\n+        GUILayout.Label($\"NativeArray 时间: {nativeArrayTime:F4}s\");\r\n+        GUILayout.Label($\"ManagedArray 时间: {managedArrayTime:F4}s\");\r\n+        GUILayout.Label($\"加速比: {speedupRatio:F2}x\");\r\n+        \r\n+        GUILayout.Space(10);\r\n+        \r\n+        // 操作按钮\r\n+        if (GUILayout.Button(\"演示 NativeArray\"))\r\n+        {\r\n+            DemonstrateNativeArray();\r\n+        }\r\n+        \r\n+        if (GUILayout.Button(\"演示 NativeList\"))\r\n+        {\r\n+            DemonstrateNativeList();\r\n+        }\r\n+        \r\n+        if (GUILayout.Button(\"演示 NativeHashMap\"))\r\n+        {\r\n+            DemonstrateNativeHashMap();\r\n+        }\r\n+        \r\n+        if (GUILayout.Button(\"演示 NativeQueue\"))\r\n+        {\r\n+            DemonstrateNativeQueue();\r\n+        }\r\n+        \r\n+        if (GUILayout.Button(\"演示 NativeStack\"))\r\n+        {\r\n+            DemonstrateNativeStack();\r\n+        }\r\n+        \r\n+        GUILayout.Space(10);\r\n+        \r\n+        if (GUILayout.Button(\"演示 Job System\"))\r\n+        {\r\n+            DemonstrateJobSystem();\r\n+        }\r\n+        \r\n+        if (GUILayout.Button(\"演示并行作业\"))\r\n+        {\r\n+            DemonstrateParallelJob();\r\n+        }\r\n+        \r\n+        if (GUILayout.Button(\"演示内存管理\"))\r\n+        {\r\n+            DemonstrateMemoryManagement();\r\n+        }\r\n+        \r\n+        GUILayout.Space(10);\r\n+        \r\n+        if (GUILayout.Button(\"比较集合\"))\r\n+        {\r\n+            CompareCollections();\r\n+        }\r\n+        \r\n+        if (GUILayout.Button(\"清理所有集合\"))\r\n+        {\r\n+            ClearAllCollections();\r\n+        }\r\n+        \r\n+        GUILayout.Space(10);\r\n+        \r\n+        useJobSystem = GUILayout.Toggle(useJobSystem, \"启用 Job System\");\r\n+        \r\n+        GUILayout.EndArea();\r\n+    }\r\n+}\r\n+\r\n+/// <summary>\r\n+/// 数组处理作业\r\n+/// </summary>\r\n+public struct ArrayProcessJob : IJobParallelFor\r\n+{\r\n+    [ReadOnly] public NativeArray<int> inputArray;\r\n+    [WriteOnly] public NativeArray<int> outputArray;\r\n+    \r\n+    public void Execute(int index)\r\n+    {\r\n+        outputArray[index] = inputArray[index] * 2;\r\n+    }\r\n+}\r\n+\r\n+/// <summary>\r\n+/// 并行数组作业\r\n+/// </summary>\r\n+public struct ParallelArrayJob : IJobParallelFor\r\n+{\r\n+    public NativeArray<int> array;\r\n+    \r\n+    public void Execute(int index)\r\n+    {\r\n+        array[index] = array[index] + 1;\r\n+    }\r\n+} \n\\ No newline at end of file\n"
                }
            ],
            "date": 1750929209146,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing Unity.Collections;\r\nusing Unity.Jobs;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// Unity.Collections 命名空间案例演示\r\n/// 展示Unity高性能集合系统的核心功能\r\n/// </summary>\r\npublic class CollectionsExample : MonoBehaviour\r\n{\r\n    [Header(\"NativeArray 示例\")]\r\n    [SerializeField] private int arraySize = 1000;\r\n    [SerializeField] private bool useJobSystem = true;\r\n    \r\n    [Header(\"性能测试\")]\r\n    [SerializeField] private float nativeArrayTime = 0f;\r\n    [SerializeField] private float managedArrayTime = 0f;\r\n    [SerializeField] private float speedupRatio = 0f;\r\n    \r\n    // NativeArray 示例\r\n    private NativeArray<int> nativeArray;\r\n    private NativeArray<float> nativeFloatArray;\r\n    private NativeArray<Vector3> nativeVectorArray;\r\n    \r\n    // NativeList 示例\r\n    private NativeList<int> nativeList;\r\n    private NativeList<string> nativeStringList;\r\n    \r\n    // NativeHashMap 示例\r\n    private NativeHashMap<int, string> nativeHashMap;\r\n    private NativeHashMap<string, Vector3> nativeVectorMap;\r\n    \r\n    // NativeQueue 示例\r\n    private NativeQueue<int> nativeQueue;\r\n    private NativeQueue<GameObject> nativeGameObjectQueue;\r\n    \r\n    // NativeStack 示例\r\n    private NativeStack<int> nativeStack;\r\n    \r\n    // 测试数据\r\n    private int[] managedArray;\r\n    private List<int> managedList;\r\n    private Dictionary<int, string> managedDictionary;\r\n    private Queue<int> managedQueue;\r\n    private Stack<int> managedStack;\r\n    \r\n    private void Start()\r\n    {\r\n        InitializeCollections();\r\n        RunPerformanceTest();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 初始化集合\r\n    /// </summary>\r\n    private void InitializeCollections()\r\n    {\r\n        // 初始化 NativeArray\r\n        nativeArray = new NativeArray<int>(arraySize, Allocator.Persistent);\r\n        nativeFloatArray = new NativeArray<float>(arraySize, Allocator.Persistent);\r\n        nativeVectorArray = new NativeArray<Vector3>(arraySize, Allocator.Persistent);\r\n        \r\n        // 初始化 NativeList\r\n        nativeList = new NativeList<int>(Allocator.Persistent);\r\n        nativeStringList = new NativeList<string>(Allocator.Persistent);\r\n        \r\n        // 初始化 NativeHashMap\r\n        nativeHashMap = new NativeHashMap<int, string>(arraySize, Allocator.Persistent);\r\n        nativeVectorMap = new NativeHashMap<string, Vector3>(arraySize, Allocator.Persistent);\r\n        \r\n        // 初始化 NativeQueue\r\n        nativeQueue = new NativeQueue<int>(Allocator.Persistent);\r\n        nativeGameObjectQueue = new NativeQueue<GameObject>(Allocator.Persistent);\r\n        \r\n        // 初始化 NativeStack\r\n        nativeStack = new NativeStack<int>(Allocator.Persistent);\r\n        \r\n        // 初始化托管集合\r\n        managedArray = new int[arraySize];\r\n        managedList = new List<int>();\r\n        managedDictionary = new Dictionary<int, string>();\r\n        managedQueue = new Queue<int>();\r\n        managedStack = new Stack<int>();\r\n        \r\n        Debug.Log(\"集合系统初始化完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 运行性能测试\r\n    /// </summary>\r\n    private void RunPerformanceTest()\r\n    {\r\n        // 测试 NativeArray 性能\r\n        float startTime = Time.realtimeSinceStartup;\r\n        TestNativeArrayPerformance();\r\n        nativeArrayTime = Time.realtimeSinceStartup - startTime;\r\n        \r\n        // 测试托管数组性能\r\n        startTime = Time.realtimeSinceStartup;\r\n        TestManagedArrayPerformance();\r\n        managedArrayTime = Time.realtimeSinceStartup - startTime;\r\n        \r\n        // 计算加速比\r\n        speedupRatio = managedArrayTime / nativeArrayTime;\r\n        \r\n        Debug.Log($\"性能测试结果 - NativeArray: {nativeArrayTime:F4}s, ManagedArray: {managedArrayTime:F4}s, 加速比: {speedupRatio:F2}x\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 测试 NativeArray 性能\r\n    /// </summary>\r\n    private void TestNativeArrayPerformance()\r\n    {\r\n        // 填充数据\r\n        for (int i = 0; i < arraySize; i++)\r\n        {\r\n            nativeArray[i] = i;\r\n            nativeFloatArray[i] = i * 0.1f;\r\n            nativeVectorArray[i] = new Vector3(i, i * 0.5f, i * 0.25f);\r\n        }\r\n        \r\n        // 执行计算\r\n        int sum = 0;\r\n        float floatSum = 0f;\r\n        Vector3 vectorSum = Vector3.zero;\r\n        \r\n        for (int i = 0; i < arraySize; i++)\r\n        {\r\n            sum += nativeArray[i];\r\n            floatSum += nativeFloatArray[i];\r\n            vectorSum += nativeVectorArray[i];\r\n        }\r\n        \r\n        // 防止编译器优化\r\n        if (sum > 0 && floatSum > 0 && vectorSum.magnitude > 0)\r\n        {\r\n            // 空操作\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 测试托管数组性能\r\n    /// </summary>\r\n    private void TestManagedArrayPerformance()\r\n    {\r\n        // 填充数据\r\n        for (int i = 0; i < arraySize; i++)\r\n        {\r\n            managedArray[i] = i;\r\n        }\r\n        \r\n        // 执行计算\r\n        int sum = 0;\r\n        for (int i = 0; i < arraySize; i++)\r\n        {\r\n            sum += managedArray[i];\r\n        }\r\n        \r\n        // 防止编译器优化\r\n        if (sum > 0)\r\n        {\r\n            // 空操作\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示 NativeArray 操作\r\n    /// </summary>\r\n    public void DemonstrateNativeArray()\r\n    {\r\n        Debug.Log(\"=== NativeArray 演示 ===\");\r\n        \r\n        // 基本操作\r\n        for (int i = 0; i < 10; i++)\r\n        {\r\n            nativeArray[i] = i * i;\r\n            Debug.Log($\"nativeArray[{i}] = {nativeArray[i]}\");\r\n        }\r\n        \r\n        // 复制操作\r\n        NativeArray<int> copyArray = new NativeArray<int>(nativeArray, Allocator.Temp);\r\n        Debug.Log($\"复制数组长度: {copyArray.Length}\");\r\n        copyArray.Dispose();\r\n        \r\n        // 切片操作\r\n        NativeSlice<int> slice = nativeArray.Slice(5, 5);\r\n        Debug.Log($\"切片长度: {slice.Length}, 第一个元素: {slice[0]}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示 NativeList 操作\r\n    /// </summary>\r\n    public void DemonstrateNativeList()\r\n    {\r\n        Debug.Log(\"=== NativeList 演示 ===\");\r\n        \r\n        // 添加元素\r\n        nativeList.Add(10);\r\n        nativeList.Add(20);\r\n        nativeList.Add(30);\r\n        \r\n        Debug.Log($\"NativeList 长度: {nativeList.Length}\");\r\n        Debug.Log($\"NativeList 容量: {nativeList.Capacity}\");\r\n        \r\n        // 访问元素\r\n        for (int i = 0; i < nativeList.Length; i++)\r\n        {\r\n            Debug.Log($\"nativeList[{i}] = {nativeList[i]}\");\r\n        }\r\n        \r\n        // 移除元素\r\n        nativeList.RemoveAt(1);\r\n        Debug.Log($\"移除后长度: {nativeList.Length}\");\r\n        \r\n        // 清空列表\r\n        nativeList.Clear();\r\n        Debug.Log($\"清空后长度: {nativeList.Length}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示 NativeHashMap 操作\r\n    /// </summary>\r\n    public void DemonstrateNativeHashMap()\r\n    {\r\n        Debug.Log(\"=== NativeHashMap 演示 ===\");\r\n        \r\n        // 添加键值对\r\n        nativeHashMap.Add(1, \"One\");\r\n        nativeHashMap.Add(2, \"Two\");\r\n        nativeHashMap.Add(3, \"Three\");\r\n        \r\n        Debug.Log($\"HashMap 长度: {nativeHashMap.Length()}\");\r\n        \r\n        // 访问值\r\n        if (nativeHashMap.TryGetValue(2, out string value))\r\n        {\r\n            Debug.Log($\"Key 2 的值: {value}\");\r\n        }\r\n        \r\n        // 检查键是否存在\r\n        Debug.Log($\"Key 4 存在: {nativeHashMap.ContainsKey(4)}\");\r\n        \r\n        // 移除键值对\r\n        nativeHashMap.Remove(2);\r\n        Debug.Log($\"移除后长度: {nativeHashMap.Length()}\");\r\n        \r\n        // 遍历所有键值对\r\n        var keyValueEnumerator = nativeHashMap.GetEnumerator();\r\n        while (keyValueEnumerator.MoveNext())\r\n        {\r\n            var kvp = keyValueEnumerator.Current;\r\n            Debug.Log($\"Key: {kvp.Key}, Value: {kvp.Value}\");\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示 NativeQueue 操作\r\n    /// </summary>\r\n    public void DemonstrateNativeQueue()\r\n    {\r\n        Debug.Log(\"=== NativeQueue 演示 ===\");\r\n        \r\n        // 入队\r\n        nativeQueue.Enqueue(100);\r\n        nativeQueue.Enqueue(200);\r\n        nativeQueue.Enqueue(300);\r\n        \r\n        Debug.Log($\"Queue 长度: {nativeQueue.Count}\");\r\n        \r\n        // 出队\r\n        while (nativeQueue.Count > 0)\r\n        {\r\n            int item = nativeQueue.Dequeue();\r\n            Debug.Log($\"出队: {item}\");\r\n        }\r\n        \r\n        Debug.Log($\"出队后长度: {nativeQueue.Count}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示 NativeStack 操作\r\n    /// </summary>\r\n    public void DemonstrateNativeStack()\r\n    {\r\n        Debug.Log(\"=== NativeStack 演示 ===\");\r\n        \r\n        // 压栈\r\n        nativeStack.Push(1000);\r\n        nativeStack.Push(2000);\r\n        nativeStack.Push(3000);\r\n        \r\n        Debug.Log($\"Stack 长度: {nativeStack.Count}\");\r\n        \r\n        // 出栈\r\n        while (nativeStack.Count > 0)\r\n        {\r\n            int item = nativeStack.Pop();\r\n            Debug.Log($\"出栈: {item}\");\r\n        }\r\n        \r\n        Debug.Log($\"出栈后长度: {nativeStack.Count}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示 Job System 集成\r\n    /// </summary>\r\n    public void DemonstrateJobSystem()\r\n    {\r\n        if (!useJobSystem) return;\r\n        \r\n        Debug.Log(\"=== Job System 集成演示 ===\");\r\n        \r\n        // 创建作业\r\n        var job = new ArrayProcessJob\r\n        {\r\n            inputArray = nativeArray,\r\n            outputArray = new NativeArray<int>(arraySize, Allocator.TempJob)\r\n        };\r\n        \r\n        // 调度作业\r\n        JobHandle jobHandle = job.Schedule(arraySize, 64);\r\n        \r\n        // 等待完成\r\n        jobHandle.Complete();\r\n        \r\n        // 检查结果\r\n        Debug.Log($\"作业完成，输出数组第一个元素: {job.outputArray[0]}\");\r\n        \r\n        // 清理\r\n        job.outputArray.Dispose();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示并行作业\r\n    /// </summary>\r\n    public void DemonstrateParallelJob()\r\n    {\r\n        if (!useJobSystem) return;\r\n        \r\n        Debug.Log(\"=== 并行作业演示 ===\");\r\n        \r\n        // 创建并行作业\r\n        var parallelJob = new ParallelArrayJob\r\n        {\r\n            array = nativeArray\r\n        };\r\n        \r\n        // 调度并行作业\r\n        JobHandle jobHandle = parallelJob.Schedule(arraySize, 64);\r\n        jobHandle.Complete();\r\n        \r\n        Debug.Log(\"并行作业完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 演示内存管理\r\n    /// </summary>\r\n    public void DemonstrateMemoryManagement()\r\n    {\r\n        Debug.Log(\"=== 内存管理演示 ===\");\r\n        \r\n        // 使用 Temp 分配器（自动管理）\r\n        using (var tempArray = new NativeArray<int>(100, Allocator.Temp))\r\n        {\r\n            Debug.Log($\"临时数组长度: {tempArray.Length}\");\r\n            // 离开作用域时自动释放\r\n        }\r\n        \r\n        // 使用 TempJob 分配器（需要手动释放）\r\n        var jobArray = new NativeArray<int>(100, Allocator.TempJob);\r\n        Debug.Log($\"作业数组长度: {jobArray.Length}\");\r\n        jobArray.Dispose(); // 手动释放\r\n        \r\n        Debug.Log(\"内存管理演示完成\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 比较托管集合和 Native 集合\r\n    /// </summary>\r\n    public void CompareCollections()\r\n    {\r\n        Debug.Log(\"=== 集合比较 ===\");\r\n        \r\n        // 填充托管集合\r\n        for (int i = 0; i < 100; i++)\r\n        {\r\n            managedList.Add(i);\r\n            managedDictionary[i] = $\"Value_{i}\";\r\n            managedQueue.Enqueue(i);\r\n            managedStack.Push(i);\r\n        }\r\n        \r\n        // 填充 Native 集合\r\n        for (int i = 0; i < 100; i++)\r\n        {\r\n            nativeList.Add(i);\r\n            nativeHashMap.Add(i, $\"Value_{i}\");\r\n            nativeQueue.Enqueue(i);\r\n            nativeStack.Push(i);\r\n        }\r\n        \r\n        Debug.Log($\"托管 List 长度: {managedList.Count}\");\r\n        Debug.Log($\"Native List 长度: {nativeList.Length}\");\r\n        Debug.Log($\"托管 Dictionary 长度: {managedDictionary.Count}\");\r\n        Debug.Log($\"Native HashMap 长度: {nativeHashMap.Length()}\");\r\n        Debug.Log($\"托管 Queue 长度: {managedQueue.Count}\");\r\n        Debug.Log($\"Native Queue 长度: {nativeQueue.Count}\");\r\n        Debug.Log($\"托管 Stack 长度: {managedStack.Count}\");\r\n        Debug.Log($\"Native Stack 长度: {nativeStack.Count}\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 清理所有集合\r\n    /// </summary>\r\n    public void ClearAllCollections()\r\n    {\r\n        // 清理 Native 集合\r\n        if (nativeArray.IsCreated) nativeArray.Dispose();\r\n        if (nativeFloatArray.IsCreated) nativeFloatArray.Dispose();\r\n        if (nativeVectorArray.IsCreated) nativeVectorArray.Dispose();\r\n        if (nativeList.IsCreated) nativeList.Dispose();\r\n        if (nativeStringList.IsCreated) nativeStringList.Dispose();\r\n        if (nativeHashMap.IsCreated) nativeHashMap.Dispose();\r\n        if (nativeVectorMap.IsCreated) nativeVectorMap.Dispose();\r\n        if (nativeQueue.IsCreated) nativeQueue.Dispose();\r\n        if (nativeGameObjectQueue.IsCreated) nativeGameObjectQueue.Dispose();\r\n        if (nativeStack.IsCreated) nativeStack.Dispose();\r\n        \r\n        // 清理托管集合\r\n        managedList.Clear();\r\n        managedDictionary.Clear();\r\n        managedQueue.Clear();\r\n        managedStack.Clear();\r\n        \r\n        Debug.Log(\"所有集合已清理\");\r\n    }\r\n    \r\n    private void OnDestroy()\r\n    {\r\n        // 确保在销毁时释放所有 Native 集合\r\n        ClearAllCollections();\r\n    }\r\n    \r\n    private void OnGUI()\r\n    {\r\n        // 简单的GUI界面用于测试\r\n        GUILayout.BeginArea(new Rect(10, 10, 400, 600));\r\n        GUILayout.Label(\"Unity Collections 演示\", EditorStyles.boldLabel);\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        // 性能信息\r\n        GUILayout.Label($\"NativeArray 时间: {nativeArrayTime:F4}s\");\r\n        GUILayout.Label($\"ManagedArray 时间: {managedArrayTime:F4}s\");\r\n        GUILayout.Label($\"加速比: {speedupRatio:F2}x\");\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        // 操作按钮\r\n        if (GUILayout.Button(\"演示 NativeArray\"))\r\n        {\r\n            DemonstrateNativeArray();\r\n        }\r\n        \r\n        if (GUILayout.Button(\"演示 NativeList\"))\r\n        {\r\n            DemonstrateNativeList();\r\n        }\r\n        \r\n        if (GUILayout.Button(\"演示 NativeHashMap\"))\r\n        {\r\n            DemonstrateNativeHashMap();\r\n        }\r\n        \r\n        if (GUILayout.Button(\"演示 NativeQueue\"))\r\n        {\r\n            DemonstrateNativeQueue();\r\n        }\r\n        \r\n        if (GUILayout.Button(\"演示 NativeStack\"))\r\n        {\r\n            DemonstrateNativeStack();\r\n        }\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        if (GUILayout.Button(\"演示 Job System\"))\r\n        {\r\n            DemonstrateJobSystem();\r\n        }\r\n        \r\n        if (GUILayout.Button(\"演示并行作业\"))\r\n        {\r\n            DemonstrateParallelJob();\r\n        }\r\n        \r\n        if (GUILayout.Button(\"演示内存管理\"))\r\n        {\r\n            DemonstrateMemoryManagement();\r\n        }\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        if (GUILayout.Button(\"比较集合\"))\r\n        {\r\n            CompareCollections();\r\n        }\r\n        \r\n        if (GUILayout.Button(\"清理所有集合\"))\r\n        {\r\n            ClearAllCollections();\r\n        }\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        useJobSystem = GUILayout.Toggle(useJobSystem, \"启用 Job System\");\r\n        \r\n        GUILayout.EndArea();\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 数组处理作业\r\n/// </summary>\r\npublic struct ArrayProcessJob : IJobParallelFor\r\n{\r\n    [ReadOnly] public NativeArray<int> inputArray;\r\n    [WriteOnly] public NativeArray<int> outputArray;\r\n    \r\n    public void Execute(int index)\r\n    {\r\n        outputArray[index] = inputArray[index] * 2;\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 并行数组作业\r\n/// </summary>\r\npublic struct ParallelArrayJob : IJobParallelFor\r\n{\r\n    public NativeArray<int> array;\r\n    \r\n    public void Execute(int index)\r\n    {\r\n        array[index] = array[index] + 1;\r\n    }\r\n} "
        }
    ]
}