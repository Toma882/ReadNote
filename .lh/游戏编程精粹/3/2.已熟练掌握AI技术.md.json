{
    "sourceFile": "游戏编程精粹/3/2.已熟练掌握AI技术.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1765967227248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1765967227248,
            "name": "Commit-0",
            "content": "# 已熟练掌握AI技术（⭐⭐⭐⭐⭐）\r\n\r\n## 游戏编程精粹3\r\n\r\n### 3.3 基于函数指针的内嵌式有限状态机\r\n- **项目已有**：完整的FSM系统实现\r\n  - ✅ **FSMKit** - 基础状态机（状态切换、事件监听、调试功能）\r\n  - ✅ **FSM_PDAKit** - 下推状态机（状态栈管理、状态历史）\r\n  - ✅ **ParallelFSMKit** - 并发状态机（多个子状态机并行运行）\r\n  - ✅ **HierarchicalFSMKit** - 层次状态机（状态嵌套、子状态机）\r\n  - ✅ **GameAI.StateMachine** - 游戏AI模块中的状态机实现\r\n  - ✅ **StateMachinePattern** - 状态机设计模式实现\r\n- **掌握程度**：完全掌握，项目中有完整的FSM系统实现，支持多种状态机类型\r\n- **学习价值**：可参考C++函数指针实现思路，优化现有Lua状态机系统\r\n- **技术对比**：\r\n  - C++函数指针实现 → Lua函数引用实现 ✅ **已实现**\r\n  - 内嵌式FSM → 完整的FSM框架 ✅ **已实现**\r\n  - 性能优化 → 对象池技术 ✅ **已使用**\r\n\r\n### 3.5 一个针对AI代理、对象,以及任务的可扩展触发器系统\r\n- **项目已有**：完整的触发器系统实现\r\n  - ✅ **TriggerKit** - 触发器核心类（触发器对象创建和管理）\r\n  - ✅ **TriggerKitFactory** - 触发器工厂类（对象池实现）\r\n  - ✅ **TriggerDefine** - 触发器相关枚举定义（触发器类型、条件、动作、事件类型）\r\n  - ✅ **TriggerUtil** - 触发器工具类（注册触发器类型、条件、动作、事件）\r\n  - ✅ **对象池集成** - 使用对象池技术管理触发器实例\r\n  - ✅ **多类型触发器** - 支持多种触发器类型，每种类型可以有独立的条件和动作定义\r\n  - ✅ **条件与动作系统** - 使用枚举定义条件类型和动作类型\r\n  - ✅ **事件驱动机制** - 支持事件分发和观察者模式\r\n- **掌握程度**：完全掌握，项目中有完整的触发器系统实现，支持自定义触发条件、动作和事件类型\r\n- **学习价值**：可参考布尔逻辑组合条件、一次性触发、标志和计数器等高级特性，扩展现有触发器系统\r\n- **学习内容**：\r\n  - 布尔逻辑组合条件（AND、OR、NOT）\r\n  - 一次性触发与载入次数\r\n  - 使用标志和计数器将触发器结合起来\r\n  - 触发器系统与脚本语言的对比\r\n\r\n### 3.6 基于A*算法的战术式寻径\r\n- **项目已有**：A*寻路算法实现和Unity NavMesh系统\r\n  - ✅ **AStar.lua** - Lua实现的A*寻路算法（网格地图寻径）\r\n  - ✅ **Unity NavMesh** - Unity导航网格系统（NavMeshAgent、NavMeshSurface）\r\n  - ✅ **CharacterPathfinder3D** - 3D角色寻径组件（NavMesh集成）\r\n  - ✅ **NavMeshComponents** - Unity官方导航网格组件系统（运行时动态生成和管理）\r\n- **掌握程度**：完全掌握，项目中有A*算法实现和Unity NavMesh系统，有大量使用经验\r\n- **学习价值**：可参考战术式寻径的扩展思路（威胁评估、暴露时间、火力线检测），优化现有寻径系统\r\n- **学习内容**：\r\n  - 有风险的A*（考虑威胁的寻径）\r\n  - 暴露时间与对敌人建模\r\n  - 威胁的动态性处理\r\n  - 有效的火力线以及视野的探测\r\n  - 扩展的A*算法的代价和性能优化\r\n\r\n### 3.7 快速游览网格的方法\r\n- **项目已有**：Unity NavMesh系统和A*寻路算法\r\n  - ✅ **Unity NavMesh** - Unity导航网格系统（自动处理网格寻径）\r\n  - ✅ **NavMeshComponents** - 导航网格组件系统（支持动态障碍）\r\n  - ✅ **AStar.lua** - A*寻路算法（网格寻径）\r\n- **掌握程度**：基本掌握，Unity NavMesh已处理大部分网格寻径需求\r\n- **学习价值**：可参考Portal系统、静态障碍与动态障碍处理、游览网格优化等思路，优化现有寻径系统\r\n- **学习内容**：\r\n  - 静态障碍与动态障碍的区别\r\n  - 游览网格的概念和实现\r\n  - Portal（门户）系统\r\n  - 建表优化方法\r\n  - 表示生物的方法\r\n  - 动态障碍的处理\r\n  - 在静态障碍与动态障碍之间进行游览\r\n\r\n### 3.8 在寻径与碰撞之间选择一种关系\r\n- **项目已有**：Unity NavMesh系统和物理碰撞系统\r\n  - ✅ **Unity NavMesh** - Unity导航网格系统（自动处理寻径）\r\n  - ✅ **Unity Physics** - Unity物理系统（碰撞检测和响应）\r\n  - ✅ **CharacterPathfinder3D** - 3D角色寻径组件（寻径与移动集成）\r\n- **掌握程度**：基本掌握，Unity NavMesh和Physics系统已处理大部分寻径与碰撞需求\r\n- **学习价值**：可参考寻径与碰撞的三种关系处理方法，优化现有系统\r\n- **学习内容**：\r\n  - 在碰撞控制下的运动\r\n  - 对于寻径的碰撞模型\r\n  - 方法1：具有容错性的AI\r\n  - 方法2：在无障碍空间一个子集内的寻径\r\n  - 方法3：使用寻径器本身处理人物碰撞\r\n  - 实现沿路的运动\r\n\r\n"
        }
    ]
}