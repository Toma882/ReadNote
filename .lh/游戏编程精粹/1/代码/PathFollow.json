{
    "sourceFile": "游戏编程精粹/1/代码/PathFollow",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1764419011020,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764419017907,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-﻿using UnityEngine;\r\n+using UnityEngine;\r\n using System.Collections.Generic;\r\n \r\n /// <summary>\r\n /// 路径跟随系统 - 优化版本\r\n"
                }
            ],
            "date": 1764419011020,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// 路径跟随系统 - 优化版本\r\n/// 整合了路径管理和路径跟随逻辑，使用更清晰的命名和优化算法\r\n/// </summary>\r\n\r\n// ==================== 路径段 ====================\r\n/// <summary>\r\n/// 路径段：表示路径上的一段，从起点到终点\r\n/// </summary>\r\npublic class PathSegment\r\n{\r\n    public Vector3 StartPoint { get; private set; }\r\n    public Vector3 EndPoint { get; private set; }\r\n    public Vector3 Direction { get; private set; }\r\n    public float Length { get; private set; }\r\n    \r\n    public PathSegment(Vector3 start, Vector3 end)\r\n    {\r\n        StartPoint = start;\r\n        EndPoint = end;\r\n        Direction = (end - start).normalized;\r\n        Length = Vector3.Distance(start, end);\r\n    }\r\n}\r\n\r\n// ==================== 路径管理 ====================\r\n/// <summary>\r\n/// 路径类：管理由多个节点组成的路径\r\n/// 优化：预计算累计距离，使用二分查找快速定位段\r\n/// </summary>\r\npublic class PathManager : MonoBehaviour\r\n{\r\n    [Header(\"路径节点\")]\r\n    public List<GameObject> PathNodes = new List<GameObject>();\r\n    \r\n    // 内部数据\r\n    private List<PathSegment> pathSegments = new List<PathSegment>();\r\n    private List<float> cumulativeDistances = new List<float>(); // 预计算：每个段结束时的累计距离\r\n    private float totalPathLength = 0f;\r\n    \r\n    // 缓存最近访问的段索引（利用局部性优化）\r\n    private int cachedSegmentIndex = 0;\r\n    \r\n    void Start()\r\n    {\r\n        BuildPath();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 构建路径：从节点生成路径段，并预计算累计距离\r\n    /// </summary>\r\n    public void BuildPath()\r\n    {\r\n        pathSegments.Clear();\r\n        cumulativeDistances.Clear();\r\n        totalPathLength = 0f;\r\n        cachedSegmentIndex = 0;\r\n        \r\n        if (PathNodes == null || PathNodes.Count < 2)\r\n        {\r\n            Debug.LogWarning(\"路径节点数量不足，至少需要2个节点\");\r\n            return;\r\n        }\r\n        \r\n        // 生成路径段\r\n        for (int i = 0; i < PathNodes.Count - 1; i++)\r\n        {\r\n            Vector3 start = PathNodes[i].transform.position;\r\n            Vector3 end = PathNodes[i + 1].transform.position;\r\n            PathSegment segment = new PathSegment(start, end);\r\n            pathSegments.Add(segment);\r\n            \r\n            // 预计算累计距离\r\n            totalPathLength += segment.Length;\r\n            cumulativeDistances.Add(totalPathLength);\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取路径总长度\r\n    /// </summary>\r\n    public float GetTotalLength()\r\n    {\r\n        return totalPathLength;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 根据3D位置获取其在路径上的距离（从起点开始的距离）\r\n    /// 优化：使用缓存和二分查找快速定位段\r\n    /// </summary>\r\n    /// <param name=\"position\">3D空间中的位置</param>\r\n    /// <param name=\"lastPathDistance\">上一次的路径距离（用于优化查找）</param>\r\n    /// <returns>从路径起点到该位置的距离</returns>\r\n    public float GetPathDistance(Vector3 position, float lastPathDistance = 0f)\r\n    {\r\n        if (pathSegments.Count == 0)\r\n            return 0f;\r\n        \r\n        // 1. 快速定位当前位置所在的路径段\r\n        int segmentIndex = FindSegmentIndex(lastPathDistance);\r\n        if (segmentIndex < 0 || segmentIndex >= pathSegments.Count)\r\n            return 0f;\r\n        \r\n        PathSegment segment = pathSegments[segmentIndex];\r\n        \r\n        // 2. 将3D位置投影到路径段上\r\n        Vector3 toPosition = position - segment.StartPoint;\r\n        Vector3 projection = Vector3.Project(toPosition, segment.Direction);\r\n        \r\n        // 3. 计算投影点在段内的距离\r\n        float distanceInSegment = projection.magnitude;\r\n        \r\n        // 限制在段范围内\r\n        distanceInSegment = Mathf.Clamp(distanceInSegment, 0f, segment.Length);\r\n        \r\n        // 4. 计算总路径距离 = 到段起点的累计距离 + 段内的距离\r\n        float distanceToSegmentStart = segmentIndex > 0 ? cumulativeDistances[segmentIndex - 1] : 0f;\r\n        float totalDistance = distanceToSegmentStart + distanceInSegment;\r\n        \r\n        // 更新缓存\r\n        cachedSegmentIndex = segmentIndex;\r\n        \r\n        return totalDistance;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 根据路径距离获取对应的3D位置\r\n    /// </summary>\r\n    /// <param name=\"pathDistance\">从路径起点开始的距离</param>\r\n    /// <returns>路径上对应距离的3D位置</returns>\r\n    public Vector3 GetPositionAtDistance(float pathDistance)\r\n    {\r\n        if (pathSegments.Count == 0)\r\n            return Vector3.zero;\r\n        \r\n        // 限制距离范围\r\n        pathDistance = Mathf.Clamp(pathDistance, 0f, totalPathLength);\r\n        \r\n        // 1. 找到对应的路径段\r\n        int segmentIndex = FindSegmentIndex(pathDistance);\r\n        if (segmentIndex < 0 || segmentIndex >= pathSegments.Count)\r\n            return pathSegments[pathSegments.Count - 1].EndPoint;\r\n        \r\n        PathSegment segment = pathSegments[segmentIndex];\r\n        \r\n        // 2. 计算在段内的距离\r\n        float distanceToSegmentStart = segmentIndex > 0 ? cumulativeDistances[segmentIndex - 1] : 0f;\r\n        float distanceInSegment = pathDistance - distanceToSegmentStart;\r\n        \r\n        // 3. 计算位置\r\n        Vector3 position = segment.StartPoint + segment.Direction * distanceInSegment;\r\n        \r\n        return position;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 查找包含指定路径距离的段索引\r\n    /// 优化：使用二分查找 + 缓存利用局部性\r\n    /// </summary>\r\n    private int FindSegmentIndex(float pathDistance)\r\n    {\r\n        if (pathSegments.Count == 0)\r\n            return -1;\r\n        \r\n        // 限制距离范围\r\n        pathDistance = Mathf.Clamp(pathDistance, 0f, totalPathLength);\r\n        \r\n        // 优化1：利用局部性，从缓存的段附近开始查找\r\n        int startIndex = Mathf.Max(0, cachedSegmentIndex - 1);\r\n        int endIndex = Mathf.Min(pathSegments.Count - 1, cachedSegmentIndex + 2);\r\n        \r\n        // 先检查缓存附近\r\n        for (int i = startIndex; i <= endIndex; i++)\r\n        {\r\n            float segmentEndDistance = cumulativeDistances[i];\r\n            float segmentStartDistance = i > 0 ? cumulativeDistances[i - 1] : 0f;\r\n            \r\n            if (pathDistance >= segmentStartDistance && pathDistance <= segmentEndDistance)\r\n            {\r\n                cachedSegmentIndex = i;\r\n                return i;\r\n            }\r\n        }\r\n        \r\n        // 优化2：如果缓存附近没找到，使用二分查找\r\n        int left = 0;\r\n        int right = cumulativeDistances.Count - 1;\r\n        \r\n        while (left <= right)\r\n        {\r\n            int mid = (left + right) / 2;\r\n            float segmentEndDistance = cumulativeDistances[mid];\r\n            float segmentStartDistance = mid > 0 ? cumulativeDistances[mid - 1] : 0f;\r\n            \r\n            if (pathDistance >= segmentStartDistance && pathDistance <= segmentEndDistance)\r\n            {\r\n                cachedSegmentIndex = mid;\r\n                return mid;\r\n            }\r\n            else if (pathDistance < segmentStartDistance)\r\n            {\r\n                right = mid - 1;\r\n            }\r\n            else\r\n            {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        \r\n        // 边界情况：返回最后一个段\r\n        return pathSegments.Count - 1;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 可视化路径（编辑器中使用）\r\n    /// </summary>\r\n    void OnDrawGizmos()\r\n    {\r\n        if (PathNodes == null || PathNodes.Count < 2)\r\n            return;\r\n        \r\n        Color originalColor = Gizmos.color;\r\n        Gizmos.color = Color.magenta;\r\n        \r\n        for (int i = 0; i < PathNodes.Count - 1; i++)\r\n        {\r\n            if (PathNodes[i] != null && PathNodes[i + 1] != null)\r\n            {\r\n                Vector3 start = PathNodes[i].transform.position;\r\n                Vector3 end = PathNodes[i + 1].transform.position;\r\n                Gizmos.DrawLine(start, end);\r\n            }\r\n        }\r\n        \r\n        Gizmos.color = originalColor;\r\n    }\r\n}\r\n\r\n// ==================== 路径跟随行为 ====================\r\n/// <summary>\r\n/// 路径跟随行为：让Agent沿着路径移动\r\n/// 继承自Seek，通过动态更新目标位置实现路径跟随\r\n/// </summary>\r\npublic class PathFollowBehavior : MonoBehaviour\r\n{\r\n    [Header(\"路径设置\")]\r\n    public PathManager Path;\r\n    \r\n    [Header(\"跟随参数\")]\r\n    [Tooltip(\"目标点距离当前位置的路径距离偏移（正数表示前方，负数表示后方）\")]\r\n    public float TargetDistanceOffset = 1.0f;\r\n    \r\n    [Header(\"调试\")]\r\n    public bool ShowDebugInfo = true;\r\n    \r\n    // 当前状态\r\n    private float currentPathDistance = 0f;\r\n    private Vector3 targetPosition;\r\n    private SeekBehavior seekBehavior;\r\n    \r\n    void Awake()\r\n    {\r\n        seekBehavior = GetComponent<SeekBehavior>();\r\n        if (seekBehavior == null)\r\n        {\r\n            Debug.LogError(\"PathFollowBehavior需要SeekBehavior组件\");\r\n        }\r\n        \r\n        // 创建目标对象\r\n        GameObject targetObj = new GameObject(\"PathFollowTarget\");\r\n        targetObj.transform.SetParent(transform);\r\n        targetPosition = transform.position;\r\n    }\r\n    \r\n    void Update()\r\n    {\r\n        if (Path == null || seekBehavior == null)\r\n            return;\r\n        \r\n        // 1. 获取当前位置在路径上的距离\r\n        currentPathDistance = Path.GetPathDistance(transform.position, currentPathDistance);\r\n        \r\n        // 2. 计算目标位置（当前位置 + 偏移距离）\r\n        float targetPathDistance = currentPathDistance + TargetDistanceOffset;\r\n        targetPosition = Path.GetPositionAtDistance(targetPathDistance);\r\n        \r\n        // 3. 设置Seek的目标位置\r\n        seekBehavior.SetTarget(targetPosition);\r\n        \r\n        // 调试信息\r\n        if (ShowDebugInfo)\r\n        {\r\n            Debug.DrawLine(transform.position, targetPosition, Color.green);\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 重置路径跟随状态\r\n    /// </summary>\r\n    public void ResetPathFollow()\r\n    {\r\n        currentPathDistance = 0f;\r\n    }\r\n}\r\n\r\n// ==================== Seek行为基类（简化版） ====================\r\n/// <summary>\r\n/// 寻找行为：移动到目标位置\r\n/// </summary>\r\npublic class SeekBehavior : MonoBehaviour\r\n{\r\n    [Header(\"移动参数\")]\r\n    public float MaxAcceleration = 10f;\r\n    public float MaxSpeed = 5f;\r\n    \r\n    private Vector3 targetPosition;\r\n    private Rigidbody rb;\r\n    \r\n    void Awake()\r\n    {\r\n        rb = GetComponent<Rigidbody>();\r\n        if (rb == null)\r\n        {\r\n            rb = gameObject.AddComponent<Rigidbody>();\r\n            rb.useGravity = false;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 设置目标位置\r\n    /// </summary>\r\n    public void SetTarget(Vector3 target)\r\n    {\r\n        targetPosition = target;\r\n    }\r\n    \r\n    void FixedUpdate()\r\n    {\r\n        if (rb == null)\r\n            return;\r\n        \r\n        // 计算到目标的方向\r\n        Vector3 direction = targetPosition - transform.position;\r\n        float distance = direction.magnitude;\r\n        \r\n        if (distance < 0.1f)\r\n            return;\r\n        \r\n        // 计算期望速度\r\n        direction.Normalize();\r\n        Vector3 desiredVelocity = direction * MaxSpeed;\r\n        \r\n        // 计算转向力\r\n        Vector3 steering = desiredVelocity - rb.velocity;\r\n        steering = Vector3.ClampMagnitude(steering, MaxAcceleration);\r\n        \r\n        // 应用力\r\n        rb.AddForce(steering, ForceMode.Acceleration);\r\n    }\r\n}\r\n\r\n"
        }
    ]
}