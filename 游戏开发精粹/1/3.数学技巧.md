# 数学技巧

**学习策略：** 先了解概念，需要时再深入。大部分技术Unity已经提供现成方案，不需要自己实现。专注于游戏逻辑和系统架构更重要。

## 1. 可预测随机数生成器

使用种子（Seed）生成可重现的随机数序列，确保相同种子产生相同序列。核心思路是：使用线性同余生成器（LCG）或其他确定性算法，通过种子初始化状态，每次调用生成下一个随机数并更新状态。这样既保证了随机性，又实现了可重现性，特别适用于需要回放、同步、测试等场景。

**伪代码：**
```lua
-- 线性同余生成器（LCG）
class PredictableRandom {
    seed = 0
    state = 0
    
    function Init(seed) {
        this.seed = seed
        this.state = seed
    }
    
    function Next() {
        -- LCG公式: (a * state + c) mod m
        state = (1103515245 * state + 12345) mod (2^31)
        return state / (2^31)  -- 归一化到[0,1)
    }
    
    function NextInt(min, max) {
        return min + floor(Next() * (max - min))
    }
}

-- 使用示例
local rng = PredictableRandom.New()
rng:Init(12345)  -- 设置种子
local value1 = rng:Next()  -- 可重现的随机数
local value2 = rng:NextInt(1, 100)  -- 可重现的随机整数
```

## 2. 替换算法（置换算法）

通过数组元素的交换实现随机排列，生成无重复的随机序列。核心思路是：从数组末尾开始，每次随机选择一个位置与当前位置交换，确保每个元素只被选择一次。这样既保证了随机性，又避免了重复，特别适用于洗牌、随机选择、生成唯一ID等场景。

**伪代码：**
```lua
-- Fisher-Yates洗牌算法
function Shuffle(array) {
    for i = array.length - 1; i > 0; i-- {
        -- 随机选择[0, i]范围内的索引
        j = random(0, i + 1)
        
        -- 交换元素
        temp = array[i]
        array[i] = array[j]
        array[j] = temp
    }
    return array
}

-- 使用示例
local cards = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
Shuffle(cards)  -- 洗牌后的数组
```

## 3. **无限宇宙算法**

通过分块生成和坐标映射实现无限大的游戏世界，无需预先生成整个地图。核心思路是：将世界划分为固定大小的区块（Chunk），根据玩家位置动态加载和卸载区块，使用哈希函数将世界坐标映射到区块坐标。这样既实现了无限世界，又控制了内存占用，特别适用于开放世界、程序化生成等场景。

### 宏无限 vs 微无限

**宏无限（Macro Infinite）：**
- **概念**：大尺度的无限扩展，整个宇宙/世界的无限生成
- **实现**：通过区块系统实现，每个区块代表一个大的区域（如1000x1000单位）
- **应用**：开放世界地图、星系探索、大型沙盒游戏
- **特点**：玩家可以无限探索，世界坐标可以非常大（如±10^9）

**微无限（Micro Infinite）：**
- **概念**：小尺度的无限细化，局部区域的无限细节生成
- **实现**：通过分层细节（LOD）或多级细分实现，同一区域可以无限放大查看细节
- **应用**：程序化地形细节、纹理细节、局部环境生成
- **特点**：在有限区域内提供无限细节，支持"放大镜"效果

**组合使用：**
```
宏无限（大世界） → 区块系统
    ↓
微无限（局部细节） → LOD系统、细节生成
```

**实际应用示例（程序化生成）：**
```csharp
// 可预测随机数生成器（LCG实现）
public class PredictableRandom {
    private long state;
    
    public PredictableRandom(int seed) {
        this.state = seed;
    }
    
    public void Seed(int seed) {
        this.state = seed;
    }
    
    // 线性同余生成器
    public int Next() {
        // LCG公式: (a * state + c) mod m
        state = (1103515245L * state + 12345L) % (1L << 31);
        return (int)state;
    }
    
    public int Next(int maxValue) {
        return Next() % maxValue;
    }
    
    public int Next(int minValue, int maxValue) {
        return minValue + (Next() % (maxValue - minValue));
    }
}

// 根据坐标程序化生成星星属性
public class Star {
    private int xPosition;
    private int yPosition;
    private int numberOfPlanets;
    private PredictableRandom random;
    
    public int XPosition => xPosition;
    public int YPosition => yPosition;
    public int NumberOfPlanets => numberOfPlanets;
    
    public Star(int x, int y) {
        this.xPosition = x;
        this.yPosition = y;
        // 使用坐标作为种子初始化随机数生成器
        int seed = xPosition + (xPosition * yPosition);
        this.random = new PredictableRandom(seed);
        SetNumberOfPlanets();
    }
    
    public void SetNumberOfPlanets() {
        // 重新设置种子，确保可重现
        random.Seed(xPosition + (xPosition * yPosition));
        
        // 生成行星数量（0-19）
        numberOfPlanets = random.Next(20);
    }
    
    // 可以根据需要生成其他属性
    public int GetPlanetDistance(int planetIndex) {
        // 使用行星索引和坐标生成距离
        int seed = planetIndex + (xPosition * yPosition);
        random.Seed(seed);
        return random.Next(10, 100); // 距离范围10-100
    }
}

// 使用示例
public class Universe {
    public Star GetStarAt(int x, int y) {
        // 根据坐标生成星星，相同坐标生成相同星星
        return new Star(x, y);
    }
    
    public void Example() {
        // 坐标(100, 200)的星星
        Star star1 = GetStarAt(100, 200);
        Debug.Log($"坐标(100,200)的行星数量: {star1.NumberOfPlanets}");
        
        // 再次获取相同坐标，结果相同
        Star star2 = GetStarAt(100, 200);
        Debug.Log($"坐标(100,200)的行星数量: {star2.NumberOfPlanets}"); // 与star1相同
        
        // 不同坐标生成不同结果
        Star star3 = GetStarAt(101, 200);
        Debug.Log($"坐标(101,200)的行星数量: {star3.NumberOfPlanets}"); // 可能不同
    }
}

// 行星类：根据行星编号和星星坐标生成距离
public class Planet {
    private int distanceFromStar;
    private PredictableRandom random;
    
    public int DistanceFromStar => distanceFromStar;
    
    public Planet(int planetNumber, int starX, int starY) {
        // 使用行星编号和星星坐标生成种子
        int seed = planetNumber + (starX + (starX * starY));
        random = new PredictableRandom(seed);
        SetDistanceFromStar(planetNumber, starX, starY);
    }
    
    public void SetDistanceFromStar(int planetNumber, int starX, int starY) {
        // 重新设置种子
        int seed = planetNumber + (starX + (starX * starY));
        random.Seed(seed);
        
        // 生成距离（0-19）
        distanceFromStar = random.Next(20);
    }
}

// 地图生成：程序化生成网格地图
public class ProceduralMap {
    private int gridSide;
    private int[,] grid;
    private PredictableRandom random;
    
    public int GridSide => gridSide;
    public int[,] Grid => grid;
    
    public ProceduralMap(int seed) {
        random = new PredictableRandom(seed);
        InitializeMap();
    }
    
    // 定义地图大小
    private void InitializeMap() {
        // 生成地图边长（0-99）
        gridSide = random.Next(100);
        grid = new int[gridSide, gridSide];
    }
    
    // 在指定位置放置对象（0或1）
    public void PlaceObject(int x, int y) {
        // 使用坐标生成种子
        int seed = (gridSide * y) + x;
        random.Seed(seed);
        
        // 生成对象类型（0或1，表示空/有对象）
        grid[x, y] = random.Next(2);
    }
    
    // 批量生成整个地图
    public void GenerateFullMap() {
        for (int y = 0; y < gridSide; y++) {
            for (int x = 0; x < gridSide; x++) {
                PlaceObject(x, y);
            }
        }
    }
    
    // 按需生成指定区域
    public void GenerateRegion(int startX, int startY, int width, int height) {
        for (int y = startY; y < startY + height && y < gridSide; y++) {
            for (int x = startX; x < startX + width && x < gridSide; x++) {
                PlaceObject(x, y);
            }
        }
    }
}

// 优化的坐标种子生成（避免循环调用rand）
public class OptimizedProceduralGenerator {
    private PredictableRandom random;
    
    public OptimizedProceduralGenerator() {
        random = new PredictableRandom(0);
    }
    
    // 直接根据坐标计算种子，无需循环
    public int GenerateAt(int x, int y) {
        // 使用坐标直接计算种子（更高效）
        int seed = (y << 16) | (x & 0xFFFF); // 将y和x组合成种子
        random.Seed(seed);
        return random.Next(100);
    }
    
    // 旧方法：需要循环调用rand（效率低）
    public int GenerateAtOld(int x, int y) {
        random.Seed(y); // 以y为种子
        int temp = x;
        while (temp > 0) {
            random.Next(); // 调用x次
            temp--;
        }
        return random.Next(100);
    }
}
```

**核心思想：**
- 坐标作为种子 → 确保可重现性
- 可预测随机数 → 相同坐标生成相同属性
- 无需存储 → 需要时根据坐标计算即可
- 无限扩展 → 任何坐标都可以生成内容

**程序化生成 vs 随机地图：**

| 特性 | 随机地图 | 程序化生成（本示例） |
|------|---------|-------------------|
| **可重现性** | ❌ 每次不同 | ✅ 相同坐标相同结果 |
| **存储需求** | ❌ 需要存储 | ✅ 无需存储，按需计算 |
| **种子机制** | ❌ 无种子 | ✅ 坐标作为种子 |
| **应用场景** | 单次游戏体验 | 无限世界、回放系统 |

**关键区别：**
- **随机地图**：每次生成都不同，不可重现，需要存储
- **程序化生成**：根据坐标/种子生成，可重现，无需存储

**与卷积核的相似性：**

程序化生成和卷积核（图像处理）有相似的设计思路：

| 特性 | 卷积核 | 程序化生成 |
|------|--------|-----------|
| **基于位置计算** | 在图像上滑动，对每个像素计算 | 在坐标空间上，对每个坐标计算 |
| **局部独立性** | 每个像素独立计算 | 每个坐标独立生成 |
| **可重现性** | 相同输入相同输出 | 相同坐标相同结果 |
| **无限扩展** | 可以处理任意大小图像 | 可以处理任意坐标范围 |
| **函数映射** | f(x,y) → 新像素值 | f(x,y) → 生成内容 |

**核心相似点：**
```
卷积核：kernel(x, y) → 输出值
程序化生成：generator(x, y) → 生成内容

都是：坐标 → 函数计算 → 结果
```

**实际应用：**
- 卷积核：图像滤波、边缘检测、模糊
- 程序化生成：地形生成、内容生成、无限世界

**伪代码：**
```lua
-- 区块管理系统
class InfiniteUniverse {
    chunkSize = 100  -- 区块大小
    loadedChunks = {}  -- 已加载的区块
    
    function GetChunkCoord(worldX, worldZ) {
        chunkX = floor(worldX / chunkSize)
        chunkZ = floor(worldZ / chunkSize)
        return {x = chunkX, z = chunkZ}
    }
    
    function GetChunkKey(chunkX, chunkZ) {
        return chunkX .. "_" .. chunkZ  -- 生成唯一键
    }
    
    function LoadChunk(chunkX, chunkZ) {
        key = GetChunkKey(chunkX, chunkZ)
        if not loadedChunks[key] {
            -- 程序化生成区块内容
            chunk = GenerateChunk(chunkX, chunkZ)
            loadedChunks[key] = chunk
        }
        return loadedChunks[key]
    }
    
    function UnloadDistantChunks(playerX, playerZ, radius) {
        playerChunk = GetChunkCoord(playerX, playerZ)
        for key, chunk in pairs(loadedChunks) {
            chunkCoord = ParseChunkKey(key)
            distance = Distance(playerChunk, chunkCoord)
            if distance > radius {
                UnloadChunk(chunk)
                loadedChunks[key] = nil
            }
        }
    }
}

-- 使用示例
local universe = InfiniteUniverse.New()
local chunk = universe:LoadChunk(0, 0)  -- 加载区块(0,0)
universe:UnloadDistantChunks(playerX, playerZ, 5)  -- 卸载距离超过5的区块
```

**宏无限实现示例：**
```lua
-- 宏无限：大世界区块系统
class MacroInfinite {
    chunkSize = 10000  -- 大区块（10km x 10km）
    
    function GenerateWorldChunk(chunkX, chunkZ) {
        -- 生成大尺度内容：地形、城市、地标
        return {
            terrain = GenerateTerrain(chunkX, chunkZ),
            cities = GenerateCities(chunkX, chunkZ),
            landmarks = GenerateLandmarks(chunkX, chunkZ)
        }
    }
}
```

**微无限实现示例：**
```lua
-- 微无限：局部细节生成
class MicroInfinite {
    detailLevels = {1, 2, 4, 8, 16}  -- 多级细节
    
    function GenerateDetail(worldX, worldZ, zoomLevel) {
        -- 根据缩放级别生成不同细节
        if zoomLevel == 1 then
            return GenerateBasicTerrain(worldX, worldZ)
        elseif zoomLevel == 2 then
            return GenerateDetailedTerrain(worldX, worldZ)
        elseif zoomLevel >= 3 then
            return GenerateUltraDetail(worldX, worldZ)  -- 无限细化
        end
    }
    
    function GetDetailAtPosition(x, z, zoom) {
        -- 支持无限放大，每次放大生成更细节
        detail = GenerateDetail(x, z, zoom)
        -- 可以继续放大，生成更细节的内容
        return detail
    }
}
```

**组合使用：**
```lua
-- 宏无限 + 微无限
function GetWorldData(worldX, worldZ, zoomLevel) {
    -- 1. 宏无限：获取大区块
    chunk = macroInfinite:GetChunk(worldX, worldZ)
    
    -- 2. 微无限：根据缩放级别生成细节
    if zoomLevel > 1 then
        detail = microInfinite:GenerateDetail(worldX, worldZ, zoomLevel)
        chunk.details = detail
    end
    
    return chunk
}
```

## 4. 插值方法

在已知数据点之间计算中间值，实现平滑过渡效果。核心思路是：根据时间或参数t（0到1之间），在起始值和目标值之间进行插值计算，支持线性、平滑、缓动等多种插值函数。这样既实现了平滑的数值过渡，又提供了多种视觉效果，特别适用于动画、UI过渡、相机移动等场景。

**伪代码：**
```lua
-- 线性插值
function Lerp(start, target, t) {
    t = Clamp(t, 0, 1)  -- 限制t在[0,1]
    return start + (target - start) * t
}

-- 平滑插值（SmoothStep） 
function SmoothStep(start, target, t) {
    t = Clamp(t, 0, 1)
    t = t * t * (3 - 2 * t)  -- 平滑曲线
    return Lerp(start, target, t)
}

-- 缓动插值（Ease In Out）
function EaseInOut(start, target, t) {
    t = Clamp(t, 0, 1)
    t = t < 0.5 ? 2 * t * t : 1 - pow(-2 * t + 2, 2) / 2
    return Lerp(start, target, t)
}

-- 向量插值
function LerpVector3(start, target, t) {
    return {
        x = Lerp(start.x, target.x, t),
        y = Lerp(start.y, target.y, t),
        z = Lerp(start.z, target.z, t)
    }
}

-- 使用示例
local currentPos = {x = 0, y = 0, z = 0}
local targetPos = {x = 10, y = 5, z = 3}
local t = 0.5  -- 50%进度
local interpolated = LerpVector3(currentPos, targetPos, t)
```

## 5. 求刚体运动方程的积分（了解即可）

通过数值积分方法计算刚体的位置和速度，实现物理模拟。核心思路是：使用欧拉法、Verlet积分或RK4等方法，根据力和加速度计算速度变化，根据速度计算位置变化，每帧更新物理状态。这样既实现了真实的物理运动，又保证了数值稳定性，特别适用于物理引擎、弹道计算、碰撞检测等场景。


## 三角函数的多项式逼近（了解即可）

**简单理解：** 用简单的加减乘除来近似计算sin、cos等三角函数，而不是直接调用系统函数。这是为了在某些特殊情况下提高性能或兼容性。

**实际应用：**
- 主要用于嵌入式设备（没有硬件支持）
- 或者需要极高频率调用的特殊场景
- 一般游戏开发用不到

**对你的项目：**
- **完全不需要学习**：Unity的Mathf.Sin/Cos已经足够好
- **遇到问题时再查**：如果真的需要，网上有现成的代码
- **现阶段跳过**：专注于游戏逻辑和系统架构更重要

**结论：** 这部分内容可以完全跳过，对实际开发没有影响。

## 小波压缩（了解即可）

**简单理解：** 一种数据压缩技术，可以将图像、音频等数据压缩得更小，同时保持较好的质量。类似于JPEG压缩，但使用不同的数学方法。

**核心思路：** 将数据分解成不同频率的"波"，保留重要的低频信息，丢弃不重要的高频细节，从而实现压缩。

**与LLM的相似性：**
- **多级变换**：小波压缩通过多级变换分解数据，类似LLM的Transformer通过多层变换提取特征
- **逐步抽象**：每级提取近似值（重要信息），丢弃细节（次要信息），类似LLM每层提取更高层次的语义
- **Transform思想**：都是通过变换重新表示数据，从原始形式转换到压缩/抽象形式
- **信息保留**：保留核心信息，丢弃冗余细节，实现高效表示

**主要用途：**
- **图像压缩**：纹理压缩、减少内存占用
- **音频压缩**：背景音乐、音效压缩
- **数据压缩**：存档文件、网络传输

**在游戏开发中：**
- Unity已经内置了纹理压缩（DXT、ETC等）
- 音频压缩（MP3、OGG等）已经足够好
- 一般不需要自己实现小波压缩

**对你的项目：**
- **完全不需要学习**：Unity的压缩工具已经足够
- **遇到问题时再查**：如果真的需要，使用现成的压缩库
- **现阶段跳过**：专注于游戏逻辑更重要

**结论：** 这部分内容可以完全跳过，Unity已经提供了更好的压缩方案。

## 水的交互模拟（了解即可）

**简单理解：** 模拟水的流动、波浪、碰撞等物理效果。

**实际应用：**
- 水面效果：Unity的Shader可以做出很好的水面效果
- 流体模拟：Unity有现成的插件（如Obi Fluid）
- 物理交互：Unity的物理引擎已经足够

**对你的项目（DND RPG）：**
- **完全不需要学习**：你的项目是回合制RPG，不需要复杂的水模拟
- **如果真的需要**：用Unity的Shader或插件就行
- **现阶段跳过**：专注于游戏逻辑更重要

**结论：** 跳过，Unity的Shader和插件已经足够好了。

## 四元数（了解即可）

**简单理解：** 用来表示旋转的数学工具，比欧拉角（x,y,z旋转）更好，避免万向锁问题。

**Unity中的应用：**
- `transform.rotation` 就是四元数
- `Quaternion.LookRotation()` 让物体看向某个方向
- `Quaternion.Slerp()` 平滑旋转
- Unity已经封装好了，直接用就行

**你需要做什么：**
- **不需要理解数学原理**：Unity的API已经足够
- **知道怎么用就行**：`transform.rotation = Quaternion.LookRotation(direction)`
- **遇到问题时查文档**：Unity文档有详细说明

**对你的项目：**
- **不需要深入学习**：Unity的Quaternion API已经足够
- **会用就行**：知道几个常用函数就够了
- **现阶段跳过**：专注于游戏逻辑更重要

**结论：** 知道Unity有Quaternion这个类，会用几个常用函数就行，不需要理解数学原理。

### 最短弧四元数（了解即可）

**简单理解：** 计算两个旋转之间的最短路径，避免物体旋转时"绕远路"。

**实际例子：**
- 物体从A方向转到B方向，应该走最短路径
- 如果不用最短弧，可能会转360度才到目标

**Unity中的应用：**
- `Quaternion.Slerp()` 就是做这个的
- `Quaternion.RotateTowards()` 也是最短路径旋转
- Unity已经帮你处理好了，直接用就行

**你需要做什么：**
- **不需要理解数学原理**：Unity的API已经实现了
- **会用就行**：`Quaternion.Slerp(from, to, t)` 就是最短弧旋转
- **遇到问题时查文档**：Unity文档有详细说明

**结论：** 知道`Quaternion.Slerp()`是做最短弧旋转的就行，不需要理解数学原理。
