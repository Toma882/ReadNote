{
    "sourceFile": "游戏编程精粹/1/代码/可视点寻径(PointsOfVisibility).md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764867981964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764867981964,
            "name": "Commit-0",
            "content": "# 可视点寻径（Points-of-Visibility Pathfinding）- C#实现\r\n\r\n## 核心概念\r\n\r\n- **定义**：可视点寻径优化技术，用于优化路径查找\r\n- **核心思想**：使用可视点（可见的角点）简化路径，减少路径点数量\r\n- **应用场景**：复杂环境中的路径优化，减少路径点数量\r\n\r\n## 基础实现\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// 可视点：路径上的关键可见点\r\n/// </summary>\r\npublic class VisibilityPoint\r\n{\r\n    public Vector3 position;        // 位置\r\n    public List<VisibilityPoint> visiblePoints;  // 可见的其他点\r\n    \r\n    public VisibilityPoint(Vector3 pos)\r\n    {\r\n        position = pos;\r\n        visiblePoints = new List<VisibilityPoint>();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 检查是否能看到另一个点\r\n    /// </summary>\r\n    public bool CanSee(VisibilityPoint other, LayerMask obstacleLayer)\r\n    {\r\n        Vector3 direction = other.position - position;\r\n        float distance = direction.magnitude;\r\n        \r\n        // 射线检测，检查是否有障碍物\r\n        RaycastHit hit;\r\n        if (Physics.Raycast(position, direction.normalized, out hit, distance, obstacleLayer))\r\n        {\r\n            return false;  // 有障碍物，不可见\r\n        }\r\n        \r\n        return true;  // 可见\r\n    }\r\n}\r\n```\r\n\r\n## 可视点寻径算法\r\n\r\n```csharp\r\n/// <summary>\r\n/// 可视点寻径：使用可视点优化路径\r\n/// </summary>\r\npublic class PointsOfVisibilityPathfinding\r\n{\r\n    private List<VisibilityPoint> visibilityPoints;\r\n    private Dictionary<VisibilityPoint, Dictionary<VisibilityPoint, float>> shortestPaths;\r\n    \r\n    /// <summary>\r\n    /// 构建可视点网络\r\n    /// </summary>\r\n    public void BuildVisibilityGraph(List<Vector3> cornerPoints, LayerMask obstacleLayer)\r\n    {\r\n        visibilityPoints = new List<VisibilityPoint>();\r\n        \r\n        // 1. 创建可视点\r\n        foreach (var corner in cornerPoints)\r\n        {\r\n            visibilityPoints.Add(new VisibilityPoint(corner));\r\n        }\r\n        \r\n        // 2. 建立可见性连接\r\n        for (int i = 0; i < visibilityPoints.Count; i++)\r\n        {\r\n            for (int j = i + 1; j < visibilityPoints.Count; j++)\r\n            {\r\n                if (visibilityPoints[i].CanSee(visibilityPoints[j], obstacleLayer))\r\n                {\r\n                    visibilityPoints[i].visiblePoints.Add(visibilityPoints[j]);\r\n                    visibilityPoints[j].visiblePoints.Add(visibilityPoints[i]);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // 3. 预计算最短路径\r\n        PrecomputeShortestPaths();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 预计算所有点对之间的最短路径\r\n    /// </summary>\r\n    private void PrecomputeShortestPaths()\r\n    {\r\n        shortestPaths = new Dictionary<VisibilityPoint, Dictionary<VisibilityPoint, float>>();\r\n        \r\n        // 使用Floyd-Warshall算法或Dijkstra算法\r\n        foreach (var start in visibilityPoints)\r\n        {\r\n            shortestPaths[start] = new Dictionary<VisibilityPoint, float>();\r\n            Dijkstra(start, shortestPaths[start]);\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// Dijkstra算法：计算从起点到所有点的最短路径\r\n    /// </summary>\r\n    private void Dijkstra(VisibilityPoint start, Dictionary<VisibilityPoint, float> distances)\r\n    {\r\n        Dictionary<VisibilityPoint, float> dist = new Dictionary<VisibilityPoint, float>();\r\n        HashSet<VisibilityPoint> visited = new HashSet<VisibilityPoint>();\r\n        \r\n        foreach (var point in visibilityPoints)\r\n        {\r\n            dist[point] = float.MaxValue;\r\n        }\r\n        dist[start] = 0f;\r\n        \r\n        while (visited.Count < visibilityPoints.Count)\r\n        {\r\n            // 找到未访问的距离最小的点\r\n            VisibilityPoint current = null;\r\n            float minDist = float.MaxValue;\r\n            \r\n            foreach (var point in visibilityPoints)\r\n            {\r\n                if (!visited.Contains(point) && dist[point] < minDist)\r\n                {\r\n                    minDist = dist[point];\r\n                    current = point;\r\n                }\r\n            }\r\n            \r\n            if (current == null) break;\r\n            \r\n            visited.Add(current);\r\n            distances[current] = dist[current];\r\n            \r\n            // 更新邻居的距离\r\n            foreach (var neighbor in current.visiblePoints)\r\n            {\r\n                if (!visited.Contains(neighbor))\r\n                {\r\n                    float newDist = dist[current] + Vector3.Distance(current.position, neighbor.position);\r\n                    if (newDist < dist[neighbor])\r\n                    {\r\n                        dist[neighbor] = newDist;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 查找路径：使用可视点网络\r\n    /// </summary>\r\n    public List<Vector3> FindPath(Vector3 start, Vector3 end)\r\n    {\r\n        // 1. 找到最近的可视点\r\n        VisibilityPoint startPoint = FindNearestVisibilityPoint(start);\r\n        VisibilityPoint endPoint = FindNearestVisibilityPoint(end);\r\n        \r\n        if (startPoint == null || endPoint == null)\r\n            return null;\r\n        \r\n        // 2. 使用预计算的最短路径\r\n        if (shortestPaths.ContainsKey(startPoint) && \r\n            shortestPaths[startPoint].ContainsKey(endPoint))\r\n        {\r\n            // 3. 回溯路径\r\n            return ReconstructPath(startPoint, endPoint);\r\n        }\r\n        \r\n        return null;\r\n    }\r\n    \r\n    private VisibilityPoint FindNearestVisibilityPoint(Vector3 position)\r\n    {\r\n        VisibilityPoint nearest = null;\r\n        float minDistance = float.MaxValue;\r\n        \r\n        foreach (var point in visibilityPoints)\r\n        {\r\n            float distance = Vector3.Distance(position, point.position);\r\n            if (distance < minDistance)\r\n            {\r\n                minDistance = distance;\r\n                nearest = point;\r\n            }\r\n        }\r\n        \r\n        return nearest;\r\n    }\r\n}\r\n```\r\n\r\n## 轮廓区优化\r\n\r\n```csharp\r\n/// <summary>\r\n/// 轮廓区：用于空间分区系统\r\n/// </summary>\r\npublic class ContourRegion\r\n{\r\n    public List<Vector3> boundaryPoints;  // 边界点\r\n    public List<VisibilityPoint> interiorPoints;  // 内部可视点\r\n    \r\n    public ContourRegion()\r\n    {\r\n        boundaryPoints = new List<Vector3>();\r\n        interiorPoints = new List<VisibilityPoint>();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 检查点是否在轮廓区内\r\n    /// </summary>\r\n    public bool Contains(Vector3 point)\r\n    {\r\n        // 使用点在多边形内的算法\r\n        return IsPointInPolygon(point, boundaryPoints);\r\n    }\r\n}\r\n```\r\n\r\n## Unity应用\r\n\r\n```csharp\r\n/// <summary>\r\n/// Unity中使用可视点寻径\r\n/// </summary>\r\npublic class PointsOfVisibilityUnity : MonoBehaviour\r\n{\r\n    private PointsOfVisibilityPathfinding pathfinding;\r\n    \r\n    void Start()\r\n    {\r\n        pathfinding = new PointsOfVisibilityPathfinding();\r\n        \r\n        // 从场景中提取角点（障碍物的角）\r\n        List<Vector3> cornerPoints = ExtractCornerPoints();\r\n        \r\n        // 构建可视点网络\r\n        pathfinding.BuildVisibilityGraph(cornerPoints, LayerMask.GetMask(\"Obstacle\"));\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 查找路径\r\n    /// </summary>\r\n    public List<Vector3> FindPathToTarget(Vector3 start, Vector3 end)\r\n    {\r\n        return pathfinding.FindPath(start, end);\r\n    }\r\n}\r\n```\r\n\r\n## 与A*的关系\r\n\r\n- A*是基础寻径算法\r\n- 可视点寻径是A*的优化技术\r\n- 可以结合使用：先用A*找到基础路径，再用可视点优化\r\n\r\n"
        }
    ]
}