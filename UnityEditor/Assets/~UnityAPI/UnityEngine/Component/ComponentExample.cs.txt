using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Unity Component 系统完整 API 示例
/// Component 是附加到 GameObject 上的功能组件，是 Unity 架构的核心
/// </summary>
public class ComponentExample : MonoBehaviour
{
    [Header("组件查找设置")]
    [SerializeField] private string componentTypeName = "Rigidbody";
    [SerializeField] private bool includeInactive = false;
    
    [Header("组件操作")]
    [SerializeField] private bool autoTest = true;
    
    private List<Component> cachedComponents = new List<Component>();
    
    private void Start()
    {
        Debug.Log("=== Unity Component 系统完整 API 示例 ===");
        
        if (autoTest)
        {
            TestAllComponentFeatures();
        }
    }
    
    #region 1. GetComponent 系列
    
    /// <summary>
    /// 测试所有 Component 功能
    /// </summary>
    private void TestAllComponentFeatures()
    {
        Debug.Log("\n--- 1. GetComponent 系列 ---");
        
        // 1.1 GetComponent<T>
        TestGetComponent();
        
        // 1.2 GetComponents<T>
        TestGetComponents();
        
        // 1.3 GetComponentInChildren<T>
        TestGetComponentInChildren();
        
        // 1.4 GetComponentsInChildren<T>
        TestGetComponentsInChildren();
        
        // 1.5 GetComponentInParent<T>
        TestGetComponentInParent();
        
        // 1.6 GetComponentsInParent<T>
        TestGetComponentsInParent();
        
        // 1.7 TryGetComponent<T>
        TestTryGetComponent();
        
        Debug.Log("\n--- 2. 组件添加和移除 ---");
        
        // 2.1 AddComponent<T>
        TestAddComponent();
        
        // 2.2 RemoveComponent
        TestRemoveComponent();
        
        Debug.Log("\n--- 3. 组件属性 ---");
        
        // 3.1 CompareTag / tag / name / layer
        TestComponentProperties();
        
        Debug.Log("\n--- 4. 组件缓存优化 ---");
        
        // 4.1 组件缓存
        TestComponentCaching();
    }
    
    /// <summary>
    /// 1.1 GetComponent<T> - 获取单个组件
    /// 最常用的组件获取方法
    /// </summary>
    private void TestGetComponent()
    {
        Debug.Log("1.1 GetComponent<T> - 获取单个组件");
        
        // 获取自身上的组件
        Rigidbody rb = GetComponent<Rigidbody>();
        if (rb != null)
        {
            Debug.Log($"找到 Rigidbody 组件: {rb.name}");
        }
        else
        {
            Debug.Log("未找到 Rigidbody 组件");
        }
        
        // 获取其他类型的组件
        Transform t = GetComponent<Transform>();
        if (t != null)
        {
            Debug.Log($"找到 Transform 组件: {t.name}");
        }
        
        // 使用字符串类型名（不推荐，性能较差）
        Component comp = GetComponent(componentTypeName);
        if (comp != null)
        {
            Debug.Log($"通过字符串找到组件: {comp.GetType().Name}");
        }
    }
    
    /// <summary>
    /// 1.2 GetComponents<T> - 获取多个组件
    /// 返回同一类型的所有组件数组
    /// </summary>
    private void TestGetComponents()
    {
        Debug.Log("1.2 GetComponents<T> - 获取多个组件");
        
        // 获取所有 Rigidbody 组件
        Rigidbody[] rigidbodies = GetComponents<Rigidbody>();
        Debug.Log($"找到 {rigidbodies.Length} 个 Rigidbody 组件");
        
        foreach (Rigidbody rb in rigidbodies)
        {
            Debug.Log($"  - {rb.name}");
        }
        
        // 获取所有 Collider 组件
        Collider[] colliders = GetComponents<Collider>();
        Debug.Log($"找到 {colliders.Length} 个 Collider 组件");
    }
    
    /// <summary>
    /// 1.3 GetComponentInChildren<T> - 在子对象中查找单个组件
    /// 递归查找子对象，返回第一个找到的组件
    /// </summary>
    private void TestGetComponentInChildren()
    {
        Debug.Log("1.3 GetComponentInChildren<T> - 在子对象中查找");
        
        // 只在激活的子对象中查找
        Rigidbody rb = GetComponentInChildren<Rigidbody>();
        if (rb != null)
        {
            Debug.Log($"在子对象中找到 Rigidbody: {rb.name}");
        }
        
        // 包括非激活的子对象
        Rigidbody rbInactive = GetComponentInChildren<Rigidbody>(includeInactive);
        if (rbInactive != null)
        {
            Debug.Log($"在子对象中找到 Rigidbody（包括非激活）: {rbInactive.name}");
        }
    }
    
    /// <summary>
    /// 1.4 GetComponentsInChildren<T> - 在子对象中查找多个组件
    /// 递归查找所有子对象，返回所有匹配的组件
    /// </summary>
    private void TestGetComponentsInChildren()
    {
        Debug.Log("1.4 GetComponentsInChildren<T> - 在子对象中查找多个");
        
        // 只在激活的子对象中查找
        Rigidbody[] rigidbodies = GetComponentsInChildren<Rigidbody>();
        Debug.Log($"在子对象中找到 {rigidbodies.Length} 个 Rigidbody 组件");
        
        // 包括非激活的子对象
        Rigidbody[] rigidbodiesAll = GetComponentsInChildren<Rigidbody>(includeInactive);
        Debug.Log($"在子对象中找到 {rigidbodiesAll.Length} 个 Rigidbody 组件（包括非激活）");
        
        // 注意：GetComponentsInChildren 默认会包含自身
        // 如果只想查找子对象，需要排除自身
        List<Rigidbody> childOnly = new List<Rigidbody>(rigidbodies);
        childOnly.Remove(GetComponent<Rigidbody>());
        Debug.Log($"仅在子对象中找到 {childOnly.Count} 个 Rigidbody 组件");
    }
    
    /// <summary>
    /// 1.5 GetComponentInParent<T> - 在父对象中查找单个组件
    /// 向上查找父对象，返回第一个找到的组件
    /// </summary>
    private void TestGetComponentInParent()
    {
        Debug.Log("1.5 GetComponentInParent<T> - 在父对象中查找");
        
        // 只在激活的父对象中查找
        Rigidbody rb = GetComponentInParent<Rigidbody>();
        if (rb != null)
        {
            Debug.Log($"在父对象中找到 Rigidbody: {rb.name}");
        }
        
        // 包括非激活的父对象
        Rigidbody rbInactive = GetComponentInParent<Rigidbody>(includeInactive);
        if (rbInactive != null)
        {
            Debug.Log($"在父对象中找到 Rigidbody（包括非激活）: {rbInactive.name}");
        }
    }
    
    /// <summary>
    /// 1.6 GetComponentsInParent<T> - 在父对象中查找多个组件
    /// 向上查找所有父对象，返回所有匹配的组件
    /// </summary>
    private void TestGetComponentsInParent()
    {
        Debug.Log("1.6 GetComponentsInParent<T> - 在父对象中查找多个");
        
        // 只在激活的父对象中查找
        Rigidbody[] rigidbodies = GetComponentsInParent<Rigidbody>();
        Debug.Log($"在父对象中找到 {rigidbodies.Length} 个 Rigidbody 组件");
        
        // 包括非激活的父对象
        Rigidbody[] rigidbodiesAll = GetComponentsInParent<Rigidbody>(includeInactive);
        Debug.Log($"在父对象中找到 {rigidbodiesAll.Length} 个 Rigidbody 组件（包括非激活）");
    }
    
    /// <summary>
    /// 1.7 TryGetComponent<T> - 尝试获取组件（Unity 2019.2+）
    /// 推荐使用，避免空值检查
    /// </summary>
    private void TestTryGetComponent()
    {
        Debug.Log("1.7 TryGetComponent<T> - 尝试获取组件");
        
        // TryGetComponent 返回 bool，组件通过 out 参数返回
        if (TryGetComponent<Rigidbody>(out Rigidbody rb))
        {
            Debug.Log($"成功获取 Rigidbody 组件: {rb.name}");
        }
        else
        {
            Debug.Log("未找到 Rigidbody 组件");
        }
        
        // 更简洁的写法
        if (TryGetComponent<Collider>(out Collider collider))
        {
            Debug.Log($"成功获取 Collider 组件: {collider.name}");
        }
    }
    
    #endregion
    
    #region 2. 组件添加和移除
    
    /// <summary>
    /// 2.1 AddComponent<T> - 添加组件
    /// 运行时动态添加组件
    /// </summary>
    private void TestAddComponent()
    {
        Debug.Log("2.1 AddComponent<T> - 添加组件");
        
        // 添加 Rigidbody 组件
        if (GetComponent<Rigidbody>() == null)
        {
            Rigidbody rb = gameObject.AddComponent<Rigidbody>();
            Debug.Log($"添加 Rigidbody 组件: {rb.name}");
            cachedComponents.Add(rb);
        }
        else
        {
            Debug.Log("已存在 Rigidbody 组件");
        }
        
        // 添加 Collider 组件
        if (GetComponent<BoxCollider>() == null)
        {
            BoxCollider collider = gameObject.AddComponent<BoxCollider>();
            Debug.Log($"添加 BoxCollider 组件: {collider.name}");
            cachedComponents.Add(collider);
        }
        
        // 添加自定义组件
        if (GetComponent<ComponentExample>() == null)
        {
            ComponentExample custom = gameObject.AddComponent<ComponentExample>();
            Debug.Log($"添加自定义组件: {custom.GetType().Name}");
        }
    }
    
    /// <summary>
    /// 2.2 RemoveComponent / Destroy - 移除组件
    /// </summary>
    private void TestRemoveComponent()
    {
        Debug.Log("2.2 RemoveComponent / Destroy - 移除组件");
        
        // 方式1：使用 Destroy（推荐）
        Rigidbody rb = GetComponent<Rigidbody>();
        if (rb != null)
        {
            Destroy(rb);
            Debug.Log("使用 Destroy 移除 Rigidbody 组件");
            cachedComponents.Remove(rb);
        }
        
        // 方式2：使用 DestroyImmediate（仅编辑器）
        #if UNITY_EDITOR
        Collider collider = GetComponent<Collider>();
        if (collider != null)
        {
            DestroyImmediate(collider);
            Debug.Log("使用 DestroyImmediate 移除 Collider 组件");
            cachedComponents.Remove(collider);
        }
        #endif
        
        // 注意：Unity 没有 RemoveComponent 方法
        // 只能使用 Destroy 或 DestroyImmediate
    }
    
    #endregion
    
    #region 3. 组件属性
    
    /// <summary>
    /// 3.1 CompareTag / tag / name / layer
    /// 组件和 GameObject 的属性访问
    /// </summary>
    private void TestComponentProperties()
    {
        Debug.Log("3.1 CompareTag / tag / name / layer");
        
        // CompareTag - 比较标签（推荐，性能更好）
        if (CompareTag("Player"))
        {
            Debug.Log("GameObject 标签是 'Player'");
        }
        
        // tag - 获取/设置标签（不推荐直接比较，会产生 GC）
        string currentTag = gameObject.tag;
        Debug.Log($"当前标签: {currentTag}");
        
        // 注意：使用 CompareTag 代替 tag == "TagName"
        // ❌ 不好：if (gameObject.tag == "Player") // 会产生 GC
        // ✅ 好：if (gameObject.CompareTag("Player")) // 无 GC
        
        // name - 获取/设置名称
        string currentName = gameObject.name;
        Debug.Log($"当前名称: {currentName}");
        gameObject.name = "RenamedObject";
        Debug.Log($"重命名后: {gameObject.name}");
        
        // layer - 获取/设置层级
        int currentLayer = gameObject.layer;
        Debug.Log($"当前层级: {currentLayer}");
        // gameObject.layer = 5; // 设置层级
        
        // 获取组件所属的 GameObject
        GameObject owner = gameObject;
        Debug.Log($"组件所属的 GameObject: {owner.name}");
    }
    
    #endregion
    
    #region 4. 组件缓存优化
    
    /// <summary>
    /// 4.1 组件缓存
    /// GetComponent 有性能开销，应该缓存结果
    /// </summary>
    private void TestComponentCaching()
    {
        Debug.Log("4.1 组件缓存优化");
        
        // ❌ 不好：每次调用都查找组件
        // void Update()
        // {
        //     Rigidbody rb = GetComponent<Rigidbody>();
        //     rb.velocity = Vector3.zero;
        // }
        
        // ✅ 好：在 Start 中缓存组件
        Rigidbody cachedRigidbody = GetComponent<Rigidbody>();
        if (cachedRigidbody != null)
        {
            Debug.Log("组件已缓存，可以在 Update 中直接使用");
            cachedComponents.Add(cachedRigidbody);
        }
        
        // ✅ 更好：使用 TryGetComponent 并缓存
        if (TryGetComponent<Collider>(out Collider cachedCollider))
        {
            Debug.Log("使用 TryGetComponent 缓存组件");
            cachedComponents.Add(cachedCollider);
        }
        
        // 使用缓存的组件
        if (cachedRigidbody != null)
        {
            // 直接使用，无需再次查找
            Vector3 velocity = cachedRigidbody.velocity;
            Debug.Log($"使用缓存的组件，速度: {velocity}");
        }
    }
    
    /// <summary>
    /// 组件缓存的最佳实践示例
    /// </summary>
    private Rigidbody cachedRb;
    private Collider cachedCollider;
    private Transform cachedTransform;
    
    private void Awake()
    {
        // 在 Awake 中缓存组件（比 Start 更早）
        cachedRb = GetComponent<Rigidbody>();
        cachedCollider = GetComponent<Collider>();
        cachedTransform = transform; // Transform 也需要缓存
    }
    
    private void Update()
    {
        // 使用缓存的组件，性能更好
        if (cachedRb != null)
        {
            // 直接使用，无查找开销
        }
        
        if (cachedTransform != null)
        {
            // transform 是属性，有开销，应该缓存
        }
    }
    
    #endregion
    
    #region 5. 组件查找性能对比
    
    /// <summary>
    /// 5.1 组件查找性能对比
    /// </summary>
    private void TestComponentPerformance()
    {
        Debug.Log("5.1 组件查找性能对比");
        
        // 性能排序（从快到慢）：
        // 1. 缓存的组件引用（最快）
        // 2. TryGetComponent（Unity 2019.2+，推荐）
        // 3. GetComponent<T>（常用）
        // 4. GetComponent(string)（最慢，不推荐）
        
        // 性能测试示例
        int iterations = 10000;
        
        // 测试1：缓存引用
        Rigidbody cached = GetComponent<Rigidbody>();
        float startTime = Time.realtimeSinceStartup;
        for (int i = 0; i < iterations; i++)
        {
            if (cached != null) { }
        }
        float cachedTime = Time.realtimeSinceStartup - startTime;
        Debug.Log($"缓存引用耗时: {cachedTime * 1000}ms");
        
        // 测试2：GetComponent<T>
        startTime = Time.realtimeSinceStartup;
        for (int i = 0; i < iterations; i++)
        {
            Rigidbody rb = GetComponent<Rigidbody>();
        }
        float getComponentTime = Time.realtimeSinceStartup - startTime;
        Debug.Log($"GetComponent<T> 耗时: {getComponentTime * 1000}ms");
        
        Debug.Log($"性能差异: GetComponent 比缓存慢 {getComponentTime / cachedTime:F2} 倍");
    }
    
    #endregion
    
    #region 6. 组件实际应用场景
    
    /// <summary>
    /// 6.1 检查组件是否存在
    /// </summary>
    public bool HasComponent<T>() where T : Component
    {
        return GetComponent<T>() != null;
    }
    
    /// <summary>
    /// 6.2 获取或添加组件
    /// </summary>
    public T GetOrAddComponent<T>() where T : Component
    {
        T component = GetComponent<T>();
        if (component == null)
        {
            component = gameObject.AddComponent<T>();
        }
        return component;
    }
    
    /// <summary>
    /// 6.3 移除所有指定类型的组件
    /// </summary>
    public void RemoveAllComponents<T>() where T : Component
    {
        T[] components = GetComponents<T>();
        foreach (T component in components)
        {
            Destroy(component);
        }
    }
    
    #endregion
}

#region 最佳实践总结

/*
 * Unity Component 系统最佳实践：
 * 
 * 1. GetComponent 系列选择：
 *    - GetComponent<T>: 获取自身组件（最常用）
 *    - GetComponents<T>: 获取所有同类型组件
 *    - GetComponentInChildren<T>: 在子对象中查找（递归）
 *    - GetComponentsInChildren<T>: 在子对象中查找所有
 *    - GetComponentInParent<T>: 在父对象中查找（向上）
 *    - GetComponentsInParent<T>: 在父对象中查找所有
 *    - TryGetComponent<T>: 尝试获取（推荐，Unity 2019.2+）
 * 
 * 2. 性能优化：
 *    - 缓存组件引用（在 Awake/Start 中）
 *    - 使用 TryGetComponent 代替 GetComponent + null 检查
 *    - 避免在 Update 中频繁调用 GetComponent
 *    - 缓存 Transform 引用（transform 是属性，有开销）
 * 
 * 3. 组件查找性能：
 *    - 缓存引用 > TryGetComponent > GetComponent<T> > GetComponent(string)
 *    - GetComponent 会遍历组件列表，有性能开销
 *    - 子对象/父对象查找会递归，开销更大
 * 
 * 4. 组件添加和移除：
 *    - AddComponent<T>: 运行时添加组件
 *    - Destroy(component): 移除组件（推荐）
 *    - DestroyImmediate(component): 立即移除（仅编辑器）
 * 
 * 5. 标签比较：
 *    - 使用 CompareTag("TagName") 代替 tag == "TagName"
 *    - CompareTag 不会产生 GC，性能更好
 * 
 * 6. 组件属性：
 *    - gameObject: 组件所属的 GameObject
 *    - transform: 组件的 Transform（应该缓存）
 *    - tag / name / layer: GameObject 属性
 * 
 * 7. 适用场景：
 *    - GetComponent: 获取自身组件
 *    - GetComponentInChildren: 查找子对象组件（如武器、UI）
 *    - GetComponentInParent: 查找父对象组件（如管理器）
 *    - TryGetComponent: 不确定是否存在时使用
 * 
 * 8. 注意事项：
 *    - GetComponent 返回 null 如果组件不存在
 *    - GetComponents 返回空数组如果不存在
 *    - includeInactive 参数控制是否包含非激活对象
 *    - 组件查找会遍历所有组件，性能开销随组件数量增加
 */

#endregion


