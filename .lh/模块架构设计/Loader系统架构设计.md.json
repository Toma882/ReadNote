{
    "sourceFile": "模块架构设计/Loader系统架构设计.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1767203797924,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1767203797924,
            "name": "Commit-0",
            "content": "# Loader资源加载系统架构设计\r\n\r\n## 设计目标\r\n\r\n设计一套完整的资源加载系统，支持多种加载策略（Editor、AssetBundle、Resources），实现统一接口、策略切换、异步加载、对象池优化，提供灵活、高性能的资源管理解决方案。\r\n\r\n---\r\n\r\n## 核心设计理念\r\n\r\n### 1. 策略模式为核心\r\n\r\n**本质**：资源加载系统的核心是策略模式的应用\r\n- 加载策略 = 不同的资源加载方式（Editor/AssetBundle/Resources）\r\n- 策略切换 = 运行时动态切换加载策略\r\n- 统一接口 = 所有策略通过统一接口访问\r\n- 策略隔离 = 每个策略独立实现，互不干扰\r\n\r\n### 2. 对象池优化 + 任务封装\r\n\r\n**本质**：通过对象池管理LoadTask，通过任务封装简化异步加载\r\n- 对象池管理 = LoadTask使用对象池，减少GC压力\r\n- 任务封装 = LoadTask封装加载参数和回调\r\n- 链式配置 = 流畅的API设计，易于使用\r\n- 性能优化 = 对象池复用，减少对象创建开销\r\n\r\n### 3. 职责分离 + 开闭原则\r\n\r\n**本质**：加载逻辑和业务逻辑分离，对扩展开放对修改封闭\r\n- 职责分离 = 专注底层概念，避免业务耦合\r\n- 开闭原则 = 新增加载策略只需实现IAssetLoadStrategy\r\n- 统一接口 = 所有策略通过统一接口访问\r\n- 向后兼容 = 与旧版本完全兼容\r\n\r\n---\r\n\r\n## 整体架构设计\r\n\r\n### 三层架构 + 策略模式\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph ClientLayer[\"客户端层<br/>业务代码\"]\r\n        LoadRequest[\"加载请求<br/>Load/LoadAsync\"]\r\n        TaskRequest[\"任务请求<br/>CreateTask\"]\r\n    end\r\n    \r\n    subgraph ServiceLayer[\"服务层<br/>AssetLoader\"]\r\n        StrategyManager[\"策略管理器<br/>currentStrategy\"]\r\n        TaskPool[\"任务对象池<br/>LoadTaskPool\"]\r\n        TaskFactory[\"任务工厂<br/>CreateTask\"]\r\n    end\r\n    \r\n    subgraph StrategyLayer[\"策略层<br/>IAssetLoadStrategy\"]\r\n        EditorStrategy[\"Editor策略<br/>EditorLoadStrategy\"]\r\n        ABStrategy[\"AssetBundle策略<br/>AssetBundleLoadStrategy\"]\r\n        ResourcesStrategy[\"Resources策略<br/>ResourcesLoadStrategy\"]\r\n        CustomStrategy[\"自定义策略<br/>...\"]\r\n    end\r\n    \r\n    ClientLayer -->|调用| ServiceLayer\r\n    ServiceLayer -->|使用| StrategyLayer\r\n    ServiceLayer -->|管理| TaskPool\r\n    \r\n    style ClientLayer fill:#e1f5ff\r\n    style ServiceLayer fill:#fff4e1\r\n    style StrategyLayer fill:#c8e6c9\r\n```\r\n\r\n### 资源加载数据流\r\n\r\n```mermaid\r\ngraph LR\r\n    Start[加载请求<br/>LoadAsync] -->|1. 创建任务| CreateTask[创建LoadTask<br/>从对象池获取]\r\n    CreateTask -->|2. 配置任务| ConfigTask[配置回调<br/>OnLoaded/OnProgress]\r\n    ConfigTask -->|3. 执行策略| Strategy[当前策略<br/>currentStrategy.LoadAsync]\r\n    Strategy -->|4. 加载资源| LoadAsset[加载资源<br/>Editor/AB/Resources]\r\n    LoadAsset -->|5. 回调通知| Callback[回调通知<br/>OnLoaded/OnProgress]\r\n    Callback -->|6. 归还任务| ReturnTask[归还到对象池<br/>TaskPool.Push]\r\n    ReturnTask -->|7. 完成| End[加载完成]\r\n    \r\n    style CreateTask fill:#e1f5ff\r\n    style Strategy fill:#fff4e1\r\n    style LoadAsset fill:#c8e6c9\r\n    style ReturnTask fill:#c8e6c9\r\n```\r\n\r\n**数据流特性**：\r\n- ✅ **策略隔离**：每个策略独立实现，互不干扰\r\n- ✅ **统一接口**：所有策略通过统一接口访问\r\n- ✅ **对象池优化**：LoadTask使用对象池，减少GC压力\r\n- ✅ **异步加载**：支持进度回调和完成回调\r\n\r\n---\r\n\r\n## 服务层架构设计\r\n\r\n### 核心职责\r\n\r\n策略管理 + 任务管理 + 统一接口\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph AssetLoader[\"AssetLoader服务层\"]\r\n        StrategyManager[\"策略管理器<br/>currentStrategy\"]\r\n        TaskFactory[\"任务工厂<br/>CreateTask\"]\r\n        TaskPool[\"任务对象池<br/>LoadTaskPool\"]\r\n        LoadInterface[\"加载接口<br/>Load/LoadAsync\"]\r\n    end\r\n    \r\n    subgraph LoadTask[\"LoadTask任务封装\"]\r\n        AssetPath[\"资源路径<br/>assetPath\"]\r\n        AssetType[\"资源类型<br/>assetType\"]\r\n        OnLoaded[\"完成回调<br/>OnLoadedCallback\"]\r\n        OnProgress[\"进度回调<br/>OnProgressCallback\"]\r\n        OnInstantiate[\"实例化回调<br/>OnInstantiateCallback\"]\r\n    end\r\n    \r\n    AssetLoader -->|创建| TaskFactory\r\n    TaskFactory -->|使用| TaskPool\r\n    TaskPool -->|管理| LoadTask\r\n    AssetLoader -->|执行| StrategyManager\r\n    \r\n    style AssetLoader fill:#e1f5ff\r\n    style LoadTask fill:#fff4e1\r\n```\r\n\r\n### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[加载请求<br/>LoadAsync] --> CreateTask[创建任务<br/>CreateTask]\r\n    CreateTask --> CheckPool{对象池<br/>是否有任务?}\r\n    CheckPool -->|是| GetFromPool[从池中获取<br/>TaskPool.Pop]\r\n    CheckPool -->|否| CreateNew[创建新任务<br/>New LoadTask]\r\n    \r\n    GetFromPool --> ConfigTask[配置任务<br/>Reset + 设置参数]\r\n    CreateNew --> ConfigTask\r\n    \r\n    ConfigTask --> ExecuteStrategy[执行策略<br/>currentStrategy.LoadAsync]\r\n    ExecuteStrategy --> LoadAsset[加载资源<br/>Editor/AB/Resources]\r\n    LoadAsset --> OnProgress[进度回调<br/>OnProgressCallback]\r\n    OnProgress --> CheckComplete{加载<br/>是否完成?}\r\n    CheckComplete -->|否| OnProgress\r\n    CheckComplete -->|是| OnLoaded[完成回调<br/>OnLoadedCallback]\r\n    OnLoaded --> ReturnToPool[归还到对象池<br/>TaskPool.Push]\r\n    ReturnToPool --> Complete[完成]\r\n    \r\n    style CheckPool fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style CheckComplete fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style ExecuteStrategy fill:#c8e6c9\r\n    style ReturnToPool fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 策略层架构设计\r\n\r\n### 核心职责\r\n\r\n资源加载实现 + 缓存管理 + 错误处理\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph IAssetLoadStrategy[\"IAssetLoadStrategy接口\"]\r\n        LoadMethod[\"Load方法<br/>同步加载\"]\r\n        LoadAsyncMethod[\"LoadAsync方法<br/>异步加载\"]\r\n        UnloadMethod[\"Unload方法<br/>卸载资源\"]\r\n    end\r\n    \r\n    subgraph EditorStrategy[\"EditorLoadStrategy\"]\r\n        AssetDatabase[\"AssetDatabase<br/>编辑器资源加载\"]\r\n    end\r\n    \r\n    subgraph ABStrategy[\"AssetBundleLoadStrategy\"]\r\n        ABManager[\"AssetBundle管理器<br/>AB加载/缓存\"]\r\n        CacheManager[\"缓存管理器<br/>资源缓存\"]\r\n    end\r\n    \r\n    subgraph ResourcesStrategy[\"ResourcesLoadStrategy\"]\r\n        ResourcesAPI[\"Resources API<br/>Resources.Load\"]\r\n    end\r\n    \r\n    IAssetLoadStrategy -->|实现| EditorStrategy\r\n    IAssetLoadStrategy -->|实现| ABStrategy\r\n    IAssetLoadStrategy -->|实现| ResourcesStrategy\r\n    \r\n    style IAssetLoadStrategy fill:#e1f5ff\r\n    style EditorStrategy fill:#fff4e1\r\n    style ABStrategy fill:#c8e6c9\r\n    style ResourcesStrategy fill:#c8e6c9\r\n```\r\n\r\n### 策略切换流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[切换策略请求<br/>SetStrategy] --> CheckCurrent{当前策略<br/>是否存在?}\r\n    CheckCurrent -->|是| UnloadOld[卸载旧策略资源<br/>可选]\r\n    CheckCurrent -->|否| SetNew[设置新策略<br/>currentStrategy = newStrategy]\r\n    UnloadOld --> SetNew\r\n    SetNew --> Complete[切换完成]\r\n    \r\n    LoadRequest[加载请求] --> GetStrategy[获取当前策略<br/>currentStrategy]\r\n    GetStrategy --> ExecuteLoad[执行加载<br/>strategy.LoadAsync]\r\n    ExecuteLoad --> Complete2[加载完成]\r\n    \r\n    style CheckCurrent fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style GetStrategy fill:#c8e6c9\r\n    style ExecuteLoad fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 架构模式分析\r\n\r\n### 策略模式（Strategy Pattern）\r\n\r\n**核心思想**：将不同的加载策略封装成独立的类，运行时动态切换\r\n\r\n```mermaid\r\ngraph TB\r\n    Context[上下文<br/>AssetLoader]\r\n    StrategyInterface[策略接口<br/>IAssetLoadStrategy]\r\n    \r\n    Strategy1[策略1<br/>EditorLoadStrategy]\r\n    Strategy2[策略2<br/>AssetBundleLoadStrategy]\r\n    Strategy3[策略3<br/>ResourcesLoadStrategy]\r\n    \r\n    Context -->|使用| StrategyInterface\r\n    StrategyInterface -->|实现| Strategy1\r\n    StrategyInterface -->|实现| Strategy2\r\n    StrategyInterface -->|实现| Strategy3\r\n    \r\n    style Context fill:#f3e5f5\r\n    style StrategyInterface fill:#e1f5ff\r\n    style Strategy1 fill:#c8e6c9\r\n    style Strategy2 fill:#c8e6c9\r\n    style Strategy3 fill:#c8e6c9\r\n```\r\n\r\n**优势**：\r\n- ✅ **策略隔离**：每个策略独立实现，互不干扰\r\n- ✅ **动态切换**：运行时动态切换加载策略\r\n- ✅ **易于扩展**：新增策略只需实现IAssetLoadStrategy\r\n- ✅ **统一接口**：所有策略通过统一接口访问\r\n\r\n### 对象池模式（Object Pool Pattern）\r\n\r\n**核心思想**：LoadTask使用对象池管理，减少GC压力\r\n\r\n```mermaid\r\ngraph LR\r\n    Request[请求LoadTask<br/>CreateTask] --> CheckPool{检查对象池<br/>TaskPool}\r\n    CheckPool -->|池中有| Reuse[复用任务<br/>Reset]\r\n    CheckPool -->|池中无| Create[创建新任务<br/>New]\r\n    Reuse --> Return[返回任务]\r\n    Create --> Return\r\n    \r\n    Release[释放任务<br/>使用完成] --> Reset[重置任务<br/>Reset]\r\n    Reset --> ReturnToPool[归还到池<br/>TaskPool.Push]\r\n    \r\n    style CheckPool fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style Reuse fill:#c8e6c9\r\n    style ReturnToPool fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 数据流设计\r\n\r\n### 资源加载数据流\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Client as 客户端\r\n    participant AssetLoader as AssetLoader\r\n    participant TaskPool as LoadTaskPool\r\n    participant Strategy as IAssetLoadStrategy\r\n    participant Resource as 资源系统\r\n    \r\n    Client->>AssetLoader: LoadAsync(path, type, callback)\r\n    AssetLoader->>TaskPool: Pop() 获取任务\r\n    TaskPool-->>AssetLoader: 返回LoadTask\r\n    AssetLoader->>AssetLoader: 配置任务参数\r\n    AssetLoader->>Strategy: LoadAsync(task)\r\n    Strategy->>Resource: 加载资源\r\n    Resource-->>Strategy: 返回资源\r\n    Strategy->>AssetLoader: 进度回调 OnProgress\r\n    Strategy->>AssetLoader: 完成回调 OnLoaded\r\n    AssetLoader->>Client: 回调通知\r\n    AssetLoader->>TaskPool: Push(task) 归还任务\r\n```\r\n\r\n### 策略切换数据流\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Client as 客户端\r\n    participant AssetLoader as AssetLoader\r\n    participant OldStrategy as 旧策略\r\n    participant NewStrategy as 新策略\r\n    \r\n    Client->>AssetLoader: SetStrategy(newStrategy)\r\n    AssetLoader->>OldStrategy: Unload() 可选卸载\r\n    AssetLoader->>AssetLoader: currentStrategy = newStrategy\r\n    AssetLoader-->>Client: 切换完成\r\n    \r\n    Client->>AssetLoader: LoadAsync(path, type)\r\n    AssetLoader->>NewStrategy: LoadAsync(task)\r\n    NewStrategy-->>AssetLoader: 加载完成\r\n    AssetLoader-->>Client: 回调通知\r\n```\r\n\r\n---\r\n\r\n## 架构验证\r\n\r\n### 流程合理性验证\r\n\r\n从架构可验证：\r\n- ✅ **数据流完整**：加载请求 → 创建任务 → 执行策略 → 加载资源 → 回调通知（完整流程）\r\n- ✅ **职责清晰**：客户端层、服务层、策略层职责明确，无重叠\r\n- ✅ **解耦设计**：通过策略模式实现加载逻辑和业务逻辑解耦\r\n- ✅ **性能优化**：对象池管理，减少GC压力\r\n\r\n### 扩展性验证\r\n\r\n从架构可验证：\r\n- ✅ **策略模式**：新增加载策略只需实现IAssetLoadStrategy\r\n- ✅ **统一接口**：所有策略通过统一接口访问\r\n- ✅ **对象池优化**：LoadTask使用对象池，减少GC压力\r\n- ✅ **向后兼容**：与旧版本完全兼容\r\n\r\n### 易用性验证\r\n\r\n从架构可验证：\r\n- ✅ **统一接口**：所有策略使用统一的加载接口\r\n- ✅ **链式配置**：LoadTask支持链式配置，易于使用\r\n- ✅ **异步加载**：支持进度回调和完成回调\r\n- ✅ **策略切换**：运行时动态切换加载策略\r\n\r\n---\r\n\r\n## 开发指导原则\r\n\r\n### 一、开发约束（什么能做，什么不能做）\r\n\r\n#### ✅ 应该做的\r\n\r\n1. **加载策略必须实现IAssetLoadStrategy**\r\n   ```\r\n   ✅ 正确：\r\n   public class CustomStrategy : IAssetLoadStrategy\r\n   \r\n   ❌ 错误：\r\n   不实现IAssetLoadStrategy的策略类\r\n   ```\r\n\r\n2. **加载必须通过AssetLoader**\r\n   ```\r\n   ✅ 正确：\r\n   AssetLoader.LoadAsync(path, type, callback)\r\n   \r\n   ❌ 错误：\r\n   直接调用策略的LoadAsync方法\r\n   ```\r\n\r\n3. **LoadTask必须使用对象池**\r\n   ```\r\n   ✅ 正确：\r\n   var task = AssetLoader.CreateTask(path, type)\r\n   -- 使用后自动归还到池\r\n   \r\n   ❌ 错误：\r\n   直接创建LoadTask实例\r\n   ```\r\n\r\n#### ❌ 不应该做的\r\n\r\n1. **禁止直接创建LoadTask**\r\n   - 必须通过AssetLoader.CreateTask创建\r\n   - 不能直接new LoadTask\r\n\r\n2. **禁止直接调用策略方法**\r\n   - 必须通过AssetLoader统一接口\r\n   - 不能直接调用策略的LoadAsync方法\r\n\r\n3. **禁止在回调中执行耗时操作**\r\n   - 回调应该快速执行\r\n   - 耗时操作应该异步处理\r\n\r\n### 二、开发流程（标准化开发步骤）\r\n\r\n#### 开发新加载策略的流程\r\n\r\n```\r\n1. 实现IAssetLoadStrategy接口\r\n   ↓\r\n   public class CustomStrategy : IAssetLoadStrategy\r\n   \r\n2. 实现Load和LoadAsync方法\r\n   ↓\r\n   public object Load(string path, Type type)\r\n   public void LoadAsync(LoadTask task)\r\n   \r\n3. 注册策略\r\n   ↓\r\n   AssetLoader.SetStrategy(new CustomStrategy())\r\n   \r\n4. 使用策略\r\n   ↓\r\n   AssetLoader.LoadAsync(path, type, callback)\r\n```\r\n\r\n---\r\n\r\n## 总结\r\n\r\n### 架构设计价值\r\n\r\n该架构设计文档的价值在于：\r\n- ✅ **思路解构**：完整解构资源加载系统的搭建思路\r\n- ✅ **流程验证**：从架构层面验证流程合理性\r\n- ✅ **模式分析**：分析策略模式、对象池模式的应用\r\n- ✅ **开发指导**：为后续详细设计和实现提供清晰指导\r\n\r\n### 设计原则\r\n\r\n- ✅ **策略模式为核心**：不同的加载策略封装成独立的类，运行时动态切换\r\n- ✅ **对象池优化 + 任务封装**：LoadTask使用对象池，通过任务封装简化异步加载\r\n- ✅ **职责分离 + 开闭原则**：加载逻辑和业务逻辑分离，对扩展开放对修改封闭\r\n- ✅ **统一接口**：所有策略通过统一接口访问\r\n\r\n### 架构特点\r\n\r\n- ✅ **策略隔离**：每个策略独立实现，互不干扰\r\n- ✅ **动态切换**：运行时动态切换加载策略\r\n- ✅ **对象池优化**：LoadTask使用对象池，减少GC压力\r\n- ✅ **向后兼容**：与旧版本完全兼容\r\n\r\n细节实现是后续开发阶段的工作，当前架构设计已足够指导整个资源加载系统的开发。\r\n"
        }
    ]
}