# 战斗系统架构设计

## 设计目标

设计一套完整的回合制战斗系统架构，支持DND规则、回合管理、状态机控制、AI决策，实现战斗流程管理、伤害计算、效果应用，提供数据驱动的配置化战斗系统。

---

## 整体架构设计

### Clean架构模式（主要架构）

**核心观点**：战斗系统采用Clean架构模式，将系统组织成四个同心圆层，业务规则在中心，框架和技术在外围。

### 战斗系统整体架构图

```mermaid
graph TB
    subgraph "框架层（Frameworks & Drivers）- 技术实现"
        Unity[Unity引擎<br/>渲染/物理/动画]
        Lua[Lua脚本引擎<br/>业务逻辑]
        Database[(数据库<br/>数据持久化)]
        FSM[状态机框架<br/>FSM Framework]
        CommunicationBus[通信总线<br/>CommunicationBus]
        DataHandleQueue[数据队列<br/>DataHandleQueue]
        Formula[公式引擎<br/>Formula Parser]
        Pool[对象池<br/>Object Pool]
        Config[配置数据<br/>Excel/JSON/Lua]
    end
    
    subgraph "服务层（Services）- 功能服务"
        InputService[输入服务<br/>Input Service<br/>玩家输入/AI输入]
        ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]
        VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]
        DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]
        CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]
    end
    
    subgraph "用例层（Use Cases）- 应用业务规则"
        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]
        ExecuteRoundUC[执行回合用例<br/>ExecuteRound]
        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam]
        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit]
        CalculateDamageUC[计算伤害用例<br/>CalculateDamage]
        ApplyEffectUC[应用效果用例<br/>ApplyEffect]
    end
    
    subgraph "实体层（Entities）- 核心业务规则"
        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]
        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]
        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]
        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]
        SkillEntity[技能实体<br/>Skill Entity]
        EffectEntity[效果实体<br/>Effect Entity]
    end
    
    Unity --> VisualService
    Lua --> ActionService
    Database --> DataService
    FSM --> ExecuteBattleUC
    CommunicationBus --> CommunicationService
    DataHandleQueue --> DataService
    Formula --> ActionService
    Pool --> VisualService
    Config --> DataService
    
    InputService --> ExecuteUnitUC
    ActionService --> ExecuteUnitUC
    VisualService --> ExecuteUnitUC
    DataService --> ExecuteUnitUC
    CommunicationService --> ExecuteUnitUC
    
    ExecuteBattleUC --> BattleEntity
    ExecuteRoundUC --> RoundEntity
    ExecuteTeamUC --> TeamEntity
    ExecuteUnitUC --> UnitEntity
    CalculateDamageUC --> SkillEntity
    ApplyEffectUC --> EffectEntity
    
    BattleEntity --> RoundEntity
    RoundEntity --> TeamEntity
    TeamEntity --> UnitEntity
    
    style BattleEntity fill:#ffebee
    style ExecuteBattleUC fill:#fff4e1
    style InputService fill:#e8f5e9
    style Unity fill:#e1f5ff
```

**依赖规则**：
- ✅ **允许**：外层依赖内层
- ❌ **禁止**：内层依赖外层
- ✅ **允许**：通过接口定义依赖
- ❌ **禁止**：直接依赖具体实现

### 战斗流程在Clean架构中的执行

```mermaid
sequenceDiagram
    participant Framework as 框架层
    participant Service as 服务层
    participant UseCase as 用例层
    participant Entity as 实体层
    
    Note over Framework,Entity: 战斗开始流程
    
    Framework->>Service: Unity触发战斗开始
    Service->>UseCase: 输入服务转换输入
    UseCase->>Entity: 执行战斗用例调用战斗实体
    Entity->>Entity: 战斗实体启动战斗循环
    
    Note over Entity: 战斗循环开始
    
    Entity->>UseCase: 战斗实体调用执行回合用例
    UseCase->>Entity: 执行回合用例调用回合实体
    Entity->>Entity: 回合实体启动回合循环
    
    Note over Entity: 回合循环开始
    
    Entity->>UseCase: 回合实体调用执行阵营用例
    UseCase->>Entity: 执行阵营用例调用阵营实体
    Entity->>Entity: 阵营实体启动阵营循环
    
    Note over Entity: 阵营循环开始
    
    Entity->>UseCase: 阵营实体调用执行单位用例
    UseCase->>Service: 执行单位用例调用输入服务
    Service->>Framework: 输入服务获取玩家输入/AI输入
    Framework->>Service: 返回输入数据
    Service->>UseCase: 转换输入数据
    
    UseCase->>Service: 执行单位用例调用行动服务
    Service->>Framework: 行动服务调用Lua脚本
    Framework->>Service: 返回行动结果
    Service->>UseCase: 转换行动结果
    
    UseCase->>Service: 执行单位用例调用视觉服务
    Service->>Framework: 视觉服务调用Unity引擎
    Framework->>Service: 播放动画/特效
    Service->>UseCase: 视觉播放完成
    
    UseCase->>Service: 执行单位用例调用数据服务
    Service->>Framework: 数据服务更新数据
    Framework->>Service: 数据更新完成
    Service->>UseCase: 数据更新结果
    
    UseCase->>Entity: 执行单位用例完成，更新单位实体
    Entity->>Entity: 单位循环继续/结束
    
    Note over Entity: 单位循环结束，返回上层循环
```


## 实体层详细设计（Entities Layer）

### 四层循环实体模型

**核心观点**：战斗系统的核心是四层循环的维护和管理，这些循环在实体层中定义。

### 层次状态机实现（框架层）

**说明**：层次状态机是框架层的实现，用于管理实体层的状态转换。

#### 层次状态机设计

```mermaid
graph TB
    subgraph "框架层 - 层次状态机"
        BattleFSM[战斗状态机<br/>BattleFSM<br/>HierarchicalFSM]
        RoundFSM[回合状态机<br/>RoundFSM<br/>HierarchicalFSM]
        TeamFSM[阵营状态机<br/>TeamFSM<br/>HierarchicalFSM]
        UnitFSM[单位状态机<br/>UnitFSM<br/>FSMBase]
        
        BattleFSM -->|包含| RoundFSM
        RoundFSM -->|包含| TeamFSM
        TeamFSM -->|包含| UnitFSM
    end
    
    subgraph "实体层 - 业务实体"
        BattleEntity[战斗实体<br/>Battle Entity]
        RoundEntity[回合实体<br/>Round Entity]
        TeamEntity[阵营实体<br/>Team Entity]
        UnitEntity[单位实体<br/>Unit Entity]
    end
    
    BattleFSM -.管理.-> BattleEntity
    RoundFSM -.管理.-> RoundEntity
    TeamFSM -.管理.-> TeamEntity
    UnitFSM -.管理.-> UnitEntity
    
    style BattleFSM fill:#e1f5ff
    style BattleEntity fill:#ffebee
```

#### 层次状态机特点

1. **状态嵌套**：
   - 父状态机可以包含子状态机
   - 子状态机在父状态机进入时自动重置
   - 子状态机在父状态机更新时自动更新

2. **状态隔离**：
   - 每层状态机独立管理自己的状态
   - 状态转换只在当前状态机内进行
   - 父状态机状态变化不影响子状态机状态

3. **自动管理**：
   - 父状态机进入时，自动重置子状态机
   - 父状态机更新时，自动更新子状态机
   - 父状态机退出时，自动清理子状态机

4. **循环驱动**：
   - 每层状态机的状态转换驱动循环推进
   - 状态机状态决定循环是否继续
   - 状态机状态决定循环行为

#### 循环分层状态机流程图
```mermaid
sequenceDiagram
    participant Main as 主状态机
    participant Round as 回合状态机
    participant Team as 阵营状态机
    participant Unit as 单位状态机
    
    Note over Main: 战斗开始
    Main->>Main: PREPARING → IN_PROGRESS
    Main->>Round: 进入IN_PROGRESS，激活回合状态机
    
    Note over Round: 第1回合开始
    Round->>Round: ROUND_START
    Round->>Round: CheckRoundActionCondition() → ROUND_ACTION
    Round->>Team: 进入ROUND_ACTION，激活阵营状态机
    
    Note over Team: 玩家阵营开始
    Team->>Team: TEAM_START
    Team->>Team: CheckTeamActionCondition() → TEAM_ACTION
    Team->>Unit: 进入TEAM_ACTION，激活单位状态机
    
    Note over Unit: 单位1行动
    Unit->>Unit: UNIT_START
    Unit->>Unit: CheckUnitActionCondition() → UNIT_ACTION
    Unit->>Unit: 执行行动
    Unit->>Unit: CheckUnitEndCondition() → UNIT_END
    Unit->>Unit: CheckNextUnitCondition() → UNIT_START (还有单位2)
    
    Note over Unit: 单位2行动
    Unit->>Unit: UNIT_START
    Unit->>Unit: UNIT_ACTION
    Unit->>Unit: UNIT_END
    Unit->>Unit: CheckNextUnitCondition() → false (没有更多单位)
    
    Note over Team: 玩家阵营结束
    Team->>Team: CheckTeamEndCondition() → TEAM_END
    Team->>Team: CheckNextTeamCondition() → TEAM_START (还有敌人阵营)
    
    Note over Team: 敌人阵营开始
    Team->>Team: TEAM_START
    Team->>Team: TEAM_ACTION
    Team->>Unit: 激活单位状态机（敌人单位1）
    Unit->>Unit: UNIT_START → UNIT_ACTION → UNIT_END
    Unit->>Unit: CheckNextUnitCondition() → UNIT_START (还有单位2)
    Unit->>Unit: UNIT_START → UNIT_ACTION → UNIT_END
    Unit->>Unit: CheckNextUnitCondition() → false
    Team->>Team: TEAM_END
    Team->>Team: CheckNextTeamCondition() → false (没有更多阵营)
    
    Note over Round: 第1回合结束
    Round->>Round: CheckRoundEndCondition() → ROUND_END
    Round->>Round: CheckNextRoundCondition() → ROUND_START (还有第2回合)
    
    Note over Round: 第2回合开始
    Round->>Round: ROUND_START → ROUND_ACTION
    Round->>Team: 激活阵营状态机
    Team->>Team: TEAM_START → TEAM_ACTION → TEAM_END
    Team->>Team: CheckNextTeamCondition() → TEAM_START (循环)
    Team->>Team: TEAM_START → TEAM_ACTION → TEAM_END
    Team->>Team: CheckNextTeamCondition() → false
    Round->>Round: ROUND_END
    Round->>Round: CheckNextRoundCondition() → false (战斗结束)
    
    Note over Main: 战斗结束
    Main->>Main: CheckBattleEndCondition() → ENDED
    Main->>Main: 激活结果状态机
```
---


