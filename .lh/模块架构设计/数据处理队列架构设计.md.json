{
    "sourceFile": "模块架构设计/数据处理队列架构设计.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1767203292700,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1767203292700,
            "name": "Commit-0",
            "content": "# 数据处理队列架构设计\r\n\r\n## 设计目标\r\n\r\n设计一套完整的数据处理队列系统，支持多系统协同（装备、技能、状态、专长等），实现模块间完全解耦、批量处理优化、统一数据访问接口，提供数据驱动的配置化数据处理系统。\r\n\r\n---\r\n\r\n## 核心设计理念\r\n\r\n### 1. 统一数据访问接口为核心\r\n\r\n**本质**：数据处理队列系统的核心是提供统一的数据访问接口\r\n- 数据推送 = 所有系统通过Queue推送数据，不直接操作目标对象\r\n- 数据查询 = 所有系统通过Queue查询数据，不直接访问UnitData内部结构\r\n- 完全解耦 = 各系统与UnitData无直接依赖，通过Queue通信\r\n- 统一接口 = 任务、战斗、剧情、装备系统都通过同一个Queue访问数据\r\n\r\n### 2. 发布-订阅模式 + 观察者模式\r\n\r\n**本质**：数据处理队列采用发布-订阅模式实现模块间解耦\r\n- 数据推送 = 发布者推送数据到队列\r\n- 数据订阅 = 订阅者注册Handler处理数据\r\n- 批量处理 = 队列延迟批量处理，性能优化\r\n- 解耦设计 = 发布者和订阅者不直接依赖\r\n\r\n### 3. 数据驱动架构\r\n\r\n**本质**：数据处理特性通过配置数据实现，无需修改代码\r\n- 数据推送、数据查询 → 通过配置数据定义\r\n- Handler映射、查询委托 → 通过配置数据调整\r\n- 新增数据类型 → 扩展配置数据即可\r\n- 数据处理流程 → 调整配置数据即可\r\n\r\n---\r\n\r\n## 整体架构设计\r\n\r\n### 三层架构 + 发布-订阅模式\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph PublisherLayer[\"发布者层<br/>各业务系统\"]\r\n        EquipSystem[\"装备系统<br/>EquipSystem\"]\r\n        SkillSystem[\"技能系统<br/>SkillSystem\"]\r\n        StateSystem[\"状态系统<br/>StateSystem\"]\r\n        FeatSystem[\"专长系统<br/>FeatSystem\"]\r\n        ConfigSystem[\"配置系统<br/>ConfigSystem\"]\r\n    end\r\n    \r\n    subgraph QueueLayer[\"队列层<br/>DataHandleQueue\"]\r\n        DataQueue[\"数据队列<br/>Queue\"]\r\n        HandlerMapping[\"处理器映射<br/>HandlerMapping\"]\r\n        QueryDelegate[\"查询委托<br/>QueryDelegate\"]\r\n    end\r\n    \r\n    subgraph SubscriberLayer[\"订阅者层<br/>UnitData子系统\"]\r\n        EquipData[\"装备数据<br/>UnitEquipData\"]\r\n        SkillData[\"技能数据<br/>UnitSkillData\"]\r\n        StateData[\"状态数据<br/>UnitStateData\"]\r\n        FeatData[\"专长数据<br/>UnitFeatData\"]\r\n    end\r\n    \r\n    PublisherLayer -->|PushData<br/>推送数据| QueueLayer\r\n    QueueLayer -->|ProcessDataHandler<br/>批量处理| SubscriberLayer\r\n    PublisherLayer -->|ProcessQueryDelegate<br/>查询数据| QueueLayer\r\n    QueueLayer -->|QueryDelegate<br/>查询委托| SubscriberLayer\r\n    \r\n    style PublisherLayer fill:#ffebee\r\n    style QueueLayer fill:#f3e5f5\r\n    style SubscriberLayer fill:#c8e6c9\r\n```\r\n\r\n### 发布-订阅数据流\r\n\r\n```mermaid\r\ngraph LR\r\n    Start[业务系统<br/>装备/技能/状态] -->|1. PushData<br/>推送数据| Queue[DataHandleQueue<br/>存储到队列]\r\n    Queue -->|2. ProcessDataHandler<br/>批量处理| Handler[HandlerMapping<br/>查找处理器]\r\n    Handler -->|3. OnDataHandler<br/>处理数据| Subscriber[UnitData子系统<br/>执行业务逻辑]\r\n    Subscriber -.数据变化.-> Start\r\n    \r\n    Query[业务系统<br/>配置/任务/战斗] -->|4. ProcessQueryDelegate<br/>查询数据| Queue\r\n    Queue -->|5. QueryDelegate<br/>查询委托| Subscriber\r\n    Subscriber -->|6. 返回数据| Query\r\n    \r\n    style Queue fill:#f3e5f5\r\n    style Handler fill:#fff4e1\r\n    style Subscriber fill:#c8e6c9\r\n```\r\n\r\n**数据流特性**：\r\n- ✅ **统一接口**：所有系统通过Queue推送和查询数据\r\n- ✅ **批量处理**：先推送后处理，100个装备变更只处理1次\r\n- ✅ **完全解耦**：各系统与UnitData无直接依赖\r\n- ✅ **配置驱动**：配置层通过QueryDelegate查询数据，无需知道UnitData结构\r\n- ✅ **扩展性强**：新增数据类型只需扩展HandlerMapping和QueryDelegate\r\n\r\n---\r\n\r\n## 队列层架构设计\r\n\r\n### 核心职责\r\n\r\n数据队列管理 + Handler映射 + 查询委托管理\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph DataHandleQueue[\"DataHandleQueue核心\"]\r\n        DataQueue[\"数据队列<br/>Queue<br/>存储待处理数据\"]\r\n        HandlerMapping[\"处理器映射<br/>HandlerMapping<br/>数据类型→处理函数\"]\r\n        QueryDelegate[\"查询委托<br/>QueryDelegate<br/>查询类型→查询函数\"]\r\n    end\r\n    \r\n    subgraph PushInterface[\"推送接口\"]\r\n        PushData[\"PushData(dataType, data)<br/>推送数据到队列\"]\r\n    end\r\n    \r\n    subgraph ProcessInterface[\"处理接口\"]\r\n        ProcessDataHandler[\"ProcessDataHandler()<br/>批量处理队列数据\"]\r\n    end\r\n    \r\n    subgraph QueryInterface[\"查询接口\"]\r\n        SetQueryDelegate[\"SetQueryDelegate(queryType, func)<br/>注册查询委托\"]\r\n        ProcessQueryDelegate[\"ProcessQueryDelegate(queryType, ...)<br/>执行查询委托\"]\r\n    end\r\n    \r\n    PushInterface --> DataQueue\r\n    DataQueue --> ProcessInterface\r\n    ProcessInterface --> HandlerMapping\r\n    QueryInterface --> QueryDelegate\r\n    \r\n    style DataHandleQueue fill:#f3e5f5\r\n    style PushInterface fill:#ffebee\r\n    style ProcessInterface fill:#fff4e1\r\n    style QueryInterface fill:#c8e6c9\r\n```\r\n\r\n### 核心组件\r\n\r\n1. **数据队列（Queue）**\r\n   - 存储待处理的数据（dataType + data）\r\n   - 支持批量推送，延迟处理\r\n   - 队列结构：`{dataType, data}` 数组\r\n\r\n2. **处理器映射（HandlerMapping）**\r\n   - 数据类型 → 处理函数的映射\r\n   - 子类定义处理函数：`handlerMapping[dataType] = function(data) end`\r\n   - 支持动态注册和查找\r\n\r\n3. **查询委托（QueryDelegate）**\r\n   - 查询类型 → 查询函数的映射\r\n   - 配置层查询单位信息，无需知道UnitData结构\r\n   - 支持参数传递和返回值\r\n\r\n---\r\n\r\n## 发布者层架构设计\r\n\r\n### 核心职责\r\n\r\n推送数据到队列 + 查询数据\r\n\r\n### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    BusinessSystem[业务系统<br/>装备/技能/状态] --> CheckCondition{检查条件<br/>是否需要推送数据?}\r\n    CheckCondition -->|需要| PushData[PushData(dataType, data)<br/>推送数据到队列]\r\n    CheckCondition -->|不需要| End1[结束]\r\n    \r\n    PushData --> Queue[DataHandleQueue<br/>存储到队列]\r\n    Queue --> BatchProcess[批量处理<br/>ProcessDataHandler]\r\n    \r\n    ConfigSystem[配置系统<br/>CfgEquip/CfgSkill] --> QueryData[ProcessQueryDelegate<br/>查询单位信息]\r\n    QueryData --> Queue\r\n    Queue --> QueryDelegate[QueryDelegate<br/>执行查询]\r\n    QueryDelegate --> ReturnData[返回数据<br/>等级/属性/装备等]\r\n    ReturnData --> ConfigSystem\r\n    \r\n    style CheckCondition fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style PushData fill:#c8e6c9\r\n    style QueryData fill:#e1f5ff\r\n```\r\n\r\n### 发布者类型\r\n\r\n1. **装备系统（EquipSystem）**\r\n   - 推送装备安装/卸载数据\r\n   - 查询单位等级、属性等\r\n\r\n2. **技能系统（SkillSystem）**\r\n   - 推送技能学习/遗忘数据\r\n   - 查询单位技能列表\r\n\r\n3. **状态系统（StateSystem）**\r\n   - 推送状态添加/移除数据\r\n   - 查询单位状态列表\r\n\r\n4. **配置系统（ConfigSystem）**\r\n   - 查询单位信息（等级、属性、装备等）\r\n   - 不推送数据，只查询数据\r\n\r\n---\r\n\r\n## 订阅者层架构设计\r\n\r\n### 核心职责\r\n\r\n注册Handler处理数据 + 注册QueryDelegate提供查询\r\n\r\n### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Queue[DataHandleQueue<br/>批量处理] --> ProcessHandler[ProcessDataHandler<br/>遍历HandlerMapping]\r\n    ProcessHandler --> FindHandler{查找Handler<br/>handlerMapping[dataType]}\r\n    FindHandler -->|找到| CallHandler[调用Handler<br/>OnDataHandler(data)]\r\n    FindHandler -->|未找到| Ignore[忽略数据]\r\n    \r\n    CallHandler --> BusinessLogic[执行业务逻辑<br/>装备安装/技能学习等]\r\n    BusinessLogic --> UpdateState[更新状态<br/>标记数据变化]\r\n    \r\n    QueryRequest[查询请求<br/>ProcessQueryDelegate] --> FindDelegate{查找QueryDelegate<br/>queryDelegate[queryType]}\r\n    FindDelegate -->|找到| CallDelegate[调用QueryDelegate<br/>返回数据]\r\n    FindDelegate -->|未找到| ReturnNil[返回nil]\r\n    \r\n    CallDelegate --> ReturnData[返回数据<br/>等级/属性/装备等]\r\n    \r\n    style FindHandler fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style FindDelegate fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style BusinessLogic fill:#c8e6c9\r\n```\r\n\r\n### 订阅者类型\r\n\r\n1. **UnitEquipData（装备数据）**\r\n   - 注册Handler：处理装备安装/卸载\r\n   - 注册QueryDelegate：查询装备列表、是否有装备\r\n\r\n2. **UnitSkillData（技能数据）**\r\n   - 注册Handler：处理技能学习/遗忘\r\n   - 注册QueryDelegate：查询技能列表、技能等级\r\n\r\n3. **UnitStateData（状态数据）**\r\n   - 注册Handler：处理状态添加/移除\r\n   - 注册QueryDelegate：查询状态列表、是否有状态\r\n\r\n---\r\n\r\n## 架构模式分析\r\n\r\n### 发布-订阅模式（Publish-Subscribe Pattern）\r\n\r\n**核心思想**：发布者和订阅者通过中间件（Queue）解耦\r\n\r\n```mermaid\r\ngraph LR\r\n    Publisher[发布者<br/>业务系统] -->|推送数据| Queue[中间件<br/>DataHandleQueue]\r\n    Queue -->|分发数据| Subscriber1[订阅者1<br/>UnitEquipData]\r\n    Queue -->|分发数据| Subscriber2[订阅者2<br/>UnitSkillData]\r\n    Queue -->|分发数据| Subscriber3[订阅者3<br/>UnitStateData]\r\n    \r\n    style Queue fill:#f3e5f5\r\n    style Publisher fill:#ffebee\r\n    style Subscriber1 fill:#c8e6c9\r\n    style Subscriber2 fill:#c8e6c9\r\n    style Subscriber3 fill:#c8e6c9\r\n```\r\n\r\n**优势**：\r\n- ✅ **完全解耦**：发布者和订阅者不直接依赖\r\n- ✅ **动态订阅**：可以动态添加/移除订阅者\r\n- ✅ **批量处理**：队列延迟批量处理，性能优化\r\n- ✅ **统一接口**：所有系统通过同一个Queue通信\r\n\r\n### 观察者模式（Observer Pattern）\r\n\r\n**核心思想**：HandlerMapping实现观察者模式\r\n\r\n```mermaid\r\ngraph TB\r\n    Subject[Subject<br/>DataHandleQueue] -->|通知| Observer1[Observer1<br/>handlerMapping[Type1]]\r\n    Subject -->|通知| Observer2[Observer2<br/>handlerMapping[Type2]]\r\n    Subject -->|通知| Observer3[Observer3<br/>handlerMapping[Type3]]\r\n    \r\n    style Subject fill:#f3e5f5\r\n    style Observer1 fill:#c8e6c9\r\n    style Observer2 fill:#c8e6c9\r\n    style Observer3 fill:#c8e6c9\r\n```\r\n\r\n**优势**：\r\n- ✅ **一对多通知**：一个数据变化可以通知多个Handler\r\n- ✅ **动态注册**：可以动态添加/移除Observer\r\n- ✅ **解耦设计**：Subject和Observer不直接依赖\r\n\r\n---\r\n\r\n## 数据流设计\r\n\r\n### 数据推送流程\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant BS as 业务系统\r\n    participant Q as DataHandleQueue\r\n    participant HM as HandlerMapping\r\n    participant SD as UnitData子系统\r\n    \r\n    BS->>Q: PushData(dataType, data)\r\n    Q->>Q: 存储到队列\r\n    BS->>Q: ProcessDataHandler()\r\n    Q->>HM: 查找Handler\r\n    HM->>SD: OnDataHandler(data)\r\n    SD->>SD: 执行业务逻辑\r\n    SD->>SD: 更新状态\r\n```\r\n\r\n### 数据查询流程\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant CS as 配置系统\r\n    participant Q as DataHandleQueue\r\n    participant QD as QueryDelegate\r\n    participant SD as UnitData子系统\r\n    \r\n    CS->>Q: ProcessQueryDelegate(queryType, ...)\r\n    Q->>QD: 查找QueryDelegate\r\n    QD->>SD: 调用查询函数\r\n    SD->>SD: 查询数据\r\n    SD->>QD: 返回数据\r\n    QD->>CS: 返回结果\r\n```\r\n\r\n---\r\n\r\n## 架构验证\r\n\r\n### 流程合理性验证\r\n\r\n从架构可验证：\r\n- ✅ **数据流完整**：推送数据 → 队列存储 → 批量处理 → Handler处理（完整流程）\r\n- ✅ **查询流完整**：查询请求 → QueryDelegate → 返回数据（完整流程）\r\n- ✅ **职责清晰**：发布者、队列、订阅者职责明确，无重叠\r\n- ✅ **解耦设计**：通过Queue实现模块间完全解耦\r\n\r\n### 扩展性验证\r\n\r\n从架构可验证：\r\n- ✅ **发布-订阅模式**：新增发布者/订阅者无需修改Queue\r\n- ✅ **Handler映射**：新增数据类型只需扩展HandlerMapping\r\n- ✅ **QueryDelegate**：新增查询类型只需扩展QueryDelegate\r\n- ✅ **配置驱动**：配置层通过QueryDelegate查询，无需知道UnitData结构\r\n\r\n### 性能验证\r\n\r\n从架构可验证：\r\n- ✅ **批量处理**：队列延迟批量处理，100个装备变更只处理1次\r\n- ✅ **按需查询**：只查询需要的数据，避免全量查询\r\n- ✅ **统一接口**：所有系统通过同一个Queue，减少重复代码\r\n\r\n---\r\n\r\n## 开发指导原则\r\n\r\n### 一、开发约束（什么能做，什么不能做）\r\n\r\n#### ✅ 应该做的\r\n\r\n1. **数据推送必须通过Queue**\r\n   ```\r\n   ✅ 正确：\r\n   业务系统 → Queue.PushData() → Queue.ProcessDataHandler()\r\n   \r\n   ❌ 错误：\r\n   业务系统 → 直接操作 → UnitData\r\n   ```\r\n\r\n2. **数据查询必须通过QueryDelegate**\r\n   ```\r\n   ✅ 正确：\r\n   配置系统 → Queue.ProcessQueryDelegate() → QueryDelegate → 返回数据\r\n   \r\n   ❌ 错误：\r\n   配置系统 → 直接访问 → UnitData内部结构\r\n   ```\r\n\r\n3. **Handler必须注册到HandlerMapping**\r\n   ```\r\n   ✅ 正确：\r\n   UnitData子系统 → handlerMapping[dataType] = function(data) end\r\n   \r\n   ❌ 错误：\r\n   直接处理数据，不注册Handler\r\n   ```\r\n\r\n#### ❌ 不应该做的\r\n\r\n1. **禁止直接操作UnitData**\r\n   - 业务系统不能直接访问UnitData内部结构\r\n   - 必须通过Queue推送和查询数据\r\n\r\n2. **禁止绕过Queue**\r\n   - 所有数据操作必须通过Queue\r\n   - 不能直接调用UnitData的方法\r\n\r\n3. **禁止硬编码数据访问**\r\n   - 配置层不能硬编码UnitData的访问方式\r\n   - 必须通过QueryDelegate查询\r\n\r\n### 二、开发流程（标准化开发步骤）\r\n\r\n#### 开发新数据类型的标准流程\r\n\r\n```\r\n1. 定义数据类型\r\n   ↓\r\n   在DataHandleRule中定义新的dataType枚举\r\n   \r\n2. 实现Handler\r\n   ↓\r\n   在UnitData子类中实现handlerMapping[dataType]\r\n   \r\n3. 注册QueryDelegate（如果需要）\r\n   ↓\r\n   在UnitData中注册queryDelegate[queryType]\r\n   \r\n4. 使用Queue\r\n   ↓\r\n   业务系统通过Queue.PushData()推送数据\r\n   配置系统通过Queue.ProcessQueryDelegate()查询数据\r\n```\r\n\r\n---\r\n\r\n## 总结\r\n\r\n### 架构设计价值\r\n\r\n该架构设计文档的价值在于：\r\n- ✅ **思路解构**：完整解构数据处理队列系统的搭建思路\r\n- ✅ **流程验证**：从架构层面验证流程合理性\r\n- ✅ **模式分析**：分析发布-订阅模式和观察者模式的应用\r\n- ✅ **开发指导**：为后续详细设计和实现提供清晰指导\r\n\r\n### 设计原则\r\n\r\n- ✅ **统一数据访问接口为核心**：所有系统通过Queue访问数据\r\n- ✅ **发布-订阅模式**：实现模块间完全解耦\r\n- ✅ **数据驱动架构**：数据处理特性通过配置数据实现\r\n- ✅ **批量处理优化**：队列延迟批量处理，性能优化\r\n\r\n### 架构特点\r\n\r\n- ✅ **完全解耦**：各系统与UnitData无直接依赖\r\n- ✅ **统一接口**：任务、战斗、剧情系统都通过同一个Queue访问数据\r\n- ✅ **配置驱动**：配置层通过QueryDelegate查询，无需知道UnitData结构\r\n- ✅ **批量处理**：100个装备变更只处理1次，性能优化\r\n\r\n细节实现是后续开发阶段的工作，当前架构设计已足够指导整个数据处理队列系统的开发。\r\n"
        }
    ]
}