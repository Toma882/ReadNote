# 触发器系统架构设计

## 设计目标

设计一套完整的事件触发和响应系统，支持条件-动作绑定、事件驱动机制、对象池管理，实现高性能、可扩展的触发器框架，提供装饰器模式和子类扩展能力。

---

## 核心设计理念

### 1. 条件-动作解耦为核心

**本质**：触发器系统的核心是条件与动作的解耦设计
- 条件检查 = 独立的函数，返回布尔值
- 动作执行 = 独立的函数，执行具体操作
- 条件-动作绑定 = 通过枚举ID建立映射关系
- 灵活组合 = 支持1对多、多对1、多对多的绑定关系

### 2. 对象池 + 工厂模式

**本质**：通过对象池技术提升性能，通过工厂模式实现类型管理
- 对象池管理 = 触发器实例的复用和缓存
- 工厂模式 = TriggerKitFactory统一管理触发器创建
- 类型注册 = 通过枚举定义触发器类型，自动初始化
- 性能优化 = 减少内存分配和GC压力

### 3. 装饰器模式 + 观察者模式

**本质**：通过装饰器模式扩展功能，通过观察者模式实现事件驱动
- 装饰器模式 = 覆盖装饰器和扩展装饰器两种模式
- 观察者模式 = 事件监听和广播机制
- 功能扩展 = 不修改原有代码即可扩展功能
- 事件驱动 = 触发器可以订阅和响应游戏事件

---

## 整体架构设计

### 核心组件架构

```mermaid
graph TB
    subgraph CoreLayer["核心层<br/>TriggerKit"]
        TriggerInstance["触发器实例<br/>条件/动作绑定"]
        ConditionMap["条件映射表<br/>ConditionId → Function"]
        ActionMap["动作映射表<br/>ActionId → Function"]
        EventListener["事件监听器<br/>EventType → Handler"]
    end
    
    subgraph FactoryLayer["工厂层<br/>TriggerKitFactory"]
        ObjFactory["对象工厂<br/>实现ObjFactory接口"]
        TypeRegistry["类型注册表<br/>TriggerType → Class"]
        PoolManager["对象池管理器<br/>Pop/Push操作"]
    end
    
    subgraph DefineLayer["定义层<br/>TriggerDefine"]
        TriggerType["触发器类型枚举<br/>ETrigger"]
        ConditionType["条件类型枚举<br/>ETC"]
        ActionType["动作类型枚举<br/>ETA"]
        EventType["事件类型枚举<br/>ETE"]
    end
    
    subgraph UtilLayer["工具层<br/>TriggerUtil"]
        ConditionRegistry["条件注册器<br/>RegisterConditionType"]
        ActionRegistry["动作注册器<br/>RegisterActionType"]
        EventRegistry["事件注册器<br/>RegisterEventType"]
    end
    
    subgraph ExtensionLayer["扩展层"]
        DecoratorPattern["装饰器模式<br/>IDecorator接口"]
        SubclassExtension["子类扩展<br/>BaseClass继承"]
    end
    
    DefineLayer -->|类型定义| CoreLayer
    FactoryLayer -->|实例创建| CoreLayer
    UtilLayer -->|功能注册| CoreLayer
    ExtensionLayer -->|功能扩展| CoreLayer
    
    style CoreLayer fill:#e1f5ff
    style FactoryLayer fill:#fff4e1
    style DefineLayer fill:#c8e6c9
    style UtilLayer fill:#f3e5f5
    style ExtensionLayer fill:#ffebee
```

### 条件-动作绑定架构

```mermaid
graph TB
    subgraph BindingTypes["绑定类型"]
        One2One["1对1绑定<br/>BindCA<br/>一个条件对应一个动作"]
        One2Many["1对多绑定<br/>MultiA2F<br/>一个条件对应多个动作"]
        Many2One["多对1绑定<br/>MultiC2A<br/>多个条件对应一个动作"]
        Many2Many["多对多绑定<br/>组合使用"]
    end
    
    subgraph ConditionSystem["条件系统"]
        ConditionId["条件ID<br/>ETC.Module.Condition"]
        ConditionFunc["条件函数<br/>function() return bool end"]
        ConditionCheck["条件检查<br/>CheckCondition"]
    end
    
    subgraph ActionSystem["动作系统"]
        ActionId["动作ID<br/>ETA.Module.Action"]
        ActionFunc["动作函数<br/>function() end"]
        ActionExecute["动作执行<br/>ExecuteAction"]
    end
    
    ConditionSystem -->|绑定| BindingTypes
    BindingTypes -->|触发| ActionSystem
    
    style BindingTypes fill:#e1f5ff
    style ConditionSystem fill:#fff4e1
    style ActionSystem fill:#c8e6c9
```

---

## 详细层级设计

### 核心层：TriggerKit

**核心职责**：触发器实例管理、条件-动作绑定、事件监听

#### 架构图

```mermaid
graph TB
    subgraph TriggerKit["TriggerKit核心类"]
        BindCA["BindCA<br/>1对1绑定"]
        MultiA2F["MultiA2F<br/>1对多绑定"]
        MultiC2F["MultiC2F<br/>多条件注册"]
        MultiC2A["MultiC2A<br/>多对1绑定"]
        CheckMultiC2A["CheckMultiC2A<br/>多条件检查"]
        ExecuteActions["ExecuteActions<br/>执行动作"]
        SetEventListener["SetEventListener<br/>设置事件监听"]
        Broadcast["Broadcast<br/>广播事件"]
    end
    
    subgraph InternalStorage["内部存储"]
        ConditionDict["conditionDict<br/>条件字典"]
        ActionDict["actionDict<br/>动作字典"]
        EventDict["eventDict<br/>事件字典"]
        DecoratorList["decoratorList<br/>装饰器列表"]
    end
    
    TriggerKit --> InternalStorage
    
    style TriggerKit fill:#e1f5ff
    style InternalStorage fill:#fff4e1
```

**关键方法**：
- `BindCA(conditionId, conditionFunc, actionId, actionFunc)` - 1对1绑定
- `MultiA2F(conditionId, actionIds, actions)` - 1对多绑定
- `MultiC2F(conditionIds, conditions)` - 多条件注册
- `MultiC2A(conditionIds, actionId, action)` - 多对1绑定
- `CheckMultiC2A(actionId)` - 检查多条件并执行动作
- `ExecuteActions(conditionId, actionId)` - 执行指定动作
- `SetEventListener(eventType, handler)` - 设置事件监听
- `Broadcast(eventType)` - 广播事件

### 工厂层：TriggerKitFactory

**核心职责**：触发器实例创建、对象池管理、类型注册

#### 架构图

```mermaid
graph TB
    subgraph Factory["TriggerKitFactory"]
        Pop["Pop<br/>从对象池获取"]
        Push["Push<br/>回收到对象池"]
        GetFactory["GetFactory<br/>获取工厂实例"]
        AddObjClass["AddObjClass<br/>注册类型"]
    end
    
    subgraph Pool["对象池"]
        PoolStorage["池存储<br/>按类型管理"]
        PoolInit["池初始化<br/>预分配对象"]
        PoolRecycle["池回收<br/>对象复用"]
    end
    
    Factory --> Pool
    
    style Factory fill:#e1f5ff
    style Pool fill:#fff4e1
```

**工作流程**：
1. 系统初始化时，工厂自动注册所有触发器类型
2. 调用`Pop(triggerType)`从对象池获取触发器实例
3. 使用完毕后调用`Push(triggerType)`回收实例
4. 支持动态注册新的触发器类型

### 定义层：TriggerDefine

**核心职责**：枚举定义、类型声明

#### 枚举结构

```mermaid
graph TB
    subgraph Enums["枚举定义"]
        ETrigger["ETrigger<br/>触发器类型枚举"]
        ETC["ETC<br/>条件类型枚举<br/>按模块组织"]
        ETA["ETA<br/>动作类型枚举<br/>按模块组织"]
        ETE["ETE<br/>事件类型枚举<br/>按模块组织"]
    end
    
    subgraph Module["模块组织"]
        ExampleModule["ExampleModule模块"]
        CustomModule["CustomModule模块"]
        OtherModule["其他模块..."]
    end
    
    Enums --> Module
    
    style Enums fill:#e1f5ff
    style Module fill:#fff4e1
```

**枚举设计原则**：
- 触发器类型：`ETrigger.ModuleName`
- 条件类型：`ETC.ModuleName.ConditionName`
- 动作类型：`ETA.ModuleName.ActionName`
- 事件类型：`ETE.ModuleName.EventName`

### 工具层：TriggerUtil

**核心职责**：条件/动作/事件注册、工具方法

**关键方法**：
- `RegisterConditionType(conditionType, handler)` - 注册条件类型
- `RegisterActionType(actionType, handler)` - 注册动作类型
- `RegisterEventType(eventType, handler)` - 注册事件类型

---

## 架构模式分析

### 观察者模式（Observer Pattern）

**核心思想**：触发器订阅事件，当事件发生时自动响应

```mermaid
graph TB
    subgraph Observer["观察者模式"]
        Subject["事件源<br/>游戏系统"]
        Observer1["触发器1<br/>订阅事件A"]
        Observer2["触发器2<br/>订阅事件B"]
        Observer3["触发器3<br/>订阅事件A"]
    end
    
    Subject -->|广播事件A| Observer1
    Subject -->|广播事件A| Observer3
    Subject -->|广播事件B| Observer2
    
    style Subject fill:#e1f5ff
    style Observer1 fill:#fff4e1
    style Observer2 fill:#fff4e1
    style Observer3 fill:#fff4e1
```

**优势**：
- ✅ **解耦设计**：事件源和触发器解耦
- ✅ **灵活扩展**：可以动态添加和移除观察者
- ✅ **事件驱动**：基于事件而非轮询

### 工厂模式（Factory Pattern）

**核心思想**：通过工厂统一管理触发器创建，支持对象池

```mermaid
graph TB
    subgraph Factory["工厂模式"]
        Client["客户端<br/>请求触发器"]
        FactoryClass["TriggerKitFactory<br/>工厂类"]
        TriggerClass1["TriggerKit类型1"]
        TriggerClass2["TriggerKit类型2"]
        ObjectPool["对象池<br/>实例缓存"]
    end
    
    Client -->|Pop| FactoryClass
    FactoryClass -->|创建/复用| ObjectPool
    ObjectPool -->|返回实例| Client
    FactoryClass -->|类型注册| TriggerClass1
    FactoryClass -->|类型注册| TriggerClass2
    
    style Client fill:#e1f5ff
    style FactoryClass fill:#fff4e1
    style ObjectPool fill:#c8e6c9
```

**优势**：
- ✅ **统一管理**：所有触发器创建通过工厂
- ✅ **对象池优化**：减少内存分配
- ✅ **类型扩展**：支持动态注册新类型

### 装饰器模式（Decorator Pattern）

**核心思想**：通过装饰器动态扩展触发器功能，不修改原有代码

```mermaid
graph TB
    subgraph Decorator["装饰器模式"]
        TriggerKit["TriggerKit<br/>核心触发器"]
        OverrideDecorator["覆盖装饰器<br/>覆盖原方法"]
        ExtendDecorator["扩展装饰器<br/>扩展原方法"]
    end
    
    TriggerKit -->|SetOverrideDecorator| OverrideDecorator
    TriggerKit -->|AddExtendDecorator| ExtendDecorator
    
    style TriggerKit fill:#e1f5ff
    style OverrideDecorator fill:#fff4e1
    style ExtendDecorator fill:#c8e6c9
```

**两种装饰器模式**：
- **覆盖装饰器**：完全覆盖原方法，只执行装饰器逻辑
- **扩展装饰器**：在原方法前后执行装饰器逻辑

**优势**：
- ✅ **功能扩展**：不修改原有代码即可扩展功能
- ✅ **灵活组合**：可以同时使用多个装饰器
- ✅ **职责分离**：装饰器专注于特定功能增强

### 策略模式（Strategy Pattern）

**核心思想**：条件和动作作为策略，可以灵活替换

```mermaid
graph TB
    subgraph Strategy["策略模式"]
        Trigger["触发器<br/>上下文"]
        ConditionStrategy1["条件策略1<br/>ConditionFunc1"]
        ConditionStrategy2["条件策略2<br/>ConditionFunc2"]
        ActionStrategy1["动作策略1<br/>ActionFunc1"]
        ActionStrategy2["动作策略2<br/>ActionFunc2"]
    end
    
    Trigger -->|绑定| ConditionStrategy1
    Trigger -->|绑定| ConditionStrategy2
    Trigger -->|绑定| ActionStrategy1
    Trigger -->|绑定| ActionStrategy2
    
    style Trigger fill:#e1f5ff
    style ConditionStrategy1 fill:#fff4e1
    style ConditionStrategy2 fill:#fff4e1
    style ActionStrategy1 fill:#c8e6c9
    style ActionStrategy2 fill:#c8e6c9
```

**优势**：
- ✅ **灵活替换**：条件和动作可以动态替换
- ✅ **易于测试**：每个策略可以独立测试
- ✅ **扩展性强**：新增策略只需实现接口

---

## 数据流设计

### 触发器执行流程

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Factory as TriggerKitFactory
    participant Trigger as TriggerKit
    participant Condition as 条件函数
    participant Action as 动作函数
    participant Event as 事件系统
    
    Client->>Factory: Pop(ETrigger.Module)
    Factory-->>Client: 返回触发器实例
    
    Client->>Trigger: BindCA(conditionId, conditionFunc, actionId, actionFunc)
    Trigger->>Trigger: 存储条件-动作映射
    
    Client->>Trigger: ExecuteActions(conditionId, actionId)
    Trigger->>Condition: 调用条件函数
    Condition-->>Trigger: 返回true/false
    
    alt 条件满足
        Trigger->>Action: 执行动作函数
        Action-->>Trigger: 动作执行完成
        Trigger-->>Client: 返回执行结果
    else 条件不满足
        Trigger-->>Client: 条件不满足，不执行动作
    end
    
    Client->>Trigger: SetEventListener(eventType, handler)
    Trigger->>Event: 注册事件监听
    
    Event->>Trigger: 广播事件
    Trigger->>Action: 执行事件处理函数
    Action-->>Trigger: 处理完成
    
    Client->>Factory: Push(ETrigger.Module)
    Factory->>Factory: 回收触发器到对象池
```

### 多条件多动作流程

```mermaid
flowchart TD
    Start[触发检查] --> CheckType{检查类型}
    
    CheckType -->|1对多| One2Many[一个条件]
    One2Many --> CheckCondition1[检查条件]
    CheckCondition1 -->|满足| ExecuteAll[执行所有关联动作]
    CheckCondition1 -->|不满足| Skip[跳过]
    
    CheckType -->|多对1| Many2One[多个条件]
    Many2One --> CheckCondition2[检查所有条件]
    CheckCondition2 -->|全部满足| ExecuteOne[执行单个动作]
    CheckCondition2 -->|任一不满足| Skip
    
    CheckType -->|多对多| Many2Many[多个条件]
    Many2Many --> CheckCondition3[检查条件组合]
    CheckCondition3 -->|满足组合| ExecuteGroup[执行动作组]
    CheckCondition3 -->|不满足| Skip
    
    ExecuteAll --> End[完成]
    ExecuteOne --> End
    ExecuteGroup --> End
    Skip --> End
    
    style Start fill:#e1f5ff
    style End fill:#c8e6c9
```

---

## 架构验证

### 流程合理性验证

从架构可验证：
- ✅ **条件-动作解耦**：条件检查和动作执行完全分离
- ✅ **灵活绑定**：支持1对1、1对多、多对1、多对多绑定
- ✅ **对象池优化**：通过对象池减少内存分配
- ✅ **事件驱动**：支持观察者模式，实现事件驱动

### 扩展性验证

从架构可验证：
- ✅ **类型扩展**：新增触发器类型只需注册枚举
- ✅ **条件扩展**：新增条件类型只需注册到ETC
- ✅ **动作扩展**：新增动作类型只需注册到ETA
- ✅ **事件扩展**：新增事件类型只需注册到ETE
- ✅ **功能扩展**：通过装饰器模式和子类扩展

### 性能验证

从架构可验证：
- ✅ **对象池**：减少内存分配和GC压力
- ✅ **函数缓存**：条件和动作函数直接存储，无需查找
- ✅ **事件优化**：事件监听通过字典快速查找
- ✅ **轻量设计**：条件和动作函数应保持轻量

---

## 开发指导原则

### 一、开发约束（什么能做，什么不能做）

#### ✅ 应该做的

1. **使用对象池管理触发器**
   ```
   ✅ 正确：
   local trigger = TriggerKit.Pop(ETrigger.Module)
   -- 使用触发器
   TriggerKit.Push(ETrigger.Module)
   
   ❌ 错误：
   直接创建触发器实例，不使用对象池
   ```

2. **条件和动作函数保持轻量**
   ```
   ✅ 正确：
   local condition = function() return player.hp < 50 end
   local action = function() player:Heal(100) end
   
   ❌ 错误：
   在条件或动作函数中执行耗时操作
   ```

3. **使用枚举定义类型**
   ```
   ✅ 正确：
   ETC.Module.Condition1
   ETA.Module.Action1
   ETE.Module.Event1
   
   ❌ 错误：
   使用字符串或数字直接定义类型
   ```

#### ❌ 不应该做的

1. **禁止忘记回收触发器**
   - 所有从对象池获取的触发器必须回收
   - 不能长时间持有触发器实例

2. **禁止在条件/动作中执行耗时操作**
   - 条件和动作函数应快速执行
   - 耗时操作应在外部处理

3. **禁止直接修改触发器内部状态**
   - 应通过提供的API操作触发器
   - 不能直接访问内部字典

### 二、开发流程（标准化开发步骤）

#### 定义触发器类型的流程

```
1. 定义枚举
   ↓
   在TriggerDefine.lua中定义ETrigger、ETC、ETA、ETE
   
2. 注册类型
   ↓
   系统初始化时自动注册
   
3. 使用触发器
   ↓
   local trigger = TriggerKit.Pop(ETrigger.Module)
   trigger:BindCA(...)
   TriggerKit.Push(ETrigger.Module)
```

#### 扩展触发器的流程

```
1. 选择扩展方式
   ↓
   装饰器模式 / 子类扩展
   
2. 实现扩展
   ↓
   装饰器：实现IDecorator接口
   子类：继承TriggerKit
   
3. 注册扩展
   ↓
   装饰器：SetOverrideDecorator / AddExtendDecorator
   子类：重写Pop方法注册到工厂
```

---

## 总结

### 架构设计价值

该架构设计文档的价值在于：
- ✅ **思路解构**：完整解构触发器系统的搭建思路
- ✅ **模式分析**：分析观察者、工厂、装饰器、策略模式的应用
- ✅ **流程验证**：从架构层面验证流程合理性
- ✅ **开发指导**：为后续详细设计和实现提供清晰指导

### 设计原则

- ✅ **条件-动作解耦为核心**：条件检查和动作执行完全分离
- ✅ **对象池 + 工厂模式**：通过对象池提升性能，通过工厂统一管理
- ✅ **装饰器模式 + 观察者模式**：通过装饰器扩展功能，通过观察者实现事件驱动
- ✅ **灵活绑定**：支持多种绑定关系，满足不同场景需求

### 架构特点

- ✅ **高性能**：对象池管理，减少内存分配
- ✅ **可扩展**：支持装饰器模式和子类扩展
- ✅ **事件驱动**：支持观察者模式，实现事件驱动
- ✅ **灵活组合**：支持1对1、1对多、多对1、多对多绑定

细节实现是后续开发阶段的工作，当前架构设计已足够指导整个触发器系统的开发。
