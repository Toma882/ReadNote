{
    "sourceFile": "C#面试题总结.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1765982020789,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1765982020789,
            "name": "Commit-0",
            "content": "# C# 面试题总结\r\n\r\n> **整理时间**：2025年  \r\n> **用途**：面试准备 + 基础知识复习  \r\n> **重点**：面向对象、内存管理、集合、泛型、委托事件等核心知识点\r\n\r\n---\r\n\r\n## 目录\r\n\r\n1. [面向对象的三大特点](#1-面向对象的三大特点)\r\n2. [值类型和引用类型](#2-简述值类型和引用类型)\r\n3. [重载和重写的区别](#3-重载和重写的区别)\r\n4. [.NET与Mono的关系](#4-net与-mono-的关系)\r\n5. [引用类型的基类](#5-c中所有引用类型的基类是什么)\r\n6. [ArrayList和List的区别](#6-请简述arraylist和-list的主要区别)\r\n7. [GC相关知识点](#7-gc-相关知识点)\r\n8. [结构体和类](#8-结构体和类)\r\n9. [访问修饰符](#9-c中四种访问修饰符是哪些各有什么区别)\r\n10. [堆和栈的区别](#11-堆和栈的区别)\r\n11. [静态构造函数](#12-静态构造函数)\r\n12. [String和StringBuilder](#13-c-string类型比-stringbuilder-类型的优势是什么)\r\n13. [Lambda表达式](#14-c函数-funcstring-a-string-b用-lambda-表达式怎么写)\r\n14. [虚函数实现原理](#15-虚函数实现原理)\r\n15. [指针和引用的区别](#16-指针和引用的区别)\r\n16. [常用容器类](#17-c中有哪些常用的容器类各有什么特点)\r\n17. [泛型容器](#18-c中常规容器和泛型容器有什么区别哪种效率高)\r\n18. [unsafe关键字](#21-c中unsafe关键字是用来做什么的什么场合下使用)\r\n19. [ref和out关键字](#22-c中ref和out关键字有什么区别)\r\n20. [循环遍历](#23-forforeachenumeratormovenext的使用与内存消耗情况)\r\n21. [JIT和AOT](#26-jit和aot区别)\r\n22. [对象池](#28-当需要频繁创建使用某个对象时有什么好的程序设计方案来节省内存)\r\n23. [委托和事件](#29-c的委托是什么有何用处)\r\n24. [接口和抽象类](#32-接口interface与抽象类)\r\n25. [C#和C++的区别](#34-c和c的区别)\r\n26. [反射](#36-反射的实现原理)\r\n27. [基本类型字节数](#37-c中基本类型占用的字节数)\r\n28. [Dictionary实现原理](#42-字典dictionary的内部实现原理)\r\n29. [using的作用](#43-using的作用)\r\n30. [IEnumerable接口](#45-能用foreach遍历访问的对象需要实现___接口或声明___方法的类型)\r\n31. [里氏替换原则](#46-什么是里氏替换原则c多态)\r\n32. [装箱拆箱](#52-什么是装箱拆箱怎样减少操作)\r\n33. [MVC](#53-mvc)\r\n34. [托管代码与非托管代码](#54-非托管代码与不安全代码)\r\n35. [栈溢出](#57-栈溢出一般是由什么原因导致)\r\n36. [栈和队列](#58-stack栈和queue队列)\r\n37. [链表](#59-链表相关)\r\n38. [数组和链表对比](#60-链表与数组的对比)\r\n39. [二叉树](#61-二叉树相关)\r\n40. [字典详解](#62-字典相关)\r\n41. [哈希表与字典对比](#63-哈希表与字典对比)\r\n42. [List与字典的遍历与查询效率](#64-关于list与字典的遍历与查询效率)\r\n\r\n---\r\n\r\n## 1. 面向对象的三大特点\r\n\r\n### 继承\r\n- **作用**：提高代码重用度，增强软件可维护性的重要手段，符合开闭原则\r\n- **主要作用**：把子类的公共属性集合起来，便于共同管理，使用起来也更加方便\r\n- **传递性**：a▶b; b▶c; c具有a的特性\r\n- **单根性**：在C#中一个类只能继承一个类，不能有多个父类\r\n\r\n### 封装\r\n- **定义**：将数据和行为相结合，通过行为约束代码修改数据的程度，增强数据的安全性\r\n- **实现**：属性是C#封装实现的最好体现\r\n- **意义**：保护或者防止代码（数据）被我们无意中破坏\r\n- **特点**：将复杂的逻辑经过包装之后给别人使用就很方便，别人不需要了解里面是如何实现的\r\n\r\n### 多态性\r\n- **定义**：同名的方法在不同环境下，自适应的反应出不同得表现，是方法动态展示的重要手段\r\n- **特点**：一个对象多种状态，子类对象可以赋值给父类型的变量\r\n\r\n---\r\n\r\n## 2. 简述值类型和引用类型\r\n\r\n### 介绍\r\n\r\n**值类型**：\r\n- 包含所有简单类型（整数、浮点、bool、char）、struct、enum\r\n- 继承自 `System.ValueType`\r\n\r\n**引用类型**：\r\n- 包含 string，object，class，interface，delegate，array\r\n- 继承自 `System.Object`\r\n\r\n### 区别\r\n\r\n| 特性 | 值类型 | 引用类型 |\r\n|------|--------|----------|\r\n| 存储位置 | 内存栈中 | 内存堆中（栈中存地址） |\r\n| 存取速度 | 快 | 慢 |\r\n| 表示内容 | 实际数据 | 指向堆中数据的指针和引用 |\r\n| 内存释放 | 栈内存自动释放 | 堆内存由GC自动释放 |\r\n| 基类 | System.ValueType | System.Object |\r\n| 存储内容 | 直接的值 | 数据在堆中，栈中存引用地址 |\r\n\r\n---\r\n\r\n## 3. 重载和重写的区别\r\n\r\n| 特性 | 重载 | 重写 |\r\n|------|------|------|\r\n| 位置 | 同类中 | 父子类中 |\r\n| 定义方式 | 方法名相同，参数列表不同 | 方法名和参数列表都相同 |\r\n| 调用方式 | 相同对象以不同参数调用 | 不同对象以相同参数调用 |\r\n| 多态时机 | 编译时多态 | 运行时多态 |\r\n\r\n---\r\n\r\n## 4. .NET与 Mono 的关系？\r\n\r\n- **.NET**：一个语言平台\r\n- **Mono**：为.NET提供集成开发环境，集成并实现了.NET的编译器、CLR和基础类库\r\n- **作用**：使得.NET既可以运行在Windows，也可以运行于Linux、Unix、Mac OS等\r\n\r\n---\r\n\r\n## 5. C#中所有引用类型的基类是什么\r\n\r\n- **引用类型的基类**：`System.Object`\r\n- **值类型的基类**：`System.ValueType`\r\n- **注意**：值类型也隐式继承自 `System.Object`\r\n\r\n---\r\n\r\n## 6. 请简述ArrayList和 List的主要区别\r\n\r\n| 特性 | ArrayList | List |\r\n|------|-----------|------|\r\n| 泛型 | 不带泛型，数据类型丢失 | 带泛型，数据类型不丢失 |\r\n| 装箱拆箱 | 需要装箱拆箱 | 不需要 |\r\n| 类型安全 | 不安全（所有数据都当做Object处理） | 安全 |\r\n| 性能 | 装箱拆箱操作费时 | 性能更好 |\r\n| 接口 | 实现了IList接口 | 继承了IList接口 |\r\n\r\n**关键区别**：\r\n- `List` 类是 `ArrayList` 类的泛型等效类\r\n- 声明 `List` 集合时，需要同时声明集合内数据的对象类型\r\n\r\n---\r\n\r\n## 7. GC 相关知识点\r\n\r\n### GC的概念\r\n\r\n- **内存管理池**：\r\n  - 栈内存(stack)：存储较小的和短暂的数据\r\n  - 堆内存(heap)：存储较大的和存储时间较长的数据\r\n- **内存分配**：变量要么存储在栈内存上，要么处于堆内存上\r\n- **内存回收**：处于栈上的内存回收及其快速，处于堆上的内存并不是及时回收的\r\n- **GC操作**：C#中会定时对堆内存进行GC操作\r\n\r\n### GC会带来的问题\r\n\r\n**游戏性能**：\r\n- GC操作是一个极其耗费时间的操作\r\n- 堆内存上的变量或者引用越多，遍历检查时的操作变得十分缓慢\r\n- 可能导致游戏帧率下降\r\n\r\n**游戏内存**：\r\n- Unity GC采用的是非分代非压缩的标记清除算法\r\n- GC操作会产生\"内存碎片化\"\r\n- 当内存被回收到堆上时，有可能被堆内存分割成碎片化的单元\r\n- 导致下次分配时找不到合适的储存单元，触发GC操作或堆内存扩容操作\r\n\r\n### GC触发时机\r\n\r\n1. 在堆内存上进行内存分配操作，而内存不够的时候\r\n2. GC会自动的触发，不同平台运行频率不一样\r\n3. GC可以被强制执行\r\n\r\n### 如何避免GC？\r\n\r\n1. **减少临时变量**：多使用公共对象，多利用缓存机制\r\n2. **减少new对象**：减少new对象的次数\r\n3. **StringBuilder代替String**：对于大量字符串拼接时使用StringBuilder\r\n4. **容器预分配**：使用扩容的容器时，定义时尽量根据存储变量的内存大小定义储存空间\r\n5. **代码逻辑优化**：例如计时器当大于1s后才进行文本修改，而不是每帧都修改\r\n6. **利用对象池**：针对经常消失生成的对象，例如子弹、怪物等\r\n7. **减少装箱拆箱**：避免不必要的装箱拆箱操作\r\n8. **协程优化**：`yield return 0` 会产生装箱拆箱，可以替换为 `yield return null`\r\n\r\n---\r\n\r\n## 8. 结构体和类\r\n\r\n### 结构体和类的区别\r\n\r\n| 特性 | 结构体 | 类 |\r\n|------|--------|-----|\r\n| 类型 | 值类型 | 引用类型 |\r\n| 存储位置 | 栈中 | 堆中 |\r\n| 类型传递 | 值传递 | 引用传递（传递指针） |\r\n| 成员初始化 | 定义时不能初始化 | 定义时可以初始化 |\r\n| 无参构造函数 | 不能声明 | 可以声明 |\r\n| 有参构造函数 | 声明后，无参构造不会被顶掉 | - |\r\n| 析构函数 | 不能声明 | 可以声明 |\r\n| 继承 | 不能被继承 | 可以继承 |\r\n| 构造函数要求 | 需要在构造函数中初始化所有成员变量 | 随意 |\r\n| static修饰 | 不能被static修饰 | 可以 |\r\n\r\n**注意**：\r\n- 结构体可以使用new运算符创建构造对象，也可以不使用new关键字\r\n- 如果不使用new，那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用\r\n\r\n### 使用情景\r\n\r\n**结构体**：\r\n- 适合轻量级的对象，比如点、矩形、颜色\r\n- 如果对象是数据集合时，优先考虑结构体（位置，坐标）\r\n- 在变量传值的时候，希望传递对象的是拷贝，而不是对象的引用地址\r\n\r\n**类**：\r\n- 适合重量级的对象\r\n- 如果对象需要继承和多态特征，用类（玩家、怪物）\r\n\r\n---\r\n\r\n## 9. C#中四种访问修饰符是哪些？各有什么区别？\r\n\r\n### 属性修饰符\r\n- **Serializable**：按值将对象封送到远程服务器\r\n- **STATread**：单线程套间的意思，是一种线程模型\r\n- **MATAThread**：多线程套间的意思，也是一种线程模型\r\n\r\n### 存取修饰符\r\n- **public**：存取不受限制\r\n- **private**：只有包含该成员的类可以存取\r\n- **internal**：只有当前工程可以存取\r\n- **protected**：只有包含该成员的类以及派生类可以存取\r\n\r\n### 类修饰符\r\n- **abstract**：抽象类。指示一个类只能作为其它类的基类\r\n- **sealed**：密封类。指示一个类不能被继承\r\n\r\n### 成员修饰符\r\n- **abstract**：指示该方法或属性没有实现\r\n- **sealed**：密封方法。可以防止在派生类中对该方法的override（重载）\r\n- **delegate**：委托。用来定义一个函数指针\r\n- **const**：指定该成员的值只读不允许修改\r\n- **event**：声明一个事件\r\n- **extern**：指示方法在外部实现\r\n- **override**：重写。对由基类继承成员的新实现\r\n- **readonly**：指示一个域只能在声明时以及相同类的内部被赋值\r\n- **static**：指示一个成员属于类型本身，而不是属于特定的对象\r\n- **virtual**：指示一个方法或存取器的实现可以在继承类中被覆盖\r\n- **new**：在派生类中隐藏指定的基类成员，从而实现重写的功能\r\n\r\n---\r\n\r\n## 10. 修饰符 简述private，public，protected，internal的区别\r\n\r\n- **public**：对任何类和成员都公开，无限制访问\r\n- **private**：仅对该类公开\r\n- **protected**：对该类和其派生类公开\r\n- **internal**：只能在包含该类的程序集中访问该类\r\n- **protected internal**：protected + internal\r\n\r\n---\r\n\r\n## 11. 堆和栈的区别?\r\n\r\n### GC方面\r\n- **栈**：保持先进后出的原则，是一片连续的内存域，有系统自动分配和维护，产生的垃圾系统自动释放\r\n- **堆**：无序的，是一片不连续的内存域，用户自己来控制和释放，如果用户自己不释放的话，当内存达到一定的特定值时，通过垃圾回收器(GC)来回收\r\n\r\n### 存储方面\r\n- **栈**：通常保存着我们代码执行的步骤，如方法变量等等。可以想象成一个接着一个叠放在一起的盒子（越高内存地址越低）\r\n- **堆**：存放的则多是对象、数据等。像一个仓库，储存着我们使用的各种对象等信息，跟栈不同的是他们被调用完毕不会立即被清理掉\r\n\r\n### 缓存方面\r\n- **栈**：使用一级缓存，通常都是被调用时处于存储空间中，调用完毕立即释放\r\n- **堆**：存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）\r\n\r\n### 存储结构\r\n- **栈(Stack)**：先进后出的数据结构，在内存中，变量会被分配在栈上来进行操作\r\n- **堆(heap)**：用于为引用类型的实例(对象)分配空间的内存区域，在堆上创建一个对象，会将对象的地址传给栈上的变量（栈上的变量指向了堆上地址为XXX的实例）\r\n\r\n---\r\n\r\n## 12. 静态构造函数\r\n\r\n### 特点\r\n- 既没有访问修饰符，也没有参数\r\n- 在创建第一个类实例或任何静态成员被引用时，.NET将自动调用静态构造函数来初始化类\r\n- 一个类只能有一个静态构造函数\r\n- 无参数的构造函数可以与静态构造函数共存\r\n- 最多只运行一次\r\n- 静态构造函数不可以被继承\r\n- 如果没有写静态构造函数，而类中包含带有初始值设定的静态成员，那么编译器会自动生成默认的静态构造函数\r\n\r\n### 注意事项\r\n- 如果静态构造函数引发异常，运行时将不会再次调用该构造函数\r\n- 在类的构造函数前加上static会报错\r\n- 静态构造函数不能有访问修饰符\r\n- 运行库创建类实例或者首次访问静态成员之前，运行库调用静态构造函数\r\n- 静态构造函数执行先于任何实例级别的构造函数\r\n- 无法使用this和base来调用构造函数\r\n\r\n---\r\n\r\n## 13. C# String类型比 stringBuilder 类型的优势是什么?\r\n\r\n### String的特点\r\n- 如果是处理字符串的话，用string中的方法每次都需要创建一个新的字符串对象并且分配新的内存地址\r\n- string类由于具有不可变性（即对一个string对象进行任何更改时，其实都是创建另外一个string类的对象）\r\n- String主要用于公共API，通用性好、用途广泛、读取性能高、占用内存小\r\n- String是不可变的，所以天然线程同步\r\n\r\n### StringBuilder的特点\r\n- StringBuilder是在原来的内存里对字符串进行修改\r\n- StringBuilder类的原理是首先在内存中开辟一定大小的内存空间，当对此StringBuilder类对象进行更改时，如果内存空间大小不够，会对此内存空间进行扩充，而不是重新创建一个对象\r\n- StringBuilder主要用于拼接String，修改性能好\r\n- StringBuilder可变，非线程同步\r\n\r\n### 使用建议\r\n- **String**：如果要操作少量的数据 = string\r\n- **StringBuilder**：单线程操作字符串缓冲区下操作大量数据 = StringBuilder\r\n- **注意**：现在的编译器已经把String的 + 操作优化成StringBuilder了，所以一般用String就可以了\r\n\r\n---\r\n\r\n## 14. C#函数 Func(string a, string b)用 Lambda 表达式怎么写?\r\n\r\n```csharp\r\n(a, b) => {};\r\n```\r\n\r\n---\r\n\r\n## 15. 虚函数实现原理\r\n\r\n- 每个虚函数都会有一个与之对应的虚函数表，该虚函数表的实质是一个指针数组，存放的是每一个对象的虚函数入口地址\r\n- 对于一个派生类来说，他会继承基类的虚函数表同时增加自己的虚函数入口地址\r\n- 如果派生类重写了基类的虚函数的话，那么继承过来的虚函数入口地址将被派生类的重写虚函数入口地址替代\r\n- 在程序运行时会发生动态绑定，将父类指针绑定到实例化的对象实现多态\r\n\r\n---\r\n\r\n## 16. 指针和引用的区别\r\n\r\n| 特性 | 引用 | 指针 |\r\n|------|------|------|\r\n| 空值 | 不能为空 | 可以为空 |\r\n| 初始化 | 必须初始化 | 不需要 |\r\n| 改变指向 | 初始化后不能改变 | 可以改变所指对象的值 |\r\n| 访问方式 | 直接访问 | 间接访问 |\r\n| 大小 | 所引用对象的大小 | 指针本身大小，通常是4字节 |\r\n| const | 没有const | 有const |\r\n| 自增运算符 | 意义不同 | 意义不同 |\r\n| 内存分配 | 不需要分配内存空间 | 需要 |\r\n\r\n**相同点**：都是地址\r\n\r\n**不同点**：\r\n- 指针是个实体，引用是个别名\r\n- 引用是类型安全的，而指针在不安全模式下\r\n- 引用访问对象是直接访问，指针访问对象是间接访问\r\n\r\n---\r\n\r\n## 17. C#中有哪些常用的容器类，各有什么特点\r\n\r\n### List（列表）\r\n- 底层实现是泛型数组\r\n- 特性：动态扩容\r\n- 泛型安全\r\n- 将泛型数据存储在一个泛型数组中，添加元素时若超过当前泛型数组容量，则以2倍扩容\r\n\r\n### Stack（栈）\r\n- 先进后出，入栈和出栈\r\n- 底层泛型数组实现\r\n- 入栈动态扩容2倍\r\n\r\n### Queue（队列）\r\n- 先进先出，入队和出队\r\n- 底层泛型数组实现\r\n- 表头表尾指针，判空还是满通过size比较\r\n\r\n### Array（数组）\r\n- 需要声明长度\r\n- 不安全\r\n\r\n### ArrayList（数组列表）\r\n- 动态增加数组\r\n- 不安全，实现了IList接口\r\n- Object数组实现\r\n\r\n### LinkedList（链表）\r\n- 底层是由链表实现的\r\n- 优点：插入、删除元素效率比较高\r\n- 缺点：访问效率比较低\r\n- 很好的解决了数组删除插入效率低的问题，且不用动态的扩充数组的长度\r\n\r\n### HashTable（哈希表）\r\n- Key—Value形式存取，无序，类型Object，需要类型转换\r\n- Hashtable查询速度快，而添加速度相对慢\r\n- Hashtable中的数据实际存储在内部的一个数据桶里（bucket结构体数组），容量固定，根据数组索引获取值\r\n\r\n### Dictionary（字典）\r\n- 泛型集合\r\n- 任何键都必须是唯一\r\n- 查找元素的时间复杂度接近O(1)\r\n- 实际项目中常被用来做一些数据的本地缓存，提升整体效率\r\n\r\n### 性能排序\r\n\r\n**插入性能**：LinkedList > Dictionary > HashTable > List\r\n\r\n**遍历性能**：List > LinkedList > Dictionary > HashTable\r\n\r\n**删除性能**：Dictionary > LinkedList > HashTable > List\r\n\r\n---\r\n\r\n## 18. C#中常规容器和泛型容器有什么区别，哪种效率高？\r\n\r\n- **常规容器**：不带泛型的容器需要装箱和拆箱操作，速度慢\r\n- **泛型容器**：效率更高，数据类型更安全\r\n\r\n---\r\n\r\n## 19. 有哪些常见的数值类？\r\n\r\n- **简单值类型**：包括整数类型、实数类型、字符类型、布尔类型\r\n- **复合值类型**：包括结构类型、枚举类型\r\n\r\n---\r\n\r\n## 20. 泛型是什么\r\n\r\n### 定义\r\n- 多个代码对【不同数据类型】执行【相同指令】的情况\r\n- 泛型：多个类型共享一组代码\r\n- 泛型允许类型参数化，泛型类型是类型的模板\r\n\r\n### 5种泛型\r\n- 类\r\n- 结构\r\n- 接口\r\n- 委托\r\n- 方法\r\n\r\n### 类型占位符\r\n- 使用 T 来表示泛型\r\n- 泛型类不是实际的类，而是类的模板\r\n\r\n### 从泛型类型创建实例\r\n1. 声明泛型类型\r\n2. 通过提供【真实类型】创建构造函数类型\r\n3. 从构造类型创建实例\r\n\r\n### 性能\r\n- 泛型不会强行对值类型进行装箱和拆箱，或对引用类型进行向下强制类型转换，所以性能得到提高\r\n\r\n### 安全\r\n- 通过知道使用泛型定义的变量的类型限制，编译器可以在一定程度上验证类型假设，所以泛型提高了程序的类型安全\r\n\r\n---\r\n\r\n## 21. C#中unsafe关键字是用来做什么的？什么场合下使用？\r\n\r\n- **作用**：非托管代码才需要这个关键字，一般用在带指针操作的场合\r\n- **使用场景**：项目背包系统的任务装备栏使用到\r\n\r\n---\r\n\r\n## 22. C#中ref和out关键字有什么区别？\r\n\r\n| 特性 | ref | out |\r\n|------|-----|-----|\r\n| 参数赋值 | 参数必须赋值 | 参数可以不赋值 |\r\n| 内部修改 | 在内部可改可不改 | 在内部必须修改该值 |\r\n| 返回值 | 带回返回值，又进又出 | 带回返回值之前必须明确赋值 |\r\n\r\n**注意**：\r\n- 引用参数和输出参数不会创建新的存储位置\r\n- 如果ref参数是值类型，原先的值类型数据，会随着方法里的数据改变而改变\r\n- 如果ref参数是引用类型，方法里重新赋值后，原对象堆中数据会改变\r\n\r\n---\r\n\r\n## 23. For，foreach，Enumerator.MoveNext的使用，与内存消耗情况\r\n\r\n- **for循环**：可以通过索引依次进行遍历\r\n- **foreach和Enumerator.MoveNext**：通过迭代的方式进行遍历\r\n- **内存消耗**：本质上并没有太大的区别\r\n- **Unity注意**：在Unity中的Update中，一般不推荐使用foreach，因为会遗留内存垃圾\r\n\r\n---\r\n\r\n## 24. foreach迭代器遍历和for循环遍历的区别\r\n\r\n### foreach的特点\r\n- foreach中的迭代变量item是只读的，不能对其进行修改，比如list.Remove（item）操作\r\n- foreach只读的时候记录下来，在对记录做操作，或者直接用for循环遍历\r\n- foreach对int[]数组循环已经不产生GC，避免对ArrayList进行遍历\r\n\r\n### for循环的特点\r\n- for语句中初始化变量i的作用域，循环体内部可见\r\n- 通过索引进行遍历，可以根据索引对所遍历集合进行修改\r\n- Unity中for循环使用lambda表达式注意闭包问题\r\n\r\n### foreach遍历原理\r\n- 任何集合类（Array）对象都有一个GetEnumerator()方法，该方法可以返回一个实现了迭代器IEnumerator接口的对象\r\n- 这个返回的IEnumerator对象既不是集合类对象，也不是集合的元素类对象，它是一个独立的类对象\r\n- 通过这个实现了IEnumerator接口对象A，可以遍历访问集合类对象中的每一个元素对象\r\n- 对象A访问MoveNext方法，方法为真，就可以访问Current方法，读取到集合的元素\r\n\r\n**示例代码**：\r\n```csharp\r\nList<string> list = new List<string>() { \"25\", \"哈3\", \"26\", \"花朵\" };\r\nIEnumerator listEnumerator = list.GetEnumerator();\r\nwhile (listEnumerator.MoveNext())\r\n{\r\n    Console.WriteLine(listEnumerator.Current);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 25. Foreach循环迭代时，若把其中的某个元素删除，程序报错，怎么找到那个元素？以及具体怎么处理这种情况？\r\n\r\n- **问题**：foreach不能进行元素的删除，因为迭代器会锁定迭代的集合\r\n- **解决方法**：记录找到索引或者key值，迭代结束后再进行删除\r\n- **替代方案**：使用For循环遍历可以解决\r\n\r\n---\r\n\r\n## 26. JIT和AOT区别\r\n\r\n### Just-In-Time (JIT) - 实时编译\r\n- 执行慢\r\n- 安装快\r\n- 占空间小一点\r\n\r\n### Ahead-Of-Time (AOT) - 预先编译\r\n- 执行快\r\n- 安装慢\r\n- 占内存占外存大\r\n\r\n---\r\n\r\n## 27. 给定一个存放参数的数组，重新排列数组\r\n\r\n```csharp\r\nvoid SortArray(Array arr)\r\n{\r\n    Array.Sort(arr);\r\n}\r\n```\r\n\r\n---\r\n\r\n## 28. 当需要频繁创建使用某个对象时，有什么好的程序设计方案来节省内存？\r\n\r\n- **设计单例模式**：进行创建对象\r\n- **使用对象池**：针对经常消失生成的对象，例如子弹、怪物等\r\n\r\n---\r\n\r\n## 29. C#的委托是什么?有何用处?\r\n\r\n### 定义\r\n- 委托类似于一种安全的指针引用，在使用它时是当做类来看待而不是一个方法\r\n- 相当于对一组方法的列表的引用，可以便捷的使用委托对这个方法集合进行操作\r\n- 委托是对函数指针的封装\r\n\r\n### 用处\r\n- 使用委托使程序员可以将方法引用封装在委托对象内\r\n- 然后可以将该委托对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法\r\n- 与C或C++中的函数指针不同，委托是面向对象，而且是类型安全的\r\n\r\n---\r\n\r\n## 30. C#中 委托和事件的区别\r\n\r\n| 特性 | 委托 | 事件 |\r\n|------|------|------|\r\n| 赋值 | 可以用\"=\"来赋值 | 不可以 |\r\n| 调用 | 可以在声明它的类外部进行调用 | 只能在类的内部进行调用 |\r\n| 类型 | 是一个类型 | 修饰的是一个对象 |\r\n| 实例化 | 可以实例化，通过委托的构造函数来把方法赋值给委托实例 | - |\r\n| 触发方式 | 委托实例.Invoke(参数列表) 或 委托实例(参数列表) | - |\r\n| 注册注销 | - | 通过+=为事件注册多个委托实例或多个方法，通过-=为事件注销 |\r\n\r\n**注意**：\r\n- EventHandler就是一个委托\r\n- 事件可以被看作一个委托类型的变量，通过事件注册、取消多个委托或方法\r\n\r\n---\r\n\r\n## 31. C#中委托 和 接口有什么区别？各用在什么场合？\r\n\r\n### 接口（interface）\r\n- 约束类应该具备的功能集合，约束了类应该具备的功能\r\n- 使类从千变万化的具体逻辑中解脱出来，便于类的管理和扩展\r\n- 同时又合理解决了类的单继承问题\r\n\r\n### 委托\r\n- 约束方法集合的一个类，可以便捷的使用委托对这个方法集合进行操作\r\n\r\n### 使用场合\r\n\r\n**接口**：\r\n- 无法使用继承的场合\r\n- 完全抽象的场合\r\n- 多人协作的场合\r\n\r\n**委托**：\r\n- 多用于事件处理中\r\n\r\n---\r\n\r\n## 32. 接口Interface与抽象类\r\n\r\n### 概念\r\n\r\n**抽象类**：\r\n- 当2个或多个类中有重复部分的时候，我们可以抽象出来一个基类\r\n- 如果希望这个基类不能被实例化，就可以把这个基类设计成抽象类\r\n- 当需要为一些类提供公共的实现代码时，应优先考虑抽象类\r\n- 因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单\r\n\r\n**接口**：\r\n- 当注重代码的扩展性跟可维护性时，应当优先采用接口\r\n- 接口与实现它的类之间可以不存在任何层次关系，接口可以实现毫不相关类的相同行为，比抽象类的使用更加方便灵活\r\n- 接口只关心对象之间的交互的方法，而不关心对象所对应的具体类\r\n- 接口是程序之间的一个协议，比抽象类的使用更安全、清晰\r\n- 一般使用接口的情况更多\r\n\r\n### 区别\r\n\r\n| 特性 | 接口 | 抽象类 |\r\n|------|------|--------|\r\n| 实例化 | 不能被实例化（无构造函数和析构函数） | 可以间接实例化（可以被继承，有构造函数，可以实例化子类的同时间接实例化抽象类这个父类） |\r\n| 方法 | 只能做方法申明 | 可以做方法申明，也可以做方法实现 |\r\n| 成员 | 只能包含抽象成员 | 可以有实现成员 |\r\n| 抽象程度 | 完全抽象 | 部分抽象 |\r\n| 继承/实现 | 要被类实现 | 要被子类继承 |\r\n| 修饰符 | 成员都是对外的，所以不需要修饰符修饰 | 所有的成员修饰符都能使用 |\r\n| 继承 | 可以实现多继承 | 只能实现单继承 |\r\n| 抽象方法 | - | 要被实现，所以不能是静态的，也不能是私有的 |\r\n\r\n### 使用情形\r\n\r\n- **使用抽象类**：是为了代码的复用\r\n- **使用接口**：是为了实现多态性\r\n- **抽象类**：适合用来定义某个领域的固有属性，也就是本质\r\n- **接口**：适合用来定义某个领域的扩展功能\r\n\r\n---\r\n\r\n## 33. 函数中多次使用string的+=处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决。\r\n\r\n- **解决方法**：通过StringBuilder来进行append，这样可以减少内存垃圾\r\n\r\n---\r\n\r\n## 34. C#和C++的区别?\r\n\r\n### 简单对比\r\n- C#与C++比较的话，最重要的特性就是C#是一种完全面向对象的语言，而C++不是\r\n- 另外C#是基于IL中间语言和.NET Framework CLR的，在可移植性，可维护性和强壮性都比C++有很大的改进\r\n- C#的设计目标是用来开发快速稳定可扩展的应用程序，当然也可以通过Interop和Pinvoke完成一些底层操作\r\n\r\n### 具体对比\r\n\r\n| 特性 | C++ | C# |\r\n|------|-----|-----|\r\n| 继承 | 支持多继承 | 类只能继承一个基类中的实现但可以实现多个接口 |\r\n| 数组声明 | 声明语法不同 | \"[]\"标记出现在数组类型的后面 |\r\n| bool类型 | bool类可以与整型转换 | bool类型和其他类型（特别是int）之间没有转换 |\r\n| long类型 | 32位 | 64位 |\r\n| struct类型 | - | 类和结构在语义上不同。struct是值类型，而class是引用类型 |\r\n| switch语句 | 支持从一个case标签贯穿到另一个case标签 | 不支持 |\r\n| delegate类型 | 函数指针 | 委托与C++中的函数指针基本相似，但前者具有类型安全，是安全的 |\r\n| 重写方法 | - | 需要父类方法中用virtual声名，子类方法用override关键字 |\r\n| 头文件 | 使用头文件 | 不使用头文件。C#中不使用头文件。C#预处理器指令 |\r\n| 异常处理 | - | C#中引入了finally语句，这是C++没有的 |\r\n| 运算符 | - | C#支持其他运算符，如is和typeof |\r\n| static的使用 | - | static方法只能由类名调用，改变static变量 |\r\n| Main方法 | main | Main而不能用main |\r\n| 方法参数 | - | C#支持ref和out参数，这两个参数取代指针通过引用传递参数 |\r\n| 指针 | 可以使用 | 在C#中只能在unsafe不安全模式下才使用指针 |\r\n| 字符串 | C++字符串 | C#字符串不同于C++字符串 |\r\n| foreach | - | C#從VB中引入了foreach关键字使得以循环访问数组和集合 |\r\n| 全局方法和全局变量 | 有 | C#中没有全局方法和全局变量：方法和变量必须包含在类型声明（如class或struct）中 |\r\n| 头文件和#include指令 | 有 | C#中没有头文件和#include指令：using指令用于引用其他未完全限定类型名的命名空间中的类型 |\r\n| 局部变量 | - | C#中的局部变量在初始化前不能使用 |\r\n| 析构函数 | 可以控制析构函数的调用时间 | 在C#中，不能控制析构函数的调用时间，原因是析构函数由垃圾回收器自动调用 |\r\n| 构造函数 | 如果在C#中没有提供类构造函数，则为您自动生成默认构造函数。该默认构造函数将所有字段初始化为它们的默认值 | 与C++类似 |\r\n\r\n---\r\n\r\n## 35. C#引用和C++指针的区别\r\n\r\n### 相同点\r\n- 都是地址\r\n\r\n### 不同点\r\n\r\n| 特性 | C#引用 | C++指针 |\r\n|------|--------|---------|\r\n| 支持 | C#不支持指针，但可以使用Unsafe，不安全模式，CLR不检测 | 可以使用指针 |\r\n| 定义 | C#可以定义指针的类型、整数型、实数型、struct结构体 | - |\r\n| 操作 | 使用fixed，可以操作类中的值类型 | - |\r\n| 实体 | 引用是个别名 | 指针是个实体 |\r\n| sizeof | \"sizeof 引用\"得到的是所指向的变量(对象)的大小 | \"sizeof 指针\"得到的是指针本身的大小 |\r\n| 类型安全 | 引用是类型安全的 | 指针在不安全模式下 |\r\n| 空值 | 引用不能为空，即不存在对空对象的引用 | 指针可以为空，指向空对象 |\r\n| 初始化 | 引用必须初始化，指定对哪个对象的引用 | 指针不需要 |\r\n| 改变指向 | 引用初始化后不能改变 | 指针可以改变所指对象的值 |\r\n| 访问方式 | 引用访问对象是直接访问 | 指针访问对象是间接访问 |\r\n| 大小 | 引用的大小是所引用对象的大小 | 指针的大小，是指针本身大小，通常是4字节 |\r\n| const | 引用没有const | 指针有const |\r\n| 自增运算符 | 引用和指针的+自增运算符意义不同 | 意义不同 |\r\n| 内存分配 | 引用不需要分配内存空间 | 指针需要 |\r\n\r\n---\r\n\r\n## 36. 反射的实现原理？\r\n\r\n### 定义\r\n- 可以在加载程序运行时，动态获取和加载程序集，并且可以获取到程序集的信息\r\n- 反射即在运行期动态获取类、对象、方法、对象数据等的一种重要手段\r\n- 审查元数据并收集关于它的类型信息的能力\r\n\r\n### 主要使用的类库\r\n- `System.Reflection`\r\n\r\n### 核心类\r\n- **Assembly**：描述了程序集\r\n- **Type**：描述了类这种类型\r\n- **ConstructorInfo**：描述了构造函数\r\n- **MethodInfo**：描述了所有的方法\r\n- **FieldInfo**：描述了类的字段\r\n- **PropertyInfo**：描述类的属性\r\n\r\n### 功能\r\n通过以上核心类可在运行时动态获取程序集中的类，并执行类构造产生类对象，动态获取对象的字段或属性值，更可以动态执行类方法和实例方法等。\r\n\r\n### 实现步骤\r\n1. 导入 `using System.Reflection;`\r\n2. `Assembly.Load(\"程序集\")` 加载程序集，返回类型是一个Assembly\r\n3. `foreach (Type type in assembly.GetTypes())` 得到程序集中所有类的名称\r\n4. `Type type = assembly.GetType(\"程序集.类名\");` 获取当前类的类型\r\n5. `Activator.CreateInstance(type);` 创建此类型实例\r\n6. `MethodInfo mInfo = type.GetMethod(\"方法名\");` 获取当前方法\r\n7. `mInfo.Invoke(null, 方法参数);` 调用方法\r\n\r\n---\r\n\r\n## 37. C#中基本类型占用的字节数\r\n\r\n| 类型 | 字节 |\r\n|------|------|\r\n| bool | true/false |\r\n| byte、char | 1字节 |\r\n| char、short | 2字节 |\r\n| int，float | 4字节 |\r\n| long、double | 8字节 |\r\n\r\n---\r\n\r\n## 38. Mock和Stub有何区别?\r\n\r\n- **Mock**：关注行为验证。细粒度的测试，即代码的逻辑，多数情况下用于单元测试\r\n- **Stub**：关注状态验证。粗粒度的测试，在某个依赖系统不存在或者还没实现或者难以测试的情况下使用，例如访问文件系统，数据库连接，远程协议等\r\n\r\n---\r\n\r\n## 39. 为什么dynamic font 在 unicode环境下优于 staticfont（字符串编码）\r\n\r\n- **Unicode**：国际组织制定的可以容纳世界上所有文字和符号的字符编码方案\r\n- **动态字体**：使用动态字体时，Unity将不会预先生成一个与所有字体的字符纹理\r\n- **优势**：当需要支持亚洲语言或者较大的字体的时候，若使用正常纹理，则字体的纹理将非常大\r\n\r\n---\r\n\r\n## 40. 简述StringBuilder和String的区别？（字符串处理）\r\n\r\n- **String**：字符串常量。String类型是个不可变的对象，当每次对String进行改变时都需要生成一个新的String对象，然后将指针指向一个新的对象\r\n- **StringBuilder**：字符串变量，线程不安全。StringBuilder对象在做字符串连接操作时是在原来的字符串上进行修改，改善了性能\r\n\r\n### 性能比较\r\n- **StringBuilder > String**\r\n\r\n### 使用建议\r\n- **String**：如果要操作少量的数据 = string\r\n- **StringBuilder**：单线程操作字符串缓冲区下操作大量数据 = StringBuilder\r\n\r\n---\r\n\r\n## 41. string、stringBuilder\r\n\r\n- **String不变性**：字符序列不可变，对原管理中实例对象赋值，会重新开一个新的实例对象赋值，新开的实例对象会等待被GC\r\n- **string拼接**：要重新开辟空间，因为string原值不会改变，导致GC频繁，性能消耗大\r\n- **StringBuilder**：是字符串可变对象\r\n- **StringBuilder非线程安全**：所以性能略好，一般用于单线程\r\n- **性能比较**：StringBuilder > String\r\n\r\n---\r\n\r\n## 42. 字典Dictionary的内部实现原理\r\n\r\n### 介绍\r\n- 泛型集合命名空间 `using System.Collections.Generic;`\r\n- 任何键都必须是唯一\r\n- 该类最大的优点就是它查找元素的时间复杂度接近O(1)，实际项目中常被用来做一些数据的本地缓存，提升整体效率\r\n\r\n### 实现原理\r\n\r\n**哈希算法**：\r\n- 将不定长度的二进制数据集给映射到一个较短的二进制长度数据集\r\n- 一个Key通过HashFunc得到HashCode\r\n\r\n**Hash桶算法**：\r\n- 对HashCode进行分段显示，常用方法是对HashCode直接取余\r\n\r\n**解决碰撞冲突算法（拉链法）**：\r\n- 分段会导致key对应的桶会相同\r\n- 拉链法的思想就像对冲突的元素，建立一个单链表，头指针存储到对应的哈希桶位置\r\n- 反之就是通过确定hash桶位置后，遍历单链表，获取对应的value\r\n\r\n---\r\n\r\n## 43. using的作用\r\n\r\n### 资源管理\r\n- **作用**：实现了IDisposable接口的类或结构\r\n- **功能**：using语句确保这些资源能够被适当的释放（Resource.Dispose）\r\n\r\n### using原理\r\n```\r\nusing（分配资源）\r\n{\r\n    使用资源\r\n}\r\n```\r\n释放资源（隐式）\r\n\r\n**实际实现**：\r\n```csharp\r\nusing（分配资源）\r\n{\r\n    try\r\n    {\r\n        使用资源（可能会导致异常）\r\n    }\r\n    finally\r\n    {\r\n        Resource.Dispose（有无异常都会执行）\r\n    }\r\n}\r\n```\r\n\r\n### using指令\r\n- `using + 命名空间`（或命名空间一个类型）在源文件的顶端声明\r\n- 调用成员方法时也可以不使用using，直接命名空间.类.成员方法\r\n\r\n---\r\n\r\n## 44. Mathf.Round和Mathf.Clamp和Mathf.Lerp含义？\r\n\r\n- **Mathf.Round**：四舍五入\r\n- **Mathf.Clamp**：左右限值\r\n- **Mathf.Lerp**：插值\r\n\r\n---\r\n\r\n## 45. 能用foreach遍历访问的对象需要实现___接口或声明___方法的类型（C#遍历）\r\n\r\n- **答案**：`IEnumerable`；`GetEnumerator`\r\n- **说明**：List和Dictionary类型可以用foreach遍历，他们都实现了IEnumerable接口，申明了GetEnumerator方法\r\n\r\n---\r\n\r\n## 46. 什么是里氏替换原则？（C#多态）\r\n\r\n### 定义\r\n- 里氏替换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一\r\n- 里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现，作用方便扩展功能\r\n\r\n### 原则\r\n1. 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法\r\n2. 子类中可以增加自己特有的方法\r\n3. 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松\r\n4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格\r\n\r\n---\r\n\r\n## 47. 想要在for循环中删除List（或者vector，都行）中的元素时，有可能出现什么问题，如何避免？\r\n\r\n### 问题\r\n- 当删除遍历节点后面的节点时，会导致List.Count进行变化\r\n- 删除元素后，当根据i++，遍历到删除的节点会发生异常\r\n\r\n### 处理方法\r\n- 可以从后往前遍历元素进行操作，即删除在访问的前面\r\n\r\n---\r\n\r\n## 48. 概述c#中代理和事件？\r\n\r\n- **代理**：就是用来定义指向方法的引用\r\n- **事件**：C＃事件本质就是对消息的封装，用作对象之间的通信；发送方叫事件发送器，接收方叫事件接收器\r\n\r\n---\r\n\r\n## 49. New的实现逻辑\r\n\r\n```csharp\r\nrPoint1 = new RefPoint(1);\r\n```\r\n\r\n**实现步骤**：\r\n1. 在应用程序堆上创建一个引用类型对象的实例，并为它分配内存地址\r\n2. 自动传递该实例的引用给构造函数(正因如此，在构造函数中才能使用this来访问这个实例)\r\n3. 调用该类型的构造函数\r\n4. 返回该实例的引用内存地址，复制给 rPoint1 变量，该rPoint1 引用对象保存的数据是指向在堆上创建该类型的实例地址\r\n\r\n---\r\n\r\n## 50. 请简述关键字Sealed用在类声明和函数声明时的作用\r\n\r\n- **类声明时**：可防止其他类继承此类\r\n- **方法中声明**：则可防止派生类重写此方法\r\n\r\n---\r\n\r\n## 51. 下列代码在运行中会发生什么问题？如何避免？\r\n\r\n```csharp\r\nList<int> ls = new List<int>(new int[]{ 1, 2, 3, 4, 5 });\r\nforeach (int item in ls)\r\n{\r\n    Console.WriteLine(item * item);\r\n    ls.Remove(item);\r\n}\r\n```\r\n\r\n### 问题\r\n- 会产生运行时错误，因为foreach是只读的。不能一边遍历一边修改\r\n\r\n### 解决方法\r\n- 使用For循环遍历可以解决\r\n\r\n---\r\n\r\n## 52. 什么是装箱拆箱，怎样减少操作\r\n\r\n### 定义\r\n- **装箱**：C#装箱是将值类型转换为引用类型\r\n- **拆箱**：拆箱是将引用类型转换为值类型\r\n- **应用场景**：牵扯到装箱和拆箱操作比较多的就是在集合中，例如：ArrayList或者HashTable之类\r\n\r\n### 转换过程\r\n\r\n**装箱：值类型 → 引用类型object**\r\n1. 分配内存堆\r\n2. 值类型数据拷贝到新的内存堆中\r\n3. 栈中分配一个新的引用地址指向内存堆\r\n\r\n**拆箱：引用类型object → 值类型**\r\n1. 检查确保对象是给定值类型的一个装箱值\r\n2. 将该值数据复制到栈中的值类型\r\n\r\n### 减少操作\r\n- 使用泛型集合（如List<T>）代替ArrayList\r\n- 避免不必要的类型转换\r\n- 注意协程中的 `yield return 0` 会产生装箱拆箱，可以替换为 `yield return null`\r\n\r\n---\r\n\r\n## 53. MVC\r\n\r\n### 定义\r\n- MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范\r\n- 用一种业务逻辑、数据、界面显示分离的方法，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑\r\n\r\n### 组成部分\r\n- **Model（模型）**：应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据\r\n- **View（视图）**：应用程序中处理数据显示的部分。通常视图是依据模型数据创建的\r\n- **Controller（控制器）**：应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据\r\n\r\n---\r\n\r\n## 54. 非托管代码与不安全代码\r\n\r\n- **托管代码**：在公共语言运行时(CLR)控制下运行的代码\r\n- **非托管代码**：不在公共语言运行时(CLR)控制下运行的代码\r\n- **不安全(Unsafe)代码**：不安全代码可以被认为是介于托管代码和非托管代码之间的。不安全代码仍然在公共语言运行时(CLR)控制下运行，但它将允许您直接通过指针访问内存\r\n\r\n---\r\n\r\n## 55. C#中基本类型占用的字节数\r\n\r\n| 类型 | 字节 |\r\n|------|------|\r\n| bool | true/false |\r\n| byte、char | 1字节 |\r\n| char、short | 2字节 |\r\n| int，float | 4字节 |\r\n| long、double | 8字节 |\r\n\r\n---\r\n\r\n## 56. Heap与Stack有何区别?\r\n\r\n- **heap（堆）**：堆，stack是栈\r\n- **stack（栈）**：栈的空间由操作系统自动分配和释放\r\n- **heap（堆）**：heap的空间是手动申请和释放的，heap常用new关键字来分配\r\n- **stack空间**：有限\r\n- **heap空间**：很大的自由区\r\n\r\n---\r\n\r\n## 57. 栈溢出一般是由什么原因导致\r\n\r\n1. **无限递归**：函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址而造成栈溢出\r\n2. **无限循环**\r\n3. **大量局部变量分配**\r\n\r\n---\r\n\r\n## 58. Stack栈和Queue队列\r\n\r\n### 相同点\r\n- 都是线性结构\r\n- 插入操作都是限定在表尾进行\r\n- 都可以通过顺序结构和链式结构实现\r\n- 插入与删除的时间复杂度都是O（1），在空间复杂度上两者也一样\r\n- 多链栈和多链队列的管理模式可以相同\r\n- 底层都是由泛型数组实现\r\n\r\n### 不同点\r\n- **栈**：先进后出，队列先进先出\r\n- **删除位置**：删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行\r\n- **空间共享**：顺序栈能够实现多栈空间共享，而顺序队列不能\r\n- **应用场景不同**\r\n\r\n### 常见栈的应用场景\r\n- 括号问题的求解\r\n- 深度优先搜索遍历等\r\n- 函数调用和递归实现\r\n- 表达式的转换和求值\r\n\r\n### 常见的队列的应用场景\r\n- 计算机系统中各种资源的管理\r\n- 消息缓冲器的管理\r\n- 广度优先搜索遍历等\r\n\r\n---\r\n\r\n## 59. 链表相关\r\n\r\n### 单双向链表的区别\r\n\r\n| 特性 | 单向链表 | 双向链表 |\r\n|------|----------|----------|\r\n| 指向 | 只有一个指向下一结点的指针 | 除了有一个指向下一结点的指针外，还有一个指向前一结点的指针 |\r\n| 功能 | 只能next | 可以return |\r\n| 遍历 | 只能单向读取 | 可以双向遍历 |\r\n\r\n### 单向链表优缺点\r\n\r\n**优点**：\r\n- 单向链表增加删除节点简单\r\n- 遍历时候不会死循环\r\n\r\n**缺点**：\r\n- 只能从头到尾遍历\r\n- 只能找到后继，无法找到前驱，也就是只能前进\r\n\r\n### 双向链表优缺点\r\n\r\n**优点**：\r\n- 可以找到前驱和后继，可进可退\r\n\r\n**缺点**：\r\n- 增加删除节点复杂，多需要分配一个指针存储空间\r\n\r\n---\r\n\r\n## 60. 链表与数组的对比\r\n\r\n| 特性 | 数组 | 链表 |\r\n|------|------|------|\r\n| 长度 | 必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况 | 动态地进行存储分配，可以适应数据动态地增减的情况 |\r\n| 插入删除 | 数组中插入、删除数据项时，需要移动其它数据项，非常繁琐 | 可以方便地插入、删除数据项 |\r\n| 访问方式 | 数组可以根据下标直接存取，时间复杂度O(1) | 链表必须根据next指针找到下一个元素 |\r\n| 使用场景 | 如果需要快速访问数据，很少或不插入和删除元素，就应该用数组 | 如果需要经常插入和删除元素就需要用链表数据结构了 |\r\n\r\n---\r\n\r\n## 61. 二叉树相关\r\n\r\n### 计算深度（高度）\r\n- 二叉树的高度是二叉树结点层次的最大值，也就是其左右子树的最大高度+1\r\n- 当树为空时，高度为0；否则为其左右子树最大高度+1\r\n\r\n### 遍历（看根节点的位置）\r\n\r\n- **前序遍历**：（根左右）先访问根节点，再访问左节点，再访问右节点\r\n- **中序遍历**：（左根右）先访问左节点，再访问根节点，再访问右节点\r\n- **后序遍历**：（左右根）先访问左节点，再访问右节点，再访问根节点\r\n\r\n---\r\n\r\n## 62. 字典相关\r\n\r\n### 介绍\r\n- Dictionary表示键和值的集合\r\n- Dictionary<object, object>是一个泛型\r\n- 他本身有集合的功能有时候可以把它看成数组\r\n- 他的结构是这样的：Dictionary<[key], [value]>\r\n- 他的特点是存入对象是需要与[key]值一一对应的存入该泛型，任何键都是唯一\r\n- 通过某一个一定的[key]去找到对应的值\r\n- 查找元素的时间复杂度为O(1)\r\n\r\n### 增删查改时间复杂度\r\n- **Dictionary字典类**：是hash表\r\n- **Add操作**：O(1)\r\n- **Containskey方法**：O(1)，原因是通过hash来查找元素而不是遍历元素\r\n- **ContainsValue方法**：O(N)，原因是内部通过遍历key来查找value，而不是通过hash来查找\r\n- **Item[Key]属性**：根据key来检索value，其时间复杂度也是O(1)\r\n- **基本都是O（1）**\r\n\r\n### 底层实现原理\r\n\r\n**Dictionary在构造的时候做了以下几件事**：\r\n1. 初始化一个桶数组 `this.buckets = new int[prime]`\r\n2. 初始化一个 `this.entries = new Entry<TKey, TValue>[prime]`\r\n\r\n**Bucket和entries的容量**：都为大于字典容量的一个最小的质数\r\n- `this.buckets` 主要用来进行Hash碰撞\r\n- `this.entries` 用来存储字典的内容，并且标识下一个元素的位置\r\n\r\n**详细过程**：\r\n\r\n1. **哈希表法**：将不定长的二进制数据集映射到一个较短的二进制数据集，一个Key通过HashFunc得到HashCode\r\n2. **Hash桶算法**：对HashCode进行分段显示，常用方法对HashCode直接取余\r\n3. **拉链法**：分段则会导致key对应的哈希桶相同，拉链法的基本思想就像对冲突的元素，建立一个单链表，头指针存储在对应哈希桶的位置。反之就是通过hash桶对应后，遍历单链表，获取value值\r\n\r\n---\r\n\r\n## 63. 哈希表与字典对比\r\n\r\n| 特性 | Dictionary | HashTable |\r\n|------|------------|-----------|\r\n| 查找不存在的键 | 如果我们试图找到一个不存在的键，它将返回/抛出异常 | 如果我们尝试查找不存在的键，则返回null |\r\n| 性能 | 它比哈希表更快，因为没有装箱和拆箱，尤其是值类型 | 它比字典慢，因为它需要装箱和拆箱 |\r\n| 线程安全 | 仅公共静态成员是线程安全的 | 哈希表中的所有成员都是线程安全的 |\r\n| 类型 | 字典是一种通用类型，意味着我们可以将其与任何数据类型一起使用 | 哈希表不是通用类型 |\r\n| 类型安全 | Dictionay是Hashtable的类型安全实现，Keys和Values是强类型的 | Hashtable是松散类型的数据结构，我们可以添加任何类型的键和值 |\r\n| 遍历顺序 | Dictionary遍历输出的顺序，就是加入的顺序 | HashTable是经过优化的，访问下标的对象先散列过，所以内部是无序散列的 |\r\n\r\n---\r\n\r\n## 64. 关于List与字典的遍历与查询效率\r\n\r\n### List的底层\r\n- 是一个泛型数组，连续且紧密的顺序存储，一般数据存储在缓存中\r\n- 而字典是离散（散列）分布，由数组和哈希表共同组成\r\n- 遍历的时候，会伴有换页的操作，且数组都存储在内存中\r\n- 而读写速度是：缓存>内存>硬盘\r\n- **因此List更适合遍历**\r\n\r\n### 字典的查询效率\r\n- 通过元素的key值进行取余操作，找的对应的哈希桶\r\n- 判定哈希桶对应的哈希表的头节点是不是该元素，若不是进行next操作，对哈希表进行遍历\r\n- 这两个过程都是常数级别的操作\r\n- **所以是O（1）**\r\n\r\n### List的查询效率\r\n- 先遍历，找到对应的值\r\n- **因此是O（n）**\r\n- **所以字典更适合查询**\r\n\r\n---\r\n\r\n## 总结\r\n\r\n这份C#面试题总结涵盖了以下核心知识点：\r\n\r\n1. **面向对象基础**：继承、封装、多态\r\n2. **类型系统**：值类型、引用类型、装箱拆箱\r\n3. **内存管理**：堆栈、GC、对象池\r\n4. **集合类型**：List、Dictionary、HashTable等\r\n5. **高级特性**：泛型、委托、事件、反射\r\n6. **数据结构**：栈、队列、链表、二叉树\r\n7. **性能优化**：GC优化、字符串处理、遍历优化\r\n\r\n这些知识点是C#开发中的核心内容，掌握这些内容对于面试和实际开发都非常重要。\r\n\r\n---\r\n\r\n**参考来源**：CSDN博客 - 呆呆敲代码的小Y\r\n\r\n"
        }
    ]
}