{
    "sourceFile": "模块架构设计/设计模式架构原理.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 9,
            "patches": [
                {
                    "date": 1767265079907,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767265085580,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,8 @@\n ---\r\n \r\n ## 🏗️ 设计模式分类\r\n \r\n-### 核心模式分类\r\n ```\r\n Pattern Library (设计模式库)\r\n ├── Creational (创建型模式) - 对象创建的艺术\r\n │   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n"
                },
                {
                    "date": 1767265095841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,4 +52,6 @@\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n     └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n ```\r\n \r\n+\r\n+\r\n"
                },
                {
                    "date": 1767265188711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,10 @@\n     ├── DependencyInjection (依赖注入模式) - 控制反转的一种实现方式，通过外部注入依赖而不是内部创建，降低耦合度 \r\n     ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n     ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n-    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n+    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典\r\n+    执行\r\n ```\r\n \r\n \r\n \r\n"
                },
                {
                    "date": 1767265478224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,10 +49,9 @@\n     ├── DependencyInjection (依赖注入模式) - 控制反转的一种实现方式，通过外部注入依赖而不是内部创建，降低耦合度 \r\n     ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n     ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n-    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典\r\n-    执行\r\n+    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n ```\r\n \r\n \r\n \r\n"
                },
                {
                    "date": 1767265521258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,6 +52,619 @@\n     ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n     └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n ```\r\n \r\n+---\r\n \r\n+## 📊 设计模式流程图\r\n \r\n+### 🏭 创建型模式 (Creational Patterns)\r\n+\r\n+#### Singleton (单例模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求 getInstance] --> B{instance 是否存在?}\r\n+    B -->|不存在| C[创建新实例]\r\n+    B -->|已存在| D[返回现有实例]\r\n+    C --> E[保存到 instance]\r\n+    E --> F[返回实例]\r\n+    D --> F\r\n+    F --> G[客户端使用实例]\r\n+    style B fill:#e1f5ff\r\n+    style C fill:#fff4e1\r\n+    style D fill:#e8f5e9\r\n+```\r\n+\r\n+#### Factory (工厂模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求创建对象] --> B[传入类型/条件]\r\n+    B --> C[Factory 接收请求]\r\n+    C --> D{判断条件}\r\n+    D -->|类型A| E[创建对象A]\r\n+    D -->|类型B| F[创建对象B]\r\n+    D -->|类型C| G[创建对象C]\r\n+    E --> H[返回对象]\r\n+    F --> H\r\n+    G --> H\r\n+    H --> I[客户端使用对象]\r\n+    style C fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### AbstractFactory (抽象工厂模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求创建产品族] --> B[选择具体工厂]\r\n+    B --> C{工厂类型}\r\n+    C -->|工厂1| D[创建产品A1]\r\n+    C -->|工厂1| E[创建产品B1]\r\n+    C -->|工厂2| F[创建产品A2]\r\n+    C -->|工厂2| G[创建产品B2]\r\n+    D --> H[确保产品兼容]\r\n+    E --> H\r\n+    F --> H\r\n+    G --> H\r\n+    H --> I[返回产品族]\r\n+    I --> J[客户端使用]\r\n+    style C fill:#e1f5ff\r\n+    style H fill:#fff4e1\r\n+```\r\n+\r\n+#### Builder (建造者模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端开始构建] --> B[创建 Builder]\r\n+    B --> C[步骤1: 构建基础部分]\r\n+    C --> D[步骤2: 构建中间部分]\r\n+    D --> E[步骤3: 构建高级部分]\r\n+    E --> F{是否完成?}\r\n+    F -->|否| G[继续构建步骤]\r\n+    G --> F\r\n+    F -->|是| H[调用 build 方法]\r\n+    H --> I[返回完整对象]\r\n+    I --> J[客户端使用]\r\n+    style F fill:#e1f5ff\r\n+    style H fill:#fff4e1\r\n+```\r\n+\r\n+#### Prototype (原型模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求对象] --> B[检查原型对象]\r\n+    B --> C{原型是否存在?}\r\n+    C -->|不存在| D[创建原型对象]\r\n+    C -->|存在| E[克隆原型对象]\r\n+    D --> E\r\n+    E --> F[返回克隆对象]\r\n+    F --> G[客户端使用]\r\n+    G --> H{需要修改?}\r\n+    H -->|是| I[修改克隆对象]\r\n+    H -->|否| J[直接使用]\r\n+    I --> J\r\n+    style C fill:#e1f5ff\r\n+    style E fill:#fff4e1\r\n+```\r\n+\r\n+### 🏗️ 结构型模式 (Structural Patterns)\r\n+\r\n+#### Adapter (适配器模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端调用] --> B[使用目标接口]\r\n+    B --> C[Adapter 接收请求]\r\n+    C --> D[转换为适配对象接口]\r\n+    D --> E[调用适配对象方法]\r\n+    E --> F[适配对象处理]\r\n+    F --> G[返回结果]\r\n+    G --> H[Adapter 转换结果]\r\n+    H --> I[返回给客户端]\r\n+    style C fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### Bridge (桥接模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端使用抽象] --> B[抽象类接收请求]\r\n+    B --> C[通过依赖注入获取实现]\r\n+    C --> D{实现类型}\r\n+    D -->|实现A| E[调用实现A的方法]\r\n+    D -->|实现B| F[调用实现B的方法]\r\n+    E --> G[产生表达结果A]\r\n+    F --> H[产生表达结果B]\r\n+    G --> I[返回给客户端]\r\n+    H --> I\r\n+    style C fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### Composite (组合模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端操作] --> B{节点类型}\r\n+    B -->|叶子节点| C[执行叶子操作]\r\n+    B -->|组合节点| D[遍历子节点]\r\n+    D --> E[递归调用子节点操作]\r\n+    E --> F{是否有子节点?}\r\n+    F -->|是| E\r\n+    F -->|否| G[完成组合操作]\r\n+    C --> H[统一返回结果]\r\n+    G --> H\r\n+    H --> I[客户端接收]\r\n+    style B fill:#e1f5ff\r\n+    style E fill:#fff4e1\r\n+```\r\n+\r\n+#### Decorator (装饰器模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求] --> B[原始对象]\r\n+    B --> C[装饰器1包装]\r\n+    C --> D[装饰器2包装]\r\n+    D --> E[装饰器N包装]\r\n+    E --> F[执行装饰链]\r\n+    F --> G[装饰器N处理]\r\n+    G --> H[装饰器2处理]\r\n+    H --> I[装饰器1处理]\r\n+    I --> J[原始对象处理]\r\n+    J --> K[返回增强结果]\r\n+    K --> L[客户端接收]\r\n+    style F fill:#e1f5ff\r\n+    style G fill:#fff4e1\r\n+```\r\n+\r\n+#### Facade (外观模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求] --> B[Facade 接收]\r\n+    B --> C[隐藏子系统复杂性]\r\n+    C --> D[调用子系统A]\r\n+    C --> E[调用子系统B]\r\n+    C --> F[调用子系统C]\r\n+    D --> G[协调子系统]\r\n+    E --> G\r\n+    F --> G\r\n+    G --> H[统一返回结果]\r\n+    H --> I[客户端接收]\r\n+    style B fill:#e1f5ff\r\n+    style G fill:#fff4e1\r\n+```\r\n+\r\n+#### Flyweight (享元模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求对象] --> B[传入对象特征]\r\n+    B --> C[FlyweightFactory 接收]\r\n+    C --> D{缓存中是否存在?}\r\n+    D -->|存在| E[返回缓存对象]\r\n+    D -->|不存在| F[创建新对象]\r\n+    F --> G[存入缓存]\r\n+    G --> H[返回对象]\r\n+    E --> I[多个客户端共享]\r\n+    H --> I\r\n+    I --> J[客户端使用]\r\n+    style C fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### Proxy (代理模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求] --> B[Proxy 接收]\r\n+    B --> C[执行前置处理]\r\n+    C --> D{是否需要代理?}\r\n+    D -->|是| E[调用真实对象]\r\n+    D -->|否| F[直接返回]\r\n+    E --> G[真实对象处理]\r\n+    G --> H[执行后置处理]\r\n+    H --> I[返回结果]\r\n+    F --> I\r\n+    I --> J[客户端接收]\r\n+    style B fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+### 🎭 行为型模式 (Behavioral Patterns)\r\n+\r\n+#### ChainOfResponsibility (责任链模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端发送请求] --> B[处理器1接收]\r\n+    B --> C{能否处理?}\r\n+    C -->|能| D[处理器1处理]\r\n+    C -->|不能| E[传递给处理器2]\r\n+    E --> F{能否处理?}\r\n+    F -->|能| G[处理器2处理]\r\n+    F -->|不能| H[传递给处理器N]\r\n+    H --> I{能否处理?}\r\n+    I -->|能| J[处理器N处理]\r\n+    I -->|不能| K[请求无法处理]\r\n+    D --> L[返回结果]\r\n+    G --> L\r\n+    J --> L\r\n+    K --> L\r\n+    style C fill:#e1f5ff\r\n+    style E fill:#fff4e1\r\n+```\r\n+\r\n+#### Command (命令模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端创建命令] --> B[封装请求为命令对象]\r\n+    B --> C[命令对象存储]\r\n+    C --> D{操作类型}\r\n+    D -->|执行| E[调用 execute]\r\n+    D -->|撤销| F[调用 undo]\r\n+    D -->|重做| G[调用 redo]\r\n+    E --> H[命令执行]\r\n+    F --> I[恢复之前状态]\r\n+    G --> J[重新执行]\r\n+    H --> K[返回结果]\r\n+    I --> K\r\n+    J --> K\r\n+    style C fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### Interpreter (解释器模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端输入表达式] --> B[解析表达式]\r\n+    B --> C[分解为简单表达式]\r\n+    C --> D[创建表达式树]\r\n+    D --> E[遍历表达式树]\r\n+    E --> F{节点类型}\r\n+    F -->|终结符| G[直接计算值]\r\n+    F -->|非终结符| H[递归计算子表达式]\r\n+    H --> I[组合子结果]\r\n+    G --> J[返回计算结果]\r\n+    I --> J\r\n+    J --> K[客户端接收]\r\n+    style D fill:#e1f5ff\r\n+    style F fill:#fff4e1\r\n+```\r\n+\r\n+#### Iterator (迭代器模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求遍历] --> B[获取迭代器]\r\n+    B --> C[调用 hasNext]\r\n+    C --> D{是否有下一个?}\r\n+    D -->|是| E[调用 next]\r\n+    D -->|否| F[遍历结束]\r\n+    E --> G[返回当前元素]\r\n+    G --> H[客户端处理元素]\r\n+    H --> C\r\n+    F --> I[客户端完成]\r\n+    style C fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### Mediator (中介者模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[对象A需要通信] --> B[发送消息给 Mediator]\r\n+    C[对象B需要通信] --> B\r\n+    D[对象C需要通信] --> B\r\n+    B --> E[Mediator 接收消息]\r\n+    E --> F[分析消息类型]\r\n+    F --> G[路由到目标对象]\r\n+    G --> H{目标对象}\r\n+    H -->|对象A| I[通知对象A]\r\n+    H -->|对象B| J[通知对象B]\r\n+    H -->|对象C| K[通知对象C]\r\n+    I --> L[对象响应]\r\n+    J --> L\r\n+    K --> L\r\n+    style B fill:#e1f5ff\r\n+    style G fill:#fff4e1\r\n+```\r\n+\r\n+#### Memento (备忘录模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[对象状态变化] --> B[创建 Memento]\r\n+    B --> C[保存当前状态]\r\n+    C --> D[存储到 Caretaker]\r\n+    D --> E{需要恢复?}\r\n+    E -->|是| F[从 Caretaker 获取 Memento]\r\n+    E -->|否| G[继续运行]\r\n+    F --> H[恢复对象状态]\r\n+    H --> I[对象回到之前状态]\r\n+    G --> J[对象继续运行]\r\n+    style D fill:#e1f5ff\r\n+    style E fill:#fff4e1\r\n+```\r\n+\r\n+#### Observer (观察者模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[Subject 状态变化] --> B[通知所有 Observer]\r\n+    B --> C[遍历观察者列表]\r\n+    C --> D[调用 Observer.update]\r\n+    D --> E[观察者1响应]\r\n+    D --> F[观察者2响应]\r\n+    D --> G[观察者N响应]\r\n+    E --> H[执行更新操作]\r\n+    F --> H\r\n+    G --> H\r\n+    H --> I[观察者完成更新]\r\n+    style B fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### State (状态模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[Context 接收请求] --> B[委托给当前 State]\r\n+    B --> C[State 处理请求]\r\n+    C --> D{需要切换状态?}\r\n+    D -->|是| E[触发状态转换]\r\n+    D -->|否| F[执行状态行为]\r\n+    E --> G[切换到新状态]\r\n+    G --> H[新状态处理]\r\n+    F --> I[返回结果]\r\n+    H --> I\r\n+    I --> J[客户端接收]\r\n+    style B fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### Strategy (策略模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求] --> B[Context 接收]\r\n+    B --> C[根据条件选择策略]\r\n+    C --> D{策略类型}\r\n+    D -->|策略A| E[使用策略A]\r\n+    D -->|策略B| F[使用策略B]\r\n+    D -->|策略C| G[使用策略C]\r\n+    E --> H[执行策略算法]\r\n+    F --> H\r\n+    G --> H\r\n+    H --> I[返回结果]\r\n+    I --> J[客户端接收]\r\n+    style C fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### TemplateMethod (模板方法模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端调用] --> B[模板方法开始]\r\n+    B --> C[步骤1: 固定流程]\r\n+    C --> D[钩子方法1]\r\n+    D --> E[步骤2: 固定流程]\r\n+    E --> F[钩子方法2]\r\n+    F --> G[步骤3: 固定流程]\r\n+    G --> H[钩子方法N]\r\n+    H --> I[完成模板流程]\r\n+    I --> J[返回结果]\r\n+    J --> K[客户端接收]\r\n+    style B fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### Visitor (访问者模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端调用 accept] --> B[元素接收 Visitor]\r\n+    B --> C[元素调用 Visitor.visit]\r\n+    C --> D{元素类型}\r\n+    D -->|类型A| E[Visitor.visitElementA]\r\n+    D -->|类型B| F[Visitor.visitElementB]\r\n+    E --> G[执行访问操作]\r\n+    F --> G\r\n+    G --> H[返回结果]\r\n+    H --> I[客户端接收]\r\n+    style B fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+### 🚀 高级模式 (Advanced Patterns)\r\n+\r\n+#### Component (组件模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[Entity 接收操作] --> B[遍历组件列表]\r\n+    B --> C{组件类型}\r\n+    C -->|组件A| D[调用组件A方法]\r\n+    C -->|组件B| E[调用组件B方法]\r\n+    C -->|组件C| F[调用组件C方法]\r\n+    D --> G[组件处理]\r\n+    E --> G\r\n+    F --> G\r\n+    G --> H[组合结果]\r\n+    H --> I[返回给 Entity]\r\n+    I --> J[客户端接收]\r\n+    style B fill:#e1f5ff\r\n+    style C fill:#fff4e1\r\n+```\r\n+\r\n+#### EventDriven (事件驱动模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[事件源触发事件] --> B[发布事件]\r\n+    B --> C[事件总线接收]\r\n+    C --> D[查找事件监听器]\r\n+    D --> E[遍历监听器列表]\r\n+    E --> F[调用监听器1]\r\n+    E --> G[调用监听器2]\r\n+    E --> H[调用监听器N]\r\n+    F --> I[执行事件处理]\r\n+    G --> I\r\n+    H --> I\r\n+    I --> J[事件处理完成]\r\n+    style C fill:#e1f5ff\r\n+    style E fill:#fff4e1\r\n+```\r\n+\r\n+#### StateMachine (状态机模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[接收事件] --> B[当前状态处理]\r\n+    B --> C{检查转换条件}\r\n+    C -->|条件满足| D[触发状态转换]\r\n+    C -->|条件不满足| E[保持当前状态]\r\n+    D --> F[执行退出动作]\r\n+    F --> G[切换到新状态]\r\n+    G --> H[执行进入动作]\r\n+    H --> I[执行状态行为]\r\n+    E --> I\r\n+    I --> J[等待下一个事件]\r\n+    style C fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### ServiceLocator (服务定位器模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求服务] --> B[ServiceLocator 接收]\r\n+    B --> C{服务是否已注册?}\r\n+    C -->|是| D[从注册表获取服务]\r\n+    C -->|否| E[注册新服务]\r\n+    E --> F[存入注册表]\r\n+    F --> D\r\n+    D --> G[返回服务实例]\r\n+    G --> H[客户端使用服务]\r\n+    style B fill:#e1f5ff\r\n+    style C fill:#fff4e1\r\n+```\r\n+\r\n+#### ObjectPool (对象池模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求对象] --> B[ObjectPool 接收]\r\n+    B --> C{池中有可用对象?}\r\n+    C -->|有| D[从池中取出对象]\r\n+    C -->|无| E[创建新对象]\r\n+    D --> F[重置对象状态]\r\n+    F --> G[返回对象给客户端]\r\n+    E --> G\r\n+    G --> H[客户端使用对象]\r\n+    H --> I[使用完毕]\r\n+    I --> J[归还对象到池]\r\n+    J --> K[对象重新可用]\r\n+    style B fill:#e1f5ff\r\n+    style C fill:#fff4e1\r\n+```\r\n+\r\n+#### DataDriven (数据驱动模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端请求操作] --> B[读取配置数据]\r\n+    B --> C[解析数据]\r\n+    C --> D[根据数据选择逻辑]\r\n+    D --> E{数据类型}\r\n+    E -->|类型A| F[执行逻辑A]\r\n+    E -->|类型B| G[执行逻辑B]\r\n+    F --> H[返回结果]\r\n+    G --> H\r\n+    H --> I[客户端接收]\r\n+    style B fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### ReactiveProgramming (响应式编程模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[数据源变化] --> B[Observable 检测变化]\r\n+    B --> C[通知所有 Observer]\r\n+    C --> D[Observer1 响应]\r\n+    C --> E[Observer2 响应]\r\n+    D --> F[自动重新计算]\r\n+    E --> F\r\n+    F --> G[更新依赖数据]\r\n+    G --> H{是否有依赖链?}\r\n+    H -->|是| I[触发下游更新]\r\n+    H -->|否| J[更新完成]\r\n+    I --> K[继续传播变化]\r\n+    K --> H\r\n+    style B fill:#e1f5ff\r\n+    style H fill:#fff4e1\r\n+```\r\n+\r\n+#### DependencyInjection (依赖注入模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[客户端需要依赖] --> B[不直接创建依赖]\r\n+    B --> C[通过构造函数/方法注入]\r\n+    C --> D[注入器提供依赖]\r\n+    D --> E{依赖类型}\r\n+    E -->|依赖A| F[注入实现A]\r\n+    E -->|依赖B| G[注入实现B]\r\n+    F --> H[客户端使用依赖]\r\n+    G --> H\r\n+    H --> I[降低耦合度]\r\n+    style C fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### DirtyFlag (脏标记模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[数据发生变化] --> B[设置脏标记]\r\n+    B --> C[客户端请求数据]\r\n+    C --> D{检查脏标记}\r\n+    D -->|标记为脏| E[重新计算数据]\r\n+    D -->|标记为干净| F[返回缓存数据]\r\n+    E --> G[清除脏标记]\r\n+    G --> H[更新缓存]\r\n+    H --> I[返回数据]\r\n+    F --> I\r\n+    I --> J[客户端接收]\r\n+    style C fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+```\r\n+\r\n+#### DoubleBuffer (双缓冲模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[开始渲染帧] --> B[使用后台缓冲区]\r\n+    B --> C[渲染到后台缓冲区]\r\n+    C --> D[渲染完成]\r\n+    D --> E[交换缓冲区]\r\n+    E --> F[前台缓冲区显示]\r\n+    F --> G[后台缓冲区清空]\r\n+    G --> H[准备下一帧]\r\n+    H --> B\r\n+    style E fill:#e1f5ff\r\n+    style B fill:#fff4e1\r\n+```\r\n+\r\n+#### DataLocality (数据局部性模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[处理数据请求] --> B[检查缓存局部性]\r\n+    B --> C{数据是否在缓存?}\r\n+    C -->|是| D[从缓存读取]\r\n+    C -->|否| E[从内存读取]\r\n+    E --> F[组织数据布局]\r\n+    F --> G[将相关数据聚集]\r\n+    G --> H[存入缓存]\r\n+    D --> I[返回数据]\r\n+    H --> I\r\n+    I --> J[提高缓存命中率]\r\n+    style B fill:#e1f5ff\r\n+    style C fill:#fff4e1\r\n+```\r\n+\r\n+#### Bytecode (字节码模式)\r\n+```mermaid\r\n+flowchart TD\r\n+    A[输入高级语言代码] --> B[编译器解析]\r\n+    B --> C[词法分析]\r\n+    C --> D[语法分析]\r\n+    D --> E[生成字节码指令]\r\n+    E --> F[虚拟机接收字节码]\r\n+    F --> G[查找 OPCODES 字典]\r\n+    G --> H[执行对应操作]\r\n+    H --> I{是否有下一条指令?}\r\n+    I -->|是| G\r\n+    I -->|否| J[返回执行结果]\r\n+    J --> K[客户端接收]\r\n+    style F fill:#e1f5ff\r\n+    style G fill:#fff4e1\r\n+```\r\n+\r\n+\r\n"
                },
                {
                    "date": 1767265606106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -430,20 +430,32 @@\n \r\n #### TemplateMethod (模板方法模式)\r\n ```mermaid\r\n flowchart TD\r\n-    A[客户端调用] --> B[模板方法开始]\r\n-    B --> C[步骤1: 固定流程]\r\n-    C --> D[钩子方法1]\r\n-    D --> E[步骤2: 固定流程]\r\n-    E --> F[钩子方法2]\r\n-    F --> G[步骤3: 固定流程]\r\n-    G --> H[钩子方法N]\r\n-    H --> I[完成模板流程]\r\n-    I --> J[返回结果]\r\n-    J --> K[客户端接收]\r\n+    A[客户端调用模板方法] --> B[模板方法: 定义算法骨架]\r\n+    B --> C[步骤1: 固定流程<br/>所有子类共享]\r\n+    C --> D{钩子方法1<br/>子类可重写}\r\n+    D -->|子类重写| E[执行子类实现]\r\n+    D -->|未重写| F[执行默认实现]\r\n+    E --> G[步骤2: 固定流程<br/>所有子类共享]\r\n+    F --> G\r\n+    G --> H{钩子方法2<br/>子类可重写}\r\n+    H -->|子类重写| I[执行子类实现]\r\n+    H -->|未重写| J[执行默认实现]\r\n+    I --> K[步骤3: 固定流程<br/>所有子类共享]\r\n+    J --> K\r\n+    K --> L[完成模板流程]\r\n+    L --> M[返回结果]\r\n+    M --> N[客户端接收]\r\n+    \r\n     style B fill:#e1f5ff\r\n+    style C fill:#c8e6c9\r\n+    style G fill:#c8e6c9\r\n+    style K fill:#c8e6c9\r\n     style D fill:#fff4e1\r\n+    style H fill:#fff4e1\r\n+    style E fill:#ffccbc\r\n+    style I fill:#ffccbc\r\n ```\r\n \r\n #### Visitor (访问者模式)\r\n ```mermaid\r\n"
                },
                {
                    "date": 1767265869060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -164,19 +164,38 @@\n \r\n #### Bridge (桥接模式)\r\n ```mermaid\r\n flowchart TD\r\n-    A[客户端使用抽象] --> B[抽象类接收请求]\r\n-    B --> C[通过依赖注入获取实现]\r\n-    C --> D{实现类型}\r\n-    D -->|实现A| E[调用实现A的方法]\r\n-    D -->|实现B| F[调用实现B的方法]\r\n-    E --> G[产生表达结果A]\r\n-    F --> H[产生表达结果B]\r\n-    G --> I[返回给客户端]\r\n-    H --> I\r\n-    style C fill:#e1f5ff\r\n-    style D fill:#fff4e1\r\n+    A[客户端请求] --> B{选择抽象方向}\r\n+    B -->|抽象1| C1[抽象1接收请求]\r\n+    B -->|抽象2| C2[抽象2接收请求]\r\n+    B -->|抽象3| C3[抽象3接收请求]\r\n+    \r\n+    C1 --> D[通过依赖注入获取实现]\r\n+    C2 --> D\r\n+    C3 --> D\r\n+    \r\n+    D --> E{选择实现方向}\r\n+    E -->|实现A| F1[抽象+实现A组合]\r\n+    E -->|实现B| F2[抽象+实现B组合]\r\n+    E -->|实现C| F3[抽象+实现C组合]\r\n+    \r\n+    F1 --> G1[产生表达结果1]\r\n+    F2 --> G2[产生表达结果2]\r\n+    F3 --> G3[产生表达结果3]\r\n+    \r\n+    G1 --> H[返回给客户端]\r\n+    G2 --> H\r\n+    G3 --> H\r\n+    \r\n+    I[抽象方向扩展<br/>通过里氏替换] -.->|独立扩展| B\r\n+    J[实现方向扩展<br/>通过里氏替换] -.->|独立扩展| E\r\n+    \r\n+    style D fill:#e1f5ff\r\n+    style E fill:#fff4e1\r\n+    style B fill:#c8e6c9\r\n+    style I fill:#ffccbc\r\n+    style J fill:#ffccbc\r\n ```\r\n \r\n #### Composite (组合模式)\r\n ```mermaid\r\n"
                },
                {
                    "date": 1767266388837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -149,18 +149,15 @@\n \r\n #### Adapter (适配器模式)\r\n ```mermaid\r\n flowchart TD\r\n-    A[客户端调用] --> B[使用目标接口]\r\n-    B --> C[Adapter 接收请求]\r\n-    C --> D[转换为适配对象接口]\r\n-    D --> E[调用适配对象方法]\r\n-    E --> F[适配对象处理]\r\n-    F --> G[返回结果]\r\n-    G --> H[Adapter 转换结果]\r\n-    H --> I[返回给客户端]\r\n+    A[客户端使用目标接口] --> B[Adapter 接收]\r\n+    B --> C[接口转换<br/>目标接口 → 适配对象接口]\r\n+    C --> D[调用适配对象]\r\n+    D --> E[返回结果给客户端]\r\n+    \r\n     style C fill:#e1f5ff\r\n-    style D fill:#fff4e1\r\n+    style B fill:#fff4e1\r\n ```\r\n \r\n #### Bridge (桥接模式)\r\n ```mermaid\r\n"
                },
                {
                    "date": 1767266451435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -213,21 +213,23 @@\n \r\n #### Decorator (装饰器模式)\r\n ```mermaid\r\n flowchart TD\r\n-    A[客户端请求] --> B[原始对象]\r\n-    B --> C[装饰器1包装]\r\n-    C --> D[装饰器2包装]\r\n-    D --> E[装饰器N包装]\r\n-    E --> F[执行装饰链]\r\n-    F --> G[装饰器N处理]\r\n-    G --> H[装饰器2处理]\r\n-    H --> I[装饰器1处理]\r\n-    I --> J[原始对象处理]\r\n-    J --> K[返回增强结果]\r\n-    K --> L[客户端接收]\r\n-    style F fill:#e1f5ff\r\n-    style G fill:#fff4e1\r\n+    A[客户端请求] --> B[读取装饰器配置数据]\r\n+    B --> C[构建装饰器执行字典]\r\n+    C --> D[遍历执行字典]\r\n+    D --> E{是否有装饰器?}\r\n+    E -->|有| F[执行当前装饰器]\r\n+    E -->|无| G[调用原始对象]\r\n+    F --> H[增强功能处理]\r\n+    H --> I[继续下一个装饰器]\r\n+    I --> D\r\n+    G --> J[返回增强结果]\r\n+    J --> K[客户端接收<br/>原对象未被修改]\r\n+    \r\n+    style C fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+    style B fill:#c8e6c9\r\n ```\r\n \r\n #### Facade (外观模式)\r\n ```mermaid\r\n"
                }
            ],
            "date": 1767265079907,
            "name": "Commit-0",
            "content": "# 🎯 Lua设计模式库 - 完整指南\r\n\r\n## 📋 概述\r\n\r\n这是一个功能完整的Lua设计模式库，涵盖了从基础到高级的各种设计模式实现。每个模式都经过精心设计，确保易用性、可扩展性和高性能。\r\n\r\n**🎯 设计理念：** 将复杂的设计模式封装成简单易用的工具，让开发者专注于业务逻辑，而不是架构细节。\r\n\r\n---\r\n\r\n## 🏗️ 设计模式分类\r\n\r\n### 核心模式分类\r\n```\r\nPattern Library (设计模式库)\r\n├── Creational (创建型模式) - 对象创建的艺术\r\n│   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域\r\n│   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)\r\n│   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容\r\n│   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护\r\n│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销，避免重复赋值\r\n├── Structural (结构型模式) - 对象组合的艺术\r\n│   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块\r\n│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果，里氏替换可以拓展抽象和实现表达方式\r\n│   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理\r\n│   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象\r\n│   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用\r\n│   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。\r\n│   └── Proxy (代理模式) - 可用钩子方法+策略模式替代，避免代理模式滥用\r\n├── Behavioral (行为型模式) - 对象交互的艺术\r\n│   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点\r\n│   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作\r\n│   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）\r\n│   ├── Iterator (迭代器模式) - 提供一种方法顺序访问聚合对象中的元素，而不暴露对象的内部表示\r\n│   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。\r\n│   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。\r\n│   ├── Observer (观察者模式) - 事件分发系统是其运用\r\n│   ├── State (状态模式) - 关注状态变化后, 但是状态机可以兼顾切换时机和状态变化后处理。\r\n│   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。\r\n│   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。\r\n│   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。\r\n└── Advanced (高级模式) - 游戏开发专用模式\r\n    ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了\r\n    ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线\r\n    ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。\r\n    ├── ServiceLocator (服务定位器模式) - 服务定位器模式是一种服务注册和获取的解决方案，通过服务定位器模式，可以实现服务的高效注册和获取，避免服务注册和获取的重复代码。\r\n    ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片 与 避免GC。\r\n    ├── DataDriven (数据驱动模式) - 通过数据驱动业务逻辑，避免硬编码。\r\n    ├── ReactiveProgramming (响应式编程模式) - 基于数据流和变化传播的编程范式，数据变化自动触发相关计算和更新\r\n    ├── DependencyInjection (依赖注入模式) - 控制反转的一种实现方式，通过外部注入依赖而不是内部创建，降低耦合度 \r\n    ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。\r\n    ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。\r\n    ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。\r\n    └── Bytecode (字节码模式) - 创建一套\"翻译字典\"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行\r\n```\r\n\r\n"
        }
    ]
}