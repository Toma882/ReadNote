{
    "sourceFile": "模块架构设计/战斗架构设计.mdc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 112,
            "patches": [
                {
                    "date": 1767016974447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767017089060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -92,8 +92,114 @@\n ```\n \n ---\n \n+## 四层循环架构设计\n+\n+### 循环层次关系\n+\n+```mermaid\n+graph TB\n+    subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n+        BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n+        BattleCheck -->|否| TurnLoop[回合循环]\n+        BattleCheck -->|是| BattleEnd[战斗结束]\n+        TurnLoop --> BattleCheck\n+    end\n+    \n+    subgraph TurnLoop[\"回合循环<br/>TurnLoop\"]\n+        TurnStart[回合开始] --> TeamLoop[阵营循环]\n+        TeamLoop --> TurnEnd[回合结束]\n+        TurnEnd --> TurnCheck{是否还有回合?}\n+        TurnCheck -->|是| TurnStart\n+        TurnCheck -->|否| TurnLoopEnd[回合循环结束]\n+    end\n+    \n+    subgraph TeamLoop[\"阵营循环<br/>TeamLoop\"]\n+        TeamStart[阵营开始] --> UnitLoop[单位循环]\n+        UnitLoop --> TeamEnd[阵营结束]\n+        TeamEnd --> TeamCheck{是否还有阵营?}\n+        TeamCheck -->|是| TeamStart\n+        TeamCheck -->|否| TeamLoopEnd[阵营循环结束]\n+    end\n+    \n+    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n+        UnitStart[单位开始] --> UnitAction[单位行动]\n+        UnitAction --> UnitEnd[单位结束]\n+        UnitEnd --> UnitCheck{是否还有单位?}\n+        UnitCheck -->|是| UnitStart\n+        UnitCheck -->|否| UnitLoopEnd[单位循环结束]\n+    end\n+    \n+    BattleLoop --> TurnLoop\n+    TurnLoop --> TeamLoop\n+    TeamLoop --> UnitLoop\n+    \n+    style BattleLoop fill:#ffebee\n+    style TurnLoop fill:#fff4e1\n+    style TeamLoop fill:#c8e6c9\n+    style UnitLoop fill:#e1f5ff\n+```\n+\n+### 循环管理器设计\n+\n+```mermaid\n+graph TB\n+    subgraph LoopManager[\"循环管理器<br/>LoopManager\"]\n+        BattleLoopManager[\"战斗循环管理器<br/>BattleLoopManager\"]\n+        TurnLoopManager[\"回合循环管理器<br/>TurnLoopManager\"]\n+        TeamLoopManager[\"阵营循环管理器<br/>TeamLoopManager\"]\n+        UnitLoopManager[\"单位循环管理器<br/>UnitLoopManager\"]\n+    end\n+    \n+    subgraph BattleContext[\"战斗上下文<br/>BattleContext\"]\n+        BattleState[\"战斗状态<br/>battleState\"]\n+        TurnState[\"回合状态<br/>turnState\"]\n+        TeamState[\"阵营状态<br/>teamState\"]\n+        UnitState[\"单位状态<br/>unitState\"]\n+    end\n+    \n+    BattleLoopManager -->|维护| BattleState\n+    TurnLoopManager -->|维护| TurnState\n+    TeamLoopManager -->|维护| TeamState\n+    UnitLoopManager -->|维护| UnitState\n+    \n+    BattleLoopManager -->|驱动| TurnLoopManager\n+    TurnLoopManager -->|驱动| TeamLoopManager\n+    TeamLoopManager -->|驱动| UnitLoopManager\n+    \n+    style LoopManager fill:#f3e5f5\n+    style BattleContext fill:#e8f5e9\n+```\n+\n+### 循环职责说明\n+\n+#### 1. 战斗循环（BattleLoop）\n+- **职责**：管理整个战斗的生命周期\n+- **状态**：BattleState（未开始/进行中/已结束）\n+- **触发**：战斗开始/结束条件检查\n+- **维护**：BattleLoopManager\n+\n+#### 2. 回合循环（TurnLoop）\n+- **职责**：管理回合的循环和切换\n+- **状态**：TurnState（回合编号/当前回合/回合数）\n+- **触发**：回合开始/结束条件检查\n+- **维护**：TurnLoopManager\n+\n+#### 3. 阵营循环（TeamLoop）\n+- **职责**：管理阵营内单位的行动顺序\n+- **状态**：TeamState（当前阵营/阵营列表/行动顺序）\n+- **触发**：阵营切换/单位行动完成\n+- **维护**：TeamLoopManager\n+\n+#### 4. 单位循环（UnitLoop）\n+- **职责**：管理单个单位的行动流程\n+- **状态**：UnitState（当前单位/行动状态/行动完成）\n+- **触发**：单位行动开始/结束\n+- **维护**：UnitLoopManager\n+\n+---\n+\n ## 分层职责说明\n \n ### 输入层（InputLayer）\n - **职责**：接收玩家输入和AI输入\n"
                },
                {
                    "date": 1767017432603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,15 +7,17 @@\n ---\n \n ## 核心设计理念\n \n-### 1. 回合驱动为核心\n+### 1. 多层循环架构为核心\n \n-**本质**：战斗系统的核心是回合流程的驱动和管理\n-- 战斗流程 = 回合循环驱动\n-- 回合管理 = 先攻计算 → 行动轮 → 回合结束\n-- 状态同步 = 回合状态在参与者间同步\n-- 流程控制 = 回合流程控制战斗节奏\n+**本质**：战斗系统的核心是四层循环的维护和管理\n+- **战斗循环**：管理整个战斗的生命周期\n+- **回合循环**：管理回合的循环和切换\n+- **阵营循环**：管理阵营内单位的行动顺序\n+- **单位循环**：管理单个单位的行动流程\n+- **循环驱动**：所有战斗逻辑都在循环框架内执行\n+- **状态维护**：每层循环维护自己的状态，驱动下层循环\n \n ### 2. 数据驱动架构\n \n **本质**：战斗特性通过配置数据实现，无需修改代码\n@@ -23,20 +25,20 @@\n - 回合流程、状态转换 → 通过配置数据调整\n - 新增战斗机制 → 扩展配置数据即可\n - 战斗平衡 → 调整配置数值即可\n \n-### 3. 分层架构 + 状态机控制\n+### 3. 分层架构（循环内的功能组织）\n \n-**本质**：分层架构实现职责分离，状态机控制实现流程管理\n-- 多层架构：输入层、决策层、执行层、表现层、管理层\n-- 状态机：战斗状态、回合状态、角色状态\n+**本质**：分层架构是循环内的功能组织方式，不是主要架构\n+- 功能组织：输入层、决策层、执行层、表现层、管理层\n+- 执行位置：所有分层功能都在单位循环内执行\n - 解耦设计：层间通过Context和CommunicationBus通信\n \n ---\n \n ## 整体架构设计\n \n-### 分层架构 + 回合驱动\n+### 多层循环架构（主要架构）\n \n ```mermaid\n graph TB\n     subgraph InputLayer[\"输入层<br/>InputLayer\"]\n"
                },
                {
                    "date": 1767017444235,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,66 +38,8 @@\n ## 整体架构设计\n \n ### 多层循环架构（主要架构）\n \n-```mermaid\n-graph TB\n-    subgraph InputLayer[\"输入层<br/>InputLayer\"]\n-        PlayerInput[\"玩家输入<br/>PlayerInput\"]\n-        AIInput[\"AI输入<br/>AIInput\"]\n-        InputValidator[\"输入验证器<br/>InputValidator\"]\n-    end\n-    \n-    subgraph DecisionLayer[\"决策层<br/>DecisionLayer\"]\n-        TurnManager[\"回合管理器<br/>TurnManager\"]\n-        ActionSelector[\"行动选择器<br/>ActionSelector\"]\n-        TargetSelector[\"目标选择器<br/>TargetSelector\"]\n-    end\n-    \n-    subgraph ExecutionLayer[\"执行层<br/>ExecutionLayer\"]\n-        ActionExecutor[\"行动执行器<br/>ActionExecutor\"]\n-        DamageCalculator[\"伤害计算器<br/>DamageCalculator\"]\n-        EffectApplier[\"效果应用器<br/>EffectApplier\"]\n-    end\n-    \n-    subgraph PresentationLayer[\"表现层<br/>PresentationLayer\"]\n-        VisualPlayer[\"视觉播放器<br/>VisualPlayer\"]\n-        AudioPlayer[\"音频播放器<br/>AudioPlayer\"]\n-        UIManager[\"UI管理器<br/>UIManager\"]\n-    end\n-    \n-    subgraph ManagementLayer[\"管理层<br/>ManagementLayer\"]\n-        BattleStateManager[\"战斗状态管理器<br/>BattleStateManager\"]\n-        ParticipantManager[\"参与者管理器<br/>ParticipantManager\"]\n-        BattleContext[\"战斗上下文<br/>BattleContext\"]\n-    end\n-    \n-    subgraph DataLayer[\"数据层<br/>DataLayer\"]\n-        BattleConfig[\"战斗配置<br/>BattleConfig\"]\n-        TurnData[\"回合数据<br/>TurnData\"]\n-        BattleData[\"战斗数据<br/>BattleData\"]\n-    end\n-    \n-    InputLayer -->|BattleContext<br/>+inputData| DecisionLayer\n-    DecisionLayer -->|BattleContext<br/>+decisionData| ExecutionLayer\n-    ExecutionLayer -->|BattleContext<br/>+executionData| PresentationLayer\n-    PresentationLayer -->|BattleContext<br/>+presentationData| ManagementLayer\n-    ManagementLayer -->|状态更新| InputLayer\n-    ManagementLayer -->|数据持久化| DataLayer\n-    DataLayer -.数据查询.-> DecisionLayer\n-    \n-    style InputLayer fill:#ffebee\n-    style DecisionLayer fill:#fff4e1\n-    style ExecutionLayer fill:#c8e6c9\n-    style PresentationLayer fill:#e1f5ff\n-    style ManagementLayer fill:#f3e5f5\n-    style DataLayer fill:#e8f5e9\n-```\n-\n----\n-\n-## 四层循环架构设计\n-\n ### 循环层次关系\n \n ```mermaid\n graph TB\n"
                },
                {
                    "date": 1767017456548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,10 +38,12 @@\n ## 整体架构设计\n \n ### 多层循环架构（主要架构）\n \n-### 循环层次关系\n+**核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n \n+#### 循环层次关系\n+\n ```mermaid\n graph TB\n     subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n         BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n"
                },
                {
                    "date": 1767017477402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,35 +144,72 @@\n - **维护**：UnitLoopManager\n \n ---\n \n-## 分层职责说明\n+### 分层架构（循环内的功能组织）\n \n-### 输入层（InputLayer）\n+**说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n+\n+#### 单位循环内的分层功能\n+\n+```mermaid\n+graph TB\n+    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n+        UnitStart[单位开始] --> InputLayer[输入层<br/>接收输入]\n+        InputLayer --> DecisionLayer[决策层<br/>选择行动/目标]\n+        DecisionLayer --> ExecutionLayer[执行层<br/>执行行动/计算伤害]\n+        ExecutionLayer --> PresentationLayer[表现层<br/>播放表现]\n+        PresentationLayer --> ManagementLayer[管理层<br/>更新状态]\n+        ManagementLayer --> UnitEnd[单位结束]\n+    end\n+    \n+    DataLayer[数据层<br/>配置数据] -.数据查询.-> DecisionLayer\n+    DataLayer -.数据查询.-> ExecutionLayer\n+    \n+    style UnitLoop fill:#e1f5ff\n+    style InputLayer fill:#ffebee\n+    style DecisionLayer fill:#fff4e1\n+    style ExecutionLayer fill:#c8e6c9\n+    style PresentationLayer fill:#e1f5ff\n+    style ManagementLayer fill:#f3e5f5\n+    style DataLayer fill:#e8f5e9\n+```\n+\n+#### 分层职责说明\n+\n+**重要**：以下所有分层功能都在**单位循环**内执行，不是独立的架构层次。\n+\n+##### 输入层（InputLayer）\n+- **执行位置**：单位循环内\n - **职责**：接收玩家输入和AI输入\n - **核心组件**：PlayerInput、AIInput、InputValidator\n - **输出**：BattleContext + inputData\n \n-### 决策层（DecisionLayer）\n-- **职责**：回合管理、行动选择、目标选择\n-- **核心组件**：TurnManager、ActionSelector、TargetSelector\n+##### 决策层（DecisionLayer）\n+- **执行位置**：单位循环内\n+- **职责**：行动选择、目标选择\n+- **核心组件**：ActionSelector、TargetSelector\n - **输出**：BattleContext + decisionData\n \n-### 执行层（ExecutionLayer）\n+##### 执行层（ExecutionLayer）\n+- **执行位置**：单位循环内\n - **职责**：行动执行、伤害计算、效果应用\n - **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n - **输出**：BattleContext + executionData\n \n-### 表现层（PresentationLayer）\n+##### 表现层（PresentationLayer）\n+- **执行位置**：单位循环内\n - **职责**：视觉表现、音频播放、UI更新\n - **核心组件**：VisualPlayer、AudioPlayer、UIManager\n - **输出**：BattleContext + presentationData\n \n-### 管理层（ManagementLayer）\n-- **职责**：战斗状态管理、参与者管理、Context管理\n-- **核心组件**：BattleStateManager、ParticipantManager、BattleContext\n-- **输出**：状态更新、数据持久化\n+##### 管理层（ManagementLayer）\n+- **执行位置**：单位循环内（状态更新）、循环间（循环管理）\n+- **职责**：战斗状态管理、参与者管理、Context管理、循环管理\n+- **核心组件**：BattleStateManager、ParticipantManager、BattleContext、LoopManager\n+- **输出**：状态更新、数据持久化、循环驱动\n \n-### 数据层（DataLayer）\n+##### 数据层（DataLayer）\n+- **执行位置**：所有循环和分层功能中\n - **职责**：战斗配置、回合数据、战斗数据\n - **核心组件**：BattleConfig、TurnData、BattleData\n - **输出**：配置数据查询\n"
                },
                {
                    "date": 1767017686371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,8 +144,113 @@\n - **维护**：UnitLoopManager\n \n ---\n \n+## 多层循环架构模式\n+\n+### 层次状态机（Hierarchical State Machine）\n+\n+**核心观点**：多层循环架构最适合使用**层次状态机（Hierarchical State Machine）**模式。\n+\n+#### 为什么是层次状态机？\n+\n+**原因**：\n+- **循环嵌套 = 状态嵌套**：每层循环都是一个状态机，可以包含子状态机\n+- **状态层次结构**：战斗状态机 → 回合状态机 → 阵营状态机 → 单位状态机\n+- **状态自动管理**：父状态机进入时自动重置子状态机，父状态机更新时自动更新子状态机\n+- **状态隔离**：每层循环的状态独立管理，互不干扰\n+\n+**适用场景**：\n+- 战斗状态机包含回合状态机（战斗进行中状态）\n+- 回合状态机包含阵营状态机（回合行动状态）\n+- 阵营状态机包含单位状态机（阵营行动状态）\n+- 单位状态机管理单位行动流程\n+\n+#### 层次状态机设计\n+\n+```mermaid\n+graph TB\n+    subgraph BattleFSM[\"战斗状态机<br/>BattleFSM<br/>HierarchicalFSM\"]\n+        BattleState1[准备中]\n+        BattleState2[进行中]\n+        BattleState3[暂停]\n+        BattleState4[结束]\n+        \n+        BattleState2 -->|包含| TurnFSM[回合状态机<br/>TurnFSM]\n+        BattleState4 -->|包含| ResultFSM[结果状态机<br/>ResultFSM]\n+    end\n+    \n+    subgraph TurnFSM[\"回合状态机<br/>TurnFSM<br/>HierarchicalFSM\"]\n+        TurnState1[回合开始]\n+        TurnState2[回合行动]\n+        TurnState3[回合结束]\n+        \n+        TurnState2 -->|包含| TeamFSM[阵营状态机<br/>TeamFSM]\n+    end\n+    \n+    subgraph TeamFSM[\"阵营状态机<br/>TeamFSM<br/>HierarchicalFSM\"]\n+        TeamState1[阵营开始]\n+        TeamState2[阵营行动]\n+        TeamState3[阵营结束]\n+        \n+        TeamState2 -->|包含| UnitFSM[单位状态机<br/>UnitFSM]\n+    end\n+    \n+    subgraph UnitFSM[\"单位状态机<br/>UnitFSM<br/>FSMBase\"]\n+        UnitState1[单位开始]\n+        UnitState2[单位行动]\n+        UnitState3[单位结束]\n+    end\n+    \n+    style BattleFSM fill:#ffebee\n+    style TurnFSM fill:#fff4e1\n+    style TeamFSM fill:#c8e6c9\n+    style UnitFSM fill:#e1f5ff\n+```\n+\n+#### 层次状态机特点\n+\n+1. **状态嵌套**：\n+   - 父状态机可以包含子状态机\n+   - 子状态机在父状态机进入时自动重置\n+   - 子状态机在父状态机更新时自动更新\n+\n+2. **状态隔离**：\n+   - 每层状态机独立管理自己的状态\n+   - 状态转换只在当前状态机内进行\n+   - 父状态机状态变化不影响子状态机状态\n+\n+3. **自动管理**：\n+   - 父状态机进入时，自动重置子状态机\n+   - 父状态机更新时，自动更新子状态机\n+   - 父状态机退出时，自动清理子状态机\n+\n+4. **循环驱动**：\n+   - 每层状态机的状态转换驱动循环推进\n+   - 状态机状态决定循环是否继续\n+   - 状态机状态决定循环行为\n+\n+#### 实现要点\n+\n+1. **层次状态机接口**：\n+   - `AddSubFSM(stateId, subFSM)`：为某个状态添加子状态机\n+   - `EnterCurrentState()`：进入当前状态时，自动重置子状态机\n+   - `UpdateCurrentState()`：更新当前状态时，自动更新子状态机\n+\n+2. **状态机层次结构**：\n+   - 战斗状态机（HierarchicalFSM）：包含回合状态机和结果状态机\n+   - 回合状态机（HierarchicalFSM）：包含阵营状态机\n+   - 阵营状态机（HierarchicalFSM）：包含单位状态机\n+   - 单位状态机（FSMBase）：最底层状态机，不包含子状态机\n+\n+3. **循环管理器 = 层次状态机**：\n+   - BattleLoopManager = 战斗状态机\n+   - TurnLoopManager = 回合状态机\n+   - TeamLoopManager = 阵营状态机\n+   - UnitLoopManager = 单位状态机\n+\n+---\n+\n ### 分层架构（循环内的功能组织）\n \n **说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n \n"
                },
                {
                    "date": 1767088777887,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -247,8 +247,74 @@\n    - TurnLoopManager = 回合状态机\n    - TeamLoopManager = 阵营状态机\n    - UnitLoopManager = 单位状态机\n \n+```mermaid\n+sequenceDiagram\n+    participant Main as 主状态机\n+    participant Round as 回合状态机\n+    participant Team as 阵营状态机\n+    participant Unit as 单位状态机\n+    \n+    Note over Main: 战斗开始\n+    Main->>Main: PREPARING → IN_PROGRESS\n+    Main->>Round: 进入IN_PROGRESS，激活回合状态机\n+    \n+    Note over Round: 第1回合开始\n+    Round->>Round: ROUND_START\n+    Round->>Round: CheckRoundActionCondition() → ROUND_ACTION\n+    Round->>Team: 进入ROUND_ACTION，激活阵营状态机\n+    \n+    Note over Team: 玩家阵营开始\n+    Team->>Team: TEAM_START\n+    Team->>Team: CheckTeamActionCondition() → TEAM_ACTION\n+    Team->>Unit: 进入TEAM_ACTION，激活单位状态机\n+    \n+    Note over Unit: 单位1行动\n+    Unit->>Unit: UNIT_START\n+    Unit->>Unit: CheckUnitActionCondition() → UNIT_ACTION\n+    Unit->>Unit: 执行行动\n+    Unit->>Unit: CheckUnitEndCondition() → UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → UNIT_START (还有单位2)\n+    \n+    Note over Unit: 单位2行动\n+    Unit->>Unit: UNIT_START\n+    Unit->>Unit: UNIT_ACTION\n+    Unit->>Unit: UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → false (没有更多单位)\n+    \n+    Note over Team: 玩家阵营结束\n+    Team->>Team: CheckTeamEndCondition() → TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → TEAM_START (还有敌人阵营)\n+    \n+    Note over Team: 敌人阵营开始\n+    Team->>Team: TEAM_START\n+    Team->>Team: TEAM_ACTION\n+    Team->>Unit: 激活单位状态机（敌人单位1）\n+    Unit->>Unit: UNIT_START → UNIT_ACTION → UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → UNIT_START (还有单位2)\n+    Unit->>Unit: UNIT_START → UNIT_ACTION → UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → false\n+    Team->>Team: TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → false (没有更多阵营)\n+    \n+    Note over Round: 第1回合结束\n+    Round->>Round: CheckRoundEndCondition() → ROUND_END\n+    Round->>Round: CheckNextRoundCondition() → ROUND_START (还有第2回合)\n+    \n+    Note over Round: 第2回合开始\n+    Round->>Round: ROUND_START → ROUND_ACTION\n+    Round->>Team: 激活阵营状态机\n+    Team->>Team: TEAM_START → TEAM_ACTION → TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → TEAM_START (循环)\n+    Team->>Team: TEAM_START → TEAM_ACTION → TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → false\n+    Round->>Round: ROUND_END\n+    Round->>Round: CheckNextRoundCondition() → false (战斗结束)\n+    \n+    Note over Main: 战斗结束\n+    Main->>Main: CheckBattleEndCondition() → ENDED\n+    Main->>Main: 激活结果状态机\n ---\n \n ### 分层架构（循环内的功能组织）\n \n"
                },
                {
                    "date": 1767088789349,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -313,8 +313,9 @@\n     \n     Note over Main: 战斗结束\n     Main->>Main: CheckBattleEndCondition() → ENDED\n     Main->>Main: 激活结果状态机\n+```\n ---\n \n ### 分层架构（循环内的功能组织）\n \n"
                },
                {
                    "date": 1767091523934,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -247,8 +247,10 @@\n    - TurnLoopManager = 回合状态机\n    - TeamLoopManager = 阵营状态机\n    - UnitLoopManager = 单位状态机\n \n+\n+### 循环机制流程图\n ```mermaid\n sequenceDiagram\n     participant Main as 主状态机\n     participant Round as 回合状态机\n"
                },
                {
                    "date": 1767091542562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -248,9 +248,9 @@\n    - TeamLoopManager = 阵营状态机\n    - UnitLoopManager = 单位状态机\n \n \n-### 循环机制流程图\n+### 循环分层状态机流程图\n ```mermaid\n sequenceDiagram\n     participant Main as 主状态机\n     participant Round as 回合状态机\n"
                },
                {
                    "date": 1767091553971,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -248,9 +248,9 @@\n    - TeamLoopManager = 阵营状态机\n    - UnitLoopManager = 单位状态机\n \n \n-### 循环分层状态机流程图\n+#### 循环分层状态机流程图\n ```mermaid\n sequenceDiagram\n     participant Main as 主状态机\n     participant Round as 回合状态机\n"
                },
                {
                    "date": 1767091586962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -241,15 +241,9 @@\n    - 回合状态机（HierarchicalFSM）：包含阵营状态机\n    - 阵营状态机（HierarchicalFSM）：包含单位状态机\n    - 单位状态机（FSMBase）：最底层状态机，不包含子状态机\n \n-3. **循环管理器 = 层次状态机**：\n-   - BattleLoopManager = 战斗状态机\n-   - TurnLoopManager = 回合状态机\n-   - TeamLoopManager = 阵营状态机\n-   - UnitLoopManager = 单位状态机\n \n-\n #### 循环分层状态机流程图\n ```mermaid\n sequenceDiagram\n     participant Main as 主状态机\n"
                },
                {
                    "date": 1767091626284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,39 +85,8 @@\n     style TeamLoop fill:#c8e6c9\n     style UnitLoop fill:#e1f5ff\n ```\n \n-### 循环管理器设计\n-\n-```mermaid\n-graph TB\n-    subgraph LoopManager[\"循环管理器<br/>LoopManager\"]\n-        BattleLoopManager[\"战斗循环管理器<br/>BattleLoopManager\"]\n-        TurnLoopManager[\"回合循环管理器<br/>TurnLoopManager\"]\n-        TeamLoopManager[\"阵营循环管理器<br/>TeamLoopManager\"]\n-        UnitLoopManager[\"单位循环管理器<br/>UnitLoopManager\"]\n-    end\n-    \n-    subgraph BattleContext[\"战斗上下文<br/>BattleContext\"]\n-        BattleState[\"战斗状态<br/>battleState\"]\n-        TurnState[\"回合状态<br/>turnState\"]\n-        TeamState[\"阵营状态<br/>teamState\"]\n-        UnitState[\"单位状态<br/>unitState\"]\n-    end\n-    \n-    BattleLoopManager -->|维护| BattleState\n-    TurnLoopManager -->|维护| TurnState\n-    TeamLoopManager -->|维护| TeamState\n-    UnitLoopManager -->|维护| UnitState\n-    \n-    BattleLoopManager -->|驱动| TurnLoopManager\n-    TurnLoopManager -->|驱动| TeamLoopManager\n-    TeamLoopManager -->|驱动| UnitLoopManager\n-    \n-    style LoopManager fill:#f3e5f5\n-    style BattleContext fill:#e8f5e9\n-```\n-\n ### 循环职责说明\n \n #### 1. 战斗循环（BattleLoop）\n - **职责**：管理整个战斗的生命周期\n"
                },
                {
                    "date": 1767091691385,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -281,72 +281,4 @@\n     Main->>Main: 激活结果状态机\n ```\n ---\n \n-### 分层架构（循环内的功能组织）\n-\n-**说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n-\n-#### 单位循环内的分层功能\n-\n-```mermaid\n-graph TB\n-    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n-        UnitStart[单位开始] --> InputLayer[输入层<br/>接收输入]\n-        InputLayer --> DecisionLayer[决策层<br/>选择行动/目标]\n-        DecisionLayer --> ExecutionLayer[执行层<br/>执行行动/计算伤害]\n-        ExecutionLayer --> PresentationLayer[表现层<br/>播放表现]\n-        PresentationLayer --> ManagementLayer[管理层<br/>更新状态]\n-        ManagementLayer --> UnitEnd[单位结束]\n-    end\n-    \n-    DataLayer[数据层<br/>配置数据] -.数据查询.-> DecisionLayer\n-    DataLayer -.数据查询.-> ExecutionLayer\n-    \n-    style UnitLoop fill:#e1f5ff\n-    style InputLayer fill:#ffebee\n-    style DecisionLayer fill:#fff4e1\n-    style ExecutionLayer fill:#c8e6c9\n-    style PresentationLayer fill:#e1f5ff\n-    style ManagementLayer fill:#f3e5f5\n-    style DataLayer fill:#e8f5e9\n-```\n-\n-#### 分层职责说明\n-\n-**重要**：以下所有分层功能都在**单位循环**内执行，不是独立的架构层次。\n-\n-##### 输入层（InputLayer）\n-- **执行位置**：单位循环内\n-- **职责**：接收玩家输入和AI输入\n-- **核心组件**：PlayerInput、AIInput、InputValidator\n-- **输出**：BattleContext + inputData\n-\n-##### 决策层（DecisionLayer）\n-- **执行位置**：单位循环内\n-- **职责**：行动选择、目标选择\n-- **核心组件**：ActionSelector、TargetSelector\n-- **输出**：BattleContext + decisionData\n-\n-##### 执行层（ExecutionLayer）\n-- **执行位置**：单位循环内\n-- **职责**：行动执行、伤害计算、效果应用\n-- **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n-- **输出**：BattleContext + executionData\n-\n-##### 表现层（PresentationLayer）\n-- **执行位置**：单位循环内\n-- **职责**：视觉表现、音频播放、UI更新\n-- **核心组件**：VisualPlayer、AudioPlayer、UIManager\n-- **输出**：BattleContext + presentationData\n-\n-##### 管理层（ManagementLayer）\n-- **执行位置**：单位循环内（状态更新）、循环间（循环管理）\n-- **职责**：战斗状态管理、参与者管理、Context管理、循环管理\n-- **核心组件**：BattleStateManager、ParticipantManager、BattleContext、LoopManager\n-- **输出**：状态更新、数据持久化、循环驱动\n-\n-##### 数据层（DataLayer）\n-- **执行位置**：所有循环和分层功能中\n-- **职责**：战斗配置、回合数据、战斗数据\n-- **核心组件**：BattleConfig、TurnData、BattleData\n-- **输出**：配置数据查询\n"
                },
                {
                    "date": 1767092932474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,50 +42,48 @@\n **核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n \n #### 循环层次关系\n \n-```mermaid\n graph TB\n-    subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n-        BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n-        BattleCheck -->|否| TurnLoop[回合循环]\n-        BattleCheck -->|是| BattleEnd[战斗结束]\n-        TurnLoop --> BattleCheck\n+    subgraph \"核心业务流程\"\n+        Start([战斗开始]) --> BattleStart[战斗循环开始]\n+        BattleStart --> RoundStart[回合循环开始]\n+        RoundStart --> TeamStart[阵营循环开始]\n+        TeamStart --> UnitStart[单位循环开始]\n+        \n+        UnitStart --> GetInput[调用 InputService]\n+        GetInput --> Execute[调用 ActionService]\n+        Execute --> UpdateData[调用 DataService]\n+        UpdateData --> PlayVisual[调用 VisualService]\n+        PlayVisual --> UnitNext{还有下一个单位?}\n+        \n+        UnitNext -->|是| UnitStart\n+        UnitNext -->|否| TeamNext{还有下一个阵营?}\n+        TeamNext -->|是| TeamStart\n+        TeamNext -->|否| RoundNext{还有下一个回合?}\n+        RoundNext -->|是| RoundStart\n+        RoundNext -->|否| BattleEnd([战斗结束])\n     end\n     \n-    subgraph TurnLoop[\"回合循环<br/>TurnLoop\"]\n-        TurnStart[回合开始] --> TeamLoop[阵营循环]\n-        TeamLoop --> TurnEnd[回合结束]\n-        TurnEnd --> TurnCheck{是否还有回合?}\n-        TurnCheck -->|是| TurnStart\n-        TurnCheck -->|否| TurnLoopEnd[回合循环结束]\n+    subgraph \"支撑服务\"\n+        InputService[InputService<br/>输入服务]\n+        ActionService[ActionService<br/>行动服务]\n+        DataService[DataService<br/>数据服务]\n+        VisualService[VisualService<br/>视觉服务]\n     end\n     \n-    subgraph TeamLoop[\"阵营循环<br/>TeamLoop\"]\n-        TeamStart[阵营开始] --> UnitLoop[单位循环]\n-        UnitLoop --> TeamEnd[阵营结束]\n-        TeamEnd --> TeamCheck{是否还有阵营?}\n-        TeamCheck -->|是| TeamStart\n-        TeamCheck -->|否| TeamLoopEnd[阵营循环结束]\n-    end\n+    GetInput -.调用.-> InputService\n+    Execute -.调用.-> ActionService\n+    UpdateData -.调用.-> DataService\n+    PlayVisual -.调用.-> VisualService\n     \n-    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n-        UnitStart[单位开始] --> UnitAction[单位行动]\n-        UnitAction --> UnitEnd[单位结束]\n-        UnitEnd --> UnitCheck{是否还有单位?}\n-        UnitCheck -->|是| UnitStart\n-        UnitCheck -->|否| UnitLoopEnd[单位循环结束]\n-    end\n-    \n-    BattleLoop --> TurnLoop\n-    TurnLoop --> TeamLoop\n-    TeamLoop --> UnitLoop\n-    \n-    style BattleLoop fill:#ffebee\n-    style TurnLoop fill:#fff4e1\n-    style TeamLoop fill:#c8e6c9\n-    style UnitLoop fill:#e1f5ff\n-```\n+    style Start fill:#90ee90\n+    style BattleEnd fill:#ffcccb\n+    style UnitStart fill:#e1f5ff\n+    style InputService fill:#fff4e1\n+    style ActionService fill:#e8f5e9\n+    style DataService fill:#ffebee\n+    style VisualService fill:#f3e5f5\n \n ### 循环职责说明\n \n #### 1. 战斗循环（BattleLoop）\n"
                },
                {
                    "date": 1767092939633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,8 +82,9 @@\n     style InputService fill:#fff4e1\n     style ActionService fill:#e8f5e9\n     style DataService fill:#ffebee\n     style VisualService fill:#f3e5f5\n+```\n \n ### 循环职责说明\n \n #### 1. 战斗循环（BattleLoop）\n"
                },
                {
                    "date": 1767092959874,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n \n **核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n \n #### 循环层次关系\n-\n+``` mermaid\n graph TB\n     subgraph \"核心业务流程\"\n         Start([战斗开始]) --> BattleStart[战斗循环开始]\n         BattleStart --> RoundStart[回合循环开始]\n"
                },
                {
                    "date": 1767092997097,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,49 +41,50 @@\n \n **核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n \n #### 循环层次关系\n-``` mermaid\n+\n+```mermaid\n graph TB\n-    subgraph \"核心业务流程\"\n-        Start([战斗开始]) --> BattleStart[战斗循环开始]\n-        BattleStart --> RoundStart[回合循环开始]\n-        RoundStart --> TeamStart[阵营循环开始]\n-        TeamStart --> UnitStart[单位循环开始]\n-        \n-        UnitStart --> GetInput[调用 InputService]\n-        GetInput --> Execute[调用 ActionService]\n-        Execute --> UpdateData[调用 DataService]\n-        UpdateData --> PlayVisual[调用 VisualService]\n-        PlayVisual --> UnitNext{还有下一个单位?}\n-        \n-        UnitNext -->|是| UnitStart\n-        UnitNext -->|否| TeamNext{还有下一个阵营?}\n-        TeamNext -->|是| TeamStart\n-        TeamNext -->|否| RoundNext{还有下一个回合?}\n-        RoundNext -->|是| RoundStart\n-        RoundNext -->|否| BattleEnd([战斗结束])\n+    subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n+        BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n+        BattleCheck -->|否| TurnLoop[回合循环]\n+        BattleCheck -->|是| BattleEnd[战斗结束]\n+        TurnLoop --> BattleCheck\n     end\n     \n-    subgraph \"支撑服务\"\n-        InputService[InputService<br/>输入服务]\n-        ActionService[ActionService<br/>行动服务]\n-        DataService[DataService<br/>数据服务]\n-        VisualService[VisualService<br/>视觉服务]\n+    subgraph TurnLoop[\"回合循环<br/>TurnLoop\"]\n+        TurnStart[回合开始] --> TeamLoop[阵营循环]\n+        TeamLoop --> TurnEnd[回合结束]\n+        TurnEnd --> TurnCheck{是否还有回合?}\n+        TurnCheck -->|是| TurnStart\n+        TurnCheck -->|否| TurnLoopEnd[回合循环结束]\n     end\n     \n-    GetInput -.调用.-> InputService\n-    Execute -.调用.-> ActionService\n-    UpdateData -.调用.-> DataService\n-    PlayVisual -.调用.-> VisualService\n+    subgraph TeamLoop[\"阵营循环<br/>TeamLoop\"]\n+        TeamStart[阵营开始] --> UnitLoop[单位循环]\n+        UnitLoop --> TeamEnd[阵营结束]\n+        TeamEnd --> TeamCheck{是否还有阵营?}\n+        TeamCheck -->|是| TeamStart\n+        TeamCheck -->|否| TeamLoopEnd[阵营循环结束]\n+    end\n     \n-    style Start fill:#90ee90\n-    style BattleEnd fill:#ffcccb\n-    style UnitStart fill:#e1f5ff\n-    style InputService fill:#fff4e1\n-    style ActionService fill:#e8f5e9\n-    style DataService fill:#ffebee\n-    style VisualService fill:#f3e5f5\n+    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n+        UnitStart[单位开始] --> UnitAction[单位行动]\n+        UnitAction --> UnitEnd[单位结束]\n+        UnitEnd --> UnitCheck{是否还有单位?}\n+        UnitCheck -->|是| UnitStart\n+        UnitCheck -->|否| UnitLoopEnd[单位循环结束]\n+    end\n+    \n+    BattleLoop --> TurnLoop\n+    TurnLoop --> TeamLoop\n+    TeamLoop --> UnitLoop\n+    \n+    style BattleLoop fill:#ffebee\n+    style TurnLoop fill:#fff4e1\n+    style TeamLoop fill:#c8e6c9\n+    style UnitLoop fill:#e1f5ff\n ```\n \n ### 循环职责说明\n \n@@ -134,46 +135,49 @@\n - 单位状态机管理单位行动流程\n \n #### 层次状态机设计\n \n-```mermaid\n+``` mermaid\n graph TB\n-    subgraph BattleFSM[\"战斗状态机<br/>BattleFSM<br/>HierarchicalFSM\"]\n-        BattleState1[准备中]\n-        BattleState2[进行中]\n-        BattleState3[暂停]\n-        BattleState4[结束]\n+    subgraph \"核心业务流程\"\n+        Start([战斗开始]) --> BattleStart[战斗循环开始]\n+        BattleStart --> RoundStart[回合循环开始]\n+        RoundStart --> TeamStart[阵营循环开始]\n+        TeamStart --> UnitStart[单位循环开始]\n         \n-        BattleState2 -->|包含| TurnFSM[回合状态机<br/>TurnFSM]\n-        BattleState4 -->|包含| ResultFSM[结果状态机<br/>ResultFSM]\n-    end\n-    \n-    subgraph TurnFSM[\"回合状态机<br/>TurnFSM<br/>HierarchicalFSM\"]\n-        TurnState1[回合开始]\n-        TurnState2[回合行动]\n-        TurnState3[回合结束]\n+        UnitStart --> GetInput[调用 InputService]\n+        GetInput --> Execute[调用 ActionService]\n+        Execute --> UpdateData[调用 DataService]\n+        UpdateData --> PlayVisual[调用 VisualService]\n+        PlayVisual --> UnitNext{还有下一个单位?}\n         \n-        TurnState2 -->|包含| TeamFSM[阵营状态机<br/>TeamFSM]\n+        UnitNext -->|是| UnitStart\n+        UnitNext -->|否| TeamNext{还有下一个阵营?}\n+        TeamNext -->|是| TeamStart\n+        TeamNext -->|否| RoundNext{还有下一个回合?}\n+        RoundNext -->|是| RoundStart\n+        RoundNext -->|否| BattleEnd([战斗结束])\n     end\n     \n-    subgraph TeamFSM[\"阵营状态机<br/>TeamFSM<br/>HierarchicalFSM\"]\n-        TeamState1[阵营开始]\n-        TeamState2[阵营行动]\n-        TeamState3[阵营结束]\n-        \n-        TeamState2 -->|包含| UnitFSM[单位状态机<br/>UnitFSM]\n+    subgraph \"支撑服务\"\n+        InputService[InputService<br/>输入服务]\n+        ActionService[ActionService<br/>行动服务]\n+        DataService[DataService<br/>数据服务]\n+        VisualService[VisualService<br/>视觉服务]\n     end\n     \n-    subgraph UnitFSM[\"单位状态机<br/>UnitFSM<br/>FSMBase\"]\n-        UnitState1[单位开始]\n-        UnitState2[单位行动]\n-        UnitState3[单位结束]\n-    end\n+    GetInput -.调用.-> InputService\n+    Execute -.调用.-> ActionService\n+    UpdateData -.调用.-> DataService\n+    PlayVisual -.调用.-> VisualService\n     \n-    style BattleFSM fill:#ffebee\n-    style TurnFSM fill:#fff4e1\n-    style TeamFSM fill:#c8e6c9\n-    style UnitFSM fill:#e1f5ff\n+    style Start fill:#90ee90\n+    style BattleEnd fill:#ffcccb\n+    style UnitStart fill:#e1f5ff\n+    style InputService fill:#fff4e1\n+    style ActionService fill:#e8f5e9\n+    style DataService fill:#ffebee\n+    style VisualService fill:#f3e5f5\n ```\n \n #### 层次状态机特点\n \n@@ -280,4 +284,72 @@\n     Main->>Main: 激活结果状态机\n ```\n ---\n \n+### 分层架构（循环内的功能组织）\n+\n+**说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n+\n+#### 单位循环内的分层功能\n+\n+```mermaid\n+graph TB\n+    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n+        UnitStart[单位开始] --> InputLayer[输入层<br/>接收输入]\n+        InputLayer --> DecisionLayer[决策层<br/>选择行动/目标]\n+        DecisionLayer --> ExecutionLayer[执行层<br/>执行行动/计算伤害]\n+        ExecutionLayer --> PresentationLayer[表现层<br/>播放表现]\n+        PresentationLayer --> ManagementLayer[管理层<br/>更新状态]\n+        ManagementLayer --> UnitEnd[单位结束]\n+    end\n+    \n+    DataLayer[数据层<br/>配置数据] -.数据查询.-> DecisionLayer\n+    DataLayer -.数据查询.-> ExecutionLayer\n+    \n+    style UnitLoop fill:#e1f5ff\n+    style InputLayer fill:#ffebee\n+    style DecisionLayer fill:#fff4e1\n+    style ExecutionLayer fill:#c8e6c9\n+    style PresentationLayer fill:#e1f5ff\n+    style ManagementLayer fill:#f3e5f5\n+    style DataLayer fill:#e8f5e9\n+```\n+\n+#### 分层职责说明\n+\n+**重要**：以下所有分层功能都在**单位循环**内执行，不是独立的架构层次。\n+\n+##### 输入层（InputLayer）\n+- **执行位置**：单位循环内\n+- **职责**：接收玩家输入和AI输入\n+- **核心组件**：PlayerInput、AIInput、InputValidator\n+- **输出**：BattleContext + inputData\n+\n+##### 决策层（DecisionLayer）\n+- **执行位置**：单位循环内\n+- **职责**：行动选择、目标选择\n+- **核心组件**：ActionSelector、TargetSelector\n+- **输出**：BattleContext + decisionData\n+\n+##### 执行层（ExecutionLayer）\n+- **执行位置**：单位循环内\n+- **职责**：行动执行、伤害计算、效果应用\n+- **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n+- **输出**：BattleContext + executionData\n+\n+##### 表现层（PresentationLayer）\n+- **执行位置**：单位循环内\n+- **职责**：视觉表现、音频播放、UI更新\n+- **核心组件**：VisualPlayer、AudioPlayer、UIManager\n+- **输出**：BattleContext + presentationData\n+\n+##### 管理层（ManagementLayer）\n+- **执行位置**：单位循环内（状态更新）、循环间（循环管理）\n+- **职责**：战斗状态管理、参与者管理、Context管理、循环管理\n+- **核心组件**：BattleStateManager、ParticipantManager、BattleContext、LoopManager\n+- **输出**：状态更新、数据持久化、循环驱动\n+\n+##### 数据层（DataLayer）\n+- **执行位置**：所有循环和分层功能中\n+- **职责**：战斗配置、回合数据、战斗数据\n+- **核心组件**：BattleConfig、TurnData、BattleData\n+- **输出**：配置数据查询\n"
                },
                {
                    "date": 1767098704512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,148 +36,302 @@\n ---\n \n ## 整体架构设计\n \n-### 多层循环架构（主要架构）\n+### Clean架构模式（主要架构）\n \n-**核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n+**核心观点**：战斗系统采用Clean架构模式，将系统组织成四个同心圆层，业务规则在中心，框架和技术在外围。\n \n-#### 循环层次关系\n+#### Clean架构层次结构\n \n ```mermaid\n graph TB\n-    subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n-        BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n-        BattleCheck -->|否| TurnLoop[回合循环]\n-        BattleCheck -->|是| BattleEnd[战斗结束]\n-        TurnLoop --> BattleCheck\n+    subgraph \"Clean架构同心圆\"\n+        direction TB\n+        Entities[实体层<br/>Entities<br/>核心业务规则<br/>最内层]\n+        UseCases[用例层<br/>Use Cases<br/>应用业务规则]\n+        InterfaceAdapters[接口适配器层<br/>Interface Adapters<br/>功能服务]\n+        Frameworks[框架层<br/>Frameworks & Drivers<br/>技术实现<br/>最外层]\n+        \n+        Frameworks --> InterfaceAdapters\n+        InterfaceAdapters --> UseCases\n+        UseCases --> Entities\n     end\n     \n-    subgraph TurnLoop[\"回合循环<br/>TurnLoop\"]\n-        TurnStart[回合开始] --> TeamLoop[阵营循环]\n-        TeamLoop --> TurnEnd[回合结束]\n-        TurnEnd --> TurnCheck{是否还有回合?}\n-        TurnCheck -->|是| TurnStart\n-        TurnCheck -->|否| TurnLoopEnd[回合循环结束]\n+    style Entities fill:#ffebee\n+    style UseCases fill:#fff4e1\n+    style InterfaceAdapters fill:#e8f5e9\n+    style Frameworks fill:#e1f5ff\n+```\n+\n+**依赖规则**：\n+- ✅ **允许**：外层依赖内层\n+- ❌ **禁止**：内层依赖外层\n+- ✅ **允许**：通过接口定义依赖\n+- ❌ **禁止**：直接依赖具体实现\n+\n+### 战斗系统在Clean架构中的映射\n+\n+```mermaid\n+graph TB\n+    subgraph \"实体层（Entities）- 核心业务规则\"\n+        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]\n+        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]\n+        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]\n+        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]\n+        SkillEntity[技能实体<br/>Skill Entity]\n+        EffectEntity[效果实体<br/>Effect Entity]\n     end\n     \n-    subgraph TeamLoop[\"阵营循环<br/>TeamLoop\"]\n-        TeamStart[阵营开始] --> UnitLoop[单位循环]\n-        UnitLoop --> TeamEnd[阵营结束]\n-        TeamEnd --> TeamCheck{是否还有阵营?}\n-        TeamCheck -->|是| TeamStart\n-        TeamCheck -->|否| TeamLoopEnd[阵营循环结束]\n+    subgraph \"用例层（Use Cases）- 应用业务规则\"\n+        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle UseCase]\n+        ExecuteRoundUC[执行回合用例<br/>ExecuteRound UseCase]\n+        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam UseCase]\n+        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n+        CalculateDamageUC[计算伤害用例<br/>CalculateDamage UseCase]\n+        ApplyEffectUC[应用效果用例<br/>ApplyEffect UseCase]\n     end\n     \n-    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n-        UnitStart[单位开始] --> UnitAction[单位行动]\n-        UnitAction --> UnitEnd[单位结束]\n-        UnitEnd --> UnitCheck{是否还有单位?}\n-        UnitCheck -->|是| UnitStart\n-        UnitCheck -->|否| UnitLoopEnd[单位循环结束]\n+    subgraph \"接口适配器层（Interface Adapters）- 功能服务\"\n+        InputAdapter[输入适配器<br/>Input Adapter<br/>输入服务]\n+        ActionAdapter[行动适配器<br/>Action Adapter<br/>执行服务]\n+        VisualAdapter[视觉适配器<br/>Visual Adapter<br/>表现服务]\n+        DataAdapter[数据适配器<br/>Data Adapter<br/>数据服务]\n+        CommunicationAdapter[通信适配器<br/>Communication Adapter<br/>通信服务]\n     end\n     \n-    BattleLoop --> TurnLoop\n-    TurnLoop --> TeamLoop\n-    TeamLoop --> UnitLoop\n+    subgraph \"框架层（Frameworks & Drivers）- 技术实现\"\n+        Unity[Unity引擎<br/>Unity Engine]\n+        Lua[Lua脚本引擎<br/>Lua Script Engine]\n+        Database[(数据库<br/>Database)]\n+        FSM[状态机框架<br/>FSM Framework]\n+        CommunicationBus[通信总线<br/>CommunicationBus]\n+        DataHandleQueue[数据队列<br/>DataHandleQueue]\n+    end\n     \n-    style BattleLoop fill:#ffebee\n-    style TurnLoop fill:#fff4e1\n-    style TeamLoop fill:#c8e6c9\n-    style UnitLoop fill:#e1f5ff\n+    ExecuteBattleUC --> BattleEntity\n+    ExecuteRoundUC --> RoundEntity\n+    ExecuteTeamUC --> TeamEntity\n+    ExecuteUnitUC --> UnitEntity\n+    CalculateDamageUC --> SkillEntity\n+    ApplyEffectUC --> EffectEntity\n+    \n+    InputAdapter --> ExecuteUnitUC\n+    ActionAdapter --> ExecuteUnitUC\n+    VisualAdapter --> ExecuteUnitUC\n+    DataAdapter --> ExecuteUnitUC\n+    CommunicationAdapter --> ExecuteUnitUC\n+    \n+    Unity --> VisualAdapter\n+    Lua --> ActionAdapter\n+    Database --> DataAdapter\n+    FSM --> ExecuteBattleUC\n+    CommunicationBus --> CommunicationAdapter\n+    DataHandleQueue --> DataAdapter\n+    \n+    style BattleEntity fill:#ffebee\n+    style ExecuteBattleUC fill:#fff4e1\n+    style InputAdapter fill:#e8f5e9\n+    style Unity fill:#e1f5ff\n ```\n \n-### 循环职责说明\n+### 各层职责说明\n \n-#### 1. 战斗循环（BattleLoop）\n-- **职责**：管理整个战斗的生命周期\n-- **状态**：BattleState（未开始/进行中/已结束）\n-- **触发**：战斗开始/结束条件检查\n-- **维护**：BattleLoopManager\n+#### 1. 实体层（Entities）- 核心业务规则\n \n-#### 2. 回合循环（TurnLoop）\n-- **职责**：管理回合的循环和切换\n-- **状态**：TurnState（回合编号/当前回合/回合数）\n-- **触发**：回合开始/结束条件检查\n-- **维护**：TurnLoopManager\n+**位置**：最内层，核心业务规则\n \n-#### 3. 阵营循环（TeamLoop）\n-- **职责**：管理阵营内单位的行动顺序\n-- **状态**：TeamState（当前阵营/阵营列表/行动顺序）\n-- **触发**：阵营切换/单位行动完成\n-- **维护**：TeamLoopManager\n+**职责**：\n+- 定义战斗核心实体（战斗、回合、阵营、单位）\n+- 包含企业级业务规则\n+- 定义四层循环的实体模型\n+- 不依赖任何外部框架\n \n-#### 4. 单位循环（UnitLoop）\n-- **职责**：管理单个单位的行动流程\n-- **状态**：UnitState（当前单位/行动状态/行动完成）\n-- **触发**：单位行动开始/结束\n-- **维护**：UnitLoopManager\n+**核心实体**：\n+- **战斗实体（Battle Entity）**：管理整个战斗的生命周期，包含战斗循环\n+- **回合实体（Round Entity）**：管理回合的循环和切换，包含回合循环\n+- **阵营实体（Team Entity）**：管理阵营内单位的行动顺序，包含阵营循环\n+- **单位实体（Unit Entity）**：管理单个单位的行动流程，包含单位循环\n+- **技能实体（Skill Entity）**：定义技能规则和效果\n+- **效果实体（Effect Entity）**：定义效果规则和应用逻辑\n \n+**特点**：\n+- 最稳定的一层\n+- 变化频率最低\n+- 包含核心业务概念\n+- 纯业务逻辑，无技术细节\n+\n+#### 2. 用例层（Use Cases）- 应用业务规则\n+\n+**位置**：第二层，应用业务规则\n+\n+**职责**：\n+- 实现具体的战斗用例\n+- 协调实体完成业务目标\n+- 定义应用输入输出接口\n+- 包含应用特定的业务逻辑\n+\n+**核心用例**：\n+- **执行战斗用例（ExecuteBattle）**：协调战斗实体执行战斗流程\n+- **执行回合用例（ExecuteRound）**：协调回合实体执行回合流程\n+- **执行阵营用例（ExecuteTeam）**：协调阵营实体执行阵营流程\n+- **执行单位用例（ExecuteUnit）**：协调单位实体执行单位行动\n+- **计算伤害用例（CalculateDamage）**：计算技能伤害\n+- **应用效果用例（ApplyEffect）**：应用技能效果\n+\n+**特点**：\n+- 依赖实体层\n+- 不依赖框架和UI\n+- 包含应用特定的业务逻辑\n+- 可以独立测试\n+\n+#### 3. 接口适配器层（Interface Adapters）- 功能服务\n+\n+**位置**：第三层，转换层\n+\n+**职责**：\n+- 转换数据格式\n+- 适配外部接口\n+- 实现接口定义\n+- 连接用例和框架\n+\n+**核心适配器**：\n+- **输入适配器（Input Adapter）**：处理玩家输入和AI输入，转换为用例输入\n+- **行动适配器（Action Adapter）**：执行行动逻辑，调用用例\n+- **视觉适配器（Visual Adapter）**：处理视觉表现，调用用例输出\n+- **数据适配器（Data Adapter）**：处理数据访问，调用用例\n+- **通信适配器（Communication Adapter）**：处理系统间通信，调用用例\n+\n+**特点**：\n+- 依赖用例层\n+- 实现框架层定义的接口\n+- 转换数据格式\n+- 适配外部服务\n+\n+#### 4. 框架层（Frameworks & Drivers）- 技术实现\n+\n+**位置**：最外层，技术实现\n+\n+**职责**：\n+- 实现具体的技术细节\n+- 提供框架和工具\n+- 处理外部系统交互\n+- 实现接口适配器定义的接口\n+\n+**核心框架**：\n+- **Unity引擎**：游戏引擎，提供渲染、物理等功能\n+- **Lua脚本引擎**：脚本语言，实现业务逻辑\n+- **数据库**：数据持久化\n+- **状态机框架（FSM）**：状态管理\n+- **通信总线（CommunicationBus）**：系统间通信\n+- **数据队列（DataHandleQueue）**：数据处理\n+\n+**特点**：\n+- 最外层，技术实现\n+- 可以被替换\n+- 不影响业务逻辑\n+- 提供基础设施\n+\n ---\n \n-## 多层循环架构模式\n+## 实体层详细设计（Entities Layer）\n \n-### 层次状态机（Hierarchical State Machine）\n+### 四层循环实体模型\n \n-**核心观点**：多层循环架构最适合使用**层次状态机（Hierarchical State Machine）**模式。\n+**核心观点**：战斗系统的核心是四层循环的维护和管理，这些循环在实体层中定义。\n \n-#### 为什么是层次状态机？\n+#### 循环层次关系\n \n-**原因**：\n-- **循环嵌套 = 状态嵌套**：每层循环都是一个状态机，可以包含子状态机\n-- **状态层次结构**：战斗状态机 → 回合状态机 → 阵营状态机 → 单位状态机\n-- **状态自动管理**：父状态机进入时自动重置子状态机，父状态机更新时自动更新子状态机\n-- **状态隔离**：每层循环的状态独立管理，互不干扰\n+```mermaid\n+graph TB\n+    subgraph \"实体层 - 四层循环模型\"\n+        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]\n+        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]\n+        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]\n+        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]\n+        \n+        BattleEntity --> RoundEntity\n+        RoundEntity --> TeamEntity\n+        TeamEntity --> UnitEntity\n+    end\n+    \n+    subgraph \"循环状态\"\n+        BattleState[战斗状态<br/>PREPARING/IN_PROGRESS/ENDED]\n+        RoundState[回合状态<br/>ROUND_START/ACTION/END]\n+        TeamState[阵营状态<br/>TEAM_START/ACTION/END]\n+        UnitState[单位状态<br/>UNIT_START/ACTION/END]\n+    end\n+    \n+    BattleEntity --> BattleState\n+    RoundEntity --> RoundState\n+    TeamEntity --> TeamState\n+    UnitEntity --> UnitState\n+    \n+    style BattleEntity fill:#ffebee\n+    style RoundEntity fill:#fff4e1\n+    style TeamEntity fill:#c8e6c9\n+    style UnitEntity fill:#e1f5ff\n+```\n \n-**适用场景**：\n-- 战斗状态机包含回合状态机（战斗进行中状态）\n-- 回合状态机包含阵营状态机（回合行动状态）\n-- 阵营状态机包含单位状态机（阵营行动状态）\n-- 单位状态机管理单位行动流程\n+#### 实体职责说明\n \n+##### 1. 战斗实体（Battle Entity）\n+- **职责**：管理整个战斗的生命周期\n+- **状态**：BattleState（PREPARING/IN_PROGRESS/PAUSED/ENDED）\n+- **循环**：战斗循环（BattleLoop）\n+- **业务规则**：战斗开始/结束条件、胜负判定\n+\n+##### 2. 回合实体（Round Entity）\n+- **职责**：管理回合的循环和切换\n+- **状态**：RoundState（ROUND_START/ROUND_ACTION/ROUND_END）\n+- **循环**：回合循环（RoundLoop）\n+- **业务规则**：回合开始/结束条件、回合数限制\n+\n+##### 3. 阵营实体（Team Entity）\n+- **职责**：管理阵营内单位的行动顺序\n+- **状态**：TeamState（TEAM_START/TEAM_ACTION/TEAM_END）\n+- **循环**：阵营循环（TeamLoop）\n+- **业务规则**：阵营切换规则、行动顺序规则\n+\n+##### 4. 单位实体（Unit Entity）\n+- **职责**：管理单个单位的行动流程\n+- **状态**：UnitState（UNIT_START/UNIT_ACTION/UNIT_END）\n+- **循环**：单位循环（UnitLoop）\n+- **业务规则**：单位行动规则、行动完成条件\n+\n+### 层次状态机实现（框架层）\n+\n+**说明**：层次状态机是框架层的实现，用于管理实体层的状态转换。\n+\n #### 层次状态机设计\n \n-``` mermaid\n+```mermaid\n graph TB\n-    subgraph \"核心业务流程\"\n-        Start([战斗开始]) --> BattleStart[战斗循环开始]\n-        BattleStart --> RoundStart[回合循环开始]\n-        RoundStart --> TeamStart[阵营循环开始]\n-        TeamStart --> UnitStart[单位循环开始]\n+    subgraph \"框架层 - 层次状态机\"\n+        BattleFSM[战斗状态机<br/>BattleFSM<br/>HierarchicalFSM]\n+        RoundFSM[回合状态机<br/>RoundFSM<br/>HierarchicalFSM]\n+        TeamFSM[阵营状态机<br/>TeamFSM<br/>HierarchicalFSM]\n+        UnitFSM[单位状态机<br/>UnitFSM<br/>FSMBase]\n         \n-        UnitStart --> GetInput[调用 InputService]\n-        GetInput --> Execute[调用 ActionService]\n-        Execute --> UpdateData[调用 DataService]\n-        UpdateData --> PlayVisual[调用 VisualService]\n-        PlayVisual --> UnitNext{还有下一个单位?}\n-        \n-        UnitNext -->|是| UnitStart\n-        UnitNext -->|否| TeamNext{还有下一个阵营?}\n-        TeamNext -->|是| TeamStart\n-        TeamNext -->|否| RoundNext{还有下一个回合?}\n-        RoundNext -->|是| RoundStart\n-        RoundNext -->|否| BattleEnd([战斗结束])\n+        BattleFSM -->|包含| RoundFSM\n+        RoundFSM -->|包含| TeamFSM\n+        TeamFSM -->|包含| UnitFSM\n     end\n     \n-    subgraph \"支撑服务\"\n-        InputService[InputService<br/>输入服务]\n-        ActionService[ActionService<br/>行动服务]\n-        DataService[DataService<br/>数据服务]\n-        VisualService[VisualService<br/>视觉服务]\n+    subgraph \"实体层 - 业务实体\"\n+        BattleEntity[战斗实体<br/>Battle Entity]\n+        RoundEntity[回合实体<br/>Round Entity]\n+        TeamEntity[阵营实体<br/>Team Entity]\n+        UnitEntity[单位实体<br/>Unit Entity]\n     end\n     \n-    GetInput -.调用.-> InputService\n-    Execute -.调用.-> ActionService\n-    UpdateData -.调用.-> DataService\n-    PlayVisual -.调用.-> VisualService\n+    BattleFSM -.管理.-> BattleEntity\n+    RoundFSM -.管理.-> RoundEntity\n+    TeamFSM -.管理.-> TeamEntity\n+    UnitFSM -.管理.-> UnitEntity\n     \n-    style Start fill:#90ee90\n-    style BattleEnd fill:#ffcccb\n-    style UnitStart fill:#e1f5ff\n-    style InputService fill:#fff4e1\n-    style ActionService fill:#e8f5e9\n-    style DataService fill:#ffebee\n-    style VisualService fill:#f3e5f5\n+    style BattleFSM fill:#e1f5ff\n+    style BattleEntity fill:#ffebee\n ```\n \n #### 层次状态机特点\n \n@@ -200,22 +354,8 @@\n    - 每层状态机的状态转换驱动循环推进\n    - 状态机状态决定循环是否继续\n    - 状态机状态决定循环行为\n \n-#### 实现要点\n-\n-1. **层次状态机接口**：\n-   - `AddSubFSM(stateId, subFSM)`：为某个状态添加子状态机\n-   - `EnterCurrentState()`：进入当前状态时，自动重置子状态机\n-   - `UpdateCurrentState()`：更新当前状态时，自动更新子状态机\n-\n-2. **状态机层次结构**：\n-   - 战斗状态机（HierarchicalFSM）：包含回合状态机和结果状态机\n-   - 回合状态机（HierarchicalFSM）：包含阵营状态机\n-   - 阵营状态机（HierarchicalFSM）：包含单位状态机\n-   - 单位状态机（FSMBase）：最底层状态机，不包含子状态机\n-\n-\n #### 循环分层状态机流程图\n ```mermaid\n sequenceDiagram\n     participant Main as 主状态机\n@@ -284,72 +424,317 @@\n     Main->>Main: 激活结果状态机\n ```\n ---\n \n-### 分层架构（循环内的功能组织）\n+## 用例层详细设计（Use Cases Layer）\n \n-**说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n+### 核心用例\n \n-#### 单位循环内的分层功能\n+**说明**：用例层实现具体的战斗用例，协调实体完成业务目标。\n \n+#### 用例层次结构\n+\n ```mermaid\n graph TB\n-    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n-        UnitStart[单位开始] --> InputLayer[输入层<br/>接收输入]\n-        InputLayer --> DecisionLayer[决策层<br/>选择行动/目标]\n-        DecisionLayer --> ExecutionLayer[执行层<br/>执行行动/计算伤害]\n-        ExecutionLayer --> PresentationLayer[表现层<br/>播放表现]\n-        PresentationLayer --> ManagementLayer[管理层<br/>更新状态]\n-        ManagementLayer --> UnitEnd[单位结束]\n+    subgraph \"用例层 - 战斗用例\"\n+        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle UseCase]\n+        ExecuteRoundUC[执行回合用例<br/>ExecuteRound UseCase]\n+        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam UseCase]\n+        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n+        CalculateDamageUC[计算伤害用例<br/>CalculateDamage UseCase]\n+        ApplyEffectUC[应用效果用例<br/>ApplyEffect UseCase]\n     end\n     \n-    DataLayer[数据层<br/>配置数据] -.数据查询.-> DecisionLayer\n-    DataLayer -.数据查询.-> ExecutionLayer\n+    subgraph \"实体层 - 业务实体\"\n+        BattleEntity[战斗实体]\n+        RoundEntity[回合实体]\n+        TeamEntity[阵营实体]\n+        UnitEntity[单位实体]\n+        SkillEntity[技能实体]\n+        EffectEntity[效果实体]\n+    end\n     \n-    style UnitLoop fill:#e1f5ff\n-    style InputLayer fill:#ffebee\n-    style DecisionLayer fill:#fff4e1\n-    style ExecutionLayer fill:#c8e6c9\n-    style PresentationLayer fill:#e1f5ff\n-    style ManagementLayer fill:#f3e5f5\n-    style DataLayer fill:#e8f5e9\n+    ExecuteBattleUC --> BattleEntity\n+    ExecuteRoundUC --> RoundEntity\n+    ExecuteTeamUC --> TeamEntity\n+    ExecuteUnitUC --> UnitEntity\n+    CalculateDamageUC --> SkillEntity\n+    ApplyEffectUC --> EffectEntity\n+    \n+    style ExecuteBattleUC fill:#fff4e1\n+    style BattleEntity fill:#ffebee\n ```\n \n-#### 分层职责说明\n+#### 用例职责说明\n \n-**重要**：以下所有分层功能都在**单位循环**内执行，不是独立的架构层次。\n+##### 1. 执行战斗用例（ExecuteBattle UseCase）\n+- **职责**：协调战斗实体执行战斗流程\n+- **输入**：战斗配置、参与者列表\n+- **输出**：战斗结果\n+- **协调实体**：战斗实体、回合实体\n \n-##### 输入层（InputLayer）\n-- **执行位置**：单位循环内\n-- **职责**：接收玩家输入和AI输入\n-- **核心组件**：PlayerInput、AIInput、InputValidator\n-- **输出**：BattleContext + inputData\n+##### 2. 执行回合用例（ExecuteRound UseCase）\n+- **职责**：协调回合实体执行回合流程\n+- **输入**：回合编号、回合配置\n+- **输出**：回合结果\n+- **协调实体**：回合实体、阵营实体\n \n-##### 决策层（DecisionLayer）\n-- **执行位置**：单位循环内\n-- **职责**：行动选择、目标选择\n-- **核心组件**：ActionSelector、TargetSelector\n-- **输出**：BattleContext + decisionData\n+##### 3. 执行阵营用例（ExecuteTeam UseCase）\n+- **职责**：协调阵营实体执行阵营流程\n+- **输入**：阵营信息、单位列表\n+- **输出**：阵营行动结果\n+- **协调实体**：阵营实体、单位实体\n \n-##### 执行层（ExecutionLayer）\n-- **执行位置**：单位循环内\n-- **职责**：行动执行、伤害计算、效果应用\n-- **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n-- **输出**：BattleContext + executionData\n+##### 4. 执行单位用例（ExecuteUnit UseCase）\n+- **职责**：协调单位实体执行单位行动\n+- **输入**：单位信息、行动指令\n+- **输出**：行动结果\n+- **协调实体**：单位实体、技能实体\n \n-##### 表现层（PresentationLayer）\n-- **执行位置**：单位循环内\n-- **职责**：视觉表现、音频播放、UI更新\n-- **核心组件**：VisualPlayer、AudioPlayer、UIManager\n-- **输出**：BattleContext + presentationData\n+##### 5. 计算伤害用例（CalculateDamage UseCase）\n+- **职责**：计算技能伤害\n+- **输入**：技能信息、攻击者、目标\n+- **输出**：伤害数值\n+- **协调实体**：技能实体、单位实体\n \n-##### 管理层（ManagementLayer）\n-- **执行位置**：单位循环内（状态更新）、循环间（循环管理）\n-- **职责**：战斗状态管理、参与者管理、Context管理、循环管理\n-- **核心组件**：BattleStateManager、ParticipantManager、BattleContext、LoopManager\n-- **输出**：状态更新、数据持久化、循环驱动\n+##### 6. 应用效果用例（ApplyEffect UseCase）\n+- **职责**：应用技能效果\n+- **输入**：效果信息、目标\n+- **输出**：效果应用结果\n+- **协调实体**：效果实体、单位实体\n \n-##### 数据层（DataLayer）\n-- **执行位置**：所有循环和分层功能中\n-- **职责**：战斗配置、回合数据、战斗数据\n-- **核心组件**：BattleConfig、TurnData、BattleData\n-- **输出**：配置数据查询\n+## 接口适配器层详细设计（Interface Adapters Layer）\n+\n+### 功能适配器\n+\n+**说明**：接口适配器层将用例层的输出转换为框架层可以使用的格式，同时将框架层的输入转换为用例层可以使用的格式。\n+\n+#### 适配器层次结构\n+\n+```mermaid\n+graph TB\n+    subgraph \"接口适配器层 - 功能适配器\"\n+        InputAdapter[输入适配器<br/>Input Adapter]\n+        ActionAdapter[行动适配器<br/>Action Adapter]\n+        VisualAdapter[视觉适配器<br/>Visual Adapter]\n+        DataAdapter[数据适配器<br/>Data Adapter]\n+        CommunicationAdapter[通信适配器<br/>Communication Adapter]\n+    end\n+    \n+    subgraph \"用例层 - 用例\"\n+        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n+    end\n+    \n+    subgraph \"框架层 - 框架\"\n+        Unity[Unity引擎]\n+        Lua[Lua脚本]\n+        Database[(数据库)]\n+        CommunicationBus[通信总线]\n+    end\n+    \n+    InputAdapter --> ExecuteUnitUC\n+    ActionAdapter --> ExecuteUnitUC\n+    VisualAdapter --> ExecuteUnitUC\n+    DataAdapter --> ExecuteUnitUC\n+    CommunicationAdapter --> ExecuteUnitUC\n+    \n+    Unity --> VisualAdapter\n+    Lua --> ActionAdapter\n+    Database --> DataAdapter\n+    CommunicationBus --> CommunicationAdapter\n+    \n+    style InputAdapter fill:#e8f5e9\n+    style ExecuteUnitUC fill:#fff4e1\n+    style Unity fill:#e1f5ff\n+```\n+\n+#### 适配器职责说明\n+\n+##### 1. 输入适配器（Input Adapter）\n+- **职责**：处理玩家输入和AI输入，转换为用例输入\n+- **功能**：\n+  - 接收玩家输入（UI交互、键盘鼠标）\n+  - 接收AI输入（AI决策结果）\n+  - 验证输入有效性\n+  - 转换为用例输入格式（BattleContext）\n+- **框架依赖**：Unity Input Manager、AI系统\n+\n+##### 2. 行动适配器（Action Adapter）\n+- **职责**：执行行动逻辑，调用用例\n+- **功能**：\n+  - 验证行动合法性\n+  - 执行行动逻辑\n+  - 调用执行单位用例\n+  - 处理行动结果\n+- **框架依赖**：Lua脚本引擎、技能系统\n+\n+##### 3. 视觉适配器（Visual Adapter）\n+- **职责**：处理视觉表现，调用用例输出\n+- **功能**：\n+  - 播放战斗动画\n+  - 播放特效\n+  - 更新UI显示\n+  - 处理相机控制\n+- **框架依赖**：Unity引擎、Visual系统\n+\n+##### 4. 数据适配器（Data Adapter）\n+- **职责**：处理数据访问，调用用例\n+- **功能**：\n+  - 读取战斗配置\n+  - 保存战斗数据\n+  - 查询单位数据\n+  - 更新战斗状态\n+- **框架依赖**：数据库、DataHandleQueue\n+\n+##### 5. 通信适配器（Communication Adapter）\n+- **职责**：处理系统间通信，调用用例\n+- **功能**：\n+  - 发布战斗事件\n+  - 订阅系统消息\n+  - 处理跨系统通信\n+  - 管理通信上下文\n+- **框架依赖**：CommunicationBus\n+\n+### 单位循环内的功能流程\n+\n+**说明**：单位循环内的功能流程通过接口适配器层实现。\n+\n+```mermaid\n+graph TB\n+    subgraph \"单位循环 - 用例层\"\n+        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n+    end\n+    \n+    subgraph \"接口适配器层 - 功能流程\"\n+        InputAdapter[输入适配器<br/>接收输入]\n+        ActionAdapter[行动适配器<br/>执行行动]\n+        VisualAdapter[视觉适配器<br/>播放表现]\n+        DataAdapter[数据适配器<br/>更新数据]\n+    end\n+    \n+    subgraph \"框架层 - 技术实现\"\n+        Unity[Unity引擎]\n+        Lua[Lua脚本]\n+        Database[(数据库)]\n+    end\n+    \n+    InputAdapter --> ExecuteUnitUC\n+    ExecuteUnitUC --> ActionAdapter\n+    ActionAdapter --> VisualAdapter\n+    VisualAdapter --> DataAdapter\n+    \n+    Unity --> VisualAdapter\n+    Lua --> ActionAdapter\n+    Database --> DataAdapter\n+    \n+    style ExecuteUnitUC fill:#fff4e1\n+    style InputAdapter fill:#e8f5e9\n+    style Unity fill:#e1f5ff\n+```\n+\n+## 框架层详细设计（Frameworks & Drivers Layer）\n+\n+### 技术框架\n+\n+**说明**：框架层提供具体的技术实现，可以被替换而不影响业务逻辑。\n+\n+#### 框架层次结构\n+\n+```mermaid\n+graph TB\n+    subgraph \"框架层 - 技术框架\"\n+        Unity[Unity引擎<br/>Unity Engine<br/>渲染、物理、动画]\n+        Lua[Lua脚本引擎<br/>Lua Script Engine<br/>业务逻辑]\n+        Database[(数据库<br/>Database<br/>数据持久化)]\n+        FSM[状态机框架<br/>FSM Framework<br/>状态管理]\n+        CommunicationBus[通信总线<br/>CommunicationBus<br/>系统通信]\n+        DataHandleQueue[数据队列<br/>DataHandleQueue<br/>数据处理]\n+        Formula[公式引擎<br/>Formula Parser<br/>公式计算]\n+        Pool[对象池<br/>Object Pool<br/>对象管理]\n+    end\n+    \n+    subgraph \"接口适配器层 - 适配器\"\n+        VisualAdapter[视觉适配器]\n+        ActionAdapter[行动适配器]\n+        DataAdapter[数据适配器]\n+        CommunicationAdapter[通信适配器]\n+    end\n+    \n+    Unity --> VisualAdapter\n+    Lua --> ActionAdapter\n+    Database --> DataAdapter\n+    FSM --> VisualAdapter\n+    CommunicationBus --> CommunicationAdapter\n+    DataHandleQueue --> DataAdapter\n+    Formula --> ActionAdapter\n+    Pool --> VisualAdapter\n+    \n+    style Unity fill:#e1f5ff\n+    style VisualAdapter fill:#e8f5e9\n+```\n+\n+#### 框架职责说明\n+\n+##### 1. Unity引擎（Unity Engine）\n+- **职责**：提供游戏引擎功能\n+- **功能**：\n+  - 渲染系统（3D渲染、UI渲染）\n+  - 物理系统（碰撞检测、物理模拟）\n+  - 动画系统（动画播放、动画控制）\n+  - 音频系统（音效播放、背景音乐）\n+  - 资源管理（资源加载、资源释放）\n+\n+##### 2. Lua脚本引擎（Lua Script Engine）\n+- **职责**：执行业务逻辑脚本\n+- **功能**：\n+  - 脚本解析和执行\n+  - 业务逻辑实现\n+  - 配置数据读取\n+  - 热更新支持\n+\n+##### 3. 数据库（Database）\n+- **职责**：数据持久化\n+- **功能**：\n+  - 战斗配置存储\n+  - 战斗数据保存\n+  - 单位数据查询\n+  - 历史记录存储\n+\n+##### 4. 状态机框架（FSM Framework）\n+- **职责**：状态管理\n+- **功能**：\n+  - 层次状态机（HierarchicalFSM）\n+  - 基础状态机（FSMBase）\n+  - 状态转换管理\n+  - 状态生命周期管理\n+\n+##### 5. 通信总线（CommunicationBus）\n+- **职责**：系统间通信\n+- **功能**：\n+  - 事件发布订阅（Event Channel）\n+  - 消息传递（Message Channel）\n+  - 数据推送（Push Channel）\n+  - 数据查询（Query Channel）\n+\n+##### 6. 数据队列（DataHandleQueue）\n+- **职责**：数据处理\n+- **功能**：\n+  - 数据推送和处理\n+- **数据查询**（Query Delegate）\n+- **批量处理**\n+- **数据同步**\n+\n+##### 7. 公式引擎（Formula Parser）\n+- **职责**：公式计算\n+- **功能**：\n+  - 三级公式解析\n+  - 公式计算\n+  - 公式缓存\n+  - 公式验证\n+\n+##### 8. 对象池（Object Pool）\n+- **职责**：对象管理\n+- **功能**：\n+  - 对象复用\n+  - 对象预加载\n+  - 对象生命周期管理\n+  - 性能优化\n"
                },
                {
                    "date": 1767098808950,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -737,4 +737,258 @@\n   - 对象复用\n   - 对象预加载\n   - 对象生命周期管理\n   - 性能优化\n+\n+---\n+\n+## 数据驱动架构在Clean架构中的位置\n+\n+### 数据驱动架构的层次分布\n+\n+**说明**：数据驱动架构贯穿Clean架构的所有层次，但主要作用在不同层次。\n+\n+```mermaid\n+graph TB\n+    subgraph \"Clean架构 + 数据驱动\"\n+        subgraph \"实体层\"\n+            Entity[实体<br/>业务规则<br/>配置数据定义规则]\n+        end\n+        \n+        subgraph \"用例层\"\n+            UseCase[用例<br/>应用逻辑<br/>配置数据驱动流程]\n+        end\n+        \n+        subgraph \"接口适配器层\"\n+            Adapter[适配器<br/>数据转换<br/>配置数据映射]\n+        end\n+        \n+        subgraph \"框架层\"\n+            Config[配置数据<br/>Excel/JSON/Lua<br/>数据驱动源]\n+        end\n+        \n+        Config -.驱动.-> Adapter\n+        Adapter -.使用.-> UseCase\n+        UseCase -.应用.-> Entity\n+        Config -.定义.-> Entity\n+    end\n+    \n+    style Entity fill:#ffebee\n+    style UseCase fill:#fff4e1\n+    style Adapter fill:#e8f5e9\n+    style Config fill:#e1f5ff\n+```\n+\n+### 数据驱动的实现方式\n+\n+#### 1. 配置数据存储（框架层）\n+- **位置**：框架层\n+- **形式**：Excel配置表、JSON配置文件、Lua配置脚本\n+- **内容**：战斗规则、伤害计算、效果应用、回合流程、状态转换\n+\n+#### 2. 配置数据读取（接口适配器层）\n+- **位置**：接口适配器层（数据适配器）\n+- **功能**：读取配置数据，转换为用例可用的格式\n+- **组件**：DataAdapter、ConfigLoader\n+\n+#### 3. 配置数据应用（用例层）\n+- **位置**：用例层\n+- **功能**：使用配置数据驱动业务逻辑\n+- **示例**：根据配置数据执行战斗流程、计算伤害、应用效果\n+\n+#### 4. 配置数据定义规则（实体层）\n+- **位置**：实体层\n+- **功能**：配置数据定义的业务规则\n+- **示例**：战斗规则、回合规则、单位规则\n+\n+---\n+\n+## Clean架构与核心设计理念的对应关系\n+\n+### 设计理念映射\n+\n+```mermaid\n+graph TB\n+    subgraph \"核心设计理念\"\n+        Loop[多层循环架构<br/>四层循环]\n+        DataDriven[数据驱动架构<br/>配置驱动]\n+        Layered[分层架构<br/>功能组织]\n+    end\n+    \n+    subgraph \"Clean架构层次\"\n+        Entities[实体层<br/>四层循环实体]\n+        UseCases[用例层<br/>循环用例]\n+        Adapters[适配器层<br/>功能适配器]\n+        Frameworks[框架层<br/>配置数据]\n+    end\n+    \n+    Loop --> Entities\n+    Loop --> UseCases\n+    DataDriven --> Frameworks\n+    DataDriven --> Adapters\n+    Layered --> Adapters\n+    \n+    style Loop fill:#ffebee\n+    style Entities fill:#ffebee\n+```\n+\n+### 对应关系说明\n+\n+#### 1. 多层循环架构 → 实体层 + 用例层\n+\n+**实体层**：\n+- 定义四层循环的实体模型（战斗、回合、阵营、单位）\n+- 包含循环的业务规则\n+- 定义循环的状态和转换条件\n+\n+**用例层**：\n+- 实现循环的执行用例（执行战斗、执行回合、执行单位）\n+- 协调实体完成循环流程\n+- 管理循环的生命周期\n+\n+#### 2. 数据驱动架构 → 框架层 + 接口适配器层\n+\n+**框架层**：\n+- 存储配置数据（Excel、JSON、Lua）\n+- 提供配置数据访问接口\n+- 管理配置数据的加载和更新\n+\n+**接口适配器层**：\n+- 读取配置数据（数据适配器）\n+- 将配置数据转换为用例可用的格式\n+- 应用配置数据驱动业务逻辑\n+\n+#### 3. 分层架构（功能组织）→ 接口适配器层\n+\n+**接口适配器层**：\n+- 输入适配器：处理输入功能\n+- 行动适配器：处理执行功能\n+- 视觉适配器：处理表现功能\n+- 数据适配器：处理数据功能\n+- 通信适配器：处理通信功能\n+\n+---\n+\n+## Clean架构的优势\n+\n+### 对战斗系统的价值\n+\n+```mermaid\n+mindmap\n+  root((Clean架构优势))\n+    业务逻辑独立\n+      实体层独立\n+      用例层独立\n+      不依赖框架\n+    可测试性\n+      实体可独立测试\n+      用例可独立测试\n+      无需Unity/Lua\n+    技术无关性\n+      可替换Unity\n+      可替换Lua\n+      可替换数据库\n+    可维护性\n+      依赖方向清晰\n+      职责分离明确\n+      易于理解\n+    可扩展性\n+      新增用例\n+      新增适配器\n+      不影响现有代码\n+```\n+\n+### 具体优势说明\n+\n+#### 1. 业务逻辑独立\n+- **实体层**：四层循环的业务规则完全独立，不依赖Unity、Lua等技术\n+- **用例层**：战斗用例可以独立实现，不依赖框架\n+- **优势**：业务逻辑稳定，技术变化不影响业务\n+\n+#### 2. 可测试性\n+- **实体层**：可以独立测试实体和业务规则\n+- **用例层**：可以独立测试用例逻辑，无需Unity引擎\n+- **优势**：提高测试覆盖率，保证代码质量\n+\n+#### 3. 技术无关性\n+- **框架层**：Unity、Lua、数据库等技术可以被替换\n+- **接口适配器层**：通过适配器隔离技术细节\n+- **优势**：可以轻松替换技术栈，不影响业务逻辑\n+\n+#### 4. 可维护性\n+- **依赖方向清晰**：从外向内，易于理解\n+- **职责分离明确**：每层职责单一，易于维护\n+- **优势**：代码组织清晰，易于理解和修改\n+\n+#### 5. 可扩展性\n+- **新增用例**：只需在用例层添加新用例，不影响现有代码\n+- **新增适配器**：只需在适配器层添加新适配器，不影响用例\n+- **优势**：易于扩展新功能，不影响现有系统\n+\n+---\n+\n+## 实施建议\n+\n+### Clean架构实施步骤\n+\n+```mermaid\n+graph TD\n+    Start[开始实施] --> Step1[1. 设计实体层<br/>定义四层循环实体]\n+    Step1 --> Step2[2. 设计用例层<br/>定义战斗用例]\n+    Step2 --> Step3[3. 设计适配器层<br/>定义功能适配器]\n+    Step3 --> Step4[4. 集成框架层<br/>集成Unity/Lua等]\n+    Step4 --> Step5[5. 实现数据驱动<br/>配置数据读取和应用]\n+    Step5 --> End[完成]\n+    \n+    style Step1 fill:#ffebee\n+    style Step2 fill:#fff4e1\n+    style Step3 fill:#e8f5e9\n+    style Step4 fill:#e1f5ff\n+```\n+\n+### 实施优先级\n+\n+#### 第一阶段：核心实体和用例\n+1. **实体层**：定义战斗、回合、阵营、单位实体\n+2. **用例层**：实现执行战斗、执行回合、执行单位用例\n+3. **框架层**：集成状态机框架，实现层次状态机\n+\n+#### 第二阶段：功能适配器\n+1. **输入适配器**：实现玩家输入和AI输入处理\n+2. **行动适配器**：实现行动执行逻辑\n+3. **视觉适配器**：实现视觉表现处理\n+4. **数据适配器**：实现数据访问和配置读取\n+\n+#### 第三阶段：框架集成\n+1. **Unity集成**：集成Unity引擎，实现视觉表现\n+2. **Lua集成**：集成Lua脚本，实现业务逻辑\n+3. **数据库集成**：集成数据库，实现数据持久化\n+4. **通信集成**：集成CommunicationBus，实现系统通信\n+\n+---\n+\n+## 总结\n+\n+战斗系统采用Clean架构模式，将系统组织成四个同心圆层，业务规则在中心，框架和技术在外围。\n+\n+### 核心价值\n+\n+- 🎯 **业务逻辑独立**：四层循环的业务规则完全独立于框架和技术\n+- 🧪 **高度可测试**：实体和用例可以独立测试，无需Unity/Lua\n+- 🔄 **技术无关**：可以轻松替换Unity、Lua、数据库等技术栈\n+- 📐 **依赖清晰**：依赖方向从外向内，易于理解和维护\n+- 📈 **易于扩展**：新增功能只需添加用例或适配器，不影响现有代码\n+\n+### 架构映射\n+\n+- **实体层** = 四层循环实体（战斗、回合、阵营、单位）\n+- **用例层** = 战斗用例（执行战斗、执行回合、执行单位）\n+- **接口适配器层** = 功能服务（输入、执行、表现、数据、通信）\n+- **框架层** = 技术实现（Unity、Lua、数据库、FSM、CommunicationBus、DataHandleQueue）\n+\n+### 设计理念对应\n+\n+- **多层循环架构** → 实体层 + 用例层\n+- **数据驱动架构** → 框架层 + 接口适配器层\n+- **分层架构（功能组织）** → 接口适配器层\n+\n+Clean架构是构建可维护、可测试、可扩展战斗系统的优秀选择，特别适合需要长期维护和持续演进的战斗系统。\n"
                },
                {
                    "date": 1767098942212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,22 +40,99 @@\n ### Clean架构模式（主要架构）\n \n **核心观点**：战斗系统采用Clean架构模式，将系统组织成四个同心圆层，业务规则在中心，框架和技术在外围。\n \n-#### Clean架构层次结构\n+### 战斗系统整体架构图\n \n ```mermaid\n graph TB\n+    subgraph \"框架层（Frameworks & Drivers）- 技术实现\"\n+        Unity[Unity引擎<br/>渲染/物理/动画]\n+        Lua[Lua脚本引擎<br/>业务逻辑]\n+        Database[(数据库<br/>数据持久化)]\n+        FSM[状态机框架<br/>FSM Framework]\n+        CommunicationBus[通信总线<br/>CommunicationBus]\n+        DataHandleQueue[数据队列<br/>DataHandleQueue]\n+        Formula[公式引擎<br/>Formula Parser]\n+        Pool[对象池<br/>Object Pool]\n+        Config[配置数据<br/>Excel/JSON/Lua]\n+    end\n+    \n+    subgraph \"接口适配器层（Interface Adapters）- 功能服务\"\n+        InputAdapter[输入适配器<br/>Input Adapter<br/>玩家输入/AI输入]\n+        ActionAdapter[行动适配器<br/>Action Adapter<br/>行动执行/伤害计算]\n+        VisualAdapter[视觉适配器<br/>Visual Adapter<br/>动画/特效/UI]\n+        DataAdapter[数据适配器<br/>Data Adapter<br/>数据访问/配置读取]\n+        CommunicationAdapter[通信适配器<br/>Communication Adapter<br/>事件/消息/查询]\n+    end\n+    \n+    subgraph \"用例层（Use Cases）- 应用业务规则\"\n+        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n+        ExecuteRoundUC[执行回合用例<br/>ExecuteRound]\n+        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam]\n+        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit]\n+        CalculateDamageUC[计算伤害用例<br/>CalculateDamage]\n+        ApplyEffectUC[应用效果用例<br/>ApplyEffect]\n+    end\n+    \n+    subgraph \"实体层（Entities）- 核心业务规则\"\n+        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]\n+        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]\n+        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]\n+        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]\n+        SkillEntity[技能实体<br/>Skill Entity]\n+        EffectEntity[效果实体<br/>Effect Entity]\n+    end\n+    \n+    Unity --> VisualAdapter\n+    Lua --> ActionAdapter\n+    Database --> DataAdapter\n+    FSM --> ExecuteBattleUC\n+    CommunicationBus --> CommunicationAdapter\n+    DataHandleQueue --> DataAdapter\n+    Formula --> ActionAdapter\n+    Pool --> VisualAdapter\n+    Config --> DataAdapter\n+    \n+    InputAdapter --> ExecuteUnitUC\n+    ActionAdapter --> ExecuteUnitUC\n+    VisualAdapter --> ExecuteUnitUC\n+    DataAdapter --> ExecuteUnitUC\n+    CommunicationAdapter --> ExecuteUnitUC\n+    \n+    ExecuteBattleUC --> BattleEntity\n+    ExecuteRoundUC --> RoundEntity\n+    ExecuteTeamUC --> TeamEntity\n+    ExecuteUnitUC --> UnitEntity\n+    CalculateDamageUC --> SkillEntity\n+    ApplyEffectUC --> EffectEntity\n+    \n+    BattleEntity --> RoundEntity\n+    RoundEntity --> TeamEntity\n+    TeamEntity --> UnitEntity\n+    \n+    style BattleEntity fill:#ffebee\n+    style ExecuteBattleUC fill:#fff4e1\n+    style InputAdapter fill:#e8f5e9\n+    style Unity fill:#e1f5ff\n+```\n+\n+### 架构层次说明\n+\n+#### Clean架构同心圆结构\n+\n+```mermaid\n+graph TB\n     subgraph \"Clean架构同心圆\"\n         direction TB\n         Entities[实体层<br/>Entities<br/>核心业务规则<br/>最内层]\n         UseCases[用例层<br/>Use Cases<br/>应用业务规则]\n         InterfaceAdapters[接口适配器层<br/>Interface Adapters<br/>功能服务]\n         Frameworks[框架层<br/>Frameworks & Drivers<br/>技术实现<br/>最外层]\n         \n-        Frameworks --> InterfaceAdapters\n-        InterfaceAdapters --> UseCases\n-        UseCases --> Entities\n+        Frameworks -.依赖.-> InterfaceAdapters\n+        InterfaceAdapters -.依赖.-> UseCases\n+        UseCases -.依赖.-> Entities\n     end\n     \n     style Entities fill:#ffebee\n     style UseCases fill:#fff4e1\n@@ -68,75 +145,103 @@\n - ❌ **禁止**：内层依赖外层\n - ✅ **允许**：通过接口定义依赖\n - ❌ **禁止**：直接依赖具体实现\n \n-### 战斗系统在Clean架构中的映射\n+### 战斗流程在Clean架构中的执行\n \n ```mermaid\n-graph TB\n-    subgraph \"实体层（Entities）- 核心业务规则\"\n-        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]\n-        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]\n-        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]\n-        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]\n-        SkillEntity[技能实体<br/>Skill Entity]\n-        EffectEntity[效果实体<br/>Effect Entity]\n-    end\n+sequenceDiagram\n+    participant Framework as 框架层\n+    participant Adapter as 适配器层\n+    participant UseCase as 用例层\n+    participant Entity as 实体层\n     \n-    subgraph \"用例层（Use Cases）- 应用业务规则\"\n-        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle UseCase]\n-        ExecuteRoundUC[执行回合用例<br/>ExecuteRound UseCase]\n-        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam UseCase]\n-        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n-        CalculateDamageUC[计算伤害用例<br/>CalculateDamage UseCase]\n-        ApplyEffectUC[应用效果用例<br/>ApplyEffect UseCase]\n-    end\n+    Note over Framework,Entity: 战斗开始流程\n     \n-    subgraph \"接口适配器层（Interface Adapters）- 功能服务\"\n-        InputAdapter[输入适配器<br/>Input Adapter<br/>输入服务]\n-        ActionAdapter[行动适配器<br/>Action Adapter<br/>执行服务]\n-        VisualAdapter[视觉适配器<br/>Visual Adapter<br/>表现服务]\n-        DataAdapter[数据适配器<br/>Data Adapter<br/>数据服务]\n-        CommunicationAdapter[通信适配器<br/>Communication Adapter<br/>通信服务]\n-    end\n+    Framework->>Adapter: Unity触发战斗开始\n+    Adapter->>UseCase: 输入适配器转换输入\n+    UseCase->>Entity: 执行战斗用例调用战斗实体\n+    Entity->>Entity: 战斗实体启动战斗循环\n     \n-    subgraph \"框架层（Frameworks & Drivers）- 技术实现\"\n-        Unity[Unity引擎<br/>Unity Engine]\n-        Lua[Lua脚本引擎<br/>Lua Script Engine]\n-        Database[(数据库<br/>Database)]\n-        FSM[状态机框架<br/>FSM Framework]\n-        CommunicationBus[通信总线<br/>CommunicationBus]\n-        DataHandleQueue[数据队列<br/>DataHandleQueue]\n-    end\n+    Note over Entity: 战斗循环开始\n     \n-    ExecuteBattleUC --> BattleEntity\n-    ExecuteRoundUC --> RoundEntity\n-    ExecuteTeamUC --> TeamEntity\n-    ExecuteUnitUC --> UnitEntity\n-    CalculateDamageUC --> SkillEntity\n-    ApplyEffectUC --> EffectEntity\n+    Entity->>UseCase: 战斗实体调用执行回合用例\n+    UseCase->>Entity: 执行回合用例调用回合实体\n+    Entity->>Entity: 回合实体启动回合循环\n     \n-    InputAdapter --> ExecuteUnitUC\n-    ActionAdapter --> ExecuteUnitUC\n-    VisualAdapter --> ExecuteUnitUC\n-    DataAdapter --> ExecuteUnitUC\n-    CommunicationAdapter --> ExecuteUnitUC\n+    Note over Entity: 回合循环开始\n     \n-    Unity --> VisualAdapter\n-    Lua --> ActionAdapter\n-    Database --> DataAdapter\n-    FSM --> ExecuteBattleUC\n-    CommunicationBus --> CommunicationAdapter\n-    DataHandleQueue --> DataAdapter\n+    Entity->>UseCase: 回合实体调用执行阵营用例\n+    UseCase->>Entity: 执行阵营用例调用阵营实体\n+    Entity->>Entity: 阵营实体启动阵营循环\n     \n-    style BattleEntity fill:#ffebee\n-    style ExecuteBattleUC fill:#fff4e1\n-    style InputAdapter fill:#e8f5e9\n-    style Unity fill:#e1f5ff\n+    Note over Entity: 阵营循环开始\n+    \n+    Entity->>UseCase: 阵营实体调用执行单位用例\n+    UseCase->>Adapter: 执行单位用例调用输入适配器\n+    Adapter->>Framework: 输入适配器获取玩家输入/AI输入\n+    Framework->>Adapter: 返回输入数据\n+    Adapter->>UseCase: 转换输入数据\n+    \n+    UseCase->>Adapter: 执行单位用例调用行动适配器\n+    Adapter->>Framework: 行动适配器调用Lua脚本\n+    Framework->>Adapter: 返回行动结果\n+    Adapter->>UseCase: 转换行动结果\n+    \n+    UseCase->>Adapter: 执行单位用例调用视觉适配器\n+    Adapter->>Framework: 视觉适配器调用Unity引擎\n+    Framework->>Adapter: 播放动画/特效\n+    Adapter->>UseCase: 视觉播放完成\n+    \n+    UseCase->>Adapter: 执行单位用例调用数据适配器\n+    Adapter->>Framework: 数据适配器更新数据\n+    Framework->>Adapter: 数据更新完成\n+    Adapter->>UseCase: 数据更新结果\n+    \n+    UseCase->>Entity: 执行单位用例完成，更新单位实体\n+    Entity->>Entity: 单位循环继续/结束\n+    \n+    Note over Entity: 单位循环结束，返回上层循环\n ```\n \n-### 各层职责说明\n+### 数据流在Clean架构中的方向\n \n+```mermaid\n+graph LR\n+    subgraph \"数据流向\"\n+        direction TB\n+        \n+        subgraph \"请求流（从外向内）\"\n+            FrameworkReq[框架层<br/>用户输入/系统事件]\n+            AdapterReq[适配器层<br/>数据转换]\n+            UseCaseReq[用例层<br/>用例输入]\n+            EntityReq[实体层<br/>实体操作]\n+            \n+            FrameworkReq --> AdapterReq\n+            AdapterReq --> UseCaseReq\n+            UseCaseReq --> EntityReq\n+        end\n+        \n+        subgraph \"响应流（从内向外）\"\n+            EntityResp[实体层<br/>业务结果]\n+            UseCaseResp[用例层<br/>用例输出]\n+            AdapterResp[适配器层<br/>数据转换]\n+            FrameworkResp[框架层<br/>UI更新/视觉表现]\n+            \n+            EntityResp --> UseCaseResp\n+            UseCaseResp --> AdapterResp\n+            AdapterResp --> FrameworkResp\n+        end\n+    end\n+    \n+    style FrameworkReq fill:#e1f5ff\n+    style EntityReq fill:#ffebee\n+    style EntityResp fill:#ffebee\n+    style FrameworkResp fill:#e1f5ff\n+```\n+\n+### 各层职责概览\n+\n #### 1. 实体层（Entities）- 核心业务规则\n \n **位置**：最内层，核心业务规则\n \n"
                },
                {
                    "date": 1767099031196,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,230 +115,9 @@\n     style InputAdapter fill:#e8f5e9\n     style Unity fill:#e1f5ff\n ```\n \n-### 架构层次说明\n \n-#### Clean架构同心圆结构\n-\n-```mermaid\n-graph TB\n-    subgraph \"Clean架构同心圆\"\n-        direction TB\n-        Entities[实体层<br/>Entities<br/>核心业务规则<br/>最内层]\n-        UseCases[用例层<br/>Use Cases<br/>应用业务规则]\n-        InterfaceAdapters[接口适配器层<br/>Interface Adapters<br/>功能服务]\n-        Frameworks[框架层<br/>Frameworks & Drivers<br/>技术实现<br/>最外层]\n-        \n-        Frameworks -.依赖.-> InterfaceAdapters\n-        InterfaceAdapters -.依赖.-> UseCases\n-        UseCases -.依赖.-> Entities\n-    end\n-    \n-    style Entities fill:#ffebee\n-    style UseCases fill:#fff4e1\n-    style InterfaceAdapters fill:#e8f5e9\n-    style Frameworks fill:#e1f5ff\n-```\n-\n-**依赖规则**：\n-- ✅ **允许**：外层依赖内层\n-- ❌ **禁止**：内层依赖外层\n-- ✅ **允许**：通过接口定义依赖\n-- ❌ **禁止**：直接依赖具体实现\n-\n-### 战斗流程在Clean架构中的执行\n-\n-```mermaid\n-sequenceDiagram\n-    participant Framework as 框架层\n-    participant Adapter as 适配器层\n-    participant UseCase as 用例层\n-    participant Entity as 实体层\n-    \n-    Note over Framework,Entity: 战斗开始流程\n-    \n-    Framework->>Adapter: Unity触发战斗开始\n-    Adapter->>UseCase: 输入适配器转换输入\n-    UseCase->>Entity: 执行战斗用例调用战斗实体\n-    Entity->>Entity: 战斗实体启动战斗循环\n-    \n-    Note over Entity: 战斗循环开始\n-    \n-    Entity->>UseCase: 战斗实体调用执行回合用例\n-    UseCase->>Entity: 执行回合用例调用回合实体\n-    Entity->>Entity: 回合实体启动回合循环\n-    \n-    Note over Entity: 回合循环开始\n-    \n-    Entity->>UseCase: 回合实体调用执行阵营用例\n-    UseCase->>Entity: 执行阵营用例调用阵营实体\n-    Entity->>Entity: 阵营实体启动阵营循环\n-    \n-    Note over Entity: 阵营循环开始\n-    \n-    Entity->>UseCase: 阵营实体调用执行单位用例\n-    UseCase->>Adapter: 执行单位用例调用输入适配器\n-    Adapter->>Framework: 输入适配器获取玩家输入/AI输入\n-    Framework->>Adapter: 返回输入数据\n-    Adapter->>UseCase: 转换输入数据\n-    \n-    UseCase->>Adapter: 执行单位用例调用行动适配器\n-    Adapter->>Framework: 行动适配器调用Lua脚本\n-    Framework->>Adapter: 返回行动结果\n-    Adapter->>UseCase: 转换行动结果\n-    \n-    UseCase->>Adapter: 执行单位用例调用视觉适配器\n-    Adapter->>Framework: 视觉适配器调用Unity引擎\n-    Framework->>Adapter: 播放动画/特效\n-    Adapter->>UseCase: 视觉播放完成\n-    \n-    UseCase->>Adapter: 执行单位用例调用数据适配器\n-    Adapter->>Framework: 数据适配器更新数据\n-    Framework->>Adapter: 数据更新完成\n-    Adapter->>UseCase: 数据更新结果\n-    \n-    UseCase->>Entity: 执行单位用例完成，更新单位实体\n-    Entity->>Entity: 单位循环继续/结束\n-    \n-    Note over Entity: 单位循环结束，返回上层循环\n-```\n-\n-### 数据流在Clean架构中的方向\n-\n-```mermaid\n-graph LR\n-    subgraph \"数据流向\"\n-        direction TB\n-        \n-        subgraph \"请求流（从外向内）\"\n-            FrameworkReq[框架层<br/>用户输入/系统事件]\n-            AdapterReq[适配器层<br/>数据转换]\n-            UseCaseReq[用例层<br/>用例输入]\n-            EntityReq[实体层<br/>实体操作]\n-            \n-            FrameworkReq --> AdapterReq\n-            AdapterReq --> UseCaseReq\n-            UseCaseReq --> EntityReq\n-        end\n-        \n-        subgraph \"响应流（从内向外）\"\n-            EntityResp[实体层<br/>业务结果]\n-            UseCaseResp[用例层<br/>用例输出]\n-            AdapterResp[适配器层<br/>数据转换]\n-            FrameworkResp[框架层<br/>UI更新/视觉表现]\n-            \n-            EntityResp --> UseCaseResp\n-            UseCaseResp --> AdapterResp\n-            AdapterResp --> FrameworkResp\n-        end\n-    end\n-    \n-    style FrameworkReq fill:#e1f5ff\n-    style EntityReq fill:#ffebee\n-    style EntityResp fill:#ffebee\n-    style FrameworkResp fill:#e1f5ff\n-```\n-\n-### 各层职责概览\n-\n-#### 1. 实体层（Entities）- 核心业务规则\n-\n-**位置**：最内层，核心业务规则\n-\n-**职责**：\n-- 定义战斗核心实体（战斗、回合、阵营、单位）\n-- 包含企业级业务规则\n-- 定义四层循环的实体模型\n-- 不依赖任何外部框架\n-\n-**核心实体**：\n-- **战斗实体（Battle Entity）**：管理整个战斗的生命周期，包含战斗循环\n-- **回合实体（Round Entity）**：管理回合的循环和切换，包含回合循环\n-- **阵营实体（Team Entity）**：管理阵营内单位的行动顺序，包含阵营循环\n-- **单位实体（Unit Entity）**：管理单个单位的行动流程，包含单位循环\n-- **技能实体（Skill Entity）**：定义技能规则和效果\n-- **效果实体（Effect Entity）**：定义效果规则和应用逻辑\n-\n-**特点**：\n-- 最稳定的一层\n-- 变化频率最低\n-- 包含核心业务概念\n-- 纯业务逻辑，无技术细节\n-\n-#### 2. 用例层（Use Cases）- 应用业务规则\n-\n-**位置**：第二层，应用业务规则\n-\n-**职责**：\n-- 实现具体的战斗用例\n-- 协调实体完成业务目标\n-- 定义应用输入输出接口\n-- 包含应用特定的业务逻辑\n-\n-**核心用例**：\n-- **执行战斗用例（ExecuteBattle）**：协调战斗实体执行战斗流程\n-- **执行回合用例（ExecuteRound）**：协调回合实体执行回合流程\n-- **执行阵营用例（ExecuteTeam）**：协调阵营实体执行阵营流程\n-- **执行单位用例（ExecuteUnit）**：协调单位实体执行单位行动\n-- **计算伤害用例（CalculateDamage）**：计算技能伤害\n-- **应用效果用例（ApplyEffect）**：应用技能效果\n-\n-**特点**：\n-- 依赖实体层\n-- 不依赖框架和UI\n-- 包含应用特定的业务逻辑\n-- 可以独立测试\n-\n-#### 3. 接口适配器层（Interface Adapters）- 功能服务\n-\n-**位置**：第三层，转换层\n-\n-**职责**：\n-- 转换数据格式\n-- 适配外部接口\n-- 实现接口定义\n-- 连接用例和框架\n-\n-**核心适配器**：\n-- **输入适配器（Input Adapter）**：处理玩家输入和AI输入，转换为用例输入\n-- **行动适配器（Action Adapter）**：执行行动逻辑，调用用例\n-- **视觉适配器（Visual Adapter）**：处理视觉表现，调用用例输出\n-- **数据适配器（Data Adapter）**：处理数据访问，调用用例\n-- **通信适配器（Communication Adapter）**：处理系统间通信，调用用例\n-\n-**特点**：\n-- 依赖用例层\n-- 实现框架层定义的接口\n-- 转换数据格式\n-- 适配外部服务\n-\n-#### 4. 框架层（Frameworks & Drivers）- 技术实现\n-\n-**位置**：最外层，技术实现\n-\n-**职责**：\n-- 实现具体的技术细节\n-- 提供框架和工具\n-- 处理外部系统交互\n-- 实现接口适配器定义的接口\n-\n-**核心框架**：\n-- **Unity引擎**：游戏引擎，提供渲染、物理等功能\n-- **Lua脚本引擎**：脚本语言，实现业务逻辑\n-- **数据库**：数据持久化\n-- **状态机框架（FSM）**：状态管理\n-- **通信总线（CommunicationBus）**：系统间通信\n-- **数据队列（DataHandleQueue）**：数据处理\n-\n-**特点**：\n-- 最外层，技术实现\n-- 可以被替换\n-- 不影响业务逻辑\n-- 提供基础设施\n-\n----\n-\n ## 实体层详细设计（Entities Layer）\n \n ### 四层循环实体模型\n \n"
                },
                {
                    "date": 1767099086239,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,37 +5,8 @@\n 设计一套完整的回合制战斗系统架构，支持DND规则、回合管理、状态机控制、AI决策，实现战斗流程管理、伤害计算、效果应用，提供数据驱动的配置化战斗系统。\n \n ---\n \n-## 核心设计理念\n-\n-### 1. 多层循环架构为核心\n-\n-**本质**：战斗系统的核心是四层循环的维护和管理\n-- **战斗循环**：管理整个战斗的生命周期\n-- **回合循环**：管理回合的循环和切换\n-- **阵营循环**：管理阵营内单位的行动顺序\n-- **单位循环**：管理单个单位的行动流程\n-- **循环驱动**：所有战斗逻辑都在循环框架内执行\n-- **状态维护**：每层循环维护自己的状态，驱动下层循环\n-\n-### 2. 数据驱动架构\n-\n-**本质**：战斗特性通过配置数据实现，无需修改代码\n-- 战斗规则、伤害计算、效果应用 → 通过配置数据定义\n-- 回合流程、状态转换 → 通过配置数据调整\n-- 新增战斗机制 → 扩展配置数据即可\n-- 战斗平衡 → 调整配置数值即可\n-\n-### 3. 分层架构（循环内的功能组织）\n-\n-**本质**：分层架构是循环内的功能组织方式，不是主要架构\n-- 功能组织：输入层、决策层、执行层、表现层、管理层\n-- 执行位置：所有分层功能都在单位循环内执行\n-- 解耦设计：层间通过Context和CommunicationBus通信\n-\n----\n-\n ## 整体架构设计\n \n ### Clean架构模式（主要架构）\n \n"
                },
                {
                    "date": 1767100609196,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,14 +27,14 @@\n         Pool[对象池<br/>Object Pool]\n         Config[配置数据<br/>Excel/JSON/Lua]\n     end\n     \n-    subgraph \"接口适配器层（Interface Adapters）- 功能服务\"\n-        InputAdapter[输入适配器<br/>Input Adapter<br/>玩家输入/AI输入]\n-        ActionAdapter[行动适配器<br/>Action Adapter<br/>行动执行/伤害计算]\n-        VisualAdapter[视觉适配器<br/>Visual Adapter<br/>动画/特效/UI]\n-        DataAdapter[数据适配器<br/>Data Adapter<br/>数据访问/配置读取]\n-        CommunicationAdapter[通信适配器<br/>Communication Adapter<br/>事件/消息/查询]\n+    subgraph \"服务层（Services）- 功能服务\"\n+        InputService[输入服务<br/>Input Service<br/>玩家输入/AI输入]\n+        ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n+        VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n+        DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n+        CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n         ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n@@ -53,23 +53,23 @@\n         SkillEntity[技能实体<br/>Skill Entity]\n         EffectEntity[效果实体<br/>Effect Entity]\n     end\n     \n-    Unity --> VisualAdapter\n-    Lua --> ActionAdapter\n-    Database --> DataAdapter\n+    Unity --> VisualService\n+    Lua --> ActionService\n+    Database --> DataService\n     FSM --> ExecuteBattleUC\n-    CommunicationBus --> CommunicationAdapter\n-    DataHandleQueue --> DataAdapter\n-    Formula --> ActionAdapter\n-    Pool --> VisualAdapter\n-    Config --> DataAdapter\n+    CommunicationBus --> CommunicationService\n+    DataHandleQueue --> DataService\n+    Formula --> ActionService\n+    Pool --> VisualService\n+    Config --> DataService\n     \n-    InputAdapter --> ExecuteUnitUC\n-    ActionAdapter --> ExecuteUnitUC\n-    VisualAdapter --> ExecuteUnitUC\n-    DataAdapter --> ExecuteUnitUC\n-    CommunicationAdapter --> ExecuteUnitUC\n+    InputService --> ExecuteUnitUC\n+    ActionService --> ExecuteUnitUC\n+    VisualService --> ExecuteUnitUC\n+    DataService --> ExecuteUnitUC\n+    CommunicationService --> ExecuteUnitUC\n     \n     ExecuteBattleUC --> BattleEntity\n     ExecuteRoundUC --> RoundEntity\n     ExecuteTeamUC --> TeamEntity\n@@ -82,13 +82,241 @@\n     TeamEntity --> UnitEntity\n     \n     style BattleEntity fill:#ffebee\n     style ExecuteBattleUC fill:#fff4e1\n-    style InputAdapter fill:#e8f5e9\n+    style InputService fill:#e8f5e9\n     style Unity fill:#e1f5ff\n ```\n \n+### Clean架构层次结构\n \n+```mermaid\n+graph TB\n+    subgraph \"Clean架构同心圆\"\n+        direction TB\n+        Entities[实体层<br/>Entities<br/>核心业务规则<br/>最内层]\n+        UseCases[用例层<br/>Use Cases<br/>应用业务规则]\n+        Services[服务层<br/>Services<br/>功能服务]\n+        Frameworks[框架层<br/>Frameworks & Drivers<br/>技术实现<br/>最外层]\n+        \n+        Frameworks -.依赖.-> Services\n+        Services -.依赖.-> UseCases\n+        UseCases -.依赖.-> Entities\n+    end\n+    \n+    style Entities fill:#ffebee\n+    style UseCases fill:#fff4e1\n+    style Services fill:#e8f5e9\n+    style Frameworks fill:#e1f5ff\n+```\n+\n+**依赖规则**：\n+- ✅ **允许**：外层依赖内层\n+- ❌ **禁止**：内层依赖外层\n+- ✅ **允许**：通过接口定义依赖\n+- ❌ **禁止**：直接依赖具体实现\n+\n+### 战斗流程在Clean架构中的执行\n+\n+```mermaid\n+sequenceDiagram\n+    participant Framework as 框架层\n+    participant Service as 服务层\n+    participant UseCase as 用例层\n+    participant Entity as 实体层\n+    \n+    Note over Framework,Entity: 战斗开始流程\n+    \n+    Framework->>Service: Unity触发战斗开始\n+    Service->>UseCase: 输入服务转换输入\n+    UseCase->>Entity: 执行战斗用例调用战斗实体\n+    Entity->>Entity: 战斗实体启动战斗循环\n+    \n+    Note over Entity: 战斗循环开始\n+    \n+    Entity->>UseCase: 战斗实体调用执行回合用例\n+    UseCase->>Entity: 执行回合用例调用回合实体\n+    Entity->>Entity: 回合实体启动回合循环\n+    \n+    Note over Entity: 回合循环开始\n+    \n+    Entity->>UseCase: 回合实体调用执行阵营用例\n+    UseCase->>Entity: 执行阵营用例调用阵营实体\n+    Entity->>Entity: 阵营实体启动阵营循环\n+    \n+    Note over Entity: 阵营循环开始\n+    \n+    Entity->>UseCase: 阵营实体调用执行单位用例\n+    UseCase->>Service: 执行单位用例调用输入服务\n+    Service->>Framework: 输入服务获取玩家输入/AI输入\n+    Framework->>Service: 返回输入数据\n+    Service->>UseCase: 转换输入数据\n+    \n+    UseCase->>Service: 执行单位用例调用行动服务\n+    Service->>Framework: 行动服务调用Lua脚本\n+    Framework->>Service: 返回行动结果\n+    Service->>UseCase: 转换行动结果\n+    \n+    UseCase->>Service: 执行单位用例调用视觉服务\n+    Service->>Framework: 视觉服务调用Unity引擎\n+    Framework->>Service: 播放动画/特效\n+    Service->>UseCase: 视觉播放完成\n+    \n+    UseCase->>Service: 执行单位用例调用数据服务\n+    Service->>Framework: 数据服务更新数据\n+    Framework->>Service: 数据更新完成\n+    Service->>UseCase: 数据更新结果\n+    \n+    UseCase->>Entity: 执行单位用例完成，更新单位实体\n+    Entity->>Entity: 单位循环继续/结束\n+    \n+    Note over Entity: 单位循环结束，返回上层循环\n+```\n+\n+### 数据流在Clean架构中的方向\n+\n+```mermaid\n+graph LR\n+    subgraph \"数据流向\"\n+        direction TB\n+        \n+        subgraph \"请求流（从外向内）\"\n+            FrameworkReq[框架层<br/>用户输入/系统事件]\n+            ServiceReq[服务层<br/>数据转换]\n+            UseCaseReq[用例层<br/>用例输入]\n+            EntityReq[实体层<br/>实体操作]\n+            \n+            FrameworkReq --> ServiceReq\n+            ServiceReq --> UseCaseReq\n+            UseCaseReq --> EntityReq\n+        end\n+        \n+        subgraph \"响应流（从内向外）\"\n+            EntityResp[实体层<br/>业务结果]\n+            UseCaseResp[用例层<br/>用例输出]\n+            ServiceResp[服务层<br/>数据转换]\n+            FrameworkResp[框架层<br/>UI更新/视觉表现]\n+            \n+            EntityResp --> UseCaseResp\n+            UseCaseResp --> ServiceResp\n+            ServiceResp --> FrameworkResp\n+        end\n+    end\n+    \n+    style FrameworkReq fill:#e1f5ff\n+    style EntityReq fill:#ffebee\n+    style EntityResp fill:#ffebee\n+    style FrameworkResp fill:#e1f5ff\n+```\n+\n+### 各层职责概览\n+\n+#### 1. 实体层（Entities）- 核心业务规则\n+\n+**位置**：最内层，核心业务规则\n+\n+**职责**：\n+- 定义战斗核心实体（战斗、回合、阵营、单位）\n+- 包含企业级业务规则\n+- 定义四层循环的实体模型\n+- 不依赖任何外部框架\n+\n+**核心实体**：\n+- **战斗实体（Battle Entity）**：管理整个战斗的生命周期，包含战斗循环\n+- **回合实体（Round Entity）**：管理回合的循环和切换，包含回合循环\n+- **阵营实体（Team Entity）**：管理阵营内单位的行动顺序，包含阵营循环\n+- **单位实体（Unit Entity）**：管理单个单位的行动流程，包含单位循环\n+- **技能实体（Skill Entity）**：定义技能规则和效果\n+- **效果实体（Effect Entity）**：定义效果规则和应用逻辑\n+\n+**特点**：\n+- 最稳定的一层\n+- 变化频率最低\n+- 包含核心业务概念\n+- 纯业务逻辑，无技术细节\n+\n+#### 2. 用例层（Use Cases）- 应用业务规则\n+\n+**位置**：第二层，应用业务规则\n+\n+**职责**：\n+- 实现具体的战斗用例\n+- 协调实体完成业务目标\n+- 定义应用输入输出接口\n+- 包含应用特定的业务逻辑\n+\n+**核心用例**：\n+- **执行战斗用例（ExecuteBattle）**：协调战斗实体执行战斗流程\n+- **执行回合用例（ExecuteRound）**：协调回合实体执行回合流程\n+- **执行阵营用例（ExecuteTeam）**：协调阵营实体执行阵营流程\n+- **执行单位用例（ExecuteUnit）**：协调单位实体执行单位行动\n+- **计算伤害用例（CalculateDamage）**：计算技能伤害\n+- **应用效果用例（ApplyEffect）**：应用技能效果\n+\n+**特点**：\n+- 依赖实体层\n+- 不依赖框架和UI\n+- 包含应用特定的业务逻辑\n+- 可以独立测试\n+\n+#### 3. 服务层（Services）- 功能服务\n+\n+**位置**：第三层，功能服务层\n+\n+**职责**：\n+- 提供功能服务\n+- 转换数据格式\n+- 适配外部接口\n+- 连接用例和框架\n+\n+**核心服务**：\n+- **输入服务（Input Service）**：处理玩家输入和AI输入，转换为用例输入\n+- **行动服务（Action Service）**：执行行动逻辑，调用用例\n+- **视觉服务（Visual Service）**：处理视觉表现，调用用例输出\n+- **数据服务（Data Service）**：处理数据访问，调用用例\n+- **通信服务（Communication Service）**：处理系统间通信，调用用例\n+\n+**服务间交互**：\n+- 输入服务 → 行动服务（输入驱动行动）\n+- 行动服务 → 视觉服务（行动触发视觉）\n+- 行动服务 → 数据服务（行动更新数据）\n+- 数据服务 → 通信服务（数据触发通信）\n+- 通信服务 → 视觉服务（通信触发视觉）\n+\n+**特点**：\n+- 依赖用例层\n+- 实现框架层定义的接口\n+- 转换数据格式\n+- 提供功能服务\n+\n+#### 4. 框架层（Frameworks & Drivers）- 技术实现\n+\n+**位置**：最外层，技术实现\n+\n+**职责**：\n+- 实现具体的技术细节\n+- 提供框架和工具\n+- 处理外部系统交互\n+- 实现服务层定义的接口\n+\n+**核心框架**：\n+- **Unity引擎**：游戏引擎，提供渲染、物理等功能\n+- **Lua脚本引擎**：脚本语言，实现业务逻辑\n+- **数据库**：数据持久化\n+- **状态机框架（FSM）**：状态管理\n+- **通信总线（CommunicationBus）**：系统间通信\n+- **数据队列（DataHandleQueue）**：数据处理\n+- **公式引擎（Formula Parser）**：公式计算\n+- **对象池（Object Pool）**：对象管理\n+- **配置数据**：Excel/JSON/Lua配置\n+\n+**特点**：\n+- 最外层，技术实现\n+- 可以被替换\n+- 不影响业务逻辑\n+- 提供基础设施\n+\n+\n ## 实体层详细设计（Entities Layer）\n \n ### 四层循环实体模型\n \n@@ -356,24 +584,24 @@\n - **输入**：效果信息、目标\n - **输出**：效果应用结果\n - **协调实体**：效果实体、单位实体\n \n-## 接口适配器层详细设计（Interface Adapters Layer）\n+## 服务层详细设计（Services Layer）\n \n-### 功能适配器\n+### 功能服务\n \n-**说明**：接口适配器层将用例层的输出转换为框架层可以使用的格式，同时将框架层的输入转换为用例层可以使用的格式。\n+**说明**：服务层提供功能服务，将用例层的输出转换为框架层可以使用的格式，同时将框架层的输入转换为用例层可以使用的格式。\n \n-#### 适配器层次结构\n+#### 服务层次结构\n \n ```mermaid\n graph TB\n-    subgraph \"接口适配器层 - 功能适配器\"\n-        InputAdapter[输入适配器<br/>Input Adapter]\n-        ActionAdapter[行动适配器<br/>Action Adapter]\n-        VisualAdapter[视觉适配器<br/>Visual Adapter]\n-        DataAdapter[数据适配器<br/>Data Adapter]\n-        CommunicationAdapter[通信适配器<br/>Communication Adapter]\n+    subgraph \"服务层 - 功能服务\"\n+        InputService[输入服务<br/>Input Service]\n+        ActionService[行动服务<br/>Action Service]\n+        VisualService[视觉服务<br/>Visual Service]\n+        DataService[数据服务<br/>Data Service]\n+        CommunicationService[通信服务<br/>Communication Service]\n     end\n     \n     subgraph \"用例层 - 用例\"\n         ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n@@ -385,105 +613,132 @@\n         Database[(数据库)]\n         CommunicationBus[通信总线]\n     end\n     \n-    InputAdapter --> ExecuteUnitUC\n-    ActionAdapter --> ExecuteUnitUC\n-    VisualAdapter --> ExecuteUnitUC\n-    DataAdapter --> ExecuteUnitUC\n-    CommunicationAdapter --> ExecuteUnitUC\n+    InputService --> ExecuteUnitUC\n+    ActionService --> ExecuteUnitUC\n+    VisualService --> ExecuteUnitUC\n+    DataService --> ExecuteUnitUC\n+    CommunicationService --> ExecuteUnitUC\n     \n-    Unity --> VisualAdapter\n-    Lua --> ActionAdapter\n-    Database --> DataAdapter\n-    CommunicationBus --> CommunicationAdapter\n+    Unity --> VisualService\n+    Lua --> ActionService\n+    Database --> DataService\n+    CommunicationBus --> CommunicationService\n     \n-    style InputAdapter fill:#e8f5e9\n+    style InputService fill:#e8f5e9\n     style ExecuteUnitUC fill:#fff4e1\n     style Unity fill:#e1f5ff\n ```\n \n-#### 适配器职责说明\n+#### 服务职责说明\n \n-##### 1. 输入适配器（Input Adapter）\n+##### 1. 输入服务（Input Service）\n - **职责**：处理玩家输入和AI输入，转换为用例输入\n - **功能**：\n   - 接收玩家输入（UI交互、键盘鼠标）\n   - 接收AI输入（AI决策结果）\n   - 验证输入有效性\n   - 转换为用例输入格式（BattleContext）\n - **框架依赖**：Unity Input Manager、AI系统\n \n-##### 2. 行动适配器（Action Adapter）\n+##### 2. 行动服务（Action Service）\n - **职责**：执行行动逻辑，调用用例\n - **功能**：\n   - 验证行动合法性\n   - 执行行动逻辑\n   - 调用执行单位用例\n   - 处理行动结果\n - **框架依赖**：Lua脚本引擎、技能系统\n \n-##### 3. 视觉适配器（Visual Adapter）\n+##### 3. 视觉服务（Visual Service）\n - **职责**：处理视觉表现，调用用例输出\n - **功能**：\n   - 播放战斗动画\n   - 播放特效\n   - 更新UI显示\n   - 处理相机控制\n - **框架依赖**：Unity引擎、Visual系统\n \n-##### 4. 数据适配器（Data Adapter）\n+##### 4. 数据服务（Data Service）\n - **职责**：处理数据访问，调用用例\n - **功能**：\n   - 读取战斗配置\n   - 保存战斗数据\n   - 查询单位数据\n   - 更新战斗状态\n - **框架依赖**：数据库、DataHandleQueue\n \n-##### 5. 通信适配器（Communication Adapter）\n+##### 5. 通信服务（Communication Service）\n - **职责**：处理系统间通信，调用用例\n - **功能**：\n   - 发布战斗事件\n   - 订阅系统消息\n   - 处理跨系统通信\n   - 管理通信上下文\n - **框架依赖**：CommunicationBus\n \n+### 服务间交互关系\n+\n+**说明**：服务层内的服务可以相互交互，形成完整的功能流程。\n+\n+```mermaid\n+graph LR\n+    subgraph \"服务层 - 服务交互\"\n+        InputService[输入服务<br/>Input Service]\n+        ActionService[行动服务<br/>Action Service]\n+        VisualService[视觉服务<br/>Visual Service]\n+        DataService[数据服务<br/>Data Service]\n+        CommunicationService[通信服务<br/>Communication Service]\n+        \n+        InputService -->|输入驱动| ActionService\n+        ActionService -->|行动触发| VisualService\n+        ActionService -->|行动更新| DataService\n+        DataService -->|数据触发| CommunicationService\n+        CommunicationService -->|通信触发| VisualService\n+    end\n+    \n+    style InputService fill:#fff4e1\n+    style ActionService fill:#e8f5e9\n+    style VisualService fill:#e1f5ff\n+    style DataService fill:#ffebee\n+    style CommunicationService fill:#c8e6c9\n+```\n+\n ### 单位循环内的功能流程\n \n-**说明**：单位循环内的功能流程通过接口适配器层实现。\n+**说明**：单位循环内的功能流程通过服务层实现。\n \n ```mermaid\n graph TB\n     subgraph \"单位循环 - 用例层\"\n         ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n     end\n     \n-    subgraph \"接口适配器层 - 功能流程\"\n-        InputAdapter[输入适配器<br/>接收输入]\n-        ActionAdapter[行动适配器<br/>执行行动]\n-        VisualAdapter[视觉适配器<br/>播放表现]\n-        DataAdapter[数据适配器<br/>更新数据]\n+    subgraph \"服务层 - 功能流程\"\n+        InputService[输入服务<br/>接收输入]\n+        ActionService[行动服务<br/>执行行动]\n+        VisualService[视觉服务<br/>播放表现]\n+        DataService[数据服务<br/>更新数据]\n     end\n     \n     subgraph \"框架层 - 技术实现\"\n         Unity[Unity引擎]\n         Lua[Lua脚本]\n         Database[(数据库)]\n     end\n     \n-    InputAdapter --> ExecuteUnitUC\n-    ExecuteUnitUC --> ActionAdapter\n-    ActionAdapter --> VisualAdapter\n-    VisualAdapter --> DataAdapter\n+    InputService --> ExecuteUnitUC\n+    ExecuteUnitUC --> ActionService\n+    ActionService --> VisualService\n+    VisualService --> DataService\n     \n-    Unity --> VisualAdapter\n-    Lua --> ActionAdapter\n-    Database --> DataAdapter\n+    Unity --> VisualService\n+    Lua --> ActionService\n+    Database --> DataService\n     \n     style ExecuteUnitUC fill:#fff4e1\n-    style InputAdapter fill:#e8f5e9\n+    style InputService fill:#e8f5e9\n     style Unity fill:#e1f5ff\n ```\n \n ## 框架层详细设计（Frameworks & Drivers Layer）\n@@ -506,26 +761,26 @@\n         Formula[公式引擎<br/>Formula Parser<br/>公式计算]\n         Pool[对象池<br/>Object Pool<br/>对象管理]\n     end\n     \n-    subgraph \"接口适配器层 - 适配器\"\n-        VisualAdapter[视觉适配器]\n-        ActionAdapter[行动适配器]\n-        DataAdapter[数据适配器]\n-        CommunicationAdapter[通信适配器]\n+    subgraph \"服务层 - 服务\"\n+        VisualService[视觉服务]\n+        ActionService[行动服务]\n+        DataService[数据服务]\n+        CommunicationService[通信服务]\n     end\n     \n-    Unity --> VisualAdapter\n-    Lua --> ActionAdapter\n-    Database --> DataAdapter\n-    FSM --> VisualAdapter\n-    CommunicationBus --> CommunicationAdapter\n-    DataHandleQueue --> DataAdapter\n-    Formula --> ActionAdapter\n-    Pool --> VisualAdapter\n+    Unity --> VisualService\n+    Lua --> ActionService\n+    Database --> DataService\n+    FSM --> VisualService\n+    CommunicationBus --> CommunicationService\n+    DataHandleQueue --> DataService\n+    Formula --> ActionService\n+    Pool --> VisualService\n     \n     style Unity fill:#e1f5ff\n-    style VisualAdapter fill:#e8f5e9\n+    style VisualService fill:#e8f5e9\n ```\n \n #### 框架职责说明\n \n@@ -639,12 +894,12 @@\n - **位置**：框架层\n - **形式**：Excel配置表、JSON配置文件、Lua配置脚本\n - **内容**：战斗规则、伤害计算、效果应用、回合流程、状态转换\n \n-#### 2. 配置数据读取（接口适配器层）\n-- **位置**：接口适配器层（数据适配器）\n+#### 2. 配置数据读取（服务层）\n+- **位置**：服务层（数据服务）\n - **功能**：读取配置数据，转换为用例可用的格式\n-- **组件**：DataAdapter、ConfigLoader\n+- **组件**：DataService、ConfigLoader\n \n #### 3. 配置数据应用（用例层）\n - **位置**：用例层\n - **功能**：使用配置数据驱动业务逻辑\n@@ -671,17 +926,17 @@\n     \n     subgraph \"Clean架构层次\"\n         Entities[实体层<br/>四层循环实体]\n         UseCases[用例层<br/>循环用例]\n-        Adapters[适配器层<br/>功能适配器]\n+        Services[服务层<br/>功能服务]\n         Frameworks[框架层<br/>配置数据]\n     end\n     \n     Loop --> Entities\n     Loop --> UseCases\n     DataDriven --> Frameworks\n-    DataDriven --> Adapters\n-    Layered --> Adapters\n+        DataDriven --> Services\n+        Layered --> Services\n     \n     style Loop fill:#ffebee\n     style Entities fill:#ffebee\n ```\n@@ -699,28 +954,28 @@\n - 实现循环的执行用例（执行战斗、执行回合、执行单位）\n - 协调实体完成循环流程\n - 管理循环的生命周期\n \n-#### 2. 数据驱动架构 → 框架层 + 接口适配器层\n+#### 2. 数据驱动架构 → 框架层 + 服务层\n \n **框架层**：\n - 存储配置数据（Excel、JSON、Lua）\n - 提供配置数据访问接口\n - 管理配置数据的加载和更新\n \n-**接口适配器层**：\n-- 读取配置数据（数据适配器）\n+**服务层**：\n+- 读取配置数据（数据服务）\n - 将配置数据转换为用例可用的格式\n - 应用配置数据驱动业务逻辑\n \n-#### 3. 分层架构（功能组织）→ 接口适配器层\n+#### 3. 分层架构（功能组织）→ 服务层\n \n-**接口适配器层**：\n-- 输入适配器：处理输入功能\n-- 行动适配器：处理执行功能\n-- 视觉适配器：处理表现功能\n-- 数据适配器：处理数据功能\n-- 通信适配器：处理通信功能\n+**服务层**：\n+- 输入服务：处理输入功能\n+- 行动服务：处理执行功能\n+- 视觉服务：处理表现功能\n+- 数据服务：处理数据功能\n+- 通信服务：处理通信功能\n \n ---\n \n ## Clean架构的优势\n@@ -765,9 +1020,9 @@\n - **优势**：提高测试覆盖率，保证代码质量\n \n #### 3. 技术无关性\n - **框架层**：Unity、Lua、数据库等技术可以被替换\n-- **接口适配器层**：通过适配器隔离技术细节\n+- **服务层**：通过服务隔离技术细节\n - **优势**：可以轻松替换技术栈，不影响业务逻辑\n \n #### 4. 可维护性\n - **依赖方向清晰**：从外向内，易于理解\n@@ -775,9 +1030,9 @@\n - **优势**：代码组织清晰，易于理解和修改\n \n #### 5. 可扩展性\n - **新增用例**：只需在用例层添加新用例，不影响现有代码\n-- **新增适配器**：只需在适配器层添加新适配器，不影响用例\n+- **新增服务**：只需在服务层添加新服务，不影响用例\n - **优势**：易于扩展新功能，不影响现有系统\n \n ---\n \n@@ -788,9 +1043,9 @@\n ```mermaid\n graph TD\n     Start[开始实施] --> Step1[1. 设计实体层<br/>定义四层循环实体]\n     Step1 --> Step2[2. 设计用例层<br/>定义战斗用例]\n-    Step2 --> Step3[3. 设计适配器层<br/>定义功能适配器]\n+    Step2 --> Step3[3. 设计服务层<br/>定义功能服务]\n     Step3 --> Step4[4. 集成框架层<br/>集成Unity/Lua等]\n     Step4 --> Step5[5. 实现数据驱动<br/>配置数据读取和应用]\n     Step5 --> End[完成]\n     \n@@ -806,13 +1061,13 @@\n 1. **实体层**：定义战斗、回合、阵营、单位实体\n 2. **用例层**：实现执行战斗、执行回合、执行单位用例\n 3. **框架层**：集成状态机框架，实现层次状态机\n \n-#### 第二阶段：功能适配器\n-1. **输入适配器**：实现玩家输入和AI输入处理\n-2. **行动适配器**：实现行动执行逻辑\n-3. **视觉适配器**：实现视觉表现处理\n-4. **数据适配器**：实现数据访问和配置读取\n+#### 第二阶段：功能服务\n+1. **输入服务**：实现玩家输入和AI输入处理\n+2. **行动服务**：实现行动执行逻辑\n+3. **视觉服务**：实现视觉表现处理\n+4. **数据服务**：实现数据访问和配置读取\n \n #### 第三阶段：框架集成\n 1. **Unity集成**：集成Unity引擎，实现视觉表现\n 2. **Lua集成**：集成Lua脚本，实现业务逻辑\n@@ -830,20 +1085,20 @@\n - 🎯 **业务逻辑独立**：四层循环的业务规则完全独立于框架和技术\n - 🧪 **高度可测试**：实体和用例可以独立测试，无需Unity/Lua\n - 🔄 **技术无关**：可以轻松替换Unity、Lua、数据库等技术栈\n - 📐 **依赖清晰**：依赖方向从外向内，易于理解和维护\n-- 📈 **易于扩展**：新增功能只需添加用例或适配器，不影响现有代码\n+- 📈 **易于扩展**：新增功能只需添加用例或服务，不影响现有代码\n \n ### 架构映射\n \n - **实体层** = 四层循环实体（战斗、回合、阵营、单位）\n - **用例层** = 战斗用例（执行战斗、执行回合、执行单位）\n-- **接口适配器层** = 功能服务（输入、执行、表现、数据、通信）\n+- **服务层** = 功能服务（输入、执行、表现、数据、通信）\n - **框架层** = 技术实现（Unity、Lua、数据库、FSM、CommunicationBus、DataHandleQueue）\n \n ### 设计理念对应\n \n - **多层循环架构** → 实体层 + 用例层\n-- **数据驱动架构** → 框架层 + 接口适配器层\n-- **分层架构（功能组织）** → 接口适配器层\n+- **数据驱动架构** → 框架层 + 服务层\n+- **分层架构（功能组织）** → 服务层\n \n Clean架构是构建可维护、可测试、可扩展战斗系统的优秀选择，特别适合需要长期维护和持续演进的战斗系统。\n"
                },
                {
                    "date": 1767100803991,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -867,18 +867,18 @@\n         subgraph \"用例层\"\n             UseCase[用例<br/>应用逻辑<br/>配置数据驱动流程]\n         end\n         \n-        subgraph \"接口适配器层\"\n-            Adapter[适配器<br/>数据转换<br/>配置数据映射]\n+        subgraph \"服务层\"\n+            Service[服务<br/>数据转换<br/>配置数据映射]\n         end\n         \n         subgraph \"框架层\"\n             Config[配置数据<br/>Excel/JSON/Lua<br/>数据驱动源]\n         end\n         \n-        Config -.驱动.-> Adapter\n-        Adapter -.使用.-> UseCase\n+        Config -.驱动.-> Service\n+        Service -.使用.-> UseCase\n         UseCase -.应用.-> Entity\n         Config -.定义.-> Entity\n     end\n     \n@@ -1002,9 +1002,9 @@\n       职责分离明确\n       易于理解\n     可扩展性\n       新增用例\n-      新增适配器\n+      新增服务\n       不影响现有代码\n ```\n \n ### 具体优势说明\n"
                },
                {
                    "date": 1767100820227,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -883,9 +883,9 @@\n     end\n     \n     style Entity fill:#ffebee\n     style UseCase fill:#fff4e1\n-    style Adapter fill:#e8f5e9\n+    style Service fill:#e8f5e9\n     style Config fill:#e1f5ff\n ```\n \n ### 数据驱动的实现方式\n"
                },
                {
                    "date": 1767101028032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -740,365 +740,4 @@\n     style InputService fill:#e8f5e9\n     style Unity fill:#e1f5ff\n ```\n \n-## 框架层详细设计（Frameworks & Drivers Layer）\n-\n-### 技术框架\n-\n-**说明**：框架层提供具体的技术实现，可以被替换而不影响业务逻辑。\n-\n-#### 框架层次结构\n-\n-```mermaid\n-graph TB\n-    subgraph \"框架层 - 技术框架\"\n-        Unity[Unity引擎<br/>Unity Engine<br/>渲染、物理、动画]\n-        Lua[Lua脚本引擎<br/>Lua Script Engine<br/>业务逻辑]\n-        Database[(数据库<br/>Database<br/>数据持久化)]\n-        FSM[状态机框架<br/>FSM Framework<br/>状态管理]\n-        CommunicationBus[通信总线<br/>CommunicationBus<br/>系统通信]\n-        DataHandleQueue[数据队列<br/>DataHandleQueue<br/>数据处理]\n-        Formula[公式引擎<br/>Formula Parser<br/>公式计算]\n-        Pool[对象池<br/>Object Pool<br/>对象管理]\n-    end\n-    \n-    subgraph \"服务层 - 服务\"\n-        VisualService[视觉服务]\n-        ActionService[行动服务]\n-        DataService[数据服务]\n-        CommunicationService[通信服务]\n-    end\n-    \n-    Unity --> VisualService\n-    Lua --> ActionService\n-    Database --> DataService\n-    FSM --> VisualService\n-    CommunicationBus --> CommunicationService\n-    DataHandleQueue --> DataService\n-    Formula --> ActionService\n-    Pool --> VisualService\n-    \n-    style Unity fill:#e1f5ff\n-    style VisualService fill:#e8f5e9\n-```\n-\n-#### 框架职责说明\n-\n-##### 1. Unity引擎（Unity Engine）\n-- **职责**：提供游戏引擎功能\n-- **功能**：\n-  - 渲染系统（3D渲染、UI渲染）\n-  - 物理系统（碰撞检测、物理模拟）\n-  - 动画系统（动画播放、动画控制）\n-  - 音频系统（音效播放、背景音乐）\n-  - 资源管理（资源加载、资源释放）\n-\n-##### 2. Lua脚本引擎（Lua Script Engine）\n-- **职责**：执行业务逻辑脚本\n-- **功能**：\n-  - 脚本解析和执行\n-  - 业务逻辑实现\n-  - 配置数据读取\n-  - 热更新支持\n-\n-##### 3. 数据库（Database）\n-- **职责**：数据持久化\n-- **功能**：\n-  - 战斗配置存储\n-  - 战斗数据保存\n-  - 单位数据查询\n-  - 历史记录存储\n-\n-##### 4. 状态机框架（FSM Framework）\n-- **职责**：状态管理\n-- **功能**：\n-  - 层次状态机（HierarchicalFSM）\n-  - 基础状态机（FSMBase）\n-  - 状态转换管理\n-  - 状态生命周期管理\n-\n-##### 5. 通信总线（CommunicationBus）\n-- **职责**：系统间通信\n-- **功能**：\n-  - 事件发布订阅（Event Channel）\n-  - 消息传递（Message Channel）\n-  - 数据推送（Push Channel）\n-  - 数据查询（Query Channel）\n-\n-##### 6. 数据队列（DataHandleQueue）\n-- **职责**：数据处理\n-- **功能**：\n-  - 数据推送和处理\n-- **数据查询**（Query Delegate）\n-- **批量处理**\n-- **数据同步**\n-\n-##### 7. 公式引擎（Formula Parser）\n-- **职责**：公式计算\n-- **功能**：\n-  - 三级公式解析\n-  - 公式计算\n-  - 公式缓存\n-  - 公式验证\n-\n-##### 8. 对象池（Object Pool）\n-- **职责**：对象管理\n-- **功能**：\n-  - 对象复用\n-  - 对象预加载\n-  - 对象生命周期管理\n-  - 性能优化\n-\n----\n-\n-## 数据驱动架构在Clean架构中的位置\n-\n-### 数据驱动架构的层次分布\n-\n-**说明**：数据驱动架构贯穿Clean架构的所有层次，但主要作用在不同层次。\n-\n-```mermaid\n-graph TB\n-    subgraph \"Clean架构 + 数据驱动\"\n-        subgraph \"实体层\"\n-            Entity[实体<br/>业务规则<br/>配置数据定义规则]\n-        end\n-        \n-        subgraph \"用例层\"\n-            UseCase[用例<br/>应用逻辑<br/>配置数据驱动流程]\n-        end\n-        \n-        subgraph \"服务层\"\n-            Service[服务<br/>数据转换<br/>配置数据映射]\n-        end\n-        \n-        subgraph \"框架层\"\n-            Config[配置数据<br/>Excel/JSON/Lua<br/>数据驱动源]\n-        end\n-        \n-        Config -.驱动.-> Service\n-        Service -.使用.-> UseCase\n-        UseCase -.应用.-> Entity\n-        Config -.定义.-> Entity\n-    end\n-    \n-    style Entity fill:#ffebee\n-    style UseCase fill:#fff4e1\n-    style Service fill:#e8f5e9\n-    style Config fill:#e1f5ff\n-```\n-\n-### 数据驱动的实现方式\n-\n-#### 1. 配置数据存储（框架层）\n-- **位置**：框架层\n-- **形式**：Excel配置表、JSON配置文件、Lua配置脚本\n-- **内容**：战斗规则、伤害计算、效果应用、回合流程、状态转换\n-\n-#### 2. 配置数据读取（服务层）\n-- **位置**：服务层（数据服务）\n-- **功能**：读取配置数据，转换为用例可用的格式\n-- **组件**：DataService、ConfigLoader\n-\n-#### 3. 配置数据应用（用例层）\n-- **位置**：用例层\n-- **功能**：使用配置数据驱动业务逻辑\n-- **示例**：根据配置数据执行战斗流程、计算伤害、应用效果\n-\n-#### 4. 配置数据定义规则（实体层）\n-- **位置**：实体层\n-- **功能**：配置数据定义的业务规则\n-- **示例**：战斗规则、回合规则、单位规则\n-\n----\n-\n-## Clean架构与核心设计理念的对应关系\n-\n-### 设计理念映射\n-\n-```mermaid\n-graph TB\n-    subgraph \"核心设计理念\"\n-        Loop[多层循环架构<br/>四层循环]\n-        DataDriven[数据驱动架构<br/>配置驱动]\n-        Layered[分层架构<br/>功能组织]\n-    end\n-    \n-    subgraph \"Clean架构层次\"\n-        Entities[实体层<br/>四层循环实体]\n-        UseCases[用例层<br/>循环用例]\n-        Services[服务层<br/>功能服务]\n-        Frameworks[框架层<br/>配置数据]\n-    end\n-    \n-    Loop --> Entities\n-    Loop --> UseCases\n-    DataDriven --> Frameworks\n-        DataDriven --> Services\n-        Layered --> Services\n-    \n-    style Loop fill:#ffebee\n-    style Entities fill:#ffebee\n-```\n-\n-### 对应关系说明\n-\n-#### 1. 多层循环架构 → 实体层 + 用例层\n-\n-**实体层**：\n-- 定义四层循环的实体模型（战斗、回合、阵营、单位）\n-- 包含循环的业务规则\n-- 定义循环的状态和转换条件\n-\n-**用例层**：\n-- 实现循环的执行用例（执行战斗、执行回合、执行单位）\n-- 协调实体完成循环流程\n-- 管理循环的生命周期\n-\n-#### 2. 数据驱动架构 → 框架层 + 服务层\n-\n-**框架层**：\n-- 存储配置数据（Excel、JSON、Lua）\n-- 提供配置数据访问接口\n-- 管理配置数据的加载和更新\n-\n-**服务层**：\n-- 读取配置数据（数据服务）\n-- 将配置数据转换为用例可用的格式\n-- 应用配置数据驱动业务逻辑\n-\n-#### 3. 分层架构（功能组织）→ 服务层\n-\n-**服务层**：\n-- 输入服务：处理输入功能\n-- 行动服务：处理执行功能\n-- 视觉服务：处理表现功能\n-- 数据服务：处理数据功能\n-- 通信服务：处理通信功能\n-\n----\n-\n-## Clean架构的优势\n-\n-### 对战斗系统的价值\n-\n-```mermaid\n-mindmap\n-  root((Clean架构优势))\n-    业务逻辑独立\n-      实体层独立\n-      用例层独立\n-      不依赖框架\n-    可测试性\n-      实体可独立测试\n-      用例可独立测试\n-      无需Unity/Lua\n-    技术无关性\n-      可替换Unity\n-      可替换Lua\n-      可替换数据库\n-    可维护性\n-      依赖方向清晰\n-      职责分离明确\n-      易于理解\n-    可扩展性\n-      新增用例\n-      新增服务\n-      不影响现有代码\n-```\n-\n-### 具体优势说明\n-\n-#### 1. 业务逻辑独立\n-- **实体层**：四层循环的业务规则完全独立，不依赖Unity、Lua等技术\n-- **用例层**：战斗用例可以独立实现，不依赖框架\n-- **优势**：业务逻辑稳定，技术变化不影响业务\n-\n-#### 2. 可测试性\n-- **实体层**：可以独立测试实体和业务规则\n-- **用例层**：可以独立测试用例逻辑，无需Unity引擎\n-- **优势**：提高测试覆盖率，保证代码质量\n-\n-#### 3. 技术无关性\n-- **框架层**：Unity、Lua、数据库等技术可以被替换\n-- **服务层**：通过服务隔离技术细节\n-- **优势**：可以轻松替换技术栈，不影响业务逻辑\n-\n-#### 4. 可维护性\n-- **依赖方向清晰**：从外向内，易于理解\n-- **职责分离明确**：每层职责单一，易于维护\n-- **优势**：代码组织清晰，易于理解和修改\n-\n-#### 5. 可扩展性\n-- **新增用例**：只需在用例层添加新用例，不影响现有代码\n-- **新增服务**：只需在服务层添加新服务，不影响用例\n-- **优势**：易于扩展新功能，不影响现有系统\n-\n----\n-\n-## 实施建议\n-\n-### Clean架构实施步骤\n-\n-```mermaid\n-graph TD\n-    Start[开始实施] --> Step1[1. 设计实体层<br/>定义四层循环实体]\n-    Step1 --> Step2[2. 设计用例层<br/>定义战斗用例]\n-    Step2 --> Step3[3. 设计服务层<br/>定义功能服务]\n-    Step3 --> Step4[4. 集成框架层<br/>集成Unity/Lua等]\n-    Step4 --> Step5[5. 实现数据驱动<br/>配置数据读取和应用]\n-    Step5 --> End[完成]\n-    \n-    style Step1 fill:#ffebee\n-    style Step2 fill:#fff4e1\n-    style Step3 fill:#e8f5e9\n-    style Step4 fill:#e1f5ff\n-```\n-\n-### 实施优先级\n-\n-#### 第一阶段：核心实体和用例\n-1. **实体层**：定义战斗、回合、阵营、单位实体\n-2. **用例层**：实现执行战斗、执行回合、执行单位用例\n-3. **框架层**：集成状态机框架，实现层次状态机\n-\n-#### 第二阶段：功能服务\n-1. **输入服务**：实现玩家输入和AI输入处理\n-2. **行动服务**：实现行动执行逻辑\n-3. **视觉服务**：实现视觉表现处理\n-4. **数据服务**：实现数据访问和配置读取\n-\n-#### 第三阶段：框架集成\n-1. **Unity集成**：集成Unity引擎，实现视觉表现\n-2. **Lua集成**：集成Lua脚本，实现业务逻辑\n-3. **数据库集成**：集成数据库，实现数据持久化\n-4. **通信集成**：集成CommunicationBus，实现系统通信\n-\n----\n-\n-## 总结\n-\n-战斗系统采用Clean架构模式，将系统组织成四个同心圆层，业务规则在中心，框架和技术在外围。\n-\n-### 核心价值\n-\n-- 🎯 **业务逻辑独立**：四层循环的业务规则完全独立于框架和技术\n-- 🧪 **高度可测试**：实体和用例可以独立测试，无需Unity/Lua\n-- 🔄 **技术无关**：可以轻松替换Unity、Lua、数据库等技术栈\n-- 📐 **依赖清晰**：依赖方向从外向内，易于理解和维护\n-- 📈 **易于扩展**：新增功能只需添加用例或服务，不影响现有代码\n-\n-### 架构映射\n-\n-- **实体层** = 四层循环实体（战斗、回合、阵营、单位）\n-- **用例层** = 战斗用例（执行战斗、执行回合、执行单位）\n-- **服务层** = 功能服务（输入、执行、表现、数据、通信）\n-- **框架层** = 技术实现（Unity、Lua、数据库、FSM、CommunicationBus、DataHandleQueue）\n-\n-### 设计理念对应\n-\n-- **多层循环架构** → 实体层 + 用例层\n-- **数据驱动架构** → 框架层 + 服务层\n-- **分层架构（功能组织）** → 服务层\n-\n-Clean架构是构建可维护、可测试、可扩展战斗系统的优秀选择，特别适合需要长期维护和持续演进的战斗系统。\n"
                },
                {
                    "date": 1767101072320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,67 +321,8 @@\n ### 四层循环实体模型\n \n **核心观点**：战斗系统的核心是四层循环的维护和管理，这些循环在实体层中定义。\n \n-#### 循环层次关系\n-\n-```mermaid\n-graph TB\n-    subgraph \"实体层 - 四层循环模型\"\n-        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]\n-        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]\n-        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]\n-        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]\n-        \n-        BattleEntity --> RoundEntity\n-        RoundEntity --> TeamEntity\n-        TeamEntity --> UnitEntity\n-    end\n-    \n-    subgraph \"循环状态\"\n-        BattleState[战斗状态<br/>PREPARING/IN_PROGRESS/ENDED]\n-        RoundState[回合状态<br/>ROUND_START/ACTION/END]\n-        TeamState[阵营状态<br/>TEAM_START/ACTION/END]\n-        UnitState[单位状态<br/>UNIT_START/ACTION/END]\n-    end\n-    \n-    BattleEntity --> BattleState\n-    RoundEntity --> RoundState\n-    TeamEntity --> TeamState\n-    UnitEntity --> UnitState\n-    \n-    style BattleEntity fill:#ffebee\n-    style RoundEntity fill:#fff4e1\n-    style TeamEntity fill:#c8e6c9\n-    style UnitEntity fill:#e1f5ff\n-```\n-\n-#### 实体职责说明\n-\n-##### 1. 战斗实体（Battle Entity）\n-- **职责**：管理整个战斗的生命周期\n-- **状态**：BattleState（PREPARING/IN_PROGRESS/PAUSED/ENDED）\n-- **循环**：战斗循环（BattleLoop）\n-- **业务规则**：战斗开始/结束条件、胜负判定\n-\n-##### 2. 回合实体（Round Entity）\n-- **职责**：管理回合的循环和切换\n-- **状态**：RoundState（ROUND_START/ROUND_ACTION/ROUND_END）\n-- **循环**：回合循环（RoundLoop）\n-- **业务规则**：回合开始/结束条件、回合数限制\n-\n-##### 3. 阵营实体（Team Entity）\n-- **职责**：管理阵营内单位的行动顺序\n-- **状态**：TeamState（TEAM_START/TEAM_ACTION/TEAM_END）\n-- **循环**：阵营循环（TeamLoop）\n-- **业务规则**：阵营切换规则、行动顺序规则\n-\n-##### 4. 单位实体（Unit Entity）\n-- **职责**：管理单个单位的行动流程\n-- **状态**：UnitState（UNIT_START/UNIT_ACTION/UNIT_END）\n-- **循环**：单位循环（UnitLoop）\n-- **业务规则**：单位行动规则、行动完成条件\n-\n ### 层次状态机实现（框架层）\n \n **说明**：层次状态机是框架层的实现，用于管理实体层的状态转换。\n \n@@ -507,237 +448,5 @@\n     Main->>Main: 激活结果状态机\n ```\n ---\n \n-## 用例层详细设计（Use Cases Layer）\n \n-### 核心用例\n-\n-**说明**：用例层实现具体的战斗用例，协调实体完成业务目标。\n-\n-#### 用例层次结构\n-\n-```mermaid\n-graph TB\n-    subgraph \"用例层 - 战斗用例\"\n-        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle UseCase]\n-        ExecuteRoundUC[执行回合用例<br/>ExecuteRound UseCase]\n-        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam UseCase]\n-        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n-        CalculateDamageUC[计算伤害用例<br/>CalculateDamage UseCase]\n-        ApplyEffectUC[应用效果用例<br/>ApplyEffect UseCase]\n-    end\n-    \n-    subgraph \"实体层 - 业务实体\"\n-        BattleEntity[战斗实体]\n-        RoundEntity[回合实体]\n-        TeamEntity[阵营实体]\n-        UnitEntity[单位实体]\n-        SkillEntity[技能实体]\n-        EffectEntity[效果实体]\n-    end\n-    \n-    ExecuteBattleUC --> BattleEntity\n-    ExecuteRoundUC --> RoundEntity\n-    ExecuteTeamUC --> TeamEntity\n-    ExecuteUnitUC --> UnitEntity\n-    CalculateDamageUC --> SkillEntity\n-    ApplyEffectUC --> EffectEntity\n-    \n-    style ExecuteBattleUC fill:#fff4e1\n-    style BattleEntity fill:#ffebee\n-```\n-\n-#### 用例职责说明\n-\n-##### 1. 执行战斗用例（ExecuteBattle UseCase）\n-- **职责**：协调战斗实体执行战斗流程\n-- **输入**：战斗配置、参与者列表\n-- **输出**：战斗结果\n-- **协调实体**：战斗实体、回合实体\n-\n-##### 2. 执行回合用例（ExecuteRound UseCase）\n-- **职责**：协调回合实体执行回合流程\n-- **输入**：回合编号、回合配置\n-- **输出**：回合结果\n-- **协调实体**：回合实体、阵营实体\n-\n-##### 3. 执行阵营用例（ExecuteTeam UseCase）\n-- **职责**：协调阵营实体执行阵营流程\n-- **输入**：阵营信息、单位列表\n-- **输出**：阵营行动结果\n-- **协调实体**：阵营实体、单位实体\n-\n-##### 4. 执行单位用例（ExecuteUnit UseCase）\n-- **职责**：协调单位实体执行单位行动\n-- **输入**：单位信息、行动指令\n-- **输出**：行动结果\n-- **协调实体**：单位实体、技能实体\n-\n-##### 5. 计算伤害用例（CalculateDamage UseCase）\n-- **职责**：计算技能伤害\n-- **输入**：技能信息、攻击者、目标\n-- **输出**：伤害数值\n-- **协调实体**：技能实体、单位实体\n-\n-##### 6. 应用效果用例（ApplyEffect UseCase）\n-- **职责**：应用技能效果\n-- **输入**：效果信息、目标\n-- **输出**：效果应用结果\n-- **协调实体**：效果实体、单位实体\n-\n-## 服务层详细设计（Services Layer）\n-\n-### 功能服务\n-\n-**说明**：服务层提供功能服务，将用例层的输出转换为框架层可以使用的格式，同时将框架层的输入转换为用例层可以使用的格式。\n-\n-#### 服务层次结构\n-\n-```mermaid\n-graph TB\n-    subgraph \"服务层 - 功能服务\"\n-        InputService[输入服务<br/>Input Service]\n-        ActionService[行动服务<br/>Action Service]\n-        VisualService[视觉服务<br/>Visual Service]\n-        DataService[数据服务<br/>Data Service]\n-        CommunicationService[通信服务<br/>Communication Service]\n-    end\n-    \n-    subgraph \"用例层 - 用例\"\n-        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n-    end\n-    \n-    subgraph \"框架层 - 框架\"\n-        Unity[Unity引擎]\n-        Lua[Lua脚本]\n-        Database[(数据库)]\n-        CommunicationBus[通信总线]\n-    end\n-    \n-    InputService --> ExecuteUnitUC\n-    ActionService --> ExecuteUnitUC\n-    VisualService --> ExecuteUnitUC\n-    DataService --> ExecuteUnitUC\n-    CommunicationService --> ExecuteUnitUC\n-    \n-    Unity --> VisualService\n-    Lua --> ActionService\n-    Database --> DataService\n-    CommunicationBus --> CommunicationService\n-    \n-    style InputService fill:#e8f5e9\n-    style ExecuteUnitUC fill:#fff4e1\n-    style Unity fill:#e1f5ff\n-```\n-\n-#### 服务职责说明\n-\n-##### 1. 输入服务（Input Service）\n-- **职责**：处理玩家输入和AI输入，转换为用例输入\n-- **功能**：\n-  - 接收玩家输入（UI交互、键盘鼠标）\n-  - 接收AI输入（AI决策结果）\n-  - 验证输入有效性\n-  - 转换为用例输入格式（BattleContext）\n-- **框架依赖**：Unity Input Manager、AI系统\n-\n-##### 2. 行动服务（Action Service）\n-- **职责**：执行行动逻辑，调用用例\n-- **功能**：\n-  - 验证行动合法性\n-  - 执行行动逻辑\n-  - 调用执行单位用例\n-  - 处理行动结果\n-- **框架依赖**：Lua脚本引擎、技能系统\n-\n-##### 3. 视觉服务（Visual Service）\n-- **职责**：处理视觉表现，调用用例输出\n-- **功能**：\n-  - 播放战斗动画\n-  - 播放特效\n-  - 更新UI显示\n-  - 处理相机控制\n-- **框架依赖**：Unity引擎、Visual系统\n-\n-##### 4. 数据服务（Data Service）\n-- **职责**：处理数据访问，调用用例\n-- **功能**：\n-  - 读取战斗配置\n-  - 保存战斗数据\n-  - 查询单位数据\n-  - 更新战斗状态\n-- **框架依赖**：数据库、DataHandleQueue\n-\n-##### 5. 通信服务（Communication Service）\n-- **职责**：处理系统间通信，调用用例\n-- **功能**：\n-  - 发布战斗事件\n-  - 订阅系统消息\n-  - 处理跨系统通信\n-  - 管理通信上下文\n-- **框架依赖**：CommunicationBus\n-\n-### 服务间交互关系\n-\n-**说明**：服务层内的服务可以相互交互，形成完整的功能流程。\n-\n-```mermaid\n-graph LR\n-    subgraph \"服务层 - 服务交互\"\n-        InputService[输入服务<br/>Input Service]\n-        ActionService[行动服务<br/>Action Service]\n-        VisualService[视觉服务<br/>Visual Service]\n-        DataService[数据服务<br/>Data Service]\n-        CommunicationService[通信服务<br/>Communication Service]\n-        \n-        InputService -->|输入驱动| ActionService\n-        ActionService -->|行动触发| VisualService\n-        ActionService -->|行动更新| DataService\n-        DataService -->|数据触发| CommunicationService\n-        CommunicationService -->|通信触发| VisualService\n-    end\n-    \n-    style InputService fill:#fff4e1\n-    style ActionService fill:#e8f5e9\n-    style VisualService fill:#e1f5ff\n-    style DataService fill:#ffebee\n-    style CommunicationService fill:#c8e6c9\n-```\n-\n-### 单位循环内的功能流程\n-\n-**说明**：单位循环内的功能流程通过服务层实现。\n-\n-```mermaid\n-graph TB\n-    subgraph \"单位循环 - 用例层\"\n-        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n-    end\n-    \n-    subgraph \"服务层 - 功能流程\"\n-        InputService[输入服务<br/>接收输入]\n-        ActionService[行动服务<br/>执行行动]\n-        VisualService[视觉服务<br/>播放表现]\n-        DataService[数据服务<br/>更新数据]\n-    end\n-    \n-    subgraph \"框架层 - 技术实现\"\n-        Unity[Unity引擎]\n-        Lua[Lua脚本]\n-        Database[(数据库)]\n-    end\n-    \n-    InputService --> ExecuteUnitUC\n-    ExecuteUnitUC --> ActionService\n-    ActionService --> VisualService\n-    VisualService --> DataService\n-    \n-    Unity --> VisualService\n-    Lua --> ActionService\n-    Database --> DataService\n-    \n-    style ExecuteUnitUC fill:#fff4e1\n-    style InputService fill:#e8f5e9\n-    style Unity fill:#e1f5ff\n-```\n-\n"
                },
                {
                    "date": 1767101143387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,30 +86,8 @@\n     style InputService fill:#e8f5e9\n     style Unity fill:#e1f5ff\n ```\n \n-### Clean架构层次结构\n-\n-```mermaid\n-graph TB\n-    subgraph \"Clean架构同心圆\"\n-        direction TB\n-        Entities[实体层<br/>Entities<br/>核心业务规则<br/>最内层]\n-        UseCases[用例层<br/>Use Cases<br/>应用业务规则]\n-        Services[服务层<br/>Services<br/>功能服务]\n-        Frameworks[框架层<br/>Frameworks & Drivers<br/>技术实现<br/>最外层]\n-        \n-        Frameworks -.依赖.-> Services\n-        Services -.依赖.-> UseCases\n-        UseCases -.依赖.-> Entities\n-    end\n-    \n-    style Entities fill:#ffebee\n-    style UseCases fill:#fff4e1\n-    style Services fill:#e8f5e9\n-    style Frameworks fill:#e1f5ff\n-```\n-\n **依赖规则**：\n - ✅ **允许**：外层依赖内层\n - ❌ **禁止**：内层依赖外层\n - ✅ **允许**：通过接口定义依赖\n@@ -171,152 +149,9 @@\n     \n     Note over Entity: 单位循环结束，返回上层循环\n ```\n \n-### 数据流在Clean架构中的方向\n \n-```mermaid\n-graph LR\n-    subgraph \"数据流向\"\n-        direction TB\n-        \n-        subgraph \"请求流（从外向内）\"\n-            FrameworkReq[框架层<br/>用户输入/系统事件]\n-            ServiceReq[服务层<br/>数据转换]\n-            UseCaseReq[用例层<br/>用例输入]\n-            EntityReq[实体层<br/>实体操作]\n-            \n-            FrameworkReq --> ServiceReq\n-            ServiceReq --> UseCaseReq\n-            UseCaseReq --> EntityReq\n-        end\n-        \n-        subgraph \"响应流（从内向外）\"\n-            EntityResp[实体层<br/>业务结果]\n-            UseCaseResp[用例层<br/>用例输出]\n-            ServiceResp[服务层<br/>数据转换]\n-            FrameworkResp[框架层<br/>UI更新/视觉表现]\n-            \n-            EntityResp --> UseCaseResp\n-            UseCaseResp --> ServiceResp\n-            ServiceResp --> FrameworkResp\n-        end\n-    end\n-    \n-    style FrameworkReq fill:#e1f5ff\n-    style EntityReq fill:#ffebee\n-    style EntityResp fill:#ffebee\n-    style FrameworkResp fill:#e1f5ff\n-```\n-\n-### 各层职责概览\n-\n-#### 1. 实体层（Entities）- 核心业务规则\n-\n-**位置**：最内层，核心业务规则\n-\n-**职责**：\n-- 定义战斗核心实体（战斗、回合、阵营、单位）\n-- 包含企业级业务规则\n-- 定义四层循环的实体模型\n-- 不依赖任何外部框架\n-\n-**核心实体**：\n-- **战斗实体（Battle Entity）**：管理整个战斗的生命周期，包含战斗循环\n-- **回合实体（Round Entity）**：管理回合的循环和切换，包含回合循环\n-- **阵营实体（Team Entity）**：管理阵营内单位的行动顺序，包含阵营循环\n-- **单位实体（Unit Entity）**：管理单个单位的行动流程，包含单位循环\n-- **技能实体（Skill Entity）**：定义技能规则和效果\n-- **效果实体（Effect Entity）**：定义效果规则和应用逻辑\n-\n-**特点**：\n-- 最稳定的一层\n-- 变化频率最低\n-- 包含核心业务概念\n-- 纯业务逻辑，无技术细节\n-\n-#### 2. 用例层（Use Cases）- 应用业务规则\n-\n-**位置**：第二层，应用业务规则\n-\n-**职责**：\n-- 实现具体的战斗用例\n-- 协调实体完成业务目标\n-- 定义应用输入输出接口\n-- 包含应用特定的业务逻辑\n-\n-**核心用例**：\n-- **执行战斗用例（ExecuteBattle）**：协调战斗实体执行战斗流程\n-- **执行回合用例（ExecuteRound）**：协调回合实体执行回合流程\n-- **执行阵营用例（ExecuteTeam）**：协调阵营实体执行阵营流程\n-- **执行单位用例（ExecuteUnit）**：协调单位实体执行单位行动\n-- **计算伤害用例（CalculateDamage）**：计算技能伤害\n-- **应用效果用例（ApplyEffect）**：应用技能效果\n-\n-**特点**：\n-- 依赖实体层\n-- 不依赖框架和UI\n-- 包含应用特定的业务逻辑\n-- 可以独立测试\n-\n-#### 3. 服务层（Services）- 功能服务\n-\n-**位置**：第三层，功能服务层\n-\n-**职责**：\n-- 提供功能服务\n-- 转换数据格式\n-- 适配外部接口\n-- 连接用例和框架\n-\n-**核心服务**：\n-- **输入服务（Input Service）**：处理玩家输入和AI输入，转换为用例输入\n-- **行动服务（Action Service）**：执行行动逻辑，调用用例\n-- **视觉服务（Visual Service）**：处理视觉表现，调用用例输出\n-- **数据服务（Data Service）**：处理数据访问，调用用例\n-- **通信服务（Communication Service）**：处理系统间通信，调用用例\n-\n-**服务间交互**：\n-- 输入服务 → 行动服务（输入驱动行动）\n-- 行动服务 → 视觉服务（行动触发视觉）\n-- 行动服务 → 数据服务（行动更新数据）\n-- 数据服务 → 通信服务（数据触发通信）\n-- 通信服务 → 视觉服务（通信触发视觉）\n-\n-**特点**：\n-- 依赖用例层\n-- 实现框架层定义的接口\n-- 转换数据格式\n-- 提供功能服务\n-\n-#### 4. 框架层（Frameworks & Drivers）- 技术实现\n-\n-**位置**：最外层，技术实现\n-\n-**职责**：\n-- 实现具体的技术细节\n-- 提供框架和工具\n-- 处理外部系统交互\n-- 实现服务层定义的接口\n-\n-**核心框架**：\n-- **Unity引擎**：游戏引擎，提供渲染、物理等功能\n-- **Lua脚本引擎**：脚本语言，实现业务逻辑\n-- **数据库**：数据持久化\n-- **状态机框架（FSM）**：状态管理\n-- **通信总线（CommunicationBus）**：系统间通信\n-- **数据队列（DataHandleQueue）**：数据处理\n-- **公式引擎（Formula Parser）**：公式计算\n-- **对象池（Object Pool）**：对象管理\n-- **配置数据**：Excel/JSON/Lua配置\n-\n-**特点**：\n-- 最外层，技术实现\n-- 可以被替换\n-- 不影响业务逻辑\n-- 提供基础设施\n-\n-\n ## 实体层详细设计（Entities Layer）\n \n ### 四层循环实体模型\n \n"
                },
                {
                    "date": 1767101157842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,9 @@\n         Config[配置数据<br/>Excel/JSON/Lua]\n     end\n     \n     subgraph \"服务层（Services）- 功能服务\"\n-        InputService[输入服务<br/>Input Service<br/>玩家输入/AI输入]\n+        InputService[]\n         ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n         VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n         DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n         CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n"
                },
                {
                    "date": 1767101169058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,10 @@\n         Config[配置数据<br/>Excel/JSON/Lua]\n     end\n     \n     subgraph \"服务层（Services）- 功能服务\"\n-        InputService[]\n+        Input\n+        AI\n         ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n         VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n         DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n         CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n"
                },
                {
                    "date": 1767101180502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     subgraph \"服务层（Services）- 功能服务\"\n         Input\n         AI\n         ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n-        VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n+        VisualSystem[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n         DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n         CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n     end\n     \n"
                },
                {
                    "date": 1767101191840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,10 +31,10 @@\n     subgraph \"服务层（Services）- 功能服务\"\n         Input\n         AI\n         ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n-        VisualSystem[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n-        DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n+        VisualSystem\n+        Data\n         CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n"
                },
                {
                    "date": 1767101196871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n         AI\n         ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n         VisualSystem\n         Data\n-        CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n+        Communicatio\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n         ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n"
                },
                {
                    "date": 1767101213449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n     \n     subgraph \"服务层（Services）- 功能服务\"\n         Input\n         AI\n-        ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n+        Formual[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n         VisualSystem\n         Data\n         Communicatio\n     end\n"
                },
                {
                    "date": 1767101223214,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,12 +30,12 @@\n     \n     subgraph \"服务层（Services）- 功能服务\"\n         Input\n         AI\n-        Formual[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n+        FormulaSystem[公式引擎<br/>Formula Parser]\n         VisualSystem\n         Data\n-        Communicatio\n+        CommunicationSystem\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n         ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n"
                },
                {
                    "date": 1767101229438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,14 +28,14 @@\n         Config[配置数据<br/>Excel/JSON/Lua]\n     end\n     \n     subgraph \"服务层（Services）- 功能服务\"\n-        Input\n-        AI\n+        Input[输入服务<br/>Input Service<br/>玩家输入/AI输入]\n+        AI[AI服务<br/>AI Service<br/>AI决策]\n         FormulaSystem[公式引擎<br/>Formula Parser]\n-        VisualSystem\n-        Data\n-        CommunicationSystem\n+        VisualSystem[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n+        DataSystem[数据服务<br/>Data Service<br/>数据访问/配置读取]\n+        CommunicationSystem[通信服务<br/>Communication Service<br/>事件/消息/查询]\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n         ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n"
                },
                {
                    "date": 1767101246377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,14 +28,13 @@\n         Config[配置数据<br/>Excel/JSON/Lua]\n     end\n     \n     subgraph \"服务层（Services）- 功能服务\"\n-        Input[输入服务<br/>Input Service<br/>玩家输入/AI输入]\n-        AI[AI服务<br/>AI Service<br/>AI决策]\n-        FormulaSystem[公式引擎<br/>Formula Parser]\n-        VisualSystem[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n-        DataSystem[数据服务<br/>Data Service<br/>数据访问/配置读取]\n-        CommunicationSystem[通信服务<br/>Communication Service<br/>事件/消息/查询]\n+        InputService[输入服务<br/>Input Service<br/>玩家输入/AI输入]\n+        ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n+        VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n+        DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n+        CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n         ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n"
                },
                {
                    "date": 1767101719161,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,151 +7,9 @@\n ---\n \n ## 整体架构设计\n \n-### Clean架构模式（主要架构）\n \n-**核心观点**：战斗系统采用Clean架构模式，将系统组织成四个同心圆层，业务规则在中心，框架和技术在外围。\n-\n-### 战斗系统整体架构图\n-\n-```mermaid\n-graph TB\n-    subgraph \"框架层（Frameworks & Drivers）- 技术实现\"\n-        Unity[Unity引擎<br/>渲染/物理/动画]\n-        Lua[Lua脚本引擎<br/>业务逻辑]\n-        Database[(数据库<br/>数据持久化)]\n-        FSM[状态机框架<br/>FSM Framework]\n-        CommunicationBus[通信总线<br/>CommunicationBus]\n-        DataHandleQueue[数据队列<br/>DataHandleQueue]\n-        Formula[公式引擎<br/>Formula Parser]\n-        Pool[对象池<br/>Object Pool]\n-        Config[配置数据<br/>Excel/JSON/Lua]\n-    end\n-    \n-    subgraph \"服务层（Services）- 功能服务\"\n-        InputService[输入服务<br/>Input Service<br/>玩家输入/AI输入]\n-        ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n-        VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n-        DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n-        CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n-    end\n-    \n-    subgraph \"用例层（Use Cases）- 应用业务规则\"\n-        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n-        ExecuteRoundUC[执行回合用例<br/>ExecuteRound]\n-        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam]\n-        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit]\n-        CalculateDamageUC[计算伤害用例<br/>CalculateDamage]\n-        ApplyEffectUC[应用效果用例<br/>ApplyEffect]\n-    end\n-    \n-    subgraph \"实体层（Entities）- 核心业务规则\"\n-        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]\n-        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]\n-        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]\n-        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]\n-        SkillEntity[技能实体<br/>Skill Entity]\n-        EffectEntity[效果实体<br/>Effect Entity]\n-    end\n-    \n-    Unity --> VisualService\n-    Lua --> ActionService\n-    Database --> DataService\n-    FSM --> ExecuteBattleUC\n-    CommunicationBus --> CommunicationService\n-    DataHandleQueue --> DataService\n-    Formula --> ActionService\n-    Pool --> VisualService\n-    Config --> DataService\n-    \n-    InputService --> ExecuteUnitUC\n-    ActionService --> ExecuteUnitUC\n-    VisualService --> ExecuteUnitUC\n-    DataService --> ExecuteUnitUC\n-    CommunicationService --> ExecuteUnitUC\n-    \n-    ExecuteBattleUC --> BattleEntity\n-    ExecuteRoundUC --> RoundEntity\n-    ExecuteTeamUC --> TeamEntity\n-    ExecuteUnitUC --> UnitEntity\n-    CalculateDamageUC --> SkillEntity\n-    ApplyEffectUC --> EffectEntity\n-    \n-    BattleEntity --> RoundEntity\n-    RoundEntity --> TeamEntity\n-    TeamEntity --> UnitEntity\n-    \n-    style BattleEntity fill:#ffebee\n-    style ExecuteBattleUC fill:#fff4e1\n-    style InputService fill:#e8f5e9\n-    style Unity fill:#e1f5ff\n-```\n-\n-**依赖规则**：\n-- ✅ **允许**：外层依赖内层\n-- ❌ **禁止**：内层依赖外层\n-- ✅ **允许**：通过接口定义依赖\n-- ❌ **禁止**：直接依赖具体实现\n-\n-### 战斗流程在Clean架构中的执行\n-\n-```mermaid\n-sequenceDiagram\n-    participant Framework as 框架层\n-    participant Service as 服务层\n-    participant UseCase as 用例层\n-    participant Entity as 实体层\n-    \n-    Note over Framework,Entity: 战斗开始流程\n-    \n-    Framework->>Service: Unity触发战斗开始\n-    Service->>UseCase: 输入服务转换输入\n-    UseCase->>Entity: 执行战斗用例调用战斗实体\n-    Entity->>Entity: 战斗实体启动战斗循环\n-    \n-    Note over Entity: 战斗循环开始\n-    \n-    Entity->>UseCase: 战斗实体调用执行回合用例\n-    UseCase->>Entity: 执行回合用例调用回合实体\n-    Entity->>Entity: 回合实体启动回合循环\n-    \n-    Note over Entity: 回合循环开始\n-    \n-    Entity->>UseCase: 回合实体调用执行阵营用例\n-    UseCase->>Entity: 执行阵营用例调用阵营实体\n-    Entity->>Entity: 阵营实体启动阵营循环\n-    \n-    Note over Entity: 阵营循环开始\n-    \n-    Entity->>UseCase: 阵营实体调用执行单位用例\n-    UseCase->>Service: 执行单位用例调用输入服务\n-    Service->>Framework: 输入服务获取玩家输入/AI输入\n-    Framework->>Service: 返回输入数据\n-    Service->>UseCase: 转换输入数据\n-    \n-    UseCase->>Service: 执行单位用例调用行动服务\n-    Service->>Framework: 行动服务调用Lua脚本\n-    Framework->>Service: 返回行动结果\n-    Service->>UseCase: 转换行动结果\n-    \n-    UseCase->>Service: 执行单位用例调用视觉服务\n-    Service->>Framework: 视觉服务调用Unity引擎\n-    Framework->>Service: 播放动画/特效\n-    Service->>UseCase: 视觉播放完成\n-    \n-    UseCase->>Service: 执行单位用例调用数据服务\n-    Service->>Framework: 数据服务更新数据\n-    Framework->>Service: 数据更新完成\n-    Service->>UseCase: 数据更新结果\n-    \n-    UseCase->>Entity: 执行单位用例完成，更新单位实体\n-    Entity->>Entity: 单位循环继续/结束\n-    \n-    Note over Entity: 单位循环结束，返回上层循环\n-```\n-\n-\n ## 实体层详细设计（Entities Layer）\n \n ### 四层循环实体模型\n \n"
                },
                {
                    "date": 1767103676979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,50 +5,210 @@\n 设计一套完整的回合制战斗系统架构，支持DND规则、回合管理、状态机控制、AI决策，实现战斗流程管理、伤害计算、效果应用，提供数据驱动的配置化战斗系统。\n \n ---\n \n+## 核心设计理念\n+\n+### 1. 多层循环架构为核心\n+\n+**本质**：战斗系统的核心是四层循环的维护和管理\n+- **战斗循环**：管理整个战斗的生命周期\n+- **回合循环**：管理回合的循环和切换\n+- **阵营循环**：管理阵营内单位的行动顺序\n+- **单位循环**：管理单个单位的行动流程\n+- **循环驱动**：所有战斗逻辑都在循环框架内执行\n+- **状态维护**：每层循环维护自己的状态，驱动下层循环\n+\n+### 2. 数据驱动架构\n+\n+**本质**：战斗特性通过配置数据实现，无需修改代码\n+- 战斗规则、伤害计算、效果应用 → 通过配置数据定义\n+- 回合流程、状态转换 → 通过配置数据调整\n+- 新增战斗机制 → 扩展配置数据即可\n+- 战斗平衡 → 调整配置数值即可\n+\n+### 3. 分层架构（循环内的功能组织）\n+\n+**本质**：分层架构是循环内的功能组织方式，不是主要架构\n+- 功能组织：输入层、决策层、执行层、表现层、管理层\n+- 执行位置：所有分层功能都在单位循环内执行\n+- 解耦设计：层间通过Context和CommunicationBus通信\n+\n+---\n+\n ## 整体架构设计\n \n+### 多层循环架构（主要架构）\n \n-## 实体层详细设计（Entities Layer）\n+**核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n \n-### 四层循环实体模型\n+#### 实体与循环的关系（领域驱动设计）\n \n-**核心观点**：战斗系统的核心是四层循环的维护和管理，这些循环在实体层中定义。\n+**核心观点**：实体控制循环，循环是实体的工具。实体是领域核心，拥有循环机制来推进业务流程。\n \n-### 层次状态机实现（框架层）\n+```mermaid\n+graph TB\n+    subgraph BattleEntity[\"战斗实体<br/>Battle Entity<br/>领域实体\"]\n+        BattleData[战斗数据<br/>结算奖励/同步任务]\n+        BattleLoop[\"战斗循环<br/>BattleLoop<br/>流程机制\"]\n+        BattleData -->|控制| BattleLoop\n+        BattleLoop -->|推进| BattleData\n+    end\n+    \n+    subgraph RoundEntity[\"回合实体<br/>Round Entity<br/>领域实体\"]\n+        RoundData[回合数据<br/>行动值排序/单位行动顺序]\n+        RoundLoop[\"回合循环<br/>RoundLoop<br/>流程机制\"]\n+        RoundData -->|控制| RoundLoop\n+        RoundLoop -->|推进| RoundData\n+    end\n+    \n+    subgraph TeamEntity[\"阵营实体<br/>Team Entity<br/>领域实体\"]\n+        TeamData[阵营数据<br/>借机攻击/阵营差异行为]\n+        TeamLoop[\"阵营循环<br/>TeamLoop<br/>流程机制\"]\n+        TeamData -->|控制| TeamLoop\n+        TeamLoop -->|推进| TeamData\n+    end\n+    \n+    subgraph UnitEntity[\"单位实体<br/>Unit Entity<br/>领域实体\"]\n+        UnitData[单位数据<br/>移动/施法/选择技能对象]\n+        UnitLoop[\"单位循环<br/>UnitLoop<br/>流程机制\"]\n+        UnitData -->|控制| UnitLoop\n+        UnitLoop -->|推进| UnitData\n+    end\n+    \n+    BattleEntity -->|包含| RoundEntity\n+    RoundEntity -->|包含| TeamEntity\n+    TeamEntity -->|包含| UnitEntity\n+    \n+    style BattleEntity fill:#ffebee\n+    style RoundEntity fill:#fff4e1\n+    style TeamEntity fill:#c8e6c9\n+    style UnitEntity fill:#e1f5ff\n+    style BattleLoop fill:#f3e5f5\n+    style RoundLoop fill:#f3e5f5\n+    style TeamLoop fill:#f3e5f5\n+    style UnitLoop fill:#f3e5f5\n+```\n \n-**说明**：层次状态机是框架层的实现，用于管理实体层的状态转换。\n+### 循环管理器设计\n \n+```mermaid\n+graph TB\n+    subgraph LoopManager[\"循环管理器<br/>LoopManager\"]\n+        BattleLoopManager[\"战斗循环管理器<br/>BattleLoopManager\"]\n+        TurnLoopManager[\"回合循环管理器<br/>TurnLoopManager\"]\n+        TeamLoopManager[\"阵营循环管理器<br/>TeamLoopManager\"]\n+        UnitLoopManager[\"单位循环管理器<br/>UnitLoopManager\"]\n+    end\n+    \n+    subgraph BattleContext[\"战斗上下文<br/>BattleContext\"]\n+        BattleState[\"战斗状态<br/>battleState\"]\n+        TurnState[\"回合状态<br/>turnState\"]\n+        TeamState[\"阵营状态<br/>teamState\"]\n+        UnitState[\"单位状态<br/>unitState\"]\n+    end\n+    \n+    BattleLoopManager -->|维护| BattleState\n+    TurnLoopManager -->|维护| TurnState\n+    TeamLoopManager -->|维护| TeamState\n+    UnitLoopManager -->|维护| UnitState\n+    \n+    BattleLoopManager -->|驱动| TurnLoopManager\n+    TurnLoopManager -->|驱动| TeamLoopManager\n+    TeamLoopManager -->|驱动| UnitLoopManager\n+    \n+    style LoopManager fill:#f3e5f5\n+    style BattleContext fill:#e8f5e9\n+```\n+\n+### 循环职责说明\n+\n+#### 1. 战斗循环（BattleLoop）\n+- **职责**：管理整个战斗的生命周期\n+- **状态**：BattleState（未开始/进行中/已结束）\n+- **触发**：战斗开始/结束条件检查\n+- **维护**：BattleLoopManager\n+\n+#### 2. 回合循环（TurnLoop）\n+- **职责**：管理回合的循环和切换\n+- **状态**：TurnState（回合编号/当前回合/回合数）\n+- **触发**：回合开始/结束条件检查\n+- **维护**：TurnLoopManager\n+\n+#### 3. 阵营循环（TeamLoop）\n+- **职责**：管理阵营内单位的行动顺序\n+- **状态**：TeamState（当前阵营/阵营列表/行动顺序）\n+- **触发**：阵营切换/单位行动完成\n+- **维护**：TeamLoopManager\n+\n+#### 4. 单位循环（UnitLoop）\n+- **职责**：管理单个单位的行动流程\n+- **状态**：UnitState（当前单位/行动状态/行动完成）\n+- **触发**：单位行动开始/结束\n+- **维护**：UnitLoopManager\n+\n+---\n+\n+## 多层循环架构模式\n+\n+### 层次状态机（Hierarchical State Machine）\n+\n+**核心观点**：多层循环架构最适合使用**层次状态机（Hierarchical State Machine）**模式。\n+\n+#### 为什么是层次状态机？\n+\n+**原因**：\n+- **循环嵌套 = 状态嵌套**：每层循环都是一个状态机，可以包含子状态机\n+- **状态层次结构**：战斗状态机 → 回合状态机 → 阵营状态机 → 单位状态机\n+- **状态自动管理**：父状态机进入时自动重置子状态机，父状态机更新时自动更新子状态机\n+- **状态隔离**：每层循环的状态独立管理，互不干扰\n+\n+**适用场景**：\n+- 战斗状态机包含回合状态机（战斗进行中状态）\n+- 回合状态机包含阵营状态机（回合行动状态）\n+- 阵营状态机包含单位状态机（阵营行动状态）\n+- 单位状态机管理单位行动流程\n+\n #### 层次状态机设计\n \n ```mermaid\n graph TB\n-    subgraph \"框架层 - 层次状态机\"\n-        BattleFSM[战斗状态机<br/>BattleFSM<br/>HierarchicalFSM]\n-        RoundFSM[回合状态机<br/>RoundFSM<br/>HierarchicalFSM]\n-        TeamFSM[阵营状态机<br/>TeamFSM<br/>HierarchicalFSM]\n-        UnitFSM[单位状态机<br/>UnitFSM<br/>FSMBase]\n+    subgraph BattleFSM[\"战斗状态机<br/>BattleFSM<br/>HierarchicalFSM\"]\n+        BattleState1[准备中]\n+        BattleState2[进行中]\n+        BattleState3[暂停]\n+        BattleState4[结束]\n         \n-        BattleFSM -->|包含| RoundFSM\n-        RoundFSM -->|包含| TeamFSM\n-        TeamFSM -->|包含| UnitFSM\n+        BattleState2 -->|包含| TurnFSM[回合状态机<br/>TurnFSM]\n+        BattleState4 -->|包含| ResultFSM[结果状态机<br/>ResultFSM]\n     end\n     \n-    subgraph \"实体层 - 业务实体\"\n-        BattleEntity[战斗实体<br/>Battle Entity]\n-        RoundEntity[回合实体<br/>Round Entity]\n-        TeamEntity[阵营实体<br/>Team Entity]\n-        UnitEntity[单位实体<br/>Unit Entity]\n+    subgraph TurnFSM[\"回合状态机<br/>TurnFSM<br/>HierarchicalFSM\"]\n+        TurnState1[回合开始]\n+        TurnState2[回合行动]\n+        TurnState3[回合结束]\n+        \n+        TurnState2 -->|包含| TeamFSM[阵营状态机<br/>TeamFSM]\n     end\n     \n-    BattleFSM -.管理.-> BattleEntity\n-    RoundFSM -.管理.-> RoundEntity\n-    TeamFSM -.管理.-> TeamEntity\n-    UnitFSM -.管理.-> UnitEntity\n+    subgraph TeamFSM[\"阵营状态机<br/>TeamFSM<br/>HierarchicalFSM\"]\n+        TeamState1[阵营开始]\n+        TeamState2[阵营行动]\n+        TeamState3[阵营结束]\n+        \n+        TeamState2 -->|包含| UnitFSM[单位状态机<br/>UnitFSM]\n+    end\n     \n-    style BattleFSM fill:#e1f5ff\n-    style BattleEntity fill:#ffebee\n+    subgraph UnitFSM[\"单位状态机<br/>UnitFSM<br/>FSMBase\"]\n+        UnitState1[单位开始]\n+        UnitState2[单位行动]\n+        UnitState3[单位结束]\n+    end\n+    \n+    style BattleFSM fill:#ffebee\n+    style TurnFSM fill:#fff4e1\n+    style TeamFSM fill:#c8e6c9\n+    style UnitFSM fill:#e1f5ff\n ```\n \n #### 层次状态机特点\n \n@@ -71,9 +231,27 @@\n    - 每层状态机的状态转换驱动循环推进\n    - 状态机状态决定循环是否继续\n    - 状态机状态决定循环行为\n \n-#### 循环分层状态机流程图\n+#### 实现要点\n+\n+1. **层次状态机接口**：\n+   - `AddSubFSM(stateId, subFSM)`：为某个状态添加子状态机\n+   - `EnterCurrentState()`：进入当前状态时，自动重置子状态机\n+   - `UpdateCurrentState()`：更新当前状态时，自动更新子状态机\n+\n+2. **状态机层次结构**：\n+   - 战斗状态机（HierarchicalFSM）：包含回合状态机和结果状态机\n+   - 回合状态机（HierarchicalFSM）：包含阵营状态机\n+   - 阵营状态机（HierarchicalFSM）：包含单位状态机\n+   - 单位状态机（FSMBase）：最底层状态机，不包含子状态机\n+\n+3. **循环管理器 = 层次状态机**：\n+   - BattleLoopManager = 战斗状态机\n+   - TurnLoopManager = 回合状态机\n+   - TeamLoopManager = 阵营状态机\n+   - UnitLoopManager = 单位状态机\n+\n ```mermaid\n sequenceDiagram\n     participant Main as 主状态机\n     participant Round as 回合状态机\n@@ -141,5 +319,72 @@\n     Main->>Main: 激活结果状态机\n ```\n ---\n \n+### 分层架构（循环内的功能组织）\n \n+**说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n+\n+#### 单位循环内的分层功能\n+\n+```mermaid\n+graph TB\n+    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n+        UnitStart[单位开始] --> InputLayer[输入层<br/>接收输入]\n+        InputLayer --> DecisionLayer[决策层<br/>选择行动/目标]\n+        DecisionLayer --> ExecutionLayer[执行层<br/>执行行动/计算伤害]\n+        ExecutionLayer --> PresentationLayer[表现层<br/>播放表现]\n+        PresentationLayer --> ManagementLayer[管理层<br/>更新状态]\n+        ManagementLayer --> UnitEnd[单位结束]\n+    end\n+    \n+    DataLayer[数据层<br/>配置数据] -.数据查询.-> DecisionLayer\n+    DataLayer -.数据查询.-> ExecutionLayer\n+    \n+    style UnitLoop fill:#e1f5ff\n+    style InputLayer fill:#ffebee\n+    style DecisionLayer fill:#fff4e1\n+    style ExecutionLayer fill:#c8e6c9\n+    style PresentationLayer fill:#e1f5ff\n+    style ManagementLayer fill:#f3e5f5\n+    style DataLayer fill:#e8f5e9\n+```\n+\n+#### 分层职责说明\n+\n+**重要**：以下所有分层功能都在**单位循环**内执行，不是独立的架构层次。\n+\n+##### 输入层（InputLayer）\n+- **执行位置**：单位循环内\n+- **职责**：接收玩家输入和AI输入\n+- **核心组件**：PlayerInput、AIInput、InputValidator\n+- **输出**：BattleContext + inputData\n+\n+##### 决策层（DecisionLayer）\n+- **执行位置**：单位循环内\n+- **职责**：行动选择、目标选择\n+- **核心组件**：ActionSelector、TargetSelector\n+- **输出**：BattleContext + decisionData\n+\n+##### 执行层（ExecutionLayer）\n+- **执行位置**：单位循环内\n+- **职责**：行动执行、伤害计算、效果应用\n+- **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n+- **输出**：BattleContext + executionData\n+\n+##### 表现层（PresentationLayer）\n+- **执行位置**：单位循环内\n+- **职责**：视觉表现、音频播放、UI更新\n+- **核心组件**：VisualPlayer、AudioPlayer、UIManager\n+- **输出**：BattleContext + presentationData\n+\n+##### 管理层（ManagementLayer）\n+- **执行位置**：单位循环内（状态更新）、循环间（循环管理）\n+- **职责**：战斗状态管理、参与者管理、Context管理、循环管理\n+- **核心组件**：BattleStateManager、ParticipantManager、BattleContext、LoopManager\n+- **输出**：状态更新、数据持久化、循环驱动\n+\n+##### 数据层（DataLayer）\n+- **执行位置**：所有循环和分层功能中\n+- **职责**：战斗配置、回合数据、战斗数据\n+- **核心组件**：BattleConfig、TurnData、BattleData\n+- **输出**：配置数据查询\n"
                },
                {
                    "date": 1767103772611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,40 +46,36 @@\n **核心观点**：实体控制循环，循环是实体的工具。实体是领域核心，拥有循环机制来推进业务流程。\n \n ```mermaid\n graph TB\n-    subgraph BattleEntity[\"战斗实体<br/>Battle Entity<br/>领域实体\"]\n+    subgraph BattleEntity[\"战斗实体<br/>Battle Entity\"]\n         BattleData[战斗数据<br/>结算奖励/同步任务]\n-        BattleLoop[\"战斗循环<br/>BattleLoop<br/>流程机制\"]\n+        BattleLoop[\"战斗循环<br/>BattleLoop\"]\n         BattleData -->|控制| BattleLoop\n         BattleLoop -->|推进| BattleData\n+        \n+        subgraph RoundEntity[\"回合实体<br/>Round Entity\"]\n+            RoundData[回合数据<br/>行动值排序/单位行动顺序]\n+            RoundLoop[\"回合循环<br/>RoundLoop\"]\n+            RoundData -->|控制| RoundLoop\n+            RoundLoop -->|推进| RoundData\n+            \n+            subgraph TeamEntity[\"阵营实体<br/>Team Entity\"]\n+                TeamData[阵营数据<br/>借机攻击/阵营差异行为]\n+                TeamLoop[\"阵营循环<br/>TeamLoop\"]\n+                TeamData -->|控制| TeamLoop\n+                TeamLoop -->|推进| TeamData\n+                \n+                subgraph UnitEntity[\"单位实体<br/>Unit Entity\"]\n+                    UnitData[单位数据<br/>移动/施法/选择技能对象]\n+                    UnitLoop[\"单位循环<br/>UnitLoop\"]\n+                    UnitData -->|控制| UnitLoop\n+                    UnitLoop -->|推进| UnitData\n+                end\n+            end\n+        end\n     end\n     \n-    subgraph RoundEntity[\"回合实体<br/>Round Entity<br/>领域实体\"]\n-        RoundData[回合数据<br/>行动值排序/单位行动顺序]\n-        RoundLoop[\"回合循环<br/>RoundLoop<br/>流程机制\"]\n-        RoundData -->|控制| RoundLoop\n-        RoundLoop -->|推进| RoundData\n-    end\n-    \n-    subgraph TeamEntity[\"阵营实体<br/>Team Entity<br/>领域实体\"]\n-        TeamData[阵营数据<br/>借机攻击/阵营差异行为]\n-        TeamLoop[\"阵营循环<br/>TeamLoop<br/>流程机制\"]\n-        TeamData -->|控制| TeamLoop\n-        TeamLoop -->|推进| TeamData\n-    end\n-    \n-    subgraph UnitEntity[\"单位实体<br/>Unit Entity<br/>领域实体\"]\n-        UnitData[单位数据<br/>移动/施法/选择技能对象]\n-        UnitLoop[\"单位循环<br/>UnitLoop<br/>流程机制\"]\n-        UnitData -->|控制| UnitLoop\n-        UnitLoop -->|推进| UnitData\n-    end\n-    \n-    BattleEntity -->|包含| RoundEntity\n-    RoundEntity -->|包含| TeamEntity\n-    TeamEntity -->|包含| UnitEntity\n-    \n     style BattleEntity fill:#ffebee\n     style RoundEntity fill:#fff4e1\n     style TeamEntity fill:#c8e6c9\n     style UnitEntity fill:#e1f5ff\n"
                },
                {
                    "date": 1767103988792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,33 +40,35 @@\n ### 多层循环架构（主要架构）\n \n **核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n \n-#### 实体与循环的关系（领域驱动设计）\n+#### Domain与循环的关系（领域驱动设计）\n \n-**核心观点**：实体控制循环，循环是实体的工具。实体是领域核心，拥有循环机制来推进业务流程。\n+**核心观点**：Domain控制循环，循环是Domain的工具。Domain是领域核心，拥有循环机制来推进业务流程。\n \n+**术语说明**：使用\"Domain\"而非\"Entity\"，避免与项目中的\"Unit\"概念混淆。\n+\n ```mermaid\n graph TB\n-    subgraph BattleEntity[\"战斗实体<br/>Battle Entity\"]\n+    subgraph BattleDomain[\"战斗Domain<br/>Battle Domain\"]\n         BattleData[战斗数据<br/>结算奖励/同步任务]\n         BattleLoop[\"战斗循环<br/>BattleLoop\"]\n         BattleData -->|控制| BattleLoop\n         BattleLoop -->|推进| BattleData\n         \n-        subgraph RoundEntity[\"回合实体<br/>Round Entity\"]\n+        subgraph RoundDomain[\"回合Domain<br/>Round Domain\"]\n             RoundData[回合数据<br/>行动值排序/单位行动顺序]\n             RoundLoop[\"回合循环<br/>RoundLoop\"]\n             RoundData -->|控制| RoundLoop\n             RoundLoop -->|推进| RoundData\n             \n-            subgraph TeamEntity[\"阵营实体<br/>Team Entity\"]\n+            subgraph TeamDomain[\"阵营Domain<br/>Team Domain\"]\n                 TeamData[阵营数据<br/>借机攻击/阵营差异行为]\n                 TeamLoop[\"阵营循环<br/>TeamLoop\"]\n                 TeamData -->|控制| TeamLoop\n                 TeamLoop -->|推进| TeamData\n                 \n-                subgraph UnitEntity[\"单位实体<br/>Unit Entity\"]\n+                subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n                     UnitData[单位数据<br/>移动/施法/选择技能对象]\n                     UnitLoop[\"单位循环<br/>UnitLoop\"]\n                     UnitData -->|控制| UnitLoop\n                     UnitLoop -->|推进| UnitData\n@@ -74,18 +76,21 @@\n             end\n         end\n     end\n     \n-    style BattleEntity fill:#ffebee\n-    style RoundEntity fill:#fff4e1\n-    style TeamEntity fill:#c8e6c9\n-    style UnitEntity fill:#e1f5ff\n+    style BattleDomain fill:#ffebee\n+    style RoundDomain fill:#fff4e1\n+    style TeamDomain fill:#c8e6c9\n+    style UnitDomain fill:#e1f5ff\n     style BattleLoop fill:#f3e5f5\n     style RoundLoop fill:#f3e5f5\n     style TeamLoop fill:#f3e5f5\n     style UnitLoop fill:#f3e5f5\n ```\n \n+**备注**：\n+- **阵营循环**：在标准DND规则中，所有单位按先攻值（Initiative）统一排序行动，不存在阵营循环。此处保留阵营循环作为扩展设计，便于后续支持阵营差异行为（如借机攻击、阵营特殊规则等）。如不需要，可简化为三层架构（战斗→回合→单位）。\n+\n ### 循环管理器设计\n \n ```mermaid\n graph TB\n"
                },
                {
                    "date": 1767104010411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -139,8 +139,9 @@\n - **职责**：管理阵营内单位的行动顺序\n - **状态**：TeamState（当前阵营/阵营列表/行动顺序）\n - **触发**：阵营切换/单位行动完成\n - **维护**：TeamLoopManager\n+- **备注**：在标准DND规则中，所有单位按先攻值统一排序，不存在阵营循环。此处保留作为扩展设计，便于支持阵营差异行为。\n \n #### 4. 单位循环（UnitLoop）\n - **职责**：管理单个单位的行动流程\n - **状态**：UnitState（当前单位/行动状态/行动完成）\n"
                },
                {
                    "date": 1767104294080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,30 +49,30 @@\n \n ```mermaid\n graph TB\n     subgraph BattleDomain[\"战斗Domain<br/>Battle Domain\"]\n-        BattleData[战斗数据<br/>结算奖励/同步任务]\n+        BattleManagement[战斗管理<br/>结算奖励/同步任务]\n         BattleLoop[\"战斗循环<br/>BattleLoop\"]\n-        BattleData -->|控制| BattleLoop\n-        BattleLoop -->|推进| BattleData\n+        BattleManagement -->|控制| BattleLoop\n+        BattleLoop -->|推进| BattleManagement\n         \n         subgraph RoundDomain[\"回合Domain<br/>Round Domain\"]\n-            RoundData[回合数据<br/>行动值排序/单位行动顺序]\n+            RoundManagement[回合管理<br/>行动值排序/单位行动顺序]\n             RoundLoop[\"回合循环<br/>RoundLoop\"]\n-            RoundData -->|控制| RoundLoop\n-            RoundLoop -->|推进| RoundData\n+            RoundManagement -->|控制| RoundLoop\n+            RoundLoop -->|推进| RoundManagement\n             \n             subgraph TeamDomain[\"阵营Domain<br/>Team Domain\"]\n-                TeamData[阵营数据<br/>借机攻击/阵营差异行为]\n+                TeamManagement[阵营管理<br/>借机攻击/阵营差异行为]\n                 TeamLoop[\"阵营循环<br/>TeamLoop\"]\n-                TeamData -->|控制| TeamLoop\n-                TeamLoop -->|推进| TeamData\n+                TeamManagement -->|控制| TeamLoop\n+                TeamLoop -->|推进| TeamManagement\n                 \n                 subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n-                    UnitData[单位数据<br/>移动/施法/选择技能对象]\n+                    UnitManagement[单位管理<br/>移动/施法/选择技能对象]\n                     UnitLoop[\"单位循环<br/>UnitLoop\"]\n-                    UnitData -->|控制| UnitLoop\n-                    UnitLoop -->|推进| UnitData\n+                    UnitManagement -->|控制| UnitLoop\n+                    UnitLoop -->|推进| UnitManagement\n                 end\n             end\n         end\n     end\n"
                },
                {
                    "date": 1767104405394,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,39 +89,9 @@\n \n **备注**：\n - **阵营循环**：在标准DND规则中，所有单位按先攻值（Initiative）统一排序行动，不存在阵营循环。此处保留阵营循环作为扩展设计，便于后续支持阵营差异行为（如借机攻击、阵营特殊规则等）。如不需要，可简化为三层架构（战斗→回合→单位）。\n \n-### 循环管理器设计\n \n-```mermaid\n-graph TB\n-    subgraph LoopManager[\"循环管理器<br/>LoopManager\"]\n-        BattleLoopManager[\"战斗循环管理器<br/>BattleLoopManager\"]\n-        TurnLoopManager[\"回合循环管理器<br/>TurnLoopManager\"]\n-        TeamLoopManager[\"阵营循环管理器<br/>TeamLoopManager\"]\n-        UnitLoopManager[\"单位循环管理器<br/>UnitLoopManager\"]\n-    end\n-    \n-    subgraph BattleContext[\"战斗上下文<br/>BattleContext\"]\n-        BattleState[\"战斗状态<br/>battleState\"]\n-        TurnState[\"回合状态<br/>turnState\"]\n-        TeamState[\"阵营状态<br/>teamState\"]\n-        UnitState[\"单位状态<br/>unitState\"]\n-    end\n-    \n-    BattleLoopManager -->|维护| BattleState\n-    TurnLoopManager -->|维护| TurnState\n-    TeamLoopManager -->|维护| TeamState\n-    UnitLoopManager -->|维护| UnitState\n-    \n-    BattleLoopManager -->|驱动| TurnLoopManager\n-    TurnLoopManager -->|驱动| TeamLoopManager\n-    TeamLoopManager -->|驱动| UnitLoopManager\n-    \n-    style LoopManager fill:#f3e5f5\n-    style BattleContext fill:#e8f5e9\n-```\n-\n ### 循环职责说明\n \n #### 1. 战斗循环（BattleLoop）\n - **职责**：管理整个战斗的生命周期\n@@ -147,246 +117,4 @@\n - **状态**：UnitState（当前单位/行动状态/行动完成）\n - **触发**：单位行动开始/结束\n - **维护**：UnitLoopManager\n \n----\n-\n-## 多层循环架构模式\n-\n-### 层次状态机（Hierarchical State Machine）\n-\n-**核心观点**：多层循环架构最适合使用**层次状态机（Hierarchical State Machine）**模式。\n-\n-#### 为什么是层次状态机？\n-\n-**原因**：\n-- **循环嵌套 = 状态嵌套**：每层循环都是一个状态机，可以包含子状态机\n-- **状态层次结构**：战斗状态机 → 回合状态机 → 阵营状态机 → 单位状态机\n-- **状态自动管理**：父状态机进入时自动重置子状态机，父状态机更新时自动更新子状态机\n-- **状态隔离**：每层循环的状态独立管理，互不干扰\n-\n-**适用场景**：\n-- 战斗状态机包含回合状态机（战斗进行中状态）\n-- 回合状态机包含阵营状态机（回合行动状态）\n-- 阵营状态机包含单位状态机（阵营行动状态）\n-- 单位状态机管理单位行动流程\n-\n-#### 层次状态机设计\n-\n-```mermaid\n-graph TB\n-    subgraph BattleFSM[\"战斗状态机<br/>BattleFSM<br/>HierarchicalFSM\"]\n-        BattleState1[准备中]\n-        BattleState2[进行中]\n-        BattleState3[暂停]\n-        BattleState4[结束]\n-        \n-        BattleState2 -->|包含| TurnFSM[回合状态机<br/>TurnFSM]\n-        BattleState4 -->|包含| ResultFSM[结果状态机<br/>ResultFSM]\n-    end\n-    \n-    subgraph TurnFSM[\"回合状态机<br/>TurnFSM<br/>HierarchicalFSM\"]\n-        TurnState1[回合开始]\n-        TurnState2[回合行动]\n-        TurnState3[回合结束]\n-        \n-        TurnState2 -->|包含| TeamFSM[阵营状态机<br/>TeamFSM]\n-    end\n-    \n-    subgraph TeamFSM[\"阵营状态机<br/>TeamFSM<br/>HierarchicalFSM\"]\n-        TeamState1[阵营开始]\n-        TeamState2[阵营行动]\n-        TeamState3[阵营结束]\n-        \n-        TeamState2 -->|包含| UnitFSM[单位状态机<br/>UnitFSM]\n-    end\n-    \n-    subgraph UnitFSM[\"单位状态机<br/>UnitFSM<br/>FSMBase\"]\n-        UnitState1[单位开始]\n-        UnitState2[单位行动]\n-        UnitState3[单位结束]\n-    end\n-    \n-    style BattleFSM fill:#ffebee\n-    style TurnFSM fill:#fff4e1\n-    style TeamFSM fill:#c8e6c9\n-    style UnitFSM fill:#e1f5ff\n-```\n-\n-#### 层次状态机特点\n-\n-1. **状态嵌套**：\n-   - 父状态机可以包含子状态机\n-   - 子状态机在父状态机进入时自动重置\n-   - 子状态机在父状态机更新时自动更新\n-\n-2. **状态隔离**：\n-   - 每层状态机独立管理自己的状态\n-   - 状态转换只在当前状态机内进行\n-   - 父状态机状态变化不影响子状态机状态\n-\n-3. **自动管理**：\n-   - 父状态机进入时，自动重置子状态机\n-   - 父状态机更新时，自动更新子状态机\n-   - 父状态机退出时，自动清理子状态机\n-\n-4. **循环驱动**：\n-   - 每层状态机的状态转换驱动循环推进\n-   - 状态机状态决定循环是否继续\n-   - 状态机状态决定循环行为\n-\n-#### 实现要点\n-\n-1. **层次状态机接口**：\n-   - `AddSubFSM(stateId, subFSM)`：为某个状态添加子状态机\n-   - `EnterCurrentState()`：进入当前状态时，自动重置子状态机\n-   - `UpdateCurrentState()`：更新当前状态时，自动更新子状态机\n-\n-2. **状态机层次结构**：\n-   - 战斗状态机（HierarchicalFSM）：包含回合状态机和结果状态机\n-   - 回合状态机（HierarchicalFSM）：包含阵营状态机\n-   - 阵营状态机（HierarchicalFSM）：包含单位状态机\n-   - 单位状态机（FSMBase）：最底层状态机，不包含子状态机\n-\n-3. **循环管理器 = 层次状态机**：\n-   - BattleLoopManager = 战斗状态机\n-   - TurnLoopManager = 回合状态机\n-   - TeamLoopManager = 阵营状态机\n-   - UnitLoopManager = 单位状态机\n-\n-```mermaid\n-sequenceDiagram\n-    participant Main as 主状态机\n-    participant Round as 回合状态机\n-    participant Team as 阵营状态机\n-    participant Unit as 单位状态机\n-    \n-    Note over Main: 战斗开始\n-    Main->>Main: PREPARING → IN_PROGRESS\n-    Main->>Round: 进入IN_PROGRESS，激活回合状态机\n-    \n-    Note over Round: 第1回合开始\n-    Round->>Round: ROUND_START\n-    Round->>Round: CheckRoundActionCondition() → ROUND_ACTION\n-    Round->>Team: 进入ROUND_ACTION，激活阵营状态机\n-    \n-    Note over Team: 玩家阵营开始\n-    Team->>Team: TEAM_START\n-    Team->>Team: CheckTeamActionCondition() → TEAM_ACTION\n-    Team->>Unit: 进入TEAM_ACTION，激活单位状态机\n-    \n-    Note over Unit: 单位1行动\n-    Unit->>Unit: UNIT_START\n-    Unit->>Unit: CheckUnitActionCondition() → UNIT_ACTION\n-    Unit->>Unit: 执行行动\n-    Unit->>Unit: CheckUnitEndCondition() → UNIT_END\n-    Unit->>Unit: CheckNextUnitCondition() → UNIT_START (还有单位2)\n-    \n-    Note over Unit: 单位2行动\n-    Unit->>Unit: UNIT_START\n-    Unit->>Unit: UNIT_ACTION\n-    Unit->>Unit: UNIT_END\n-    Unit->>Unit: CheckNextUnitCondition() → false (没有更多单位)\n-    \n-    Note over Team: 玩家阵营结束\n-    Team->>Team: CheckTeamEndCondition() → TEAM_END\n-    Team->>Team: CheckNextTeamCondition() → TEAM_START (还有敌人阵营)\n-    \n-    Note over Team: 敌人阵营开始\n-    Team->>Team: TEAM_START\n-    Team->>Team: TEAM_ACTION\n-    Team->>Unit: 激活单位状态机（敌人单位1）\n-    Unit->>Unit: UNIT_START → UNIT_ACTION → UNIT_END\n-    Unit->>Unit: CheckNextUnitCondition() → UNIT_START (还有单位2)\n-    Unit->>Unit: UNIT_START → UNIT_ACTION → UNIT_END\n-    Unit->>Unit: CheckNextUnitCondition() → false\n-    Team->>Team: TEAM_END\n-    Team->>Team: CheckNextTeamCondition() → false (没有更多阵营)\n-    \n-    Note over Round: 第1回合结束\n-    Round->>Round: CheckRoundEndCondition() → ROUND_END\n-    Round->>Round: CheckNextRoundCondition() → ROUND_START (还有第2回合)\n-    \n-    Note over Round: 第2回合开始\n-    Round->>Round: ROUND_START → ROUND_ACTION\n-    Round->>Team: 激活阵营状态机\n-    Team->>Team: TEAM_START → TEAM_ACTION → TEAM_END\n-    Team->>Team: CheckNextTeamCondition() → TEAM_START (循环)\n-    Team->>Team: TEAM_START → TEAM_ACTION → TEAM_END\n-    Team->>Team: CheckNextTeamCondition() → false\n-    Round->>Round: ROUND_END\n-    Round->>Round: CheckNextRoundCondition() → false (战斗结束)\n-    \n-    Note over Main: 战斗结束\n-    Main->>Main: CheckBattleEndCondition() → ENDED\n-    Main->>Main: 激活结果状态机\n-```\n----\n-\n-### 分层架构（循环内的功能组织）\n-\n-**说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n-\n-#### 单位循环内的分层功能\n-\n-```mermaid\n-graph TB\n-    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n-        UnitStart[单位开始] --> InputLayer[输入层<br/>接收输入]\n-        InputLayer --> DecisionLayer[决策层<br/>选择行动/目标]\n-        DecisionLayer --> ExecutionLayer[执行层<br/>执行行动/计算伤害]\n-        ExecutionLayer --> PresentationLayer[表现层<br/>播放表现]\n-        PresentationLayer --> ManagementLayer[管理层<br/>更新状态]\n-        ManagementLayer --> UnitEnd[单位结束]\n-    end\n-    \n-    DataLayer[数据层<br/>配置数据] -.数据查询.-> DecisionLayer\n-    DataLayer -.数据查询.-> ExecutionLayer\n-    \n-    style UnitLoop fill:#e1f5ff\n-    style InputLayer fill:#ffebee\n-    style DecisionLayer fill:#fff4e1\n-    style ExecutionLayer fill:#c8e6c9\n-    style PresentationLayer fill:#e1f5ff\n-    style ManagementLayer fill:#f3e5f5\n-    style DataLayer fill:#e8f5e9\n-```\n-\n-#### 分层职责说明\n-\n-**重要**：以下所有分层功能都在**单位循环**内执行，不是独立的架构层次。\n-\n-##### 输入层（InputLayer）\n-- **执行位置**：单位循环内\n-- **职责**：接收玩家输入和AI输入\n-- **核心组件**：PlayerInput、AIInput、InputValidator\n-- **输出**：BattleContext + inputData\n-\n-##### 决策层（DecisionLayer）\n-- **执行位置**：单位循环内\n-- **职责**：行动选择、目标选择\n-- **核心组件**：ActionSelector、TargetSelector\n-- **输出**：BattleContext + decisionData\n-\n-##### 执行层（ExecutionLayer）\n-- **执行位置**：单位循环内\n-- **职责**：行动执行、伤害计算、效果应用\n-- **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n-- **输出**：BattleContext + executionData\n-\n-##### 表现层（PresentationLayer）\n-- **执行位置**：单位循环内\n-- **职责**：视觉表现、音频播放、UI更新\n-- **核心组件**：VisualPlayer、AudioPlayer、UIManager\n-- **输出**：BattleContext + presentationData\n-\n-##### 管理层（ManagementLayer）\n-- **执行位置**：单位循环内（状态更新）、循环间（循环管理）\n-- **职责**：战斗状态管理、参与者管理、Context管理、循环管理\n-- **核心组件**：BattleStateManager、ParticipantManager、BattleContext、LoopManager\n-- **输出**：状态更新、数据持久化、循环驱动\n-\n-##### 数据层（DataLayer）\n-- **执行位置**：所有循环和分层功能中\n-- **职责**：战斗配置、回合数据、战斗数据\n-- **核心组件**：BattleConfig、TurnData、BattleData\n-- **输出**：配置数据查询\n"
                },
                {
                    "date": 1767104514319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -89,9 +89,49 @@\n \n **备注**：\n - **阵营循环**：在标准DND规则中，所有单位按先攻值（Initiative）统一排序行动，不存在阵营循环。此处保留阵营循环作为扩展设计，便于后续支持阵营差异行为（如借机攻击、阵营特殊规则等）。如不需要，可简化为三层架构（战斗→回合→单位）。\n \n+#### Domain协作关系\n \n+**核心观点**：Domain之间通过协作推进业务流程，父Domain调用子Domain，子Domain完成业务后返回父Domain。\n+\n+```mermaid\n+graph TB\n+    BattleDomain[战斗Domain<br/>Battle Domain]\n+    RoundDomain[回合Domain<br/>Round Domain]\n+    TeamDomain[阵营Domain<br/>Team Domain]\n+    UnitDomain[单位Domain<br/>Unit Domain]\n+    \n+    BattleDomain -->|1. 调用| RoundDomain\n+    RoundDomain -->|2. 返回| BattleDomain\n+    RoundDomain -->|3. 调用| TeamDomain\n+    TeamDomain -->|4. 返回| RoundDomain\n+    TeamDomain -->|5. 调用| UnitDomain\n+    UnitDomain -->|6. 返回| TeamDomain\n+    \n+    BattleDomain -.->|包含| RoundDomain\n+    RoundDomain -.->|包含| TeamDomain\n+    TeamDomain -.->|包含| UnitDomain\n+    \n+    style BattleDomain fill:#ffebee\n+    style RoundDomain fill:#fff4e1\n+    style TeamDomain fill:#c8e6c9\n+    style UnitDomain fill:#e1f5ff\n+```\n+\n+**协作流程说明**：\n+1. **战斗Domain** → 调用 **回合Domain**：战斗进行中，需要执行回合\n+2. **回合Domain** → 调用 **阵营Domain**：回合进行中，需要处理阵营\n+3. **阵营Domain** → 调用 **单位Domain**：阵营进行中，需要处理单位\n+4. **单位Domain** → 返回 **阵营Domain**：单位行动完成\n+5. **阵营Domain** → 返回 **回合Domain**：阵营处理完成\n+6. **回合Domain** → 返回 **战斗Domain**：回合完成\n+\n+**协作原则**：\n+- 父Domain控制子Domain的调用时机\n+- 子Domain完成业务后主动返回父Domain\n+- 每个Domain独立管理自己的业务逻辑和循环\n+\n ### 循环职责说明\n \n #### 1. 战斗循环（BattleLoop）\n - **职责**：管理整个战斗的生命周期\n"
                },
                {
                    "date": 1767105866334,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,4 +157,253 @@\n - **状态**：UnitState（当前单位/行动状态/行动完成）\n - **触发**：单位行动开始/结束\n - **维护**：UnitLoopManager\n \n+---\n+\n+## 单位领域详细架构设计\n+\n+### 核心职责\n+\n+单位领域是战斗系统的核心，负责管理单个单位的行动流程，包括移动、技能释放、数值控制等。\n+\n+### 单位领域完整结构\n+\n+```mermaid\n+graph TB\n+    subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n+        UnitManagement[单位管理<br/>UnitManagement]\n+        UnitLoop[单位循环<br/>UnitLoop<br/>START → ACTION → END]\n+        ActionCoordinator[行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用]\n+    end\n+    \n+    subgraph UnitManagement[\"单位管理<br/>UnitManagement\"]\n+        DataMgr[单位数据管理<br/>属性/状态/位置]\n+        RuleMgr[单位规则管理<br/>移动点数检查/行动规则]\n+        ValueControlMgr[数值控制管理<br/>接收DataHandleQueue数据]\n+    end\n+    \n+    subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator\"]\n+        MoveCoord[移动协调<br/>调用网格系统]\n+        SkillCoord[技能协调<br/>调用技能领域]\n+        ValueCoord[数值控制协调<br/>推送DataHandleQueue]\n+        VisualCoord[表现协调<br/>通知表现层]\n+    end\n+    \n+    subgraph ExternalSystems[\"外部系统\"]\n+        GridSystem[网格系统<br/>GridSystem]\n+        SkillDomain[技能领域<br/>Skill Domain]\n+        DataHandleQueue[数据队列<br/>DataHandleQueue<br/>中间层]\n+        VisualSystem[表现系统<br/>Visual System]\n+    end\n+    \n+    UnitManagement --> UnitLoop\n+    UnitLoop --> ActionCoordinator\n+    \n+    ActionCoordinator -->|调用| GridSystem\n+    ActionCoordinator -->|调用| SkillDomain\n+    ActionCoordinator -->|推送数据| DataHandleQueue\n+    ActionCoordinator -->|通知| VisualSystem\n+    \n+    DataHandleQueue -->|处理数据| ValueControlMgr\n+    SkillDomain -->|返回效果数据| ValueCoord\n+    \n+    style UnitDomain fill:#e1f5ff\n+    style UnitManagement fill:#fff4e1\n+    style UnitLoop fill:#f3e5f5\n+    style ActionCoordinator fill:#c8e6c9\n+    style DataHandleQueue fill:#f3e5f5\n+```\n+\n+### 单位管理（UnitManagement）\n+\n+#### 1. 单位数据管理\n+- **单位属性**：生命值、移动点数、状态等\n+- **单位状态**：是否可行动、是否已移动、是否已攻击等\n+- **单位位置**：当前网格位置\n+\n+#### 2. 单位规则管理\n+- **移动点数规则**：移动前检查能否移动（回答1：移动前检查）\n+- **行动规则**：是否可执行行动\n+- **状态规则**：状态转换规则\n+\n+#### 3. 数值控制管理\n+- **接收数据变更**：通过 DataHandleQueue 接收其他单位对自己的数值控制（攻击扣血、加buff等）\n+- **效果应用**：应用技能效果到自身\n+- **状态更新**：更新自身状态\n+\n+### 单位循环（UnitLoop）\n+\n+**循环状态**：START → ACTION → END（回答2：不需要更细的状态）\n+\n+- **START**：单位开始行动\n+- **ACTION**：执行行动（移动、技能等）\n+- **END**：单位结束行动\n+\n+### 行动协调器（ActionCoordinator）- 微核心\n+\n+**核心原则**：只负责协调调用，不包含业务规则（回答3：只负责协调调用）\n+\n+#### 1. 移动协调\n+- **移动前检查**：调用单位管理检查移动点数\n+- **调用网格系统**：进行移动计算\n+- **移动后更新**：通过 DataHandleQueue 更新单位位置和移动点数\n+\n+#### 2. 技能协调\n+- **调用技能领域**：执行技能\n+- **接收技能结果**：获取技能效果数据\n+- **协调数值控制**：将技能效果通过 DataHandleQueue 推送到目标单位\n+\n+#### 3. 数值控制协调\n+- **接收技能效果**：从技能领域获取效果数据\n+- **推送到 DataHandleQueue**：将效果数据推送到队列，由队列处理\n+- **不直接修改目标**：不直接操作目标单位数据，通过队列解耦\n+\n+#### 4. 表现协调\n+- **通知表现层**：移动表现、技能表现、受攻击表现\n+\n+### DataHandleQueue 作为中间层\n+\n+**核心设计**：所有数值控制都通过 DataHandleQueue 推送，实现模块间解耦。\n+\n+```mermaid\n+sequenceDiagram\n+    participant AC as 行动协调器\n+    participant SD as 技能领域\n+    participant DHQ as DataHandleQueue\n+    participant TU as 目标单位\n+    participant UM as 单位管理\n+    \n+    AC -> SD: 调用技能领域执行技能\n+    SD -> AC: 返回技能效果数据\n+    AC -> DHQ: PushData(效果数据, 目标单位ID)\n+    DHQ -> TU: ProcessDataHandler()\n+    TU -> UM: OnDataHandler(效果数据)\n+    UM -> UM: 应用效果（扣血/加buff）\n+    UM -> UM: 更新状态\n+```\n+\n+**数据流特性**：\n+- ✅ **解耦设计**：行动协调器不直接操作目标单位，通过队列解耦\n+- ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n+- ✅ **统一接口**：所有数值控制通过统一接口推送\n+- ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n+\n+### 单位行动完整流程\n+\n+```mermaid\n+flowchart TD\n+    Start[START: 单位开始行动] --> CheckMove[移动前检查<br/>单位管理检查移动点数]\n+    \n+    CheckMove -->|可以移动| Move[单位移动<br/>行动协调器调用网格系统]\n+    CheckMove -->|不能移动| SkipMove[跳过移动]\n+    \n+    Move --> UpdateMove[更新移动点数<br/>通过DataHandleQueue推送]\n+    SkipMove --> Skill\n+    \n+    UpdateMove --> Skill[攻击/治疗<br/>行动协调器调用技能领域]\n+    \n+    Skill --> SkillResult[获取技能效果数据]\n+    SkillResult --> PushData[推送效果数据<br/>通过DataHandleQueue推送到目标单位]\n+    \n+    PushData --> Visual[可视化<br/>行动协调器通知表现层]\n+    Visual --> CheckMovePoint[移动点数检查<br/>单位管理检查是否还有移动点]\n+    \n+    CheckMovePoint -->|还有移动点| Loop[继续循环<br/>返回ACTION状态]\n+    CheckMovePoint -->|无移动点| End[END: 单位结束行动]\n+    Loop --> Skill\n+    \n+    style Start fill:#e1f5ff\n+    style Move fill:#fff4e1\n+    style Skill fill:#c8e6c9\n+    style PushData fill:#f3e5f5\n+    style Visual fill:#c8e6c9\n+    style End fill:#c8e6c9\n+```\n+\n+**流程说明**：\n+1. **START**：单位开始行动\n+2. **移动前检查**：单位管理检查移动点数（能否移动）\n+3. **单位移动**：行动协调器调用网格系统进行移动\n+4. **更新移动点数**：通过 DataHandleQueue 推送移动点数变更\n+5. **攻击/治疗**：行动协调器调用技能领域执行技能\n+6. **推送效果数据**：将技能效果通过 DataHandleQueue 推送到目标单位\n+7. **可视化**：行动协调器通知表现层播放效果\n+8. **移动点数检查**：单位管理检查是否还有移动点\n+9. **循环或结束**：还有移动点则继续循环，否则结束\n+\n+### 数值控制流程（通过 DataHandleQueue）\n+\n+**核心设计**：对其他单位的数值控制（攻击扣血、加buff）通过 DataHandleQueue 推送，目标单位通过队列接收并处理。\n+\n+```mermaid\n+flowchart LR\n+    SkillDomain[技能领域<br/>返回效果数据] --> ActionCoord[行动协调器<br/>接收效果数据]\n+    ActionCoord --> PushQueue[DataHandleQueue<br/>PushData效果数据]\n+    PushQueue --> ProcessQueue[DataHandleQueue<br/>ProcessDataHandler]\n+    ProcessQueue --> TargetUnit[目标单位<br/>OnDataHandler]\n+    TargetUnit --> UnitManagement[单位管理<br/>应用效果]\n+    UnitManagement --> UpdateState[更新状态<br/>扣血/加buff]\n+    \n+    style PushQueue fill:#f3e5f5\n+    style ProcessQueue fill:#f3e5f5\n+    style TargetUnit fill:#e1f5ff\n+    style UnitManagement fill:#fff4e1\n+```\n+\n+**数据推送示例**：\n+```lua\n+-- 行动协调器：推送效果数据到队列\n+local context = {\n+    dataType = EDataHandle.Effect.Damage,\n+    targetUnitId = targetUnitId,\n+    damage = 50,\n+    sourceUnitId = self.unitId\n+}\n+DataHandleQueue:PushData(context)\n+\n+-- 目标单位：通过队列接收并处理\n+function UnitData:OnDataHandler(dataType, data)\n+    if dataType == EDataHandle.Effect.Damage then\n+        -- 应用伤害\n+        self:ApplyDamage(data.damage)\n+    elseif dataType == EDataHandle.Effect.Buff then\n+        -- 应用buff\n+        self:ApplyBuff(data.buffId)\n+    end\n+end\n+```\n+\n+### 单位领域与外部系统的关系\n+\n+```mermaid\n+graph TB\n+    UnitDomain[单位领域] --> GridSystem[网格系统<br/>基础设施层]\n+    UnitDomain --> SkillDomain[技能领域<br/>领域层]\n+    UnitDomain --> DataHandleQueue[DataHandleQueue<br/>通信层]\n+    UnitDomain --> VisualSystem[表现系统<br/>表现层]\n+    \n+    DataHandleQueue --> TargetUnit[目标单位<br/>通过队列接收数据]\n+    \n+    style UnitDomain fill:#e1f5ff\n+    style GridSystem fill:#fff4e1\n+    style SkillDomain fill:#c8e6c9\n+    style DataHandleQueue fill:#f3e5f5\n+    style VisualSystem fill:#c8e6c9\n+    style TargetUnit fill:#e1f5ff\n+```\n+\n+**关系说明**：\n+- **网格系统**：基础设施层，提供移动计算服务\n+- **技能领域**：领域层，提供技能执行服务\n+- **DataHandleQueue**：通信层，提供数据推送和处理服务\n+- **表现系统**：表现层，提供可视化服务\n+- **目标单位**：通过 DataHandleQueue 接收数据变更，实现解耦\n+\n+### 设计优势\n+\n+- ✅ **解耦设计**：通过 DataHandleQueue 实现模块间解耦，行动协调器不直接操作目标单位\n+- ✅ **统一接口**：所有数值控制通过统一接口推送，易于维护\n+- ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n+- ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n+- ✅ **微核心设计**：行动协调器只负责协调调用，不包含业务规则，易于扩展\n+\n"
                },
                {
                    "date": 1767105981481,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -181,18 +181,17 @@\n         RuleMgr[单位规则管理<br/>移动点数检查/行动规则]\n         ValueControlMgr[数值控制管理<br/>接收DataHandleQueue数据]\n     end\n     \n-    subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator\"]\n+    subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n         MoveCoord[移动协调<br/>调用网格系统]\n         SkillCoord[技能协调<br/>调用技能领域]\n-        ValueCoord[数值控制协调<br/>推送DataHandleQueue]\n         VisualCoord[表现协调<br/>通知表现层]\n     end\n     \n     subgraph ExternalSystems[\"外部系统\"]\n         GridSystem[网格系统<br/>GridSystem]\n-        SkillDomain[技能领域<br/>Skill Domain]\n+        SkillDomain[技能领域<br/>Skill Domain<br/>EffectHandler推送DataHandleQueue]\n         DataHandleQueue[数据队列<br/>DataHandleQueue<br/>中间层]\n         VisualSystem[表现系统<br/>Visual System]\n     end\n     \n@@ -200,13 +199,12 @@\n     UnitLoop --> ActionCoordinator\n     \n     ActionCoordinator -->|调用| GridSystem\n     ActionCoordinator -->|调用| SkillDomain\n-    ActionCoordinator -->|推送数据| DataHandleQueue\n     ActionCoordinator -->|通知| VisualSystem\n     \n+    SkillDomain -->|EffectHandler推送| DataHandleQueue\n     DataHandleQueue -->|处理数据| ValueControlMgr\n-    SkillDomain -->|返回效果数据| ValueCoord\n     \n     style UnitDomain fill:#e1f5ff\n     style UnitManagement fill:#fff4e1\n     style UnitLoop fill:#f3e5f5\n"
                },
                {
                    "date": 1767105995999,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -247,45 +247,43 @@\n - **移动后更新**：通过 DataHandleQueue 更新单位位置和移动点数\n \n #### 2. 技能协调\n - **调用技能领域**：执行技能\n-- **接收技能结果**：获取技能效果数据\n-- **协调数值控制**：将技能效果通过 DataHandleQueue 推送到目标单位\n+- **不处理数值控制**：数值控制由技能领域的EffectHandler通过DataHandleQueue处理\n+- **接收技能结果**：获取技能执行结果（成功/失败），用于流程控制\n \n-#### 3. 数值控制协调\n-- **接收技能效果**：从技能领域获取效果数据\n-- **推送到 DataHandleQueue**：将效果数据推送到队列，由队列处理\n-- **不直接修改目标**：不直接操作目标单位数据，通过队列解耦\n-\n-#### 4. 表现协调\n+#### 3. 表现协调\n - **通知表现层**：移动表现、技能表现、受攻击表现\n \n ### DataHandleQueue 作为中间层\n \n-**核心设计**：所有数值控制都通过 DataHandleQueue 推送，实现模块间解耦。\n+**核心设计**：所有数值控制都通过 DataHandleQueue 推送，实现模块间解耦。**数值控制由技能领域的EffectHandler负责推送，行动协调器不处理数值控制**。\n \n ```mermaid\n sequenceDiagram\n     participant AC as 行动协调器\n     participant SD as 技能领域\n+    participant EH as EffectHandler\n     participant DHQ as DataHandleQueue\n     participant TU as 目标单位\n     participant UM as 单位管理\n     \n     AC -> SD: 调用技能领域执行技能\n-    SD -> AC: 返回技能效果数据\n-    AC -> DHQ: PushData(效果数据, 目标单位ID)\n+    SD -> EH: EffectHandler应用效果\n+    EH -> DHQ: PushData(效果数据, 目标单位ID)\n+    SD -> AC: 返回技能执行结果（成功/失败）\n     DHQ -> TU: ProcessDataHandler()\n     TU -> UM: OnDataHandler(效果数据)\n     UM -> UM: 应用效果（扣血/加buff）\n     UM -> UM: 更新状态\n ```\n \n **数据流特性**：\n-- ✅ **解耦设计**：行动协调器不直接操作目标单位，通过队列解耦\n+- ✅ **解耦设计**：技能领域的EffectHandler负责推送数据，行动协调器不处理数值控制\n - ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n - ✅ **统一接口**：所有数值控制通过统一接口推送\n - ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n+- ✅ **职责清晰**：行动协调器只负责协调调用，EffectHandler负责数值控制\n \n ### 单位行动完整流程\n \n ```mermaid\n"
                },
                {
                    "date": 1767106001151,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -297,12 +297,11 @@\n     SkipMove --> Skill\n     \n     UpdateMove --> Skill[攻击/治疗<br/>行动协调器调用技能领域]\n     \n-    Skill --> SkillResult[获取技能效果数据]\n-    SkillResult --> PushData[推送效果数据<br/>通过DataHandleQueue推送到目标单位]\n+    Skill --> SkillResult[获取技能执行结果<br/>成功/失败]\n     \n-    PushData --> Visual[可视化<br/>行动协调器通知表现层]\n+    SkillResult --> Visual[可视化<br/>行动协调器通知表现层<br/>技能领域的EffectHandler已推送DataHandleQueue]\n     Visual --> CheckMovePoint[移动点数检查<br/>单位管理检查是否还有移动点]\n     \n     CheckMovePoint -->|还有移动点| Loop[继续循环<br/>返回ACTION状态]\n     CheckMovePoint -->|无移动点| End[END: 单位结束行动]\n"
                },
                {
                    "date": 1767106011711,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -320,42 +320,57 @@\n 2. **移动前检查**：单位管理检查移动点数（能否移动）\n 3. **单位移动**：行动协调器调用网格系统进行移动\n 4. **更新移动点数**：通过 DataHandleQueue 推送移动点数变更\n 5. **攻击/治疗**：行动协调器调用技能领域执行技能\n-6. **推送效果数据**：将技能效果通过 DataHandleQueue 推送到目标单位\n+6. **技能执行**：技能领域的EffectHandler通过DataHandleQueue推送效果数据到目标单位\n 7. **可视化**：行动协调器通知表现层播放效果\n 8. **移动点数检查**：单位管理检查是否还有移动点\n 9. **循环或结束**：还有移动点则继续循环，否则结束\n \n+**关键点**：\n+- ✅ **行动协调器不处理数值控制**：只负责调用技能领域，不处理效果数据推送\n+- ✅ **EffectHandler负责推送**：技能领域的EffectHandler负责通过DataHandleQueue推送效果数据\n+- ✅ **单位管理接收数据**：目标单位通过DataHandleQueue接收并处理效果数据\n+\n ### 数值控制流程（通过 DataHandleQueue）\n \n-**核心设计**：对其他单位的数值控制（攻击扣血、加buff）通过 DataHandleQueue 推送，目标单位通过队列接收并处理。\n+**核心设计**：对其他单位的数值控制（攻击扣血、加buff）由**技能领域的EffectHandler**通过 DataHandleQueue 推送，目标单位通过队列接收并处理。**行动协调器不处理数值控制**。\n \n ```mermaid\n flowchart LR\n-    SkillDomain[技能领域<br/>返回效果数据] --> ActionCoord[行动协调器<br/>接收效果数据]\n-    ActionCoord --> PushQueue[DataHandleQueue<br/>PushData效果数据]\n+    ActionCoord[行动协调器<br/>调用技能领域] --> SkillDomain[技能领域<br/>执行技能]\n+    SkillDomain --> EffectHandler[EffectHandler<br/>应用效果]\n+    EffectHandler --> PushQueue[DataHandleQueue<br/>PushData效果数据]\n     PushQueue --> ProcessQueue[DataHandleQueue<br/>ProcessDataHandler]\n     ProcessQueue --> TargetUnit[目标单位<br/>OnDataHandler]\n     TargetUnit --> UnitManagement[单位管理<br/>应用效果]\n     UnitManagement --> UpdateState[更新状态<br/>扣血/加buff]\n     \n+    style ActionCoord fill:#c8e6c9\n+    style SkillDomain fill:#c8e6c9\n+    style EffectHandler fill:#fff4e1\n     style PushQueue fill:#f3e5f5\n     style ProcessQueue fill:#f3e5f5\n     style TargetUnit fill:#e1f5ff\n     style UnitManagement fill:#fff4e1\n ```\n \n **数据推送示例**：\n ```lua\n--- 行动协调器：推送效果数据到队列\n-local context = {\n-    dataType = EDataHandle.Effect.Damage,\n-    targetUnitId = targetUnitId,\n-    damage = 50,\n-    sourceUnitId = self.unitId\n-}\n-DataHandleQueue:PushData(context)\n+-- 技能领域的EffectHandler：推送效果数据到队列\n+-- SkillEffectHandler内部实现\n+function SkillEffectHandler:ApplyEffect(context)\n+    local effectData = self:CalculateEffect(context)\n+    \n+    -- EffectHandler负责推送数据\n+    local queueContext = {\n+        dataType = EDataHandle.Effect.Damage,\n+        targetUnitId = context.targetUnitId,\n+        damage = effectData.damage,\n+        sourceUnitId = context.caster.unitId\n+    }\n+    DataHandleQueue:PushData(queueContext)\n+end\n \n -- 目标单位：通过队列接收并处理\n function UnitData:OnDataHandler(dataType, data)\n     if dataType == EDataHandle.Effect.Damage then\n@@ -367,8 +382,13 @@\n     end\n end\n ```\n \n+**职责划分**：\n+- ✅ **行动协调器**：只负责调用技能领域，不处理数值控制\n+- ✅ **技能领域的EffectHandler**：负责通过DataHandleQueue推送效果数据\n+- ✅ **目标单位**：通过DataHandleQueue接收并处理效果数据\n+\n ### 单位领域与外部系统的关系\n \n ```mermaid\n graph TB\n"
                },
                {
                    "date": 1767106025078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -415,10 +415,12 @@\n - **目标单位**：通过 DataHandleQueue 接收数据变更，实现解耦\n \n ### 设计优势\n \n-- ✅ **解耦设计**：通过 DataHandleQueue 实现模块间解耦，行动协调器不直接操作目标单位\n+- ✅ **解耦设计**：通过 DataHandleQueue 实现模块间解耦，技能领域的EffectHandler负责推送数据\n+- ✅ **职责清晰**：行动协调器只负责协调调用，EffectHandler负责数值控制，职责分离\n - ✅ **统一接口**：所有数值控制通过统一接口推送，易于维护\n - ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n - ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n - ✅ **微核心设计**：行动协调器只负责协调调用，不包含业务规则，易于扩展\n+- ✅ **符合技能系统架构**：与技能系统的Handler策略模式设计一致，EffectHandler负责效果应用\n \n"
                },
                {
                    "date": 1767106218416,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -194,10 +194,12 @@\n         DataHandleQueue[数据队列<br/>DataHandleQueue<br/>中间层]\n         VisualSystem[表现系统<br/>Visual System]\n     end\n     \n-    UnitManagement --> UnitLoop\n-    UnitLoop --> ActionCoordinator\n+    UnitManagement -->|控制| UnitLoop\n+    UnitManagement --> ActionCoordinator\n+    ActionCoordinator -->|反向推动| UnitLoop\n+    UnitLoop -->|推进| UnitManagement\n     \n     ActionCoordinator -->|调用| GridSystem\n     ActionCoordinator -->|调用| SkillDomain\n     ActionCoordinator -->|通知| VisualSystem\n"
                },
                {
                    "date": 1767106242442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -242,21 +242,33 @@\n ### 行动协调器（ActionCoordinator）- 微核心\n \n **核心原则**：只负责协调调用，不包含业务规则（回答3：只负责协调调用）\n \n+**核心职责**：\n+- ✅ **协调调用**：调用网格系统、技能领域、表现系统\n+- ✅ **反向推动循环**：执行完行动后，主动推动单位循环进入下一个状态（Domain controls Loop）\n+\n #### 1. 移动协调\n - **移动前检查**：调用单位管理检查移动点数\n - **调用网格系统**：进行移动计算\n - **移动后更新**：通过 DataHandleQueue 更新单位位置和移动点数\n+- **推动循环**：移动完成后，推动循环进入下一个状态\n \n #### 2. 技能协调\n - **调用技能领域**：执行技能\n - **不处理数值控制**：数值控制由技能领域的EffectHandler通过DataHandleQueue处理\n - **接收技能结果**：获取技能执行结果（成功/失败），用于流程控制\n+- **推动循环**：技能执行完成后，推动循环进入下一个状态\n \n #### 3. 表现协调\n - **通知表现层**：移动表现、技能表现、受攻击表现\n+- **推动循环**：表现播放完成后（可选），推动循环进入下一个状态\n \n+#### 4. 循环推动机制\n+- **推动到END**：行动完成后，推动循环从ACTION状态进入END状态\n+- **推动到ACTION**：如果需要继续行动（还有移动点），推动循环从END状态回到ACTION状态\n+- **推动到START**：单位行动开始时，推动循环进入START状态\n+\n ### DataHandleQueue 作为中间层\n \n **核心设计**：所有数值控制都通过 DataHandleQueue 推送，实现模块间解耦。**数值控制由技能领域的EffectHandler负责推送，行动协调器不处理数值控制**。\n \n"
                },
                {
                    "date": 1767106278688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -301,10 +301,12 @@\n ### 单位行动完整流程\n \n ```mermaid\n flowchart TD\n-    Start[START: 单位开始行动] --> CheckMove[移动前检查<br/>单位管理检查移动点数]\n+    Start[START: 单位开始行动<br/>单位管理推动循环] --> Action[ACTION: 执行行动<br/>单位循环进入ACTION状态]\n     \n+    Action --> CheckMove[移动前检查<br/>单位管理检查移动点数]\n+    \n     CheckMove -->|可以移动| Move[单位移动<br/>行动协调器调用网格系统]\n     CheckMove -->|不能移动| SkipMove[跳过移动]\n     \n     Move --> UpdateMove[更新移动点数<br/>通过DataHandleQueue推送]\n@@ -314,19 +316,26 @@\n     \n     Skill --> SkillResult[获取技能执行结果<br/>成功/失败]\n     \n     SkillResult --> Visual[可视化<br/>行动协调器通知表现层<br/>技能领域的EffectHandler已推送DataHandleQueue]\n-    Visual --> CheckMovePoint[移动点数检查<br/>单位管理检查是否还有移动点]\n+    Visual --> PushLoop[行动协调器推动循环<br/>推动到END状态]\n     \n-    CheckMovePoint -->|还有移动点| Loop[继续循环<br/>返回ACTION状态]\n-    CheckMovePoint -->|无移动点| End[END: 单位结束行动]\n-    Loop --> Skill\n+    PushLoop --> CheckMovePoint[移动点数检查<br/>单位管理检查是否还有移动点]\n     \n+    CheckMovePoint -->|还有移动点| PushAction[行动协调器推动循环<br/>推动回ACTION状态]\n+    CheckMovePoint -->|无移动点| PushEnd[行动协调器推动循环<br/>推动到END状态]\n+    \n+    PushAction --> Skill\n+    PushEnd --> End[END: 单位结束行动<br/>单位循环进入END状态]\n+    \n     style Start fill:#e1f5ff\n+    style Action fill:#fff4e1\n     style Move fill:#fff4e1\n     style Skill fill:#c8e6c9\n-    style PushData fill:#f3e5f5\n     style Visual fill:#c8e6c9\n+    style PushLoop fill:#f3e5f5\n+    style PushAction fill:#f3e5f5\n+    style PushEnd fill:#f3e5f5\n     style End fill:#c8e6c9\n ```\n \n **流程说明**：\n"
                },
                {
                    "date": 1767106294392,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -338,19 +338,25 @@\n     style End fill:#c8e6c9\n ```\n \n **流程说明**：\n-1. **START**：单位开始行动\n-2. **移动前检查**：单位管理检查移动点数（能否移动）\n-3. **单位移动**：行动协调器调用网格系统进行移动\n-4. **更新移动点数**：通过 DataHandleQueue 推送移动点数变更\n-5. **攻击/治疗**：行动协调器调用技能领域执行技能\n-6. **技能执行**：技能领域的EffectHandler通过DataHandleQueue推送效果数据到目标单位\n-7. **可视化**：行动协调器通知表现层播放效果\n-8. **移动点数检查**：单位管理检查是否还有移动点\n-9. **循环或结束**：还有移动点则继续循环，否则结束\n+1. **START**：单位管理推动循环进入START状态\n+2. **ACTION**：单位循环进入ACTION状态，开始执行行动\n+3. **移动前检查**：单位管理检查移动点数（能否移动）\n+4. **单位移动**：行动协调器调用网格系统进行移动\n+5. **更新移动点数**：通过 DataHandleQueue 推送移动点数变更\n+6. **攻击/治疗**：行动协调器调用技能领域执行技能\n+7. **技能执行**：技能领域的EffectHandler通过DataHandleQueue推送效果数据到目标单位\n+8. **可视化**：行动协调器通知表现层播放效果\n+9. **推动循环**：行动协调器推动循环进入END状态\n+10. **移动点数检查**：单位管理检查是否还有移动点\n+11. **循环或结束**：\n+    - 还有移动点：行动协调器推动循环回到ACTION状态，继续执行\n+    - 无移动点：行动协调器推动循环保持在END状态，结束行动\n \n **关键点**：\n+- ✅ **Domain controls Loop**：单位管理通过行动协调器控制循环状态转换\n+- ✅ **反向推动机制**：行动协调器执行完行动后，主动推动循环进入下一个状态\n - ✅ **行动协调器不处理数值控制**：只负责调用技能领域，不处理效果数据推送\n - ✅ **EffectHandler负责推送**：技能领域的EffectHandler负责通过DataHandleQueue推送效果数据\n - ✅ **单位管理接收数据**：目标单位通过DataHandleQueue接收并处理效果数据\n \n"
                },
                {
                    "date": 1767106313221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -172,21 +172,22 @@\n graph TB\n     subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n         UnitManagement[单位管理<br/>UnitManagement]\n         UnitLoop[单位循环<br/>UnitLoop<br/>START → ACTION → END]\n-        ActionCoordinator[行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用]\n+        ActionCoordinator[行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用<br/>反向推动循环]\n     end\n     \n     subgraph UnitManagement[\"单位管理<br/>UnitManagement\"]\n         DataMgr[单位数据管理<br/>属性/状态/位置]\n         RuleMgr[单位规则管理<br/>移动点数检查/行动规则]\n         ValueControlMgr[数值控制管理<br/>接收DataHandleQueue数据]\n     end\n     \n-    subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n+    subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator\"]\n         MoveCoord[移动协调<br/>调用网格系统]\n         SkillCoord[技能协调<br/>调用技能领域]\n         VisualCoord[表现协调<br/>通知表现层]\n+        LoopPusher[循环推动器<br/>推动循环状态转换]\n     end\n     \n     subgraph ExternalSystems[\"外部系统\"]\n         GridSystem[网格系统<br/>GridSystem]\n@@ -195,23 +196,25 @@\n         VisualSystem[表现系统<br/>Visual System]\n     end\n     \n     UnitManagement -->|控制| UnitLoop\n-    UnitManagement --> ActionCoordinator\n+    UnitManagement -->|创建| ActionCoordinator\n     ActionCoordinator -->|反向推动| UnitLoop\n     UnitLoop -->|推进| UnitManagement\n     \n     ActionCoordinator -->|调用| GridSystem\n     ActionCoordinator -->|调用| SkillDomain\n     ActionCoordinator -->|通知| VisualSystem\n+    ActionCoordinator -->|推动状态| LoopPusher\n     \n     SkillDomain -->|EffectHandler推送| DataHandleQueue\n     DataHandleQueue -->|处理数据| ValueControlMgr\n     \n     style UnitDomain fill:#e1f5ff\n     style UnitManagement fill:#fff4e1\n     style UnitLoop fill:#f3e5f5\n     style ActionCoordinator fill:#c8e6c9\n+    style LoopPusher fill:#f3e5f5\n     style DataHandleQueue fill:#f3e5f5\n ```\n \n ### 单位管理（UnitManagement）\n"
                },
                {
                    "date": 1767106333405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -172,22 +172,21 @@\n graph TB\n     subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n         UnitManagement[单位管理<br/>UnitManagement]\n         UnitLoop[单位循环<br/>UnitLoop<br/>START → ACTION → END]\n-        ActionCoordinator[行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用<br/>反向推动循环]\n+        ActionCoordinator[行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用]\n     end\n     \n     subgraph UnitManagement[\"单位管理<br/>UnitManagement\"]\n         DataMgr[单位数据管理<br/>属性/状态/位置]\n         RuleMgr[单位规则管理<br/>移动点数检查/行动规则]\n         ValueControlMgr[数值控制管理<br/>接收DataHandleQueue数据]\n     end\n     \n-    subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator\"]\n+    subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n         MoveCoord[移动协调<br/>调用网格系统]\n         SkillCoord[技能协调<br/>调用技能领域]\n         VisualCoord[表现协调<br/>通知表现层]\n-        LoopPusher[循环推动器<br/>推动循环状态转换]\n     end\n     \n     subgraph ExternalSystems[\"外部系统\"]\n         GridSystem[网格系统<br/>GridSystem]\n@@ -196,25 +195,23 @@\n         VisualSystem[表现系统<br/>Visual System]\n     end\n     \n     UnitManagement -->|控制| UnitLoop\n-    UnitManagement -->|创建| ActionCoordinator\n+    UnitManagement --> ActionCoordinator\n     ActionCoordinator -->|反向推动| UnitLoop\n     UnitLoop -->|推进| UnitManagement\n     \n     ActionCoordinator -->|调用| GridSystem\n     ActionCoordinator -->|调用| SkillDomain\n     ActionCoordinator -->|通知| VisualSystem\n-    ActionCoordinator -->|推动状态| LoopPusher\n     \n     SkillDomain -->|EffectHandler推送| DataHandleQueue\n     DataHandleQueue -->|处理数据| ValueControlMgr\n     \n     style UnitDomain fill:#e1f5ff\n     style UnitManagement fill:#fff4e1\n     style UnitLoop fill:#f3e5f5\n     style ActionCoordinator fill:#c8e6c9\n-    style LoopPusher fill:#f3e5f5\n     style DataHandleQueue fill:#f3e5f5\n ```\n \n ### 单位管理（UnitManagement）\n"
                },
                {
                    "date": 1767106522261,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -176,13 +176,17 @@\n         ActionCoordinator[行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用]\n     end\n     \n     subgraph UnitManagement[\"单位管理<br/>UnitManagement\"]\n+        UnitData[单位数据<br/>UnitData<br/>1:1关系]\n         DataMgr[单位数据管理<br/>属性/状态/位置]\n         RuleMgr[单位规则管理<br/>移动点数检查/行动规则]\n-        ValueControlMgr[数值控制管理<br/>接收DataHandleQueue数据]\n     end\n     \n+    subgraph DataHandleQueue[\"DataHandleQueue<br/>数据队列<br/>1:1关系\"]\n+        Queue[数据队列<br/>Queue]\n+    end\n+    \n     subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n         MoveCoord[移动协调<br/>调用网格系统]\n         SkillCoord[技能协调<br/>调用技能领域]\n         VisualCoord[表现协调<br/>通知表现层]\n"
                },
                {
                    "date": 1767106535417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -194,23 +194,24 @@\n     \n     subgraph ExternalSystems[\"外部系统\"]\n         GridSystem[网格系统<br/>GridSystem]\n         SkillDomain[技能领域<br/>Skill Domain<br/>EffectHandler推送DataHandleQueue]\n-        DataHandleQueue[数据队列<br/>DataHandleQueue<br/>中间层]\n         VisualSystem[表现系统<br/>Visual System]\n     end\n     \n     UnitManagement -->|控制| UnitLoop\n     UnitManagement --> ActionCoordinator\n+    UnitManagement --> UnitData\n     ActionCoordinator -->|反向推动| UnitLoop\n     UnitLoop -->|推进| UnitManagement\n     \n     ActionCoordinator -->|调用| GridSystem\n     ActionCoordinator -->|调用| SkillDomain\n     ActionCoordinator -->|通知| VisualSystem\n     \n     SkillDomain -->|EffectHandler推送| DataHandleQueue\n-    DataHandleQueue -->|处理数据| ValueControlMgr\n+    DataHandleQueue -->|1:1关系| UnitData\n+    DataHandleQueue -->|直接修改| UnitData\n     \n     style UnitDomain fill:#e1f5ff\n     style UnitManagement fill:#fff4e1\n     style UnitLoop fill:#f3e5f5\n"
                },
                {
                    "date": 1767106543383,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -230,12 +230,12 @@\n - **移动点数规则**：移动前检查能否移动（回答1：移动前检查）\n - **行动规则**：是否可执行行动\n - **状态规则**：状态转换规则\n \n-#### 3. 数值控制管理\n-- **接收数据变更**：通过 DataHandleQueue 接收其他单位对自己的数值控制（攻击扣血、加buff等）\n-- **效果应用**：应用技能效果到自身\n-- **状态更新**：更新自身状态\n+#### 3. UnitData（单位数据）\n+- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，数据直接修改 UnitData\n+- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n+- **无需中间层**：不需要\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n \n ### 单位循环（UnitLoop）\n \n **循环状态**：START → ACTION → END（回答2：不需要更细的状态）\n"
                },
                {
                    "date": 1767106559829,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,32 +272,35 @@\n - **推动到END**：行动完成后，推动循环从ACTION状态进入END状态\n - **推动到ACTION**：如果需要继续行动（还有移动点），推动循环从END状态回到ACTION状态\n - **推动到START**：单位行动开始时，推动循环进入START状态\n \n-### DataHandleQueue 作为中间层\n+### DataHandleQueue 作为单位领域内部组件\n \n-**核心设计**：所有数值控制都通过 DataHandleQueue 推送，实现模块间解耦。**数值控制由技能领域的EffectHandler负责推送，行动协调器不处理数值控制**。\n+**核心设计**：\n+- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n+- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n+- **无需中间层**：不需要\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n \n ```mermaid\n sequenceDiagram\n     participant AC as 行动协调器\n     participant SD as 技能领域\n     participant EH as EffectHandler\n-    participant DHQ as DataHandleQueue\n-    participant TU as 目标单位\n-    participant UM as 单位管理\n+    participant DHQ as DataHandleQueue<br/>单位领域内部\n+    participant UD as UnitData<br/>1:1关系\n     \n     AC -> SD: 调用技能领域执行技能\n     SD -> EH: EffectHandler应用效果\n     EH -> DHQ: PushData(效果数据, 目标单位ID)\n     SD -> AC: 返回技能执行结果（成功/失败）\n-    DHQ -> TU: ProcessDataHandler()\n-    TU -> UM: OnDataHandler(效果数据)\n-    UM -> UM: 应用效果（扣血/加buff）\n-    UM -> UM: 更新状态\n+    DHQ -> UD: ProcessDataHandler()<br/>直接修改UnitData\n+    UD -> UD: 应用效果（扣血/加buff）\n+    UD -> UD: 更新状态\n ```\n \n **数据流特性**：\n+- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n+- ✅ **直接修改**：数据直接修改UnitData，无需经过中间层\n - ✅ **解耦设计**：技能领域的EffectHandler负责推送数据，行动协调器不处理数值控制\n - ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n - ✅ **统一接口**：所有数值控制通过统一接口推送\n - ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n"
                },
                {
                    "date": 1767106568036,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -216,8 +216,9 @@\n     style UnitManagement fill:#fff4e1\n     style UnitLoop fill:#f3e5f5\n     style ActionCoordinator fill:#c8e6c9\n     style DataHandleQueue fill:#f3e5f5\n+    style UnitData fill:#fff4e1\n ```\n \n ### 单位管理（UnitManagement）\n \n"
                },
                {
                    "date": 1767106595967,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,26 +173,26 @@\n     subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n         UnitManagement[单位管理<br/>UnitManagement]\n         UnitLoop[单位循环<br/>UnitLoop<br/>START → ACTION → END]\n         ActionCoordinator[行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用]\n+        \n+        subgraph UnitManagement[\"单位管理<br/>UnitManagement\"]\n+            UnitData[单位数据<br/>UnitData]\n+            DataMgr[单位数据管理<br/>属性/状态/位置]\n+            RuleMgr[单位规则管理<br/>移动点数检查/行动规则]\n+        end\n+        \n+        subgraph DataHandleQueue[\"DataHandleQueue<br/>数据队列<br/>1:1关系\"]\n+            Queue[数据队列<br/>Queue]\n+        end\n+        \n+        subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n+            MoveCoord[移动协调<br/>调用网格系统]\n+            SkillCoord[技能协调<br/>调用技能领域]\n+            VisualCoord[表现协调<br/>通知表现层]\n+        end\n     end\n     \n-    subgraph UnitManagement[\"单位管理<br/>UnitManagement\"]\n-        UnitData[单位数据<br/>UnitData<br/>1:1关系]\n-        DataMgr[单位数据管理<br/>属性/状态/位置]\n-        RuleMgr[单位规则管理<br/>移动点数检查/行动规则]\n-    end\n-    \n-    subgraph DataHandleQueue[\"DataHandleQueue<br/>数据队列<br/>1:1关系\"]\n-        Queue[数据队列<br/>Queue]\n-    end\n-    \n-    subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n-        MoveCoord[移动协调<br/>调用网格系统]\n-        SkillCoord[技能协调<br/>调用技能领域]\n-        VisualCoord[表现协调<br/>通知表现层]\n-    end\n-    \n     subgraph ExternalSystems[\"外部系统\"]\n         GridSystem[网格系统<br/>GridSystem]\n         SkillDomain[技能领域<br/>Skill Domain<br/>EffectHandler推送DataHandleQueue]\n         VisualSystem[表现系统<br/>Visual System]\n"
                },
                {
                    "date": 1767106611430,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -366,9 +366,10 @@\n - ✅ **Domain controls Loop**：单位管理通过行动协调器控制循环状态转换\n - ✅ **反向推动机制**：行动协调器执行完行动后，主动推动循环进入下一个状态\n - ✅ **行动协调器不处理数值控制**：只负责调用技能领域，不处理效果数据推送\n - ✅ **EffectHandler负责推送**：技能领域的EffectHandler负责通过DataHandleQueue推送效果数据\n-- ✅ **单位管理接收数据**：目标单位通过DataHandleQueue接收并处理效果数据\n+- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，数据直接修改 UnitData\n+- ✅ **直接修改**：不需要经过\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n \n ### 数值控制流程（通过 DataHandleQueue）\n \n **核心设计**：对其他单位的数值控制（攻击扣血、加buff）由**技能领域的EffectHandler**通过 DataHandleQueue 推送，目标单位通过队列接收并处理。**行动协调器不处理数值控制**。\n"
                },
                {
                    "date": 1767106646025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -371,27 +371,30 @@\n - ✅ **直接修改**：不需要经过\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n \n ### 数值控制流程（通过 DataHandleQueue）\n \n-**核心设计**：对其他单位的数值控制（攻击扣血、加buff）由**技能领域的EffectHandler**通过 DataHandleQueue 推送，目标单位通过队列接收并处理。**行动协调器不处理数值控制**。\n+**核心设计**：\n+- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n+- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n+- **无需中间层**：不需要经过\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n+- **行动协调器不处理数值控制**：只负责调用技能领域，不处理效果数据推送\n \n ```mermaid\n flowchart LR\n     ActionCoord[行动协调器<br/>调用技能领域] --> SkillDomain[技能领域<br/>执行技能]\n     SkillDomain --> EffectHandler[EffectHandler<br/>应用效果]\n-    EffectHandler --> PushQueue[DataHandleQueue<br/>PushData效果数据]\n+    EffectHandler --> PushQueue[DataHandleQueue<br/>单位领域内部<br/>PushData效果数据]\n     PushQueue --> ProcessQueue[DataHandleQueue<br/>ProcessDataHandler]\n-    ProcessQueue --> TargetUnit[目标单位<br/>OnDataHandler]\n-    TargetUnit --> UnitManagement[单位管理<br/>应用效果]\n-    UnitManagement --> UpdateState[更新状态<br/>扣血/加buff]\n+    ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>直接修改]\n+    UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n     \n     style ActionCoord fill:#c8e6c9\n     style SkillDomain fill:#c8e6c9\n     style EffectHandler fill:#fff4e1\n     style PushQueue fill:#f3e5f5\n     style ProcessQueue fill:#f3e5f5\n-    style TargetUnit fill:#e1f5ff\n-    style UnitManagement fill:#fff4e1\n+    style UnitData fill:#e1f5ff\n+    style UpdateState fill:#fff4e1\n ```\n \n **数据推送示例**：\n ```lua\n"
                },
                {
                    "date": 1767106663999,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -402,34 +402,37 @@\n -- SkillEffectHandler内部实现\n function SkillEffectHandler:ApplyEffect(context)\n     local effectData = self:CalculateEffect(context)\n     \n-    -- EffectHandler负责推送数据\n+    -- EffectHandler负责推送数据到目标单位的DataHandleQueue\n+    local targetUnit = UnitDataMgr:GetUnit(context.targetUnitId)\n     local queueContext = {\n         dataType = EDataHandle.Effect.Damage,\n         targetUnitId = context.targetUnitId,\n         damage = effectData.damage,\n         sourceUnitId = context.caster.unitId\n     }\n-    DataHandleQueue:PushData(queueContext)\n+    -- DataHandleQueue 与 UnitData 是 1:1 关系，直接推送到目标单位的队列\n+    targetUnit.dataHandleQueue:PushData(queueContext)\n end\n \n--- 目标单位：通过队列接收并处理\n+-- UnitData：通过DataHandleQueue接收并直接处理（1:1关系）\n function UnitData:OnDataHandler(dataType, data)\n     if dataType == EDataHandle.Effect.Damage then\n-        -- 应用伤害\n+        -- 直接修改UnitData，无需经过中间层\n         self:ApplyDamage(data.damage)\n     elseif dataType == EDataHandle.Effect.Buff then\n-        -- 应用buff\n+        -- 直接修改UnitData，无需经过中间层\n         self:ApplyBuff(data.buffId)\n     end\n end\n ```\n \n **职责划分**：\n - ✅ **行动协调器**：只负责调用技能领域，不处理数值控制\n-- ✅ **技能领域的EffectHandler**：负责通过DataHandleQueue推送效果数据\n-- ✅ **目标单位**：通过DataHandleQueue接收并处理效果数据\n+- ✅ **技能领域的EffectHandler**：负责通过DataHandleQueue推送效果数据到目标单位\n+- ✅ **DataHandleQueue**：与UnitData是1:1关系，属于单位领域内部\n+- ✅ **UnitData**：通过DataHandleQueue接收并直接处理，无需经过\"数值控制管理\"中间层\n \n ### 单位领域与外部系统的关系\n \n ```mermaid\n"
                },
                {
                    "date": 1767106684243,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -460,8 +460,10 @@\n - **目标单位**：通过 DataHandleQueue 接收数据变更，实现解耦\n \n ### 设计优势\n \n+- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部，数据直接修改UnitData\n+- ✅ **无需中间层**：不需要\"数值控制管理\"中间层，简化架构设计\n - ✅ **解耦设计**：通过 DataHandleQueue 实现模块间解耦，技能领域的EffectHandler负责推送数据\n - ✅ **职责清晰**：行动协调器只负责协调调用，EffectHandler负责数值控制，职责分离\n - ✅ **统一接口**：所有数值控制通过统一接口推送，易于维护\n - ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n"
                },
                {
                    "date": 1767107097518,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -470,4 +470,364 @@\n - ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n - ✅ **微核心设计**：行动协调器只负责协调调用，不包含业务规则，易于扩展\n - ✅ **符合技能系统架构**：与技能系统的Handler策略模式设计一致，EffectHandler负责效果应用\n \n+---\n+\n+## 地形要素（陷阱）架构设计分析\n+\n+### 问题背景\n+\n+地形要素（如陷阱）是否应该包装为技能？这是一个重要的架构设计决策，需要从职责分离、概念清晰度、代码复用性等角度进行分析。\n+\n+### 相似性分析\n+\n+**陷阱与技能的共同点**：\n+- ✅ **触发条件**：都需要条件检查（距离、状态等）\n+- ✅ **目标选择**：都需要区域选择（单体、范围等）\n+- ✅ **效果应用**：都需要应用伤害、buff等效果\n+- ✅ **表现播放**：都需要播放特效、音效等\n+- ✅ **数据流**：都需要通过 DataHandleQueue 推送效果\n+\n+### 差异性分析\n+\n+| 维度 | 技能系统 | 地形要素（陷阱） |\n+|------|---------|----------------|\n+| **概念归属** | 单位能力 | 环境要素 |\n+| **触发方式** | 主动释放 | 被动触发（进入/接触） |\n+| **拥有者** | 单位拥有 | 地图/地形拥有 |\n+| **生命周期** | 单位生命周期 | 地图生命周期 |\n+| **冷却机制** | 有冷却 | 通常无冷却（或一次性） |\n+| **资源消耗** | 消耗MP/HP | 通常无消耗 |\n+\n+### 方案对比\n+\n+#### 方案1：包装为技能（不推荐）\n+\n+**设计思路**：将陷阱包装为技能，复用技能系统的Handler机制。\n+\n+**优点**：\n+- ✅ 复用技能系统的Handler机制\n+- ✅ 统一效果应用流程\n+- ✅ 减少代码重复\n+\n+**缺点**：\n+- ❌ **概念混淆**：环境要素被当作单位能力，语义不匹配\n+- ❌ **职责不清**：技能系统承担环境交互职责\n+- ❌ **扩展性差**：未来其他地形要素（门、宝箱等）是否也要包装为技能？\n+- ❌ **维护困难**：技能系统需要处理环境要素的特殊逻辑\n+\n+**结论**：不推荐，违反职责分离原则。\n+\n+---\n+\n+#### 方案2：独立的地形要素系统（推荐）\n+\n+**设计思路**：建立独立的地形要素系统，与技能系统平行，各自管理自己的职责。\n+\n+**架构设计**：\n+\n+```mermaid\n+graph TB\n+    subgraph TerrainDomain[\"地形要素Domain<br/>Terrain Domain\"]\n+        TerrainManagement[地形要素管理<br/>TerrainManagement]\n+        TerrainTrigger[地形要素触发<br/>TerrainTrigger]\n+    end\n+    \n+    subgraph TerrainManagement[\"地形要素管理<br/>TerrainManagement\"]\n+        TrapData[陷阱数据<br/>TrapData]\n+        TerrainRule[地形规则<br/>触发条件/效果配置]\n+    end\n+    \n+    subgraph TerrainTrigger[\"地形要素触发<br/>TerrainTrigger\"]\n+        ConditionCheck[条件检查<br/>距离/状态检查]\n+        EffectApply[效果应用<br/>通过DataHandleQueue推送]\n+        VisualPlay[表现播放<br/>通知表现层]\n+    end\n+    \n+    subgraph ExternalSystems[\"外部系统\"]\n+        GridSystem[网格系统<br/>位置检测]\n+        DataHandleQueue[DataHandleQueue<br/>效果推送]\n+        VisualSystem[表现系统<br/>可视化]\n+    end\n+    \n+    TerrainManagement --> TerrainTrigger\n+    TerrainTrigger -->|调用| GridSystem\n+    TerrainTrigger -->|推送| DataHandleQueue\n+    TerrainTrigger -->|通知| VisualSystem\n+    \n+    style TerrainDomain fill:#e1f5ff\n+    style TerrainManagement fill:#fff4e1\n+    style TerrainTrigger fill:#c8e6c9\n+    style ExternalSystems fill:#f3e5f5\n+```\n+\n+**优点**：\n+- ✅ **职责清晰**：地形要素属于环境系统，概念明确\n+- ✅ **概念明确**：符合领域驱动设计，系统边界清晰\n+- ✅ **扩展性好**：可支持多种地形要素（陷阱、门、宝箱等）\n+- ✅ **维护性强**：系统边界清晰，易于维护\n+\n+**缺点**：\n+- ⚠️ 需要重复实现类似Handler的机制（条件检查、效果应用等）\n+- ⚠️ 与技能系统存在代码重复\n+\n+**结论**：推荐，符合职责分离原则，但存在代码重复问题。\n+\n+---\n+\n+#### 方案3：共享Handler机制，但独立系统（最佳推荐）\n+\n+**设计思路**：抽象出公共的Handler接口，技能系统和地形要素系统都使用这些Handler，但保持系统独立。\n+\n+**核心设计**：\n+- **共享Handler层**：抽象出公共的Handler接口（ConditionHandler、EffectHandler、VisualHandler等）\n+- **独立系统层**：技能系统和地形要素系统各自实现自己的执行流程\n+- **统一数据流**：都通过DataHandleQueue推送效果\n+\n+**架构设计**：\n+\n+```mermaid\n+graph TB\n+    subgraph SharedHandlerLayer[\"共享Handler层<br/>Shared Handler Layer\"]\n+        ConditionHandler[条件Handler<br/>ConditionHandler<br/>接口]\n+        EffectHandler[效果Handler<br/>EffectHandler<br/>接口]\n+        VisualHandler[表现Handler<br/>VisualHandler<br/>接口]\n+    end\n+    \n+    subgraph SkillDomain[\"技能领域<br/>Skill Domain\"]\n+        SkillBase[技能基类<br/>SkillBase]\n+        SkillContext[技能上下文<br/>SkillContext]\n+        SkillExecution[技能执行流程<br/>条件→目标→效果→表现]\n+    end\n+    \n+    subgraph TerrainDomain[\"地形要素Domain<br/>Terrain Domain\"]\n+        TerrainBase[地形要素基类<br/>TerrainBase]\n+        TerrainContext[地形要素上下文<br/>TerrainContext]\n+        TerrainExecution[地形要素执行流程<br/>条件→效果→表现]\n+    end\n+    \n+    subgraph ExternalSystems[\"外部系统\"]\n+        DataHandleQueue[DataHandleQueue<br/>效果推送]\n+        VisualSystem[表现系统<br/>可视化]\n+    end\n+    \n+    SkillBase -->|使用| ConditionHandler\n+    SkillBase -->|使用| EffectHandler\n+    SkillBase -->|使用| VisualHandler\n+    \n+    TerrainBase -->|使用| ConditionHandler\n+    TerrainBase -->|使用| EffectHandler\n+    TerrainBase -->|使用| VisualHandler\n+    \n+    SkillExecution -->|推送| DataHandleQueue\n+    TerrainExecution -->|推送| DataHandleQueue\n+    \n+    SkillExecution -->|通知| VisualSystem\n+    TerrainExecution -->|通知| VisualSystem\n+    \n+    style SharedHandlerLayer fill:#f3e5f5\n+    style SkillDomain fill:#e1f5ff\n+    style TerrainDomain fill:#fff4e1\n+    style ExternalSystems fill:#c8e6c9\n+```\n+\n+**Handler接口设计**：\n+\n+```mermaid\n+graph TB\n+    subgraph HandlerInterface[\"Handler接口层\"]\n+        IHandler[IHandler<br/>基础接口]\n+        IConditionHandler[IConditionHandler<br/>条件检查接口]\n+        IEffectHandler[IEffectHandler<br/>效果应用接口]\n+        IVisualHandler[IVisualHandler<br/>表现播放接口]\n+    end\n+    \n+    subgraph SkillImplementation[\"技能系统实现\"]\n+        SkillConditionHandler[SkillConditionHandler<br/>实现IConditionHandler]\n+        SkillEffectHandler[SkillEffectHandler<br/>实现IEffectHandler]\n+        SkillVisualHandler[SkillVisualHandler<br/>实现IVisualHandler]\n+    end\n+    \n+    subgraph TerrainImplementation[\"地形要素系统实现\"]\n+        TerrainConditionHandler[TerrainConditionHandler<br/>实现IConditionHandler]\n+        TerrainEffectHandler[TerrainEffectHandler<br/>实现IEffectHandler]\n+        TerrainVisualHandler[TerrainVisualHandler<br/>实现IVisualHandler]\n+    end\n+    \n+    IHandler --> IConditionHandler\n+    IHandler --> IEffectHandler\n+    IHandler --> IVisualHandler\n+    \n+    IConditionHandler --> SkillConditionHandler\n+    IConditionHandler --> TerrainConditionHandler\n+    \n+    IEffectHandler --> SkillEffectHandler\n+    IEffectHandler --> TerrainEffectHandler\n+    \n+    IVisualHandler --> SkillVisualHandler\n+    IVisualHandler --> TerrainVisualHandler\n+    \n+    style HandlerInterface fill:#f3e5f5\n+    style SkillImplementation fill:#e1f5ff\n+    style TerrainImplementation fill:#fff4e1\n+```\n+\n+**执行流程对比**：\n+\n+```mermaid\n+graph LR\n+    subgraph SkillFlow[\"技能执行流程\"]\n+        S1[创建SkillContext] --> S2[ConditionHandler检查]\n+        S2 --> S3[RegionHandler选择目标]\n+        S3 --> S4[EffectHandler应用效果]\n+        S4 --> S5[VisualHandler播放表现]\n+    end\n+    \n+    subgraph TerrainFlow[\"地形要素执行流程\"]\n+        T1[创建TerrainContext] --> T2[ConditionHandler检查]\n+        T2 --> T3[EffectHandler应用效果]\n+        T3 --> T4[VisualHandler播放表现]\n+    end\n+    \n+    S4 -.推送DataHandleQueue.-> DataQueue[DataHandleQueue]\n+    T3 -.推送DataHandleQueue.-> DataQueue\n+    \n+    style SkillFlow fill:#e1f5ff\n+    style TerrainFlow fill:#fff4e1\n+    style DataQueue fill:#f3e5f5\n+```\n+\n+**实现示例**：\n+\n+```lua\n+-- ========== 共享Handler接口 ==========\n+-- IHandler.lua\n+IHandler = {}\n+function IHandler:Execute(context)\n+    -- 子类实现\n+end\n+\n+-- IConditionHandler.lua\n+IConditionHandler = {}\n+setmetatable(IConditionHandler, {__index = IHandler})\n+function IConditionHandler:Check(context)\n+    -- 子类实现\n+end\n+\n+-- IEffectHandler.lua\n+IEffectHandler = {}\n+setmetatable(IEffectHandler, {__index = IHandler})\n+function IEffectHandler:ApplyEffect(context)\n+    -- 子类实现\n+    -- 通过DataHandleQueue推送效果数据\n+end\n+\n+-- ========== 技能系统实现 ==========\n+-- SkillConditionHandler.lua\n+SkillConditionHandler = {}\n+setmetatable(SkillConditionHandler, {__index = IConditionHandler})\n+function SkillConditionHandler:Check(context)\n+    -- 技能特定的条件检查（MP、冷却等）\n+    return self:CheckMana(context) and self:CheckCooldown(context)\n+end\n+\n+-- SkillEffectHandler.lua\n+SkillEffectHandler = {}\n+setmetatable(SkillEffectHandler, {__index = IEffectHandler})\n+function SkillEffectHandler:ApplyEffect(context)\n+    -- 技能特定的效果应用\n+    local effectData = self:CalculateSkillEffect(context)\n+    -- 推送到目标单位的DataHandleQueue\n+    local targetUnit = UnitDataMgr:GetUnit(context.targetUnitId)\n+    targetUnit.dataHandleQueue:PushData({\n+        dataType = EDataHandle.Effect.Damage,\n+        damage = effectData.damage,\n+        sourceUnitId = context.caster.unitId\n+    })\n+end\n+\n+-- ========== 地形要素系统实现 ==========\n+-- TerrainBase.lua\n+TerrainBase = {}\n+function TerrainBase:Trigger(triggerUnit)\n+    local context = TerrainContext:New(self, triggerUnit)\n+    \n+    -- 使用共享的Handler接口\n+    if not self.conditionHandler:Check(context) then\n+        return false\n+    end\n+    \n+    self.effectHandler:ApplyEffect(context)\n+    self.visualHandler:Play(context)\n+    \n+    return true\n+end\n+\n+-- TerrainConditionHandler.lua\n+TerrainConditionHandler = {}\n+setmetatable(TerrainConditionHandler, {__index = IConditionHandler})\n+function TerrainConditionHandler:Check(context)\n+    -- 地形要素特定的条件检查（距离、状态等）\n+    return self:CheckDistance(context) and self:CheckState(context)\n+end\n+\n+-- TerrainEffectHandler.lua\n+TerrainEffectHandler = {}\n+setmetatable(TerrainEffectHandler, {__index = IEffectHandler})\n+function TerrainEffectHandler:ApplyEffect(context)\n+    -- 地形要素特定的效果应用\n+    local effectData = self:CalculateTrapEffect(context)\n+    -- 推送到触发单位的DataHandleQueue\n+    local triggerUnit = UnitDataMgr:GetUnit(context.triggerUnitId)\n+    triggerUnit.dataHandleQueue:PushData({\n+        dataType = EDataHandle.Effect.Damage,\n+        damage = effectData.damage,\n+        sourceTerrainId = context.terrain.id\n+    })\n+end\n+```\n+\n+**优点**：\n+- ✅ **职责清晰**：技能系统和地形要素系统各自独立，概念明确\n+- ✅ **代码复用**：共享Handler接口，避免代码重复\n+- ✅ **统一数据流**：都通过DataHandleQueue推送效果，统一接口\n+- ✅ **扩展性好**：新增Handler类型或系统都很容易\n+- ✅ **维护性强**：系统边界清晰，Handler接口统一，易于维护\n+- ✅ **符合开闭原则**：对扩展开放，对修改关闭\n+\n+**缺点**：\n+- ⚠️ 需要抽象出Handler接口，增加一层抽象\n+- ⚠️ 需要维护Handler接口的稳定性\n+\n+**结论**：**最佳推荐**，既保持了系统独立性，又实现了代码复用，符合SOLID原则。\n+\n+---\n+\n+### 方案对比总结\n+\n+| 对比项 | 方案1：包装为技能 | 方案2：独立系统 | 方案3：共享Handler |\n+|--------|------------------|----------------|-------------------|\n+| **职责清晰度** | ❌ 概念混淆 | ✅ 职责清晰 | ✅ 职责清晰 |\n+| **代码复用性** | ✅ 完全复用 | ❌ 代码重复 | ✅ 共享接口 |\n+| **扩展性** | ❌ 扩展困难 | ✅ 易于扩展 | ✅ 易于扩展 |\n+| **维护性** | ❌ 维护困难 | ✅ 易于维护 | ✅ 易于维护 |\n+| **架构复杂度** | ⚠️ 中等 | ✅ 简单 | ⚠️ 中等（需要抽象） |\n+| **符合SOLID** | ❌ 违反职责分离 | ✅ 符合 | ✅ 符合 |\n+\n+### 最终推荐\n+\n+**推荐方案3：共享Handler机制，但独立系统**\n+\n+**理由**：\n+1. **职责清晰**：技能系统和地形要素系统各自独立，符合领域驱动设计\n+2. **代码复用**：通过共享Handler接口实现代码复用，避免重复\n+3. **统一数据流**：都通过DataHandleQueue推送效果，保持数据流一致性\n+4. **扩展性好**：新增Handler类型或系统都很容易\n+5. **符合SOLID原则**：单一职责、开闭原则、依赖倒置\n+\n+**实施建议**：\n+1. **第一步**：抽象出Handler接口层（IConditionHandler、IEffectHandler、IVisualHandler等）\n+2. **第二步**：重构技能系统，使用Handler接口\n+3. **第三步**：实现地形要素系统，使用相同的Handler接口\n+4. **第四步**：统一数据流，都通过DataHandleQueue推送效果\n+\n"
                },
                {
                    "date": 1767107649668,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -498,84 +498,9 @@\n | **生命周期** | 单位生命周期 | 地图生命周期 |\n | **冷却机制** | 有冷却 | 通常无冷却（或一次性） |\n | **资源消耗** | 消耗MP/HP | 通常无消耗 |\n \n-### 方案对比\n \n-#### 方案1：包装为技能（不推荐）\n-\n-**设计思路**：将陷阱包装为技能，复用技能系统的Handler机制。\n-\n-**优点**：\n-- ✅ 复用技能系统的Handler机制\n-- ✅ 统一效果应用流程\n-- ✅ 减少代码重复\n-\n-**缺点**：\n-- ❌ **概念混淆**：环境要素被当作单位能力，语义不匹配\n-- ❌ **职责不清**：技能系统承担环境交互职责\n-- ❌ **扩展性差**：未来其他地形要素（门、宝箱等）是否也要包装为技能？\n-- ❌ **维护困难**：技能系统需要处理环境要素的特殊逻辑\n-\n-**结论**：不推荐，违反职责分离原则。\n-\n----\n-\n-#### 方案2：独立的地形要素系统（推荐）\n-\n-**设计思路**：建立独立的地形要素系统，与技能系统平行，各自管理自己的职责。\n-\n-**架构设计**：\n-\n-```mermaid\n-graph TB\n-    subgraph TerrainDomain[\"地形要素Domain<br/>Terrain Domain\"]\n-        TerrainManagement[地形要素管理<br/>TerrainManagement]\n-        TerrainTrigger[地形要素触发<br/>TerrainTrigger]\n-    end\n-    \n-    subgraph TerrainManagement[\"地形要素管理<br/>TerrainManagement\"]\n-        TrapData[陷阱数据<br/>TrapData]\n-        TerrainRule[地形规则<br/>触发条件/效果配置]\n-    end\n-    \n-    subgraph TerrainTrigger[\"地形要素触发<br/>TerrainTrigger\"]\n-        ConditionCheck[条件检查<br/>距离/状态检查]\n-        EffectApply[效果应用<br/>通过DataHandleQueue推送]\n-        VisualPlay[表现播放<br/>通知表现层]\n-    end\n-    \n-    subgraph ExternalSystems[\"外部系统\"]\n-        GridSystem[网格系统<br/>位置检测]\n-        DataHandleQueue[DataHandleQueue<br/>效果推送]\n-        VisualSystem[表现系统<br/>可视化]\n-    end\n-    \n-    TerrainManagement --> TerrainTrigger\n-    TerrainTrigger -->|调用| GridSystem\n-    TerrainTrigger -->|推送| DataHandleQueue\n-    TerrainTrigger -->|通知| VisualSystem\n-    \n-    style TerrainDomain fill:#e1f5ff\n-    style TerrainManagement fill:#fff4e1\n-    style TerrainTrigger fill:#c8e6c9\n-    style ExternalSystems fill:#f3e5f5\n-```\n-\n-**优点**：\n-- ✅ **职责清晰**：地形要素属于环境系统，概念明确\n-- ✅ **概念明确**：符合领域驱动设计，系统边界清晰\n-- ✅ **扩展性好**：可支持多种地形要素（陷阱、门、宝箱等）\n-- ✅ **维护性强**：系统边界清晰，易于维护\n-\n-**缺点**：\n-- ⚠️ 需要重复实现类似Handler的机制（条件检查、效果应用等）\n-- ⚠️ 与技能系统存在代码重复\n-\n-**结论**：推荐，符合职责分离原则，但存在代码重复问题。\n-\n----\n-\n #### 方案3：共享Handler机制，但独立系统（最佳推荐）\n \n **设计思路**：抽象出公共的Handler接口，技能系统和地形要素系统都使用这些Handler，但保持系统独立。\n \n"
                },
                {
                    "date": 1767107721686,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -595,164 +595,4 @@\n     style HandlerInterface fill:#f3e5f5\n     style SkillImplementation fill:#e1f5ff\n     style TerrainImplementation fill:#fff4e1\n ```\n-\n-**执行流程对比**：\n-\n-```mermaid\n-graph LR\n-    subgraph SkillFlow[\"技能执行流程\"]\n-        S1[创建SkillContext] --> S2[ConditionHandler检查]\n-        S2 --> S3[RegionHandler选择目标]\n-        S3 --> S4[EffectHandler应用效果]\n-        S4 --> S5[VisualHandler播放表现]\n-    end\n-    \n-    subgraph TerrainFlow[\"地形要素执行流程\"]\n-        T1[创建TerrainContext] --> T2[ConditionHandler检查]\n-        T2 --> T3[EffectHandler应用效果]\n-        T3 --> T4[VisualHandler播放表现]\n-    end\n-    \n-    S4 -.推送DataHandleQueue.-> DataQueue[DataHandleQueue]\n-    T3 -.推送DataHandleQueue.-> DataQueue\n-    \n-    style SkillFlow fill:#e1f5ff\n-    style TerrainFlow fill:#fff4e1\n-    style DataQueue fill:#f3e5f5\n-```\n-\n-**实现示例**：\n-\n-```lua\n--- ========== 共享Handler接口 ==========\n--- IHandler.lua\n-IHandler = {}\n-function IHandler:Execute(context)\n-    -- 子类实现\n-end\n-\n--- IConditionHandler.lua\n-IConditionHandler = {}\n-setmetatable(IConditionHandler, {__index = IHandler})\n-function IConditionHandler:Check(context)\n-    -- 子类实现\n-end\n-\n--- IEffectHandler.lua\n-IEffectHandler = {}\n-setmetatable(IEffectHandler, {__index = IHandler})\n-function IEffectHandler:ApplyEffect(context)\n-    -- 子类实现\n-    -- 通过DataHandleQueue推送效果数据\n-end\n-\n--- ========== 技能系统实现 ==========\n--- SkillConditionHandler.lua\n-SkillConditionHandler = {}\n-setmetatable(SkillConditionHandler, {__index = IConditionHandler})\n-function SkillConditionHandler:Check(context)\n-    -- 技能特定的条件检查（MP、冷却等）\n-    return self:CheckMana(context) and self:CheckCooldown(context)\n-end\n-\n--- SkillEffectHandler.lua\n-SkillEffectHandler = {}\n-setmetatable(SkillEffectHandler, {__index = IEffectHandler})\n-function SkillEffectHandler:ApplyEffect(context)\n-    -- 技能特定的效果应用\n-    local effectData = self:CalculateSkillEffect(context)\n-    -- 推送到目标单位的DataHandleQueue\n-    local targetUnit = UnitDataMgr:GetUnit(context.targetUnitId)\n-    targetUnit.dataHandleQueue:PushData({\n-        dataType = EDataHandle.Effect.Damage,\n-        damage = effectData.damage,\n-        sourceUnitId = context.caster.unitId\n-    })\n-end\n-\n--- ========== 地形要素系统实现 ==========\n--- TerrainBase.lua\n-TerrainBase = {}\n-function TerrainBase:Trigger(triggerUnit)\n-    local context = TerrainContext:New(self, triggerUnit)\n-    \n-    -- 使用共享的Handler接口\n-    if not self.conditionHandler:Check(context) then\n-        return false\n-    end\n-    \n-    self.effectHandler:ApplyEffect(context)\n-    self.visualHandler:Play(context)\n-    \n-    return true\n-end\n-\n--- TerrainConditionHandler.lua\n-TerrainConditionHandler = {}\n-setmetatable(TerrainConditionHandler, {__index = IConditionHandler})\n-function TerrainConditionHandler:Check(context)\n-    -- 地形要素特定的条件检查（距离、状态等）\n-    return self:CheckDistance(context) and self:CheckState(context)\n-end\n-\n--- TerrainEffectHandler.lua\n-TerrainEffectHandler = {}\n-setmetatable(TerrainEffectHandler, {__index = IEffectHandler})\n-function TerrainEffectHandler:ApplyEffect(context)\n-    -- 地形要素特定的效果应用\n-    local effectData = self:CalculateTrapEffect(context)\n-    -- 推送到触发单位的DataHandleQueue\n-    local triggerUnit = UnitDataMgr:GetUnit(context.triggerUnitId)\n-    triggerUnit.dataHandleQueue:PushData({\n-        dataType = EDataHandle.Effect.Damage,\n-        damage = effectData.damage,\n-        sourceTerrainId = context.terrain.id\n-    })\n-end\n-```\n-\n-**优点**：\n-- ✅ **职责清晰**：技能系统和地形要素系统各自独立，概念明确\n-- ✅ **代码复用**：共享Handler接口，避免代码重复\n-- ✅ **统一数据流**：都通过DataHandleQueue推送效果，统一接口\n-- ✅ **扩展性好**：新增Handler类型或系统都很容易\n-- ✅ **维护性强**：系统边界清晰，Handler接口统一，易于维护\n-- ✅ **符合开闭原则**：对扩展开放，对修改关闭\n-\n-**缺点**：\n-- ⚠️ 需要抽象出Handler接口，增加一层抽象\n-- ⚠️ 需要维护Handler接口的稳定性\n-\n-**结论**：**最佳推荐**，既保持了系统独立性，又实现了代码复用，符合SOLID原则。\n-\n----\n-\n-### 方案对比总结\n-\n-| 对比项 | 方案1：包装为技能 | 方案2：独立系统 | 方案3：共享Handler |\n-|--------|------------------|----------------|-------------------|\n-| **职责清晰度** | ❌ 概念混淆 | ✅ 职责清晰 | ✅ 职责清晰 |\n-| **代码复用性** | ✅ 完全复用 | ❌ 代码重复 | ✅ 共享接口 |\n-| **扩展性** | ❌ 扩展困难 | ✅ 易于扩展 | ✅ 易于扩展 |\n-| **维护性** | ❌ 维护困难 | ✅ 易于维护 | ✅ 易于维护 |\n-| **架构复杂度** | ⚠️ 中等 | ✅ 简单 | ⚠️ 中等（需要抽象） |\n-| **符合SOLID** | ❌ 违反职责分离 | ✅ 符合 | ✅ 符合 |\n-\n-### 最终推荐\n-\n-**推荐方案3：共享Handler机制，但独立系统**\n-\n-**理由**：\n-1. **职责清晰**：技能系统和地形要素系统各自独立，符合领域驱动设计\n-2. **代码复用**：通过共享Handler接口实现代码复用，避免重复\n-3. **统一数据流**：都通过DataHandleQueue推送效果，保持数据流一致性\n-4. **扩展性好**：新增Handler类型或系统都很容易\n-5. **符合SOLID原则**：单一职责、开闭原则、依赖倒置\n-\n-**实施建议**：\n-1. **第一步**：抽象出Handler接口层（IConditionHandler、IEffectHandler、IVisualHandler等）\n-2. **第二步**：重构技能系统，使用Handler接口\n-3. **第三步**：实现地形要素系统，使用相同的Handler接口\n-4. **第四步**：统一数据流，都通过DataHandleQueue推送效果\n-\n"
                },
                {
                    "date": 1767107746395,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -470,39 +470,9 @@\n - ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n - ✅ **微核心设计**：行动协调器只负责协调调用，不包含业务规则，易于扩展\n - ✅ **符合技能系统架构**：与技能系统的Handler策略模式设计一致，EffectHandler负责效果应用\n \n----\n \n-## 地形要素（陷阱）架构设计分析\n-\n-### 问题背景\n-\n-地形要素（如陷阱）是否应该包装为技能？这是一个重要的架构设计决策，需要从职责分离、概念清晰度、代码复用性等角度进行分析。\n-\n-### 相似性分析\n-\n-**陷阱与技能的共同点**：\n-- ✅ **触发条件**：都需要条件检查（距离、状态等）\n-- ✅ **目标选择**：都需要区域选择（单体、范围等）\n-- ✅ **效果应用**：都需要应用伤害、buff等效果\n-- ✅ **表现播放**：都需要播放特效、音效等\n-- ✅ **数据流**：都需要通过 DataHandleQueue 推送效果\n-\n-### 差异性分析\n-\n-| 维度 | 技能系统 | 地形要素（陷阱） |\n-|------|---------|----------------|\n-| **概念归属** | 单位能力 | 环境要素 |\n-| **触发方式** | 主动释放 | 被动触发（进入/接触） |\n-| **拥有者** | 单位拥有 | 地图/地形拥有 |\n-| **生命周期** | 单位生命周期 | 地图生命周期 |\n-| **冷却机制** | 有冷却 | 通常无冷却（或一次性） |\n-| **资源消耗** | 消耗MP/HP | 通常无消耗 |\n-\n-\n-#### 方案3：共享Handler机制，但独立系统（最佳推荐）\n-\n **设计思路**：抽象出公共的Handler接口，技能系统和地形要素系统都使用这些Handler，但保持系统独立。\n \n **核心设计**：\n - **共享Handler层**：抽象出公共的Handler接口（ConditionHandler、EffectHandler、VisualHandler等）\n"
                },
                {
                    "date": 1767107754510,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -470,9 +470,9 @@\n - ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n - ✅ **微核心设计**：行动协调器只负责协调调用，不包含业务规则，易于扩展\n - ✅ **符合技能系统架构**：与技能系统的Handler策略模式设计一致，EffectHandler负责效果应用\n \n-\n+### 技能系统与地形要素系统架构设计\n **设计思路**：抽象出公共的Handler接口，技能系统和地形要素系统都使用这些Handler，但保持系统独立。\n \n **核心设计**：\n - **共享Handler层**：抽象出公共的Handler接口（ConditionHandler、EffectHandler、VisualHandler等）\n"
                },
                {
                    "date": 1767107766551,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -470,9 +470,9 @@\n - ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n - ✅ **微核心设计**：行动协调器只负责协调调用，不包含业务规则，易于扩展\n - ✅ **符合技能系统架构**：与技能系统的Handler策略模式设计一致，EffectHandler负责效果应用\n \n-### 技能系统与地形要素系统架构设计\n+### 数据同步统架构设计\n **设计思路**：抽象出公共的Handler接口，技能系统和地形要素系统都使用这些Handler，但保持系统独立。\n \n **核心设计**：\n - **共享Handler层**：抽象出公共的Handler接口（ConditionHandler、EffectHandler、VisualHandler等）\n"
                },
                {
                    "date": 1767107807172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -193,9 +193,9 @@\n     end\n     \n     subgraph ExternalSystems[\"外部系统\"]\n         GridSystem[网格系统<br/>GridSystem]\n-        SkillDomain[技能领域<br/>Skill Domain<br/>EffectHandler推送DataHandleQueue]\n+        SkillDomain[技能领域<br/>Skill Domain<br/>]\n         VisualSystem[表现系统<br/>Visual System]\n     end\n     \n     UnitManagement -->|控制| UnitLoop\n@@ -470,9 +470,9 @@\n - ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n - ✅ **微核心设计**：行动协调器只负责协调调用，不包含业务规则，易于扩展\n - ✅ **符合技能系统架构**：与技能系统的Handler策略模式设计一致，EffectHandler负责效果应用\n \n-### 数据同步统架构设计\n+### 数据同步统一架构设计\n **设计思路**：抽象出公共的Handler接口，技能系统和地形要素系统都使用这些Handler，但保持系统独立。\n \n **核心设计**：\n - **共享Handler层**：抽象出公共的Handler接口（ConditionHandler、EffectHandler、VisualHandler等）\n"
                },
                {
                    "date": 1767107813760,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,8 +195,10 @@\n     subgraph ExternalSystems[\"外部系统\"]\n         GridSystem[网格系统<br/>GridSystem]\n         SkillDomain[技能领域<br/>Skill Domain<br/>]\n         VisualSystem[表现系统<br/>Visual System]\n+\n+        SkillDomain -->|EffectHandler推送| DataHandleQueue\n     end\n     \n     UnitManagement -->|控制| UnitLoop\n     UnitManagement --> ActionCoordinator\n"
                },
                {
                    "date": 1767107822369,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,10 +195,8 @@\n     subgraph ExternalSystems[\"外部系统\"]\n         GridSystem[网格系统<br/>GridSystem]\n         SkillDomain[技能领域<br/>Skill Domain<br/>]\n         VisualSystem[表现系统<br/>Visual System]\n-\n-        SkillDomain -->|EffectHandler推送| DataHandleQueue\n     end\n     \n     UnitManagement -->|控制| UnitLoop\n     UnitManagement --> ActionCoordinator\n"
                },
                {
                    "date": 1767107827637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -193,9 +193,9 @@\n     end\n     \n     subgraph ExternalSystems[\"外部系统\"]\n         GridSystem[网格系统<br/>GridSystem]\n-        SkillDomain[技能领域<br/>Skill Domain<br/>]\n+        SkillDomain[技能领域<br/>Skill Domain]\n         VisualSystem[表现系统<br/>Visual System]\n     end\n     \n     UnitManagement -->|控制| UnitLoop\n"
                },
                {
                    "date": 1767107843657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -181,9 +181,8 @@\n             RuleMgr[单位规则管理<br/>移动点数检查/行动规则]\n         end\n         \n         subgraph DataHandleQueue[\"DataHandleQueue<br/>数据队列<br/>1:1关系\"]\n-            Queue[数据队列<br/>Queue]\n         end\n         \n         subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n             MoveCoord[移动协调<br/>调用网格系统]\n"
                },
                {
                    "date": 1767107862477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -215,9 +215,9 @@\n     style UnitManagement fill:#fff4e1\n     style UnitLoop fill:#f3e5f5\n     style ActionCoordinator fill:#c8e6c9\n     style DataHandleQueue fill:#f3e5f5\n-    style UnitData fill:#fff4e1\n+    style UnitData fill:#e1f5ff\n ```\n \n ### 单位管理（UnitManagement）\n \n"
                },
                {
                    "date": 1767107898552,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -207,10 +207,9 @@\n     ActionCoordinator -->|调用| SkillDomain\n     ActionCoordinator -->|通知| VisualSystem\n     \n     SkillDomain -->|EffectHandler推送| DataHandleQueue\n-    DataHandleQueue -->|1:1关系| UnitData\n-    DataHandleQueue -->|直接修改| UnitData\n+    DataHandleQueue -->|推送数据| UnitData\n     \n     style UnitDomain fill:#e1f5ff\n     style UnitManagement fill:#fff4e1\n     style UnitLoop fill:#f3e5f5\n"
                },
                {
                    "date": 1767107914759,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,8 +187,9 @@\n         subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n             MoveCoord[移动协调<br/>调用网格系统]\n             SkillCoord[技能协调<br/>调用技能领域]\n             VisualCoord[表现协调<br/>通知表现层]\n+                SkillCoord[技能协调<br/>调用技能领域]\n         end\n     end\n     \n     subgraph ExternalSystems[\"外部系统\"]\n"
                },
                {
                    "date": 1767107926918,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,9 +187,9 @@\n         subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n             MoveCoord[移动协调<br/>调用网格系统]\n             SkillCoord[技能协调<br/>调用技能领域]\n             VisualCoord[表现协调<br/>通知表现层]\n-                SkillCoord[技能协调<br/>调用技能领域]\n+            TriCoord[技能协调<br/>调用技能领域]\n         end\n     end\n     \n     subgraph ExternalSystems[\"外部系统\"]\n"
                },
                {
                    "date": 1767107946913,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -394,39 +394,9 @@\n     style UnitData fill:#e1f5ff\n     style UpdateState fill:#fff4e1\n ```\n \n-**数据推送示例**：\n-```lua\n--- 技能领域的EffectHandler：推送效果数据到队列\n--- SkillEffectHandler内部实现\n-function SkillEffectHandler:ApplyEffect(context)\n-    local effectData = self:CalculateEffect(context)\n-    \n-    -- EffectHandler负责推送数据到目标单位的DataHandleQueue\n-    local targetUnit = UnitDataMgr:GetUnit(context.targetUnitId)\n-    local queueContext = {\n-        dataType = EDataHandle.Effect.Damage,\n-        targetUnitId = context.targetUnitId,\n-        damage = effectData.damage,\n-        sourceUnitId = context.caster.unitId\n-    }\n-    -- DataHandleQueue 与 UnitData 是 1:1 关系，直接推送到目标单位的队列\n-    targetUnit.dataHandleQueue:PushData(queueContext)\n-end\n \n--- UnitData：通过DataHandleQueue接收并直接处理（1:1关系）\n-function UnitData:OnDataHandler(dataType, data)\n-    if dataType == EDataHandle.Effect.Damage then\n-        -- 直接修改UnitData，无需经过中间层\n-        self:ApplyDamage(data.damage)\n-    elseif dataType == EDataHandle.Effect.Buff then\n-        -- 直接修改UnitData，无需经过中间层\n-        self:ApplyBuff(data.buffId)\n-    end\n-end\n-```\n-\n **职责划分**：\n - ✅ **行动协调器**：只负责调用技能领域，不处理数值控制\n - ✅ **技能领域的EffectHandler**：负责通过DataHandleQueue推送效果数据到目标单位\n - ✅ **DataHandleQueue**：与UnitData是1:1关系，属于单位领域内部\n"
                },
                {
                    "date": 1767107967932,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,8 +195,9 @@\n     subgraph ExternalSystems[\"外部系统\"]\n         GridSystem[网格系统<br/>GridSystem]\n         SkillDomain[技能领域<br/>Skill Domain]\n         VisualSystem[表现系统<br/>Visual System]\n+        TerrainDomain[地形领域<br/>Terrain Domain]\n     end\n     \n     UnitManagement -->|控制| UnitLoop\n     UnitManagement --> ActionCoordinator\n"
                },
                {
                    "date": 1767107985298,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -209,8 +209,9 @@\n     ActionCoordinator -->|调用| SkillDomain\n     ActionCoordinator -->|通知| VisualSystem\n     \n     SkillDomain -->|EffectHandler推送| DataHandleQueue\n+    TerrainDomain -->|EffectHandler推送| DataHandleQueue\n     DataHandleQueue -->|推送数据| UnitData\n     \n     style UnitDomain fill:#e1f5ff\n     style UnitManagement fill:#fff4e1\n"
                },
                {
                    "date": 1767108046286,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -210,8 +210,9 @@\n     ActionCoordinator -->|通知| VisualSystem\n     \n     SkillDomain -->|EffectHandler推送| DataHandleQueue\n     TerrainDomain -->|EffectHandler推送| DataHandleQueue\n+\n     DataHandleQueue -->|推送数据| UnitData\n     \n     style UnitDomain fill:#e1f5ff\n     style UnitManagement fill:#fff4e1\n@@ -403,27 +404,9 @@\n - ✅ **技能领域的EffectHandler**：负责通过DataHandleQueue推送效果数据到目标单位\n - ✅ **DataHandleQueue**：与UnitData是1:1关系，属于单位领域内部\n - ✅ **UnitData**：通过DataHandleQueue接收并直接处理，无需经过\"数值控制管理\"中间层\n \n-### 单位领域与外部系统的关系\n \n-```mermaid\n-graph TB\n-    UnitDomain[单位领域] --> GridSystem[网格系统<br/>基础设施层]\n-    UnitDomain --> SkillDomain[技能领域<br/>领域层]\n-    UnitDomain --> DataHandleQueue[DataHandleQueue<br/>通信层]\n-    UnitDomain --> VisualSystem[表现系统<br/>表现层]\n-    \n-    DataHandleQueue --> TargetUnit[目标单位<br/>通过队列接收数据]\n-    \n-    style UnitDomain fill:#e1f5ff\n-    style GridSystem fill:#fff4e1\n-    style SkillDomain fill:#c8e6c9\n-    style DataHandleQueue fill:#f3e5f5\n-    style VisualSystem fill:#c8e6c9\n-    style TargetUnit fill:#e1f5ff\n-```\n-\n **关系说明**：\n - **网格系统**：基础设施层，提供移动计算服务\n - **技能领域**：领域层，提供技能执行服务\n - **DataHandleQueue**：通信层，提供数据推送和处理服务\n"
                },
                {
                    "date": 1767108062220,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -383,8 +383,9 @@\n ```mermaid\n flowchart LR\n     ActionCoord[行动协调器<br/>调用技能领域] --> SkillDomain[技能领域<br/>执行技能]\n     SkillDomain --> EffectHandler[EffectHandler<br/>应用效果]\n+    EffectHandler --> TerrainDomain[地形领域<br/>执行地形要素]\n     EffectHandler --> PushQueue[DataHandleQueue<br/>单位领域内部<br/>PushData效果数据]\n     PushQueue --> ProcessQueue[DataHandleQueue<br/>ProcessDataHandler]\n     ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>直接修改]\n     UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n@@ -405,15 +406,8 @@\n - ✅ **DataHandleQueue**：与UnitData是1:1关系，属于单位领域内部\n - ✅ **UnitData**：通过DataHandleQueue接收并直接处理，无需经过\"数值控制管理\"中间层\n \n \n-**关系说明**：\n-- **网格系统**：基础设施层，提供移动计算服务\n-- **技能领域**：领域层，提供技能执行服务\n-- **DataHandleQueue**：通信层，提供数据推送和处理服务\n-- **表现系统**：表现层，提供可视化服务\n-- **目标单位**：通过 DataHandleQueue 接收数据变更，实现解耦\n-\n ### 设计优势\n \n - ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部，数据直接修改UnitData\n - ✅ **无需中间层**：不需要\"数值控制管理\"中间层，简化架构设计\n"
                },
                {
                    "date": 1767108076109,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -383,13 +383,15 @@\n ```mermaid\n flowchart LR\n     ActionCoord[行动协调器<br/>调用技能领域] --> SkillDomain[技能领域<br/>执行技能]\n     SkillDomain --> EffectHandler[EffectHandler<br/>应用效果]\n-    EffectHandler --> TerrainDomain[地形领域<br/>执行地形要素]\n+    TerrainDomain --> EffectHandler[EffectHandler<br/>应用效果]\n     EffectHandler --> PushQueue[DataHandleQueue<br/>单位领域内部<br/>PushData效果数据]\n     PushQueue --> ProcessQueue[DataHandleQueue<br/>ProcessDataHandler]\n+    ProcessQueue --> TerrainDomain[地形领域<br/>执行地形要素]\n     ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>直接修改]\n     UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n+    TerrainDomain --> UpdateState[更新状态<br/>扣血/加buff]\n     \n     style ActionCoord fill:#c8e6c9\n     style SkillDomain fill:#c8e6c9\n     style EffectHandler fill:#fff4e1\n"
                },
                {
                    "date": 1767108087117,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -386,12 +386,10 @@\n     SkillDomain --> EffectHandler[EffectHandler<br/>应用效果]\n     TerrainDomain --> EffectHandler[EffectHandler<br/>应用效果]\n     EffectHandler --> PushQueue[DataHandleQueue<br/>单位领域内部<br/>PushData效果数据]\n     PushQueue --> ProcessQueue[DataHandleQueue<br/>ProcessDataHandler]\n-    ProcessQueue --> TerrainDomain[地形领域<br/>执行地形要素]\n     ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>直接修改]\n     UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n-    TerrainDomain --> UpdateState[更新状态<br/>扣血/加buff]\n     \n     style ActionCoord fill:#c8e6c9\n     style SkillDomain fill:#c8e6c9\n     style EffectHandler fill:#fff4e1\n"
                },
                {
                    "date": 1767108104473,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -383,9 +383,9 @@\n ```mermaid\n flowchart LR\n     ActionCoord[行动协调器<br/>调用技能领域] --> SkillDomain[技能领域<br/>执行技能]\n     SkillDomain --> EffectHandler[EffectHandler<br/>应用效果]\n-    TerrainDomain --> EffectHandler[EffectHandler<br/>应用效果]\n+    TerrainDomain[地形领域<br/>执行地形要素] --> EffectHandler[EffectHandler<br/>应用效果]\n     EffectHandler --> PushQueue[DataHandleQueue<br/>单位领域内部<br/>PushData效果数据]\n     PushQueue --> ProcessQueue[DataHandleQueue<br/>ProcessDataHandler]\n     ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>直接修改]\n     UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n"
                },
                {
                    "date": 1767108124723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -388,9 +388,9 @@\n     EffectHandler --> PushQueue[DataHandleQueue<br/>单位领域内部<br/>PushData效果数据]\n     PushQueue --> ProcessQueue[DataHandleQueue<br/>ProcessDataHandler]\n     ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>直接修改]\n     UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n-    \n+    ActionCoord --> TerrainDomain\n     style ActionCoord fill:#c8e6c9\n     style SkillDomain fill:#c8e6c9\n     style EffectHandler fill:#fff4e1\n     style PushQueue fill:#f3e5f5\n"
                },
                {
                    "date": 1767108168889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,516 @@\n+# 战斗系统架构设计\n+\n+## 设计目标\n+\n+设计一套完整的回合制战斗系统架构，支持DND规则、回合管理、状态机控制、AI决策，实现战斗流程管理、伤害计算、效果应用，提供数据驱动的配置化战斗系统。\n+\n+---\n+\n+## 核心设计理念\n+\n+### 1. 多层循环架构为核心\n+\n+**本质**：战斗系统的核心是四层循环的维护和管理\n+- **战斗循环**：管理整个战斗的生命周期\n+- **回合循环**：管理回合的循环和切换\n+- **阵营循环**：管理阵营内单位的行动顺序\n+- **单位循环**：管理单个单位的行动流程\n+- **循环驱动**：所有战斗逻辑都在循环框架内执行\n+- **状态维护**：每层循环维护自己的状态，驱动下层循环\n+\n+### 2. 数据驱动架构\n+\n+**本质**：战斗特性通过配置数据实现，无需修改代码\n+- 战斗规则、伤害计算、效果应用 → 通过配置数据定义\n+- 回合流程、状态转换 → 通过配置数据调整\n+- 新增战斗机制 → 扩展配置数据即可\n+- 战斗平衡 → 调整配置数值即可\n+\n+### 3. 分层架构（循环内的功能组织）\n+\n+**本质**：分层架构是循环内的功能组织方式，不是主要架构\n+- 功能组织：输入层、决策层、执行层、表现层、管理层\n+- 执行位置：所有分层功能都在单位循环内执行\n+- 解耦设计：层间通过Context和CommunicationBus通信\n+\n+---\n+\n+## 整体架构设计\n+\n+### 多层循环架构（主要架构）\n+\n+**核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n+\n+#### Domain与循环的关系（领域驱动设计）\n+\n+**核心观点**：Domain控制循环，循环是Domain的工具。Domain是领域核心，拥有循环机制来推进业务流程。\n+\n+**术语说明**：使用\"Domain\"而非\"Entity\"，避免与项目中的\"Unit\"概念混淆。\n+\n+```mermaid\n+graph TB\n+    subgraph BattleDomain[\"战斗Domain<br/>Battle Domain\"]\n+        BattleManagement[战斗管理<br/>结算奖励/同步任务]\n+        BattleLoop[\"战斗循环<br/>BattleLoop\"]\n+        BattleManagement -->|控制| BattleLoop\n+        BattleLoop -->|推进| BattleManagement\n+        \n+        subgraph RoundDomain[\"回合Domain<br/>Round Domain\"]\n+            RoundManagement[回合管理<br/>行动值排序/单位行动顺序]\n+            RoundLoop[\"回合循环<br/>RoundLoop\"]\n+            RoundManagement -->|控制| RoundLoop\n+            RoundLoop -->|推进| RoundManagement\n+            \n+            subgraph TeamDomain[\"阵营Domain<br/>Team Domain\"]\n+                TeamManagement[阵营管理<br/>借机攻击/阵营差异行为]\n+                TeamLoop[\"阵营循环<br/>TeamLoop\"]\n+                TeamManagement -->|控制| TeamLoop\n+                TeamLoop -->|推进| TeamManagement\n+                \n+                subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n+                    UnitManagement[单位管理<br/>移动/施法/选择技能对象]\n+                    UnitLoop[\"单位循环<br/>UnitLoop\"]\n+                    UnitManagement -->|控制| UnitLoop\n+                    UnitLoop -->|推进| UnitManagement\n+                end\n+            end\n+        end\n+    end\n+    \n+    style BattleDomain fill:#ffebee\n+    style RoundDomain fill:#fff4e1\n+    style TeamDomain fill:#c8e6c9\n+    style UnitDomain fill:#e1f5ff\n+    style BattleLoop fill:#f3e5f5\n+    style RoundLoop fill:#f3e5f5\n+    style TeamLoop fill:#f3e5f5\n+    style UnitLoop fill:#f3e5f5\n+```\n+\n+**备注**：\n+- **阵营循环**：在标准DND规则中，所有单位按先攻值（Initiative）统一排序行动，不存在阵营循环。此处保留阵营循环作为扩展设计，便于后续支持阵营差异行为（如借机攻击、阵营特殊规则等）。如不需要，可简化为三层架构（战斗→回合→单位）。\n+\n+#### Domain协作关系\n+\n+**核心观点**：Domain之间通过协作推进业务流程，父Domain调用子Domain，子Domain完成业务后返回父Domain。\n+\n+```mermaid\n+graph TB\n+    BattleDomain[战斗Domain<br/>Battle Domain]\n+    RoundDomain[回合Domain<br/>Round Domain]\n+    TeamDomain[阵营Domain<br/>Team Domain]\n+    UnitDomain[单位Domain<br/>Unit Domain]\n+    \n+    BattleDomain -->|1. 调用| RoundDomain\n+    RoundDomain -->|2. 返回| BattleDomain\n+    RoundDomain -->|3. 调用| TeamDomain\n+    TeamDomain -->|4. 返回| RoundDomain\n+    TeamDomain -->|5. 调用| UnitDomain\n+    UnitDomain -->|6. 返回| TeamDomain\n+    \n+    BattleDomain -.->|包含| RoundDomain\n+    RoundDomain -.->|包含| TeamDomain\n+    TeamDomain -.->|包含| UnitDomain\n+    \n+    style BattleDomain fill:#ffebee\n+    style RoundDomain fill:#fff4e1\n+    style TeamDomain fill:#c8e6c9\n+    style UnitDomain fill:#e1f5ff\n+```\n+\n+**协作流程说明**：\n+1. **战斗Domain** → 调用 **回合Domain**：战斗进行中，需要执行回合\n+2. **回合Domain** → 调用 **阵营Domain**：回合进行中，需要处理阵营\n+3. **阵营Domain** → 调用 **单位Domain**：阵营进行中，需要处理单位\n+4. **单位Domain** → 返回 **阵营Domain**：单位行动完成\n+5. **阵营Domain** → 返回 **回合Domain**：阵营处理完成\n+6. **回合Domain** → 返回 **战斗Domain**：回合完成\n+\n+**协作原则**：\n+- 父Domain控制子Domain的调用时机\n+- 子Domain完成业务后主动返回父Domain\n+- 每个Domain独立管理自己的业务逻辑和循环\n+\n+### 循环职责说明\n+\n+#### 1. 战斗循环（BattleLoop）\n+- **职责**：管理整个战斗的生命周期\n+- **状态**：BattleState（未开始/进行中/已结束）\n+- **触发**：战斗开始/结束条件检查\n+- **维护**：BattleLoopManager\n+\n+#### 2. 回合循环（TurnLoop）\n+- **职责**：管理回合的循环和切换\n+- **状态**：TurnState（回合编号/当前回合/回合数）\n+- **触发**：回合开始/结束条件检查\n+- **维护**：TurnLoopManager\n+\n+#### 3. 阵营循环（TeamLoop）\n+- **职责**：管理阵营内单位的行动顺序\n+- **状态**：TeamState（当前阵营/阵营列表/行动顺序）\n+- **触发**：阵营切换/单位行动完成\n+- **维护**：TeamLoopManager\n+- **备注**：在标准DND规则中，所有单位按先攻值统一排序，不存在阵营循环。此处保留作为扩展设计，便于支持阵营差异行为。\n+\n+#### 4. 单位循环（UnitLoop）\n+- **职责**：管理单个单位的行动流程\n+- **状态**：UnitState（当前单位/行动状态/行动完成）\n+- **触发**：单位行动开始/结束\n+- **维护**：UnitLoopManager\n+\n+---\n+\n+## 单位领域详细架构设计\n+\n+### 核心职责\n+\n+单位领域是战斗系统的核心，负责管理单个单位的行动流程，包括移动、技能释放、数值控制等。\n+\n+### 单位领域完整结构\n+\n+```mermaid\n+graph TB\n+    subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n+        UnitManagement[单位管理<br/>UnitManagement]\n+        UnitLoop[单位循环<br/>UnitLoop<br/>START → ACTION → END]\n+        ActionCoordinator[行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用]\n+        \n+        subgraph UnitManagement[\"单位管理<br/>UnitManagement\"]\n+            UnitData[单位数据<br/>UnitData]\n+            DataMgr[单位数据管理<br/>属性/状态/位置]\n+            RuleMgr[单位规则管理<br/>移动点数检查/行动规则]\n+        end\n+        \n+        subgraph DataHandleQueue[\"DataHandleQueue<br/>数据队列<br/>1:1关系\"]\n+        end\n+        \n+        subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n+            MoveCoord[移动协调<br/>调用网格系统]\n+            SkillCoord[技能协调<br/>调用技能领域]\n+            VisualCoord[表现协调<br/>通知表现层]\n+            TriCoord[技能协调<br/>调用技能领域]\n+        end\n+    end\n+    \n+    subgraph ExternalSystems[\"外部系统\"]\n+        GridSystem[网格系统<br/>GridSystem]\n+        SkillDomain[技能领域<br/>Skill Domain]\n+        VisualSystem[表现系统<br/>Visual System]\n+        TerrainDomain[地形领域<br/>Terrain Domain]\n+    end\n+    \n+    UnitManagement -->|控制| UnitLoop\n+    UnitManagement --> ActionCoordinator\n+    UnitManagement --> UnitData\n+    ActionCoordinator -->|反向推动| UnitLoop\n+    UnitLoop -->|推进| UnitManagement\n+    \n+    ActionCoordinator -->|调用| GridSystem\n+    ActionCoordinator -->|调用| SkillDomain\n+    ActionCoordinator -->|通知| VisualSystem\n+    \n+    SkillDomain -->|EffectHandler推送| DataHandleQueue\n+    TerrainDomain -->|EffectHandler推送| DataHandleQueue\n+\n+    DataHandleQueue -->|推送数据| UnitData\n+    \n+    style UnitDomain fill:#e1f5ff\n+    style UnitManagement fill:#fff4e1\n+    style UnitLoop fill:#f3e5f5\n+    style ActionCoordinator fill:#c8e6c9\n+    style DataHandleQueue fill:#f3e5f5\n+    style UnitData fill:#e1f5ff\n+```\n+\n+### 单位管理（UnitManagement）\n+\n+#### 1. 单位数据管理\n+- **单位属性**：生命值、移动点数、状态等\n+- **单位状态**：是否可行动、是否已移动、是否已攻击等\n+- **单位位置**：当前网格位置\n+\n+#### 2. 单位规则管理\n+- **移动点数规则**：移动前检查能否移动（回答1：移动前检查）\n+- **行动规则**：是否可执行行动\n+- **状态规则**：状态转换规则\n+\n+#### 3. UnitData（单位数据）\n+- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，数据直接修改 UnitData\n+- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n+- **无需中间层**：不需要\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n+\n+### 单位循环（UnitLoop）\n+\n+**循环状态**：START → ACTION → END（回答2：不需要更细的状态）\n+\n+- **START**：单位开始行动\n+- **ACTION**：执行行动（移动、技能等）\n+- **END**：单位结束行动\n+\n+### 行动协调器（ActionCoordinator）- 微核心\n+\n+**核心原则**：只负责协调调用，不包含业务规则（回答3：只负责协调调用）\n+\n+**核心职责**：\n+- ✅ **协调调用**：调用网格系统、技能领域、表现系统\n+- ✅ **反向推动循环**：执行完行动后，主动推动单位循环进入下一个状态（Domain controls Loop）\n+\n+#### 1. 移动协调\n+- **移动前检查**：调用单位管理检查移动点数\n+- **调用网格系统**：进行移动计算\n+- **移动后更新**：通过 DataHandleQueue 更新单位位置和移动点数\n+- **推动循环**：移动完成后，推动循环进入下一个状态\n+\n+#### 2. 技能协调\n+- **调用技能领域**：执行技能\n+- **不处理数值控制**：数值控制由技能领域的EffectHandler通过DataHandleQueue处理\n+- **接收技能结果**：获取技能执行结果（成功/失败），用于流程控制\n+- **推动循环**：技能执行完成后，推动循环进入下一个状态\n+\n+#### 3. 表现协调\n+- **通知表现层**：移动表现、技能表现、受攻击表现\n+- **推动循环**：表现播放完成后（可选），推动循环进入下一个状态\n+\n+#### 4. 循环推动机制\n+- **推动到END**：行动完成后，推动循环从ACTION状态进入END状态\n+- **推动到ACTION**：如果需要继续行动（还有移动点），推动循环从END状态回到ACTION状态\n+- **推动到START**：单位行动开始时，推动循环进入START状态\n+\n+### DataHandleQueue 作为单位领域内部组件\n+\n+**核心设计**：\n+- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n+- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n+- **无需中间层**：不需要\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n+\n+```mermaid\n+sequenceDiagram\n+    participant AC as 行动协调器\n+    participant SD as 技能领域\n+    participant EH as EffectHandler\n+    participant DHQ as DataHandleQueue<br/>单位领域内部\n+    participant UD as UnitData<br/>1:1关系\n+    \n+    AC -> SD: 调用技能领域执行技能\n+    SD -> EH: EffectHandler应用效果\n+    EH -> DHQ: PushData(效果数据, 目标单位ID)\n+    SD -> AC: 返回技能执行结果（成功/失败）\n+    DHQ -> UD: ProcessDataHandler()<br/>直接修改UnitData\n+    UD -> UD: 应用效果（扣血/加buff）\n+    UD -> UD: 更新状态\n+```\n+\n+**数据流特性**：\n+- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n+- ✅ **直接修改**：数据直接修改UnitData，无需经过中间层\n+- ✅ **解耦设计**：技能领域的EffectHandler负责推送数据，行动协调器不处理数值控制\n+- ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n+- ✅ **统一接口**：所有数值控制通过统一接口推送\n+- ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n+- ✅ **职责清晰**：行动协调器只负责协调调用，EffectHandler负责数值控制\n+\n+### 单位行动完整流程\n+\n+```mermaid\n+flowchart TD\n+    Start[START: 单位开始行动<br/>单位管理推动循环] --> Action[ACTION: 执行行动<br/>单位循环进入ACTION状态]\n+    \n+    Action --> CheckMove[移动前检查<br/>单位管理检查移动点数]\n+    \n+    CheckMove -->|可以移动| Move[单位移动<br/>行动协调器调用网格系统]\n+    CheckMove -->|不能移动| SkipMove[跳过移动]\n+    \n+    Move --> UpdateMove[更新移动点数<br/>通过DataHandleQueue推送]\n+    SkipMove --> Skill\n+    \n+    UpdateMove --> Skill[攻击/治疗<br/>行动协调器调用技能领域]\n+    \n+    Skill --> SkillResult[获取技能执行结果<br/>成功/失败]\n+    \n+    SkillResult --> Visual[可视化<br/>行动协调器通知表现层<br/>技能领域的EffectHandler已推送DataHandleQueue]\n+    Visual --> PushLoop[行动协调器推动循环<br/>推动到END状态]\n+    \n+    PushLoop --> CheckMovePoint[移动点数检查<br/>单位管理检查是否还有移动点]\n+    \n+    CheckMovePoint -->|还有移动点| PushAction[行动协调器推动循环<br/>推动回ACTION状态]\n+    CheckMovePoint -->|无移动点| PushEnd[行动协调器推动循环<br/>推动到END状态]\n+    \n+    PushAction --> Skill\n+    PushEnd --> End[END: 单位结束行动<br/>单位循环进入END状态]\n+    \n+    style Start fill:#e1f5ff\n+    style Action fill:#fff4e1\n+    style Move fill:#fff4e1\n+    style Skill fill:#c8e6c9\n+    style Visual fill:#c8e6c9\n+    style PushLoop fill:#f3e5f5\n+    style PushAction fill:#f3e5f5\n+    style PushEnd fill:#f3e5f5\n+    style End fill:#c8e6c9\n+```\n+\n+**流程说明**：\n+1. **START**：单位管理推动循环进入START状态\n+2. **ACTION**：单位循环进入ACTION状态，开始执行行动\n+3. **移动前检查**：单位管理检查移动点数（能否移动）\n+4. **单位移动**：行动协调器调用网格系统进行移动\n+5. **更新移动点数**：通过 DataHandleQueue 推送移动点数变更\n+6. **攻击/治疗**：行动协调器调用技能领域执行技能\n+7. **技能执行**：技能领域的EffectHandler通过DataHandleQueue推送效果数据到目标单位\n+8. **可视化**：行动协调器通知表现层播放效果\n+9. **推动循环**：行动协调器推动循环进入END状态\n+10. **移动点数检查**：单位管理检查是否还有移动点\n+11. **循环或结束**：\n+    - 还有移动点：行动协调器推动循环回到ACTION状态，继续执行\n+    - 无移动点：行动协调器推动循环保持在END状态，结束行动\n+\n+**关键点**：\n+- ✅ **Domain controls Loop**：单位管理通过行动协调器控制循环状态转换\n+- ✅ **反向推动机制**：行动协调器执行完行动后，主动推动循环进入下一个状态\n+- ✅ **行动协调器不处理数值控制**：只负责调用技能领域，不处理效果数据推送\n+- ✅ **EffectHandler负责推送**：技能领域的EffectHandler负责通过DataHandleQueue推送效果数据\n+- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，数据直接修改 UnitData\n+- ✅ **直接修改**：不需要经过\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n+\n+### 数值控制流程（通过 DataHandleQueue）\n+\n+**核心设计**：\n+- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n+- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n+- **无需中间层**：不需要经过\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n+- **行动协调器不处理数值控制**：只负责调用技能领域，不处理效果数据推送\n+\n+```mermaid\n+flowchart LR\n+    ActionCoord[行动协调器<br/>调用技能领域] --> SkillDomain[技能领域<br/>执行技能]\n+    SkillDomain --> EffectHandler[EffectHandler<br/>应用效果]\n+    TerrainDomain[地形领域<br/>执行地形要素] --> EffectHandler[EffectHandler<br/>应用效果]\n+    EffectHandler --> ProcessQueue[DataHandleQueue<br/>ProcessDataHandler]\n+    ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>直接修改]\n+    UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n+    ActionCoord --> TerrainDomain\n+\n+    style ActionCoord fill:#c8e6c9\n+    style SkillDomain fill:#c8e6c9\n+    style EffectHandler fill:#fff4e1\n+    style PushQueue fill:#f3e5f5\n+    style ProcessQueue fill:#f3e5f5\n+    style UnitData fill:#e1f5ff\n+    style UpdateState fill:#fff4e1\n+```\n+\n+\n+**职责划分**：\n+- ✅ **行动协调器**：只负责调用技能领域，不处理数值控制\n+- ✅ **技能领域的EffectHandler**：负责通过DataHandleQueue推送效果数据到目标单位\n+- ✅ **DataHandleQueue**：与UnitData是1:1关系，属于单位领域内部\n+- ✅ **UnitData**：通过DataHandleQueue接收并直接处理，无需经过\"数值控制管理\"中间层\n+\n+\n+### 设计优势\n+\n+- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部，数据直接修改UnitData\n+- ✅ **无需中间层**：不需要\"数值控制管理\"中间层，简化架构设计\n+- ✅ **解耦设计**：通过 DataHandleQueue 实现模块间解耦，技能领域的EffectHandler负责推送数据\n+- ✅ **职责清晰**：行动协调器只负责协调调用，EffectHandler负责数值控制，职责分离\n+- ✅ **统一接口**：所有数值控制通过统一接口推送，易于维护\n+- ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n+- ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n+- ✅ **微核心设计**：行动协调器只负责协调调用，不包含业务规则，易于扩展\n+- ✅ **符合技能系统架构**：与技能系统的Handler策略模式设计一致，EffectHandler负责效果应用\n+\n+### 数据同步统一架构设计\n+**设计思路**：抽象出公共的Handler接口，技能系统和地形要素系统都使用这些Handler，但保持系统独立。\n+\n+**核心设计**：\n+- **共享Handler层**：抽象出公共的Handler接口（ConditionHandler、EffectHandler、VisualHandler等）\n+- **独立系统层**：技能系统和地形要素系统各自实现自己的执行流程\n+- **统一数据流**：都通过DataHandleQueue推送效果\n+\n+**架构设计**：\n+\n+```mermaid\n+graph TB\n+    subgraph SharedHandlerLayer[\"共享Handler层<br/>Shared Handler Layer\"]\n+        ConditionHandler[条件Handler<br/>ConditionHandler<br/>接口]\n+        EffectHandler[效果Handler<br/>EffectHandler<br/>接口]\n+        VisualHandler[表现Handler<br/>VisualHandler<br/>接口]\n+    end\n+    \n+    subgraph SkillDomain[\"技能领域<br/>Skill Domain\"]\n+        SkillBase[技能基类<br/>SkillBase]\n+        SkillContext[技能上下文<br/>SkillContext]\n+        SkillExecution[技能执行流程<br/>条件→目标→效果→表现]\n+    end\n+    \n+    subgraph TerrainDomain[\"地形要素Domain<br/>Terrain Domain\"]\n+        TerrainBase[地形要素基类<br/>TerrainBase]\n+        TerrainContext[地形要素上下文<br/>TerrainContext]\n+        TerrainExecution[地形要素执行流程<br/>条件→效果→表现]\n+    end\n+    \n+    subgraph ExternalSystems[\"外部系统\"]\n+        DataHandleQueue[DataHandleQueue<br/>效果推送]\n+        VisualSystem[表现系统<br/>可视化]\n+    end\n+    \n+    SkillBase -->|使用| ConditionHandler\n+    SkillBase -->|使用| EffectHandler\n+    SkillBase -->|使用| VisualHandler\n+    \n+    TerrainBase -->|使用| ConditionHandler\n+    TerrainBase -->|使用| EffectHandler\n+    TerrainBase -->|使用| VisualHandler\n+    \n+    SkillExecution -->|推送| DataHandleQueue\n+    TerrainExecution -->|推送| DataHandleQueue\n+    \n+    SkillExecution -->|通知| VisualSystem\n+    TerrainExecution -->|通知| VisualSystem\n+    \n+    style SharedHandlerLayer fill:#f3e5f5\n+    style SkillDomain fill:#e1f5ff\n+    style TerrainDomain fill:#fff4e1\n+    style ExternalSystems fill:#c8e6c9\n+```\n+\n+**Handler接口设计**：\n+\n+```mermaid\n+graph TB\n+    subgraph HandlerInterface[\"Handler接口层\"]\n+        IHandler[IHandler<br/>基础接口]\n+        IConditionHandler[IConditionHandler<br/>条件检查接口]\n+        IEffectHandler[IEffectHandler<br/>效果应用接口]\n+        IVisualHandler[IVisualHandler<br/>表现播放接口]\n+    end\n+    \n+    subgraph SkillImplementation[\"技能系统实现\"]\n+        SkillConditionHandler[SkillConditionHandler<br/>实现IConditionHandler]\n+        SkillEffectHandler[SkillEffectHandler<br/>实现IEffectHandler]\n+        SkillVisualHandler[SkillVisualHandler<br/>实现IVisualHandler]\n+    end\n+    \n+    subgraph TerrainImplementation[\"地形要素系统实现\"]\n+        TerrainConditionHandler[TerrainConditionHandler<br/>实现IConditionHandler]\n+        TerrainEffectHandler[TerrainEffectHandler<br/>实现IEffectHandler]\n+        TerrainVisualHandler[TerrainVisualHandler<br/>实现IVisualHandler]\n+    end\n+    \n+    IHandler --> IConditionHandler\n+    IHandler --> IEffectHandler\n+    IHandler --> IVisualHandler\n+    \n+    IConditionHandler --> SkillConditionHandler\n+    IConditionHandler --> TerrainConditionHandler\n+    \n+    IEffectHandler --> SkillEffectHandler\n+    IEffectHandler --> TerrainEffectHandler\n+    \n+    IVisualHandler --> SkillVisualHandler\n+    IVisualHandler --> TerrainVisualHandler\n+    \n+    style HandlerInterface fill:#f3e5f5\n+    style SkillImplementation fill:#e1f5ff\n+    style TerrainImplementation fill:#fff4e1\n+```\n"
                },
                {
                    "date": 1767108184766,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -384,10 +384,10 @@\n flowchart LR\n     ActionCoord[行动协调器<br/>调用技能领域] --> SkillDomain[技能领域<br/>执行技能]\n     SkillDomain --> EffectHandler[EffectHandler<br/>应用效果]\n     TerrainDomain[地形领域<br/>执行地形要素] --> EffectHandler[EffectHandler<br/>应用效果]\n-    EffectHandler --> ProcessQueue[DataHandleQueue<br/>ProcessDataHandler]\n-    ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>直接修改]\n+    EffectHandler --> ProcessQueue[DataHandleQueue]\n+    ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>推送修改]\n     UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n     ActionCoord --> TerrainDomain\n \n     style ActionCoord fill:#c8e6c9\n@@ -513,520 +513,4 @@\n     style HandlerInterface fill:#f3e5f5\n     style SkillImplementation fill:#e1f5ff\n     style TerrainImplementation fill:#fff4e1\n ```\n-# 战斗系统架构设计\n-\n-## 设计目标\n-\n-设计一套完整的回合制战斗系统架构，支持DND规则、回合管理、状态机控制、AI决策，实现战斗流程管理、伤害计算、效果应用，提供数据驱动的配置化战斗系统。\n-\n----\n-\n-## 核心设计理念\n-\n-### 1. 多层循环架构为核心\n-\n-**本质**：战斗系统的核心是四层循环的维护和管理\n-- **战斗循环**：管理整个战斗的生命周期\n-- **回合循环**：管理回合的循环和切换\n-- **阵营循环**：管理阵营内单位的行动顺序\n-- **单位循环**：管理单个单位的行动流程\n-- **循环驱动**：所有战斗逻辑都在循环框架内执行\n-- **状态维护**：每层循环维护自己的状态，驱动下层循环\n-\n-### 2. 数据驱动架构\n-\n-**本质**：战斗特性通过配置数据实现，无需修改代码\n-- 战斗规则、伤害计算、效果应用 → 通过配置数据定义\n-- 回合流程、状态转换 → 通过配置数据调整\n-- 新增战斗机制 → 扩展配置数据即可\n-- 战斗平衡 → 调整配置数值即可\n-\n-### 3. 分层架构（循环内的功能组织）\n-\n-**本质**：分层架构是循环内的功能组织方式，不是主要架构\n-- 功能组织：输入层、决策层、执行层、表现层、管理层\n-- 执行位置：所有分层功能都在单位循环内执行\n-- 解耦设计：层间通过Context和CommunicationBus通信\n-\n----\n-\n-## 整体架构设计\n-\n-### 多层循环架构（主要架构）\n-\n-**核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n-\n-#### Domain与循环的关系（领域驱动设计）\n-\n-**核心观点**：Domain控制循环，循环是Domain的工具。Domain是领域核心，拥有循环机制来推进业务流程。\n-\n-**术语说明**：使用\"Domain\"而非\"Entity\"，避免与项目中的\"Unit\"概念混淆。\n-\n-```mermaid\n-graph TB\n-    subgraph BattleDomain[\"战斗Domain<br/>Battle Domain\"]\n-        BattleManagement[战斗管理<br/>结算奖励/同步任务]\n-        BattleLoop[\"战斗循环<br/>BattleLoop\"]\n-        BattleManagement -->|控制| BattleLoop\n-        BattleLoop -->|推进| BattleManagement\n-        \n-        subgraph RoundDomain[\"回合Domain<br/>Round Domain\"]\n-            RoundManagement[回合管理<br/>行动值排序/单位行动顺序]\n-            RoundLoop[\"回合循环<br/>RoundLoop\"]\n-            RoundManagement -->|控制| RoundLoop\n-            RoundLoop -->|推进| RoundManagement\n-            \n-            subgraph TeamDomain[\"阵营Domain<br/>Team Domain\"]\n-                TeamManagement[阵营管理<br/>借机攻击/阵营差异行为]\n-                TeamLoop[\"阵营循环<br/>TeamLoop\"]\n-                TeamManagement -->|控制| TeamLoop\n-                TeamLoop -->|推进| TeamManagement\n-                \n-                subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n-                    UnitManagement[单位管理<br/>移动/施法/选择技能对象]\n-                    UnitLoop[\"单位循环<br/>UnitLoop\"]\n-                    UnitManagement -->|控制| UnitLoop\n-                    UnitLoop -->|推进| UnitManagement\n-                end\n-            end\n-        end\n-    end\n-    \n-    style BattleDomain fill:#ffebee\n-    style RoundDomain fill:#fff4e1\n-    style TeamDomain fill:#c8e6c9\n-    style UnitDomain fill:#e1f5ff\n-    style BattleLoop fill:#f3e5f5\n-    style RoundLoop fill:#f3e5f5\n-    style TeamLoop fill:#f3e5f5\n-    style UnitLoop fill:#f3e5f5\n-```\n-\n-**备注**：\n-- **阵营循环**：在标准DND规则中，所有单位按先攻值（Initiative）统一排序行动，不存在阵营循环。此处保留阵营循环作为扩展设计，便于后续支持阵营差异行为（如借机攻击、阵营特殊规则等）。如不需要，可简化为三层架构（战斗→回合→单位）。\n-\n-#### Domain协作关系\n-\n-**核心观点**：Domain之间通过协作推进业务流程，父Domain调用子Domain，子Domain完成业务后返回父Domain。\n-\n-```mermaid\n-graph TB\n-    BattleDomain[战斗Domain<br/>Battle Domain]\n-    RoundDomain[回合Domain<br/>Round Domain]\n-    TeamDomain[阵营Domain<br/>Team Domain]\n-    UnitDomain[单位Domain<br/>Unit Domain]\n-    \n-    BattleDomain -->|1. 调用| RoundDomain\n-    RoundDomain -->|2. 返回| BattleDomain\n-    RoundDomain -->|3. 调用| TeamDomain\n-    TeamDomain -->|4. 返回| RoundDomain\n-    TeamDomain -->|5. 调用| UnitDomain\n-    UnitDomain -->|6. 返回| TeamDomain\n-    \n-    BattleDomain -.->|包含| RoundDomain\n-    RoundDomain -.->|包含| TeamDomain\n-    TeamDomain -.->|包含| UnitDomain\n-    \n-    style BattleDomain fill:#ffebee\n-    style RoundDomain fill:#fff4e1\n-    style TeamDomain fill:#c8e6c9\n-    style UnitDomain fill:#e1f5ff\n-```\n-\n-**协作流程说明**：\n-1. **战斗Domain** → 调用 **回合Domain**：战斗进行中，需要执行回合\n-2. **回合Domain** → 调用 **阵营Domain**：回合进行中，需要处理阵营\n-3. **阵营Domain** → 调用 **单位Domain**：阵营进行中，需要处理单位\n-4. **单位Domain** → 返回 **阵营Domain**：单位行动完成\n-5. **阵营Domain** → 返回 **回合Domain**：阵营处理完成\n-6. **回合Domain** → 返回 **战斗Domain**：回合完成\n-\n-**协作原则**：\n-- 父Domain控制子Domain的调用时机\n-- 子Domain完成业务后主动返回父Domain\n-- 每个Domain独立管理自己的业务逻辑和循环\n-\n-### 循环职责说明\n-\n-#### 1. 战斗循环（BattleLoop）\n-- **职责**：管理整个战斗的生命周期\n-- **状态**：BattleState（未开始/进行中/已结束）\n-- **触发**：战斗开始/结束条件检查\n-- **维护**：BattleLoopManager\n-\n-#### 2. 回合循环（TurnLoop）\n-- **职责**：管理回合的循环和切换\n-- **状态**：TurnState（回合编号/当前回合/回合数）\n-- **触发**：回合开始/结束条件检查\n-- **维护**：TurnLoopManager\n-\n-#### 3. 阵营循环（TeamLoop）\n-- **职责**：管理阵营内单位的行动顺序\n-- **状态**：TeamState（当前阵营/阵营列表/行动顺序）\n-- **触发**：阵营切换/单位行动完成\n-- **维护**：TeamLoopManager\n-- **备注**：在标准DND规则中，所有单位按先攻值统一排序，不存在阵营循环。此处保留作为扩展设计，便于支持阵营差异行为。\n-\n-#### 4. 单位循环（UnitLoop）\n-- **职责**：管理单个单位的行动流程\n-- **状态**：UnitState（当前单位/行动状态/行动完成）\n-- **触发**：单位行动开始/结束\n-- **维护**：UnitLoopManager\n-\n----\n-\n-## 单位领域详细架构设计\n-\n-### 核心职责\n-\n-单位领域是战斗系统的核心，负责管理单个单位的行动流程，包括移动、技能释放、数值控制等。\n-\n-### 单位领域完整结构\n-\n-```mermaid\n-graph TB\n-    subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n-        UnitManagement[单位管理<br/>UnitManagement]\n-        UnitLoop[单位循环<br/>UnitLoop<br/>START → ACTION → END]\n-        ActionCoordinator[行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用]\n-        \n-        subgraph UnitManagement[\"单位管理<br/>UnitManagement\"]\n-            UnitData[单位数据<br/>UnitData]\n-            DataMgr[单位数据管理<br/>属性/状态/位置]\n-            RuleMgr[单位规则管理<br/>移动点数检查/行动规则]\n-        end\n-        \n-        subgraph DataHandleQueue[\"DataHandleQueue<br/>数据队列<br/>1:1关系\"]\n-        end\n-        \n-        subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n-            MoveCoord[移动协调<br/>调用网格系统]\n-            SkillCoord[技能协调<br/>调用技能领域]\n-            VisualCoord[表现协调<br/>通知表现层]\n-            TriCoord[技能协调<br/>调用技能领域]\n-        end\n-    end\n-    \n-    subgraph ExternalSystems[\"外部系统\"]\n-        GridSystem[网格系统<br/>GridSystem]\n-        SkillDomain[技能领域<br/>Skill Domain]\n-        VisualSystem[表现系统<br/>Visual System]\n-        TerrainDomain[地形领域<br/>Terrain Domain]\n-    end\n-    \n-    UnitManagement -->|控制| UnitLoop\n-    UnitManagement --> ActionCoordinator\n-    UnitManagement --> UnitData\n-    ActionCoordinator -->|反向推动| UnitLoop\n-    UnitLoop -->|推进| UnitManagement\n-    \n-    ActionCoordinator -->|调用| GridSystem\n-    ActionCoordinator -->|调用| SkillDomain\n-    ActionCoordinator -->|通知| VisualSystem\n-    \n-    SkillDomain -->|EffectHandler推送| DataHandleQueue\n-    TerrainDomain -->|EffectHandler推送| DataHandleQueue\n-\n-    DataHandleQueue -->|推送数据| UnitData\n-    \n-    style UnitDomain fill:#e1f5ff\n-    style UnitManagement fill:#fff4e1\n-    style UnitLoop fill:#f3e5f5\n-    style ActionCoordinator fill:#c8e6c9\n-    style DataHandleQueue fill:#f3e5f5\n-    style UnitData fill:#e1f5ff\n-```\n-\n-### 单位管理（UnitManagement）\n-\n-#### 1. 单位数据管理\n-- **单位属性**：生命值、移动点数、状态等\n-- **单位状态**：是否可行动、是否已移动、是否已攻击等\n-- **单位位置**：当前网格位置\n-\n-#### 2. 单位规则管理\n-- **移动点数规则**：移动前检查能否移动（回答1：移动前检查）\n-- **行动规则**：是否可执行行动\n-- **状态规则**：状态转换规则\n-\n-#### 3. UnitData（单位数据）\n-- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，数据直接修改 UnitData\n-- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n-- **无需中间层**：不需要\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n-\n-### 单位循环（UnitLoop）\n-\n-**循环状态**：START → ACTION → END（回答2：不需要更细的状态）\n-\n-- **START**：单位开始行动\n-- **ACTION**：执行行动（移动、技能等）\n-- **END**：单位结束行动\n-\n-### 行动协调器（ActionCoordinator）- 微核心\n-\n-**核心原则**：只负责协调调用，不包含业务规则（回答3：只负责协调调用）\n-\n-**核心职责**：\n-- ✅ **协调调用**：调用网格系统、技能领域、表现系统\n-- ✅ **反向推动循环**：执行完行动后，主动推动单位循环进入下一个状态（Domain controls Loop）\n-\n-#### 1. 移动协调\n-- **移动前检查**：调用单位管理检查移动点数\n-- **调用网格系统**：进行移动计算\n-- **移动后更新**：通过 DataHandleQueue 更新单位位置和移动点数\n-- **推动循环**：移动完成后，推动循环进入下一个状态\n-\n-#### 2. 技能协调\n-- **调用技能领域**：执行技能\n-- **不处理数值控制**：数值控制由技能领域的EffectHandler通过DataHandleQueue处理\n-- **接收技能结果**：获取技能执行结果（成功/失败），用于流程控制\n-- **推动循环**：技能执行完成后，推动循环进入下一个状态\n-\n-#### 3. 表现协调\n-- **通知表现层**：移动表现、技能表现、受攻击表现\n-- **推动循环**：表现播放完成后（可选），推动循环进入下一个状态\n-\n-#### 4. 循环推动机制\n-- **推动到END**：行动完成后，推动循环从ACTION状态进入END状态\n-- **推动到ACTION**：如果需要继续行动（还有移动点），推动循环从END状态回到ACTION状态\n-- **推动到START**：单位行动开始时，推动循环进入START状态\n-\n-### DataHandleQueue 作为单位领域内部组件\n-\n-**核心设计**：\n-- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n-- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n-- **无需中间层**：不需要\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n-\n-```mermaid\n-sequenceDiagram\n-    participant AC as 行动协调器\n-    participant SD as 技能领域\n-    participant EH as EffectHandler\n-    participant DHQ as DataHandleQueue<br/>单位领域内部\n-    participant UD as UnitData<br/>1:1关系\n-    \n-    AC -> SD: 调用技能领域执行技能\n-    SD -> EH: EffectHandler应用效果\n-    EH -> DHQ: PushData(效果数据, 目标单位ID)\n-    SD -> AC: 返回技能执行结果（成功/失败）\n-    DHQ -> UD: ProcessDataHandler()<br/>直接修改UnitData\n-    UD -> UD: 应用效果（扣血/加buff）\n-    UD -> UD: 更新状态\n-```\n-\n-**数据流特性**：\n-- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n-- ✅ **直接修改**：数据直接修改UnitData，无需经过中间层\n-- ✅ **解耦设计**：技能领域的EffectHandler负责推送数据，行动协调器不处理数值控制\n-- ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n-- ✅ **统一接口**：所有数值控制通过统一接口推送\n-- ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n-- ✅ **职责清晰**：行动协调器只负责协调调用，EffectHandler负责数值控制\n-\n-### 单位行动完整流程\n-\n-```mermaid\n-flowchart TD\n-    Start[START: 单位开始行动<br/>单位管理推动循环] --> Action[ACTION: 执行行动<br/>单位循环进入ACTION状态]\n-    \n-    Action --> CheckMove[移动前检查<br/>单位管理检查移动点数]\n-    \n-    CheckMove -->|可以移动| Move[单位移动<br/>行动协调器调用网格系统]\n-    CheckMove -->|不能移动| SkipMove[跳过移动]\n-    \n-    Move --> UpdateMove[更新移动点数<br/>通过DataHandleQueue推送]\n-    SkipMove --> Skill\n-    \n-    UpdateMove --> Skill[攻击/治疗<br/>行动协调器调用技能领域]\n-    \n-    Skill --> SkillResult[获取技能执行结果<br/>成功/失败]\n-    \n-    SkillResult --> Visual[可视化<br/>行动协调器通知表现层<br/>技能领域的EffectHandler已推送DataHandleQueue]\n-    Visual --> PushLoop[行动协调器推动循环<br/>推动到END状态]\n-    \n-    PushLoop --> CheckMovePoint[移动点数检查<br/>单位管理检查是否还有移动点]\n-    \n-    CheckMovePoint -->|还有移动点| PushAction[行动协调器推动循环<br/>推动回ACTION状态]\n-    CheckMovePoint -->|无移动点| PushEnd[行动协调器推动循环<br/>推动到END状态]\n-    \n-    PushAction --> Skill\n-    PushEnd --> End[END: 单位结束行动<br/>单位循环进入END状态]\n-    \n-    style Start fill:#e1f5ff\n-    style Action fill:#fff4e1\n-    style Move fill:#fff4e1\n-    style Skill fill:#c8e6c9\n-    style Visual fill:#c8e6c9\n-    style PushLoop fill:#f3e5f5\n-    style PushAction fill:#f3e5f5\n-    style PushEnd fill:#f3e5f5\n-    style End fill:#c8e6c9\n-```\n-\n-**流程说明**：\n-1. **START**：单位管理推动循环进入START状态\n-2. **ACTION**：单位循环进入ACTION状态，开始执行行动\n-3. **移动前检查**：单位管理检查移动点数（能否移动）\n-4. **单位移动**：行动协调器调用网格系统进行移动\n-5. **更新移动点数**：通过 DataHandleQueue 推送移动点数变更\n-6. **攻击/治疗**：行动协调器调用技能领域执行技能\n-7. **技能执行**：技能领域的EffectHandler通过DataHandleQueue推送效果数据到目标单位\n-8. **可视化**：行动协调器通知表现层播放效果\n-9. **推动循环**：行动协调器推动循环进入END状态\n-10. **移动点数检查**：单位管理检查是否还有移动点\n-11. **循环或结束**：\n-    - 还有移动点：行动协调器推动循环回到ACTION状态，继续执行\n-    - 无移动点：行动协调器推动循环保持在END状态，结束行动\n-\n-**关键点**：\n-- ✅ **Domain controls Loop**：单位管理通过行动协调器控制循环状态转换\n-- ✅ **反向推动机制**：行动协调器执行完行动后，主动推动循环进入下一个状态\n-- ✅ **行动协调器不处理数值控制**：只负责调用技能领域，不处理效果数据推送\n-- ✅ **EffectHandler负责推送**：技能领域的EffectHandler负责通过DataHandleQueue推送效果数据\n-- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，数据直接修改 UnitData\n-- ✅ **直接修改**：不需要经过\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n-\n-### 数值控制流程（通过 DataHandleQueue）\n-\n-**核心设计**：\n-- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n-- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n-- **无需中间层**：不需要经过\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n-- **行动协调器不处理数值控制**：只负责调用技能领域，不处理效果数据推送\n-\n-```mermaid\n-flowchart LR\n-    ActionCoord[行动协调器<br/>调用技能领域] --> SkillDomain[技能领域<br/>执行技能]\n-    SkillDomain --> EffectHandler[EffectHandler<br/>应用效果]\n-    TerrainDomain[地形领域<br/>执行地形要素] --> EffectHandler[EffectHandler<br/>应用效果]\n-    EffectHandler --> PushQueue[DataHandleQueue<br/>单位领域内部<br/>PushData效果数据]\n-    PushQueue --> ProcessQueue[DataHandleQueue<br/>ProcessDataHandler]\n-    ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>直接修改]\n-    UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n-    ActionCoord --> TerrainDomain\n-    style ActionCoord fill:#c8e6c9\n-    style SkillDomain fill:#c8e6c9\n-    style EffectHandler fill:#fff4e1\n-    style PushQueue fill:#f3e5f5\n-    style ProcessQueue fill:#f3e5f5\n-    style UnitData fill:#e1f5ff\n-    style UpdateState fill:#fff4e1\n-```\n-\n-\n-**职责划分**：\n-- ✅ **行动协调器**：只负责调用技能领域，不处理数值控制\n-- ✅ **技能领域的EffectHandler**：负责通过DataHandleQueue推送效果数据到目标单位\n-- ✅ **DataHandleQueue**：与UnitData是1:1关系，属于单位领域内部\n-- ✅ **UnitData**：通过DataHandleQueue接收并直接处理，无需经过\"数值控制管理\"中间层\n-\n-\n-### 设计优势\n-\n-- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部，数据直接修改UnitData\n-- ✅ **无需中间层**：不需要\"数值控制管理\"中间层，简化架构设计\n-- ✅ **解耦设计**：通过 DataHandleQueue 实现模块间解耦，技能领域的EffectHandler负责推送数据\n-- ✅ **职责清晰**：行动协调器只负责协调调用，EffectHandler负责数值控制，职责分离\n-- ✅ **统一接口**：所有数值控制通过统一接口推送，易于维护\n-- ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n-- ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n-- ✅ **微核心设计**：行动协调器只负责协调调用，不包含业务规则，易于扩展\n-- ✅ **符合技能系统架构**：与技能系统的Handler策略模式设计一致，EffectHandler负责效果应用\n-\n-### 数据同步统一架构设计\n-**设计思路**：抽象出公共的Handler接口，技能系统和地形要素系统都使用这些Handler，但保持系统独立。\n-\n-**核心设计**：\n-- **共享Handler层**：抽象出公共的Handler接口（ConditionHandler、EffectHandler、VisualHandler等）\n-- **独立系统层**：技能系统和地形要素系统各自实现自己的执行流程\n-- **统一数据流**：都通过DataHandleQueue推送效果\n-\n-**架构设计**：\n-\n-```mermaid\n-graph TB\n-    subgraph SharedHandlerLayer[\"共享Handler层<br/>Shared Handler Layer\"]\n-        ConditionHandler[条件Handler<br/>ConditionHandler<br/>接口]\n-        EffectHandler[效果Handler<br/>EffectHandler<br/>接口]\n-        VisualHandler[表现Handler<br/>VisualHandler<br/>接口]\n-    end\n-    \n-    subgraph SkillDomain[\"技能领域<br/>Skill Domain\"]\n-        SkillBase[技能基类<br/>SkillBase]\n-        SkillContext[技能上下文<br/>SkillContext]\n-        SkillExecution[技能执行流程<br/>条件→目标→效果→表现]\n-    end\n-    \n-    subgraph TerrainDomain[\"地形要素Domain<br/>Terrain Domain\"]\n-        TerrainBase[地形要素基类<br/>TerrainBase]\n-        TerrainContext[地形要素上下文<br/>TerrainContext]\n-        TerrainExecution[地形要素执行流程<br/>条件→效果→表现]\n-    end\n-    \n-    subgraph ExternalSystems[\"外部系统\"]\n-        DataHandleQueue[DataHandleQueue<br/>效果推送]\n-        VisualSystem[表现系统<br/>可视化]\n-    end\n-    \n-    SkillBase -->|使用| ConditionHandler\n-    SkillBase -->|使用| EffectHandler\n-    SkillBase -->|使用| VisualHandler\n-    \n-    TerrainBase -->|使用| ConditionHandler\n-    TerrainBase -->|使用| EffectHandler\n-    TerrainBase -->|使用| VisualHandler\n-    \n-    SkillExecution -->|推送| DataHandleQueue\n-    TerrainExecution -->|推送| DataHandleQueue\n-    \n-    SkillExecution -->|通知| VisualSystem\n-    TerrainExecution -->|通知| VisualSystem\n-    \n-    style SharedHandlerLayer fill:#f3e5f5\n-    style SkillDomain fill:#e1f5ff\n-    style TerrainDomain fill:#fff4e1\n-    style ExternalSystems fill:#c8e6c9\n-```\n-\n-**Handler接口设计**：\n-\n-```mermaid\n-graph TB\n-    subgraph HandlerInterface[\"Handler接口层\"]\n-        IHandler[IHandler<br/>基础接口]\n-        IConditionHandler[IConditionHandler<br/>条件检查接口]\n-        IEffectHandler[IEffectHandler<br/>效果应用接口]\n-        IVisualHandler[IVisualHandler<br/>表现播放接口]\n-    end\n-    \n-    subgraph SkillImplementation[\"技能系统实现\"]\n-        SkillConditionHandler[SkillConditionHandler<br/>实现IConditionHandler]\n-        SkillEffectHandler[SkillEffectHandler<br/>实现IEffectHandler]\n-        SkillVisualHandler[SkillVisualHandler<br/>实现IVisualHandler]\n-    end\n-    \n-    subgraph TerrainImplementation[\"地形要素系统实现\"]\n-        TerrainConditionHandler[TerrainConditionHandler<br/>实现IConditionHandler]\n-        TerrainEffectHandler[TerrainEffectHandler<br/>实现IEffectHandler]\n-        TerrainVisualHandler[TerrainVisualHandler<br/>实现IVisualHandler]\n-    end\n-    \n-    IHandler --> IConditionHandler\n-    IHandler --> IEffectHandler\n-    IHandler --> IVisualHandler\n-    \n-    IConditionHandler --> SkillConditionHandler\n-    IConditionHandler --> TerrainConditionHandler\n-    \n-    IEffectHandler --> SkillEffectHandler\n-    IEffectHandler --> TerrainEffectHandler\n-    \n-    IVisualHandler --> SkillVisualHandler\n-    IVisualHandler --> TerrainVisualHandler\n-    \n-    style HandlerInterface fill:#f3e5f5\n-    style SkillImplementation fill:#e1f5ff\n-    style TerrainImplementation fill:#fff4e1\n-```\n"
                },
                {
                    "date": 1767108211314,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -392,9 +392,8 @@\n \n     style ActionCoord fill:#c8e6c9\n     style SkillDomain fill:#c8e6c9\n     style EffectHandler fill:#fff4e1\n-    style PushQueue fill:#f3e5f5\n     style ProcessQueue fill:#f3e5f5\n     style UnitData fill:#e1f5ff\n     style UpdateState fill:#fff4e1\n ```\n"
                },
                {
                    "date": 1767108222212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -388,9 +388,11 @@\n     EffectHandler --> ProcessQueue[DataHandleQueue]\n     ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>推送修改]\n     UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n     ActionCoord --> TerrainDomain\n+    ActionCoord --> UnitData\n \n+\n     style ActionCoord fill:#c8e6c9\n     style SkillDomain fill:#c8e6c9\n     style EffectHandler fill:#fff4e1\n     style ProcessQueue fill:#f3e5f5\n"
                },
                {
                    "date": 1767108242771,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -388,9 +388,9 @@\n     EffectHandler --> ProcessQueue[DataHandleQueue]\n     ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>推送修改]\n     UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n     ActionCoord --> TerrainDomain\n-    ActionCoord --> UnitData\n+    ActionCoord --> 其他领域\n \n \n     style ActionCoord fill:#c8e6c9\n     style SkillDomain fill:#c8e6c9\n"
                },
                {
                    "date": 1767108248848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -389,10 +389,10 @@\n     ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>推送修改]\n     UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n     ActionCoord --> TerrainDomain\n     ActionCoord --> 其他领域\n+    其他领域 --> EffectHandler\n \n-\n     style ActionCoord fill:#c8e6c9\n     style SkillDomain fill:#c8e6c9\n     style EffectHandler fill:#fff4e1\n     style ProcessQueue fill:#f3e5f5\n"
                },
                {
                    "date": 1767108268281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -373,14 +373,8 @@\n - ✅ **直接修改**：不需要经过\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n \n ### 数值控制流程（通过 DataHandleQueue）\n \n-**核心设计**：\n-- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n-- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n-- **无需中间层**：不需要经过\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n-- **行动协调器不处理数值控制**：只负责调用技能领域，不处理效果数据推送\n-\n ```mermaid\n flowchart LR\n     ActionCoord[行动协调器<br/>调用技能领域] --> SkillDomain[技能领域<br/>执行技能]\n     SkillDomain --> EffectHandler[EffectHandler<br/>应用效果]\n"
                },
                {
                    "date": 1767108314807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -413,99 +413,4 @@\n - ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n - ✅ **微核心设计**：行动协调器只负责协调调用，不包含业务规则，易于扩展\n - ✅ **符合技能系统架构**：与技能系统的Handler策略模式设计一致，EffectHandler负责效果应用\n \n-### 数据同步统一架构设计\n-**设计思路**：抽象出公共的Handler接口，技能系统和地形要素系统都使用这些Handler，但保持系统独立。\n-\n-**核心设计**：\n-- **共享Handler层**：抽象出公共的Handler接口（ConditionHandler、EffectHandler、VisualHandler等）\n-- **独立系统层**：技能系统和地形要素系统各自实现自己的执行流程\n-- **统一数据流**：都通过DataHandleQueue推送效果\n-\n-**架构设计**：\n-\n-```mermaid\n-graph TB\n-    subgraph SharedHandlerLayer[\"共享Handler层<br/>Shared Handler Layer\"]\n-        ConditionHandler[条件Handler<br/>ConditionHandler<br/>接口]\n-        EffectHandler[效果Handler<br/>EffectHandler<br/>接口]\n-        VisualHandler[表现Handler<br/>VisualHandler<br/>接口]\n-    end\n-    \n-    subgraph SkillDomain[\"技能领域<br/>Skill Domain\"]\n-        SkillBase[技能基类<br/>SkillBase]\n-        SkillContext[技能上下文<br/>SkillContext]\n-        SkillExecution[技能执行流程<br/>条件→目标→效果→表现]\n-    end\n-    \n-    subgraph TerrainDomain[\"地形要素Domain<br/>Terrain Domain\"]\n-        TerrainBase[地形要素基类<br/>TerrainBase]\n-        TerrainContext[地形要素上下文<br/>TerrainContext]\n-        TerrainExecution[地形要素执行流程<br/>条件→效果→表现]\n-    end\n-    \n-    subgraph ExternalSystems[\"外部系统\"]\n-        DataHandleQueue[DataHandleQueue<br/>效果推送]\n-        VisualSystem[表现系统<br/>可视化]\n-    end\n-    \n-    SkillBase -->|使用| ConditionHandler\n-    SkillBase -->|使用| EffectHandler\n-    SkillBase -->|使用| VisualHandler\n-    \n-    TerrainBase -->|使用| ConditionHandler\n-    TerrainBase -->|使用| EffectHandler\n-    TerrainBase -->|使用| VisualHandler\n-    \n-    SkillExecution -->|推送| DataHandleQueue\n-    TerrainExecution -->|推送| DataHandleQueue\n-    \n-    SkillExecution -->|通知| VisualSystem\n-    TerrainExecution -->|通知| VisualSystem\n-    \n-    style SharedHandlerLayer fill:#f3e5f5\n-    style SkillDomain fill:#e1f5ff\n-    style TerrainDomain fill:#fff4e1\n-    style ExternalSystems fill:#c8e6c9\n-```\n-\n-**Handler接口设计**：\n-\n-```mermaid\n-graph TB\n-    subgraph HandlerInterface[\"Handler接口层\"]\n-        IHandler[IHandler<br/>基础接口]\n-        IConditionHandler[IConditionHandler<br/>条件检查接口]\n-        IEffectHandler[IEffectHandler<br/>效果应用接口]\n-        IVisualHandler[IVisualHandler<br/>表现播放接口]\n-    end\n-    \n-    subgraph SkillImplementation[\"技能系统实现\"]\n-        SkillConditionHandler[SkillConditionHandler<br/>实现IConditionHandler]\n-        SkillEffectHandler[SkillEffectHandler<br/>实现IEffectHandler]\n-        SkillVisualHandler[SkillVisualHandler<br/>实现IVisualHandler]\n-    end\n-    \n-    subgraph TerrainImplementation[\"地形要素系统实现\"]\n-        TerrainConditionHandler[TerrainConditionHandler<br/>实现IConditionHandler]\n-        TerrainEffectHandler[TerrainEffectHandler<br/>实现IEffectHandler]\n-        TerrainVisualHandler[TerrainVisualHandler<br/>实现IVisualHandler]\n-    end\n-    \n-    IHandler --> IConditionHandler\n-    IHandler --> IEffectHandler\n-    IHandler --> IVisualHandler\n-    \n-    IConditionHandler --> SkillConditionHandler\n-    IConditionHandler --> TerrainConditionHandler\n-    \n-    IEffectHandler --> SkillEffectHandler\n-    IEffectHandler --> TerrainEffectHandler\n-    \n-    IVisualHandler --> SkillVisualHandler\n-    IVisualHandler --> TerrainVisualHandler\n-    \n-    style HandlerInterface fill:#f3e5f5\n-    style SkillImplementation fill:#e1f5ff\n-    style TerrainImplementation fill:#fff4e1\n-```\n"
                },
                {
                    "date": 1767108391442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -393,24 +393,29 @@\n     style UnitData fill:#e1f5ff\n     style UpdateState fill:#fff4e1\n ```\n \n+### 职责划分\n \n-**职责划分**：\n-- ✅ **行动协调器**：只负责调用技能领域，不处理数值控制\n-- ✅ **技能领域的EffectHandler**：负责通过DataHandleQueue推送效果数据到目标单位\n-- ✅ **DataHandleQueue**：与UnitData是1:1关系，属于单位领域内部\n-- ✅ **UnitData**：通过DataHandleQueue接收并直接处理，无需经过\"数值控制管理\"中间层\n+| 组件 | 职责 | 说明 |\n+|------|------|------|\n+| **行动协调器** | 协调调用 | 调用技能领域/地形领域，不处理数值控制 |\n+| **EffectHandler** | 效果推送 | 通过DataHandleQueue推送效果数据到目标单位 |\n+| **DataHandleQueue** | 数据队列 | 与UnitData是1:1关系，属于单位领域内部 |\n+| **UnitData** | 数据接收 | 通过DataHandleQueue接收并直接处理，无需中间层 |\n \n-\n ### 设计优势\n \n-- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部，数据直接修改UnitData\n-- ✅ **无需中间层**：不需要\"数值控制管理\"中间层，简化架构设计\n-- ✅ **解耦设计**：通过 DataHandleQueue 实现模块间解耦，技能领域的EffectHandler负责推送数据\n-- ✅ **职责清晰**：行动协调器只负责协调调用，EffectHandler负责数值控制，职责分离\n+**架构层面**：\n+- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，数据直接修改，无需中间层\n+- ✅ **职责分离**：行动协调器（协调调用）与 EffectHandler（数值控制）职责清晰\n+- ✅ **微核心设计**：行动协调器只负责协调，不包含业务规则，易于扩展\n+\n+**数据流层面**：\n - ✅ **统一接口**：所有数值控制通过统一接口推送，易于维护\n-- ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n+- ✅ **批量处理**：支持批量处理，减少调用次数\n - ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n-- ✅ **微核心设计**：行动协调器只负责协调调用，不包含业务规则，易于扩展\n-- ✅ **符合技能系统架构**：与技能系统的Handler策略模式设计一致，EffectHandler负责效果应用\n \n+**系统集成**：\n+- ✅ **解耦设计**：通过 DataHandleQueue 实现模块间解耦\n+- ✅ **符合架构**：与技能系统的Handler策略模式设计一致\n+\n"
                },
                {
                    "date": 1767108550132,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,42 +312,41 @@\n ### 单位行动完整流程\n \n ```mermaid\n flowchart TD\n-    Start[START: 单位开始行动<br/>单位管理推动循环] --> Action[ACTION: 执行行动<br/>单位循环进入ACTION状态]\n+    Start[START<br/>单位管理推动循环] --> Action[ACTION<br/>执行行动]\n     \n-    Action --> CheckMove[移动前检查<br/>单位管理检查移动点数]\n+    Action --> CheckMove{移动前检查<br/>单位管理检查移动点数}\n     \n     CheckMove -->|可以移动| Move[单位移动<br/>行动协调器调用网格系统]\n-    CheckMove -->|不能移动| SkipMove[跳过移动]\n+    CheckMove -->|不能移动| Skill\n     \n-    Move --> UpdateMove[更新移动点数<br/>通过DataHandleQueue推送]\n-    SkipMove --> Skill\n-    \n+    Move --> UpdateMove[更新移动点数<br/>DataHandleQueue推送]\n     UpdateMove --> Skill[攻击/治疗<br/>行动协调器调用技能领域]\n     \n-    Skill --> SkillResult[获取技能执行结果<br/>成功/失败]\n+    Skill --> EffectPush[EffectHandler推送效果<br/>通过DataHandleQueue到目标单位]\n+    EffectPush --> Visual[可视化<br/>行动协调器通知表现层]\n     \n-    SkillResult --> Visual[可视化<br/>行动协调器通知表现层<br/>技能领域的EffectHandler已推送DataHandleQueue]\n-    Visual --> PushLoop[行动协调器推动循环<br/>推动到END状态]\n+    Visual --> PushEnd[行动协调器推动循环<br/>推动到END状态]\n     \n-    PushLoop --> CheckMovePoint[移动点数检查<br/>单位管理检查是否还有移动点]\n+    PushEnd --> CheckMovePoint{移动点数检查<br/>单位管理检查是否还有移动点}\n     \n     CheckMovePoint -->|还有移动点| PushAction[行动协调器推动循环<br/>推动回ACTION状态]\n-    CheckMovePoint -->|无移动点| PushEnd[行动协调器推动循环<br/>推动到END状态]\n+    CheckMovePoint -->|无移动点| End[END<br/>单位结束行动]\n     \n-    PushAction --> Skill\n-    PushEnd --> End[END: 单位结束行动<br/>单位循环进入END状态]\n+    PushAction --> Action\n     \n     style Start fill:#e1f5ff\n     style Action fill:#fff4e1\n     style Move fill:#fff4e1\n     style Skill fill:#c8e6c9\n+    style EffectPush fill:#fff4e1\n     style Visual fill:#c8e6c9\n-    style PushLoop fill:#f3e5f5\n+    style PushEnd fill:#f3e5f5\n     style PushAction fill:#f3e5f5\n-    style PushEnd fill:#f3e5f5\n     style End fill:#c8e6c9\n+    style CheckMove fill:#ffe0b2\n+    style CheckMovePoint fill:#ffe0b2\n ```\n \n **流程说明**：\n 1. **START**：单位管理推动循环进入START状态\n"
                },
                {
                    "date": 1767108578008,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -334,9 +334,9 @@\n     CheckMovePoint -->|无移动点| End[END<br/>单位结束行动]\n     \n     PushAction --> Action\n     \n-    style Start fill:#e1f5ff\n+    style LoopStart fill:#e1f5ff\n     style Action fill:#fff4e1\n     style Move fill:#fff4e1\n     style Skill fill:#c8e6c9\n     style EffectPush fill:#fff4e1\n"
                },
                {
                    "date": 1767108595086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,11 +312,11 @@\n ### 单位行动完整流程\n \n ```mermaid\n flowchart TD\n-    Start[START<br/>单位管理推动循环] --> Action[ACTION<br/>执行行动]\n+    LoopStart[START<br/>单位管理推动循环] --> Action[ACTION<br/>执行行动]\n     \n-    Action --> CheckMove{移动前检查<br/>单位管理检查移动点数}\n+    LoopAction --> CheckMove{移动前检查<br/>单位管理检查移动点数}\n     \n     CheckMove -->|可以移动| Move[单位移动<br/>行动协调器调用网格系统]\n     CheckMove -->|不能移动| Skill\n     \n"
                },
                {
                    "date": 1767108600234,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,9 +312,9 @@\n ### 单位行动完整流程\n \n ```mermaid\n flowchart TD\n-    LoopStart[START<br/>单位管理推动循环] --> Action[ACTION<br/>执行行动]\n+    LoopStart[START<br/>单位管理推动循环] --> LoopAction[ACTION<br/>执行行动]\n     \n     LoopAction --> CheckMove{移动前检查<br/>单位管理检查移动点数}\n     \n     CheckMove -->|可以移动| Move[单位移动<br/>行动协调器调用网格系统]\n@@ -335,9 +335,9 @@\n     \n     PushAction --> Action\n     \n     style LoopStart fill:#e1f5ff\n-    style Action fill:#fff4e1\n+    style LoopAction fill:#fff4e1\n     style Move fill:#fff4e1\n     style Skill fill:#c8e6c9\n     style EffectPush fill:#fff4e1\n     style Visual fill:#c8e6c9\n"
                },
                {
                    "date": 1767108615861,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -332,9 +332,9 @@\n     \n     CheckMovePoint -->|还有移动点| PushAction[行动协调器推动循环<br/>推动回ACTION状态]\n     CheckMovePoint -->|无移动点| End[END<br/>单位结束行动]\n     \n-    PushAction --> Action\n+    PushAction --> LoopAction\n     \n     style LoopStart fill:#e1f5ff\n     style LoopAction fill:#fff4e1\n     style Move fill:#fff4e1\n@@ -342,9 +342,9 @@\n     style EffectPush fill:#fff4e1\n     style Visual fill:#c8e6c9\n     style PushEnd fill:#f3e5f5\n     style PushAction fill:#f3e5f5\n-    style End fill:#c8e6c9\n+    style LoopEnd fill:#c8e6c9\n     style CheckMove fill:#ffe0b2\n     style CheckMovePoint fill:#ffe0b2\n ```\n \n"
                },
                {
                    "date": 1767108631644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -330,9 +330,9 @@\n     \n     PushEnd --> CheckMovePoint{移动点数检查<br/>单位管理检查是否还有移动点}\n     \n     CheckMovePoint -->|还有移动点| PushAction[行动协调器推动循环<br/>推动回ACTION状态]\n-    CheckMovePoint -->|无移动点| End[END<br/>单位结束行动]\n+    CheckMovePoint -->|无移动点| LoopEnd[END<br/>单位结束行动]\n     \n     PushAction --> LoopAction\n     \n     style LoopStart fill:#e1f5ff\n"
                },
                {
                    "date": 1767108639483,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,9 +312,9 @@\n ### 单位行动完整流程\n \n ```mermaid\n flowchart TD\n-    LoopStart[START<br/>单位管理推动循环] --> LoopAction[ACTION<br/>执行行动]\n+    LoopStart[START<br/>单位管理推动循环] --> LoopAction[LoopAction<br/>执行行动]\n     \n     LoopAction --> CheckMove{移动前检查<br/>单位管理检查移动点数}\n     \n     CheckMove -->|可以移动| Move[单位移动<br/>行动协调器调用网格系统]\n@@ -330,9 +330,9 @@\n     \n     PushEnd --> CheckMovePoint{移动点数检查<br/>单位管理检查是否还有移动点}\n     \n     CheckMovePoint -->|还有移动点| PushAction[行动协调器推动循环<br/>推动回ACTION状态]\n-    CheckMovePoint -->|无移动点| LoopEnd[END<br/>单位结束行动]\n+    CheckMovePoint -->|无移动点| LoopEnd[LoopEnd<br/>单位结束行动]\n     \n     PushAction --> LoopAction\n     \n     style LoopStart fill:#e1f5ff\n"
                },
                {
                    "date": 1767108660623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -312,9 +312,9 @@\n ### 单位行动完整流程\n \n ```mermaid\n flowchart TD\n-    LoopStart[START<br/>单位管理推动循环] --> LoopAction[LoopAction<br/>执行行动]\n+    LoopStart[LoopStart<br/>单位管理推动循环] --> LoopAction[LoopAction<br/>执行行动]\n     \n     LoopAction --> CheckMove{移动前检查<br/>单位管理检查移动点数}\n     \n     CheckMove -->|可以移动| Move[单位移动<br/>行动协调器调用网格系统]\n@@ -335,16 +335,16 @@\n     \n     PushAction --> LoopAction\n     \n     style LoopStart fill:#e1f5ff\n-    style LoopAction fill:#fff4e1\n+    style LoopAction fill:#e1f5ff\n     style Move fill:#fff4e1\n     style Skill fill:#c8e6c9\n     style EffectPush fill:#fff4e1\n     style Visual fill:#c8e6c9\n     style PushEnd fill:#f3e5f5\n     style PushAction fill:#f3e5f5\n-    style LoopEnd fill:#c8e6c9\n+    style LoopEnd fill:#e1f5ff\n     style CheckMove fill:#ffe0b2\n     style CheckMovePoint fill:#ffe0b2\n ```\n \n"
                },
                {
                    "date": 1767108801727,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -342,9 +342,9 @@\n     style EffectPush fill:#fff4e1\n     style Visual fill:#c8e6c9\n     style PushEnd fill:#f3e5f5\n     style PushAction fill:#f3e5f5\n-    style LoopEnd fill:#e1f5ff\n+    style LoopEnd fill:#4b1818\n     style CheckMove fill:#ffe0b2\n     style CheckMovePoint fill:#ffe0b2\n ```\n \n"
                },
                {
                    "date": 1767108822636,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -334,9 +334,9 @@\n     CheckMovePoint -->|无移动点| LoopEnd[LoopEnd<br/>单位结束行动]\n     \n     PushAction --> LoopAction\n     \n-    style LoopStart fill:#4b1818\n+    style LoopStart fill:#373d29\n     style LoopAction fill:#4b1818\n     style Move fill:#fff4e1\n     style Skill fill:#c8e6c9\n     style EffectPush fill:#fff4e1\n"
                },
                {
                    "date": 1767108841078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,420 @@\n+# 战斗系统架构设计\n+\n+## 设计目标\n+\n+设计一套完整的回合制战斗系统架构，支持DND规则、回合管理、状态机控制、AI决策，实现战斗流程管理、伤害计算、效果应用，提供数据驱动的配置化战斗系统。\n+\n+---\n+\n+## 核心设计理念\n+\n+### 1. 多层循环架构为核心\n+\n+**本质**：战斗系统的核心是四层循环的维护和管理\n+- **战斗循环**：管理整个战斗的生命周期\n+- **回合循环**：管理回合的循环和切换\n+- **阵营循环**：管理阵营内单位的行动顺序\n+- **单位循环**：管理单个单位的行动流程\n+- **循环驱动**：所有战斗逻辑都在循环框架内执行\n+- **状态维护**：每层循环维护自己的状态，驱动下层循环\n+\n+### 2. 数据驱动架构\n+\n+**本质**：战斗特性通过配置数据实现，无需修改代码\n+- 战斗规则、伤害计算、效果应用 → 通过配置数据定义\n+- 回合流程、状态转换 → 通过配置数据调整\n+- 新增战斗机制 → 扩展配置数据即可\n+- 战斗平衡 → 调整配置数值即可\n+\n+### 3. 分层架构（循环内的功能组织）\n+\n+**本质**：分层架构是循环内的功能组织方式，不是主要架构\n+- 功能组织：输入层、决策层、执行层、表现层、管理层\n+- 执行位置：所有分层功能都在单位循环内执行\n+- 解耦设计：层间通过Context和CommunicationBus通信\n+\n+---\n+\n+## 整体架构设计\n+\n+### 多层循环架构（主要架构）\n+\n+**核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n+\n+#### Domain与循环的关系（领域驱动设计）\n+\n+**核心观点**：Domain控制循环，循环是Domain的工具。Domain是领域核心，拥有循环机制来推进业务流程。\n+\n+**术语说明**：使用\"Domain\"而非\"Entity\"，避免与项目中的\"Unit\"概念混淆。\n+\n+```mermaid\n+graph TB\n+    subgraph BattleDomain[\"战斗Domain<br/>Battle Domain\"]\n+        BattleManagement[战斗管理<br/>结算奖励/同步任务]\n+        BattleLoop[\"战斗循环<br/>BattleLoop\"]\n+        BattleManagement -->|控制| BattleLoop\n+        BattleLoop -->|推进| BattleManagement\n+        \n+        subgraph RoundDomain[\"回合Domain<br/>Round Domain\"]\n+            RoundManagement[回合管理<br/>行动值排序/单位行动顺序]\n+            RoundLoop[\"回合循环<br/>RoundLoop\"]\n+            RoundManagement -->|控制| RoundLoop\n+            RoundLoop -->|推进| RoundManagement\n+            \n+            subgraph TeamDomain[\"阵营Domain<br/>Team Domain\"]\n+                TeamManagement[阵营管理<br/>借机攻击/阵营差异行为]\n+                TeamLoop[\"阵营循环<br/>TeamLoop\"]\n+                TeamManagement -->|控制| TeamLoop\n+                TeamLoop -->|推进| TeamManagement\n+                \n+                subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n+                    UnitManagement[单位管理<br/>移动/施法/选择技能对象]\n+                    UnitLoop[\"单位循环<br/>UnitLoop\"]\n+                    UnitManagement -->|控制| UnitLoop\n+                    UnitLoop -->|推进| UnitManagement\n+                end\n+            end\n+        end\n+    end\n+    \n+    style BattleDomain fill:#ffebee\n+    style RoundDomain fill:#fff4e1\n+    style TeamDomain fill:#c8e6c9\n+    style UnitDomain fill:#e1f5ff\n+    style BattleLoop fill:#f3e5f5\n+    style RoundLoop fill:#f3e5f5\n+    style TeamLoop fill:#f3e5f5\n+    style UnitLoop fill:#f3e5f5\n+```\n+\n+**备注**：\n+- **阵营循环**：在标准DND规则中，所有单位按先攻值（Initiative）统一排序行动，不存在阵营循环。此处保留阵营循环作为扩展设计，便于后续支持阵营差异行为（如借机攻击、阵营特殊规则等）。如不需要，可简化为三层架构（战斗→回合→单位）。\n+\n+#### Domain协作关系\n+\n+**核心观点**：Domain之间通过协作推进业务流程，父Domain调用子Domain，子Domain完成业务后返回父Domain。\n+\n+```mermaid\n+graph TB\n+    BattleDomain[战斗Domain<br/>Battle Domain]\n+    RoundDomain[回合Domain<br/>Round Domain]\n+    TeamDomain[阵营Domain<br/>Team Domain]\n+    UnitDomain[单位Domain<br/>Unit Domain]\n+    \n+    BattleDomain -->|1. 调用| RoundDomain\n+    RoundDomain -->|2. 返回| BattleDomain\n+    RoundDomain -->|3. 调用| TeamDomain\n+    TeamDomain -->|4. 返回| RoundDomain\n+    TeamDomain -->|5. 调用| UnitDomain\n+    UnitDomain -->|6. 返回| TeamDomain\n+    \n+    BattleDomain -.->|包含| RoundDomain\n+    RoundDomain -.->|包含| TeamDomain\n+    TeamDomain -.->|包含| UnitDomain\n+    \n+    style BattleDomain fill:#ffebee\n+    style RoundDomain fill:#fff4e1\n+    style TeamDomain fill:#c8e6c9\n+    style UnitDomain fill:#e1f5ff\n+```\n+\n+**协作流程说明**：\n+1. **战斗Domain** → 调用 **回合Domain**：战斗进行中，需要执行回合\n+2. **回合Domain** → 调用 **阵营Domain**：回合进行中，需要处理阵营\n+3. **阵营Domain** → 调用 **单位Domain**：阵营进行中，需要处理单位\n+4. **单位Domain** → 返回 **阵营Domain**：单位行动完成\n+5. **阵营Domain** → 返回 **回合Domain**：阵营处理完成\n+6. **回合Domain** → 返回 **战斗Domain**：回合完成\n+\n+**协作原则**：\n+- 父Domain控制子Domain的调用时机\n+- 子Domain完成业务后主动返回父Domain\n+- 每个Domain独立管理自己的业务逻辑和循环\n+\n+### 循环职责说明\n+\n+#### 1. 战斗循环（BattleLoop）\n+- **职责**：管理整个战斗的生命周期\n+- **状态**：BattleState（未开始/进行中/已结束）\n+- **触发**：战斗开始/结束条件检查\n+- **维护**：BattleLoopManager\n+\n+#### 2. 回合循环（TurnLoop）\n+- **职责**：管理回合的循环和切换\n+- **状态**：TurnState（回合编号/当前回合/回合数）\n+- **触发**：回合开始/结束条件检查\n+- **维护**：TurnLoopManager\n+\n+#### 3. 阵营循环（TeamLoop）\n+- **职责**：管理阵营内单位的行动顺序\n+- **状态**：TeamState（当前阵营/阵营列表/行动顺序）\n+- **触发**：阵营切换/单位行动完成\n+- **维护**：TeamLoopManager\n+- **备注**：在标准DND规则中，所有单位按先攻值统一排序，不存在阵营循环。此处保留作为扩展设计，便于支持阵营差异行为。\n+\n+#### 4. 单位循环（UnitLoop）\n+- **职责**：管理单个单位的行动流程\n+- **状态**：UnitState（当前单位/行动状态/行动完成）\n+- **触发**：单位行动开始/结束\n+- **维护**：UnitLoopManager\n+\n+---\n+\n+## 单位领域详细架构设计\n+\n+### 核心职责\n+\n+单位领域是战斗系统的核心，负责管理单个单位的行动流程，包括移动、技能释放、数值控制等。\n+\n+### 单位领域完整结构\n+\n+```mermaid\n+graph TB\n+    subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\n+        UnitManagement[单位管理<br/>UnitManagement]\n+        UnitLoop[单位循环<br/>UnitLoop<br/>START → ACTION → END]\n+        ActionCoordinator[行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用]\n+        \n+        subgraph UnitManagement[\"单位管理<br/>UnitManagement\"]\n+            UnitData[单位数据<br/>UnitData]\n+            DataMgr[单位数据管理<br/>属性/状态/位置]\n+            RuleMgr[单位规则管理<br/>移动点数检查/行动规则]\n+        end\n+        \n+        subgraph DataHandleQueue[\"DataHandleQueue<br/>数据队列<br/>1:1关系\"]\n+        end\n+        \n+        subgraph ActionCoordinator[\"行动协调器<br/>ActionCoordinator<br/>微核心：只负责协调调用\"]\n+            MoveCoord[移动协调<br/>调用网格系统]\n+            SkillCoord[技能协调<br/>调用技能领域]\n+            VisualCoord[表现协调<br/>通知表现层]\n+            TriCoord[技能协调<br/>调用技能领域]\n+        end\n+    end\n+    \n+    subgraph ExternalSystems[\"外部系统\"]\n+        GridSystem[网格系统<br/>GridSystem]\n+        SkillDomain[技能领域<br/>Skill Domain]\n+        VisualSystem[表现系统<br/>Visual System]\n+        TerrainDomain[地形领域<br/>Terrain Domain]\n+    end\n+    \n+    UnitManagement -->|控制| UnitLoop\n+    UnitManagement --> ActionCoordinator\n+    UnitManagement --> UnitData\n+    ActionCoordinator -->|反向推动| UnitLoop\n+    UnitLoop -->|推进| UnitManagement\n+    \n+    ActionCoordinator -->|调用| GridSystem\n+    ActionCoordinator -->|调用| SkillDomain\n+    ActionCoordinator -->|通知| VisualSystem\n+    \n+    SkillDomain -->|EffectHandler推送| DataHandleQueue\n+    TerrainDomain -->|EffectHandler推送| DataHandleQueue\n+\n+    DataHandleQueue -->|推送数据| UnitData\n+    \n+    style UnitDomain fill:#e1f5ff\n+    style UnitManagement fill:#fff4e1\n+    style UnitLoop fill:#f3e5f5\n+    style ActionCoordinator fill:#c8e6c9\n+    style DataHandleQueue fill:#f3e5f5\n+    style UnitData fill:#e1f5ff\n+```\n+\n+### 单位管理（UnitManagement）\n+\n+#### 1. 单位数据管理\n+- **单位属性**：生命值、移动点数、状态等\n+- **单位状态**：是否可行动、是否已移动、是否已攻击等\n+- **单位位置**：当前网格位置\n+\n+#### 2. 单位规则管理\n+- **移动点数规则**：移动前检查能否移动（回答1：移动前检查）\n+- **行动规则**：是否可执行行动\n+- **状态规则**：状态转换规则\n+\n+#### 3. UnitData（单位数据）\n+- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，数据直接修改 UnitData\n+- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n+- **无需中间层**：不需要\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n+\n+### 单位循环（UnitLoop）\n+\n+**循环状态**：START → ACTION → END（回答2：不需要更细的状态）\n+\n+- **START**：单位开始行动\n+- **ACTION**：执行行动（移动、技能等）\n+- **END**：单位结束行动\n+\n+### 行动协调器（ActionCoordinator）- 微核心\n+\n+**核心原则**：只负责协调调用，不包含业务规则（回答3：只负责协调调用）\n+\n+**核心职责**：\n+- ✅ **协调调用**：调用网格系统、技能领域、表现系统\n+- ✅ **反向推动循环**：执行完行动后，主动推动单位循环进入下一个状态（Domain controls Loop）\n+\n+#### 1. 移动协调\n+- **移动前检查**：调用单位管理检查移动点数\n+- **调用网格系统**：进行移动计算\n+- **移动后更新**：通过 DataHandleQueue 更新单位位置和移动点数\n+- **推动循环**：移动完成后，推动循环进入下一个状态\n+\n+#### 2. 技能协调\n+- **调用技能领域**：执行技能\n+- **不处理数值控制**：数值控制由技能领域的EffectHandler通过DataHandleQueue处理\n+- **接收技能结果**：获取技能执行结果（成功/失败），用于流程控制\n+- **推动循环**：技能执行完成后，推动循环进入下一个状态\n+\n+#### 3. 表现协调\n+- **通知表现层**：移动表现、技能表现、受攻击表现\n+- **推动循环**：表现播放完成后（可选），推动循环进入下一个状态\n+\n+#### 4. 循环推动机制\n+- **推动到END**：行动完成后，推动循环从ACTION状态进入END状态\n+- **推动到ACTION**：如果需要继续行动（还有移动点），推动循环从END状态回到ACTION状态\n+- **推动到START**：单位行动开始时，推动循环进入START状态\n+\n+### DataHandleQueue 作为单位领域内部组件\n+\n+**核心设计**：\n+- **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n+- **直接修改**：技能领域的EffectHandler推送数据到DataHandleQueue后，直接修改UnitData\n+- **无需中间层**：不需要\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n+\n+```mermaid\n+sequenceDiagram\n+    participant AC as 行动协调器\n+    participant SD as 技能领域\n+    participant EH as EffectHandler\n+    participant DHQ as DataHandleQueue<br/>单位领域内部\n+    participant UD as UnitData<br/>1:1关系\n+    \n+    AC -> SD: 调用技能领域执行技能\n+    SD -> EH: EffectHandler应用效果\n+    EH -> DHQ: PushData(效果数据, 目标单位ID)\n+    SD -> AC: 返回技能执行结果（成功/失败）\n+    DHQ -> UD: ProcessDataHandler()<br/>直接修改UnitData\n+    UD -> UD: 应用效果（扣血/加buff）\n+    UD -> UD: 更新状态\n+```\n+\n+**数据流特性**：\n+- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，属于单位领域内部\n+- ✅ **直接修改**：数据直接修改UnitData，无需经过中间层\n+- ✅ **解耦设计**：技能领域的EffectHandler负责推送数据，行动协调器不处理数值控制\n+- ✅ **批量处理**：DataHandleQueue 支持批量处理，减少调用次数\n+- ✅ **统一接口**：所有数值控制通过统一接口推送\n+- ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n+- ✅ **职责清晰**：行动协调器只负责协调调用，EffectHandler负责数值控制\n+\n+### 单位行动完整流程\n+\n+```mermaid\n+flowchart TD\n+    LoopStart[LoopStart<br/>单位管理推动循环] --> LoopAction[LoopAction<br/>执行行动]\n+    \n+    LoopAction --> CheckMove{移动前检查<br/>单位管理检查移动点数}\n+    \n+    CheckMove -->|可以移动| Move[单位移动<br/>行动协调器调用网格系统]\n+    CheckMove -->|不能移动| Skill\n+    \n+    Move --> UpdateMove[更新移动点数<br/>DataHandleQueue推送]\n+    UpdateMove --> Skill[攻击/治疗<br/>行动协调器调用技能领域]\n+    \n+    Skill --> EffectPush[EffectHandler推送效果<br/>通过DataHandleQueue到目标单位]\n+    EffectPush --> Visual[可视化<br/>行动协调器通知表现层]\n+    \n+    Visual --> PushEnd[行动协调器推动循环<br/>推动到END状态]\n+    \n+    PushEnd --> CheckMovePoint{移动点数检查<br/>单位管理检查是否还有移动点}\n+    \n+    CheckMovePoint -->|还有移动点| PushAction[行动协调器推动循环<br/>推动回ACTION状态]\n+    CheckMovePoint -->|无移动点| LoopEnd[LoopEnd<br/>单位结束行动]\n+    \n+    PushAction --> LoopAction\n+    \n+    style LoopStart fill:#e1f5ff\n+    style LoopAction fill:#e1f5ff\n+    style Move fill:#fff4e1\n+    style Skill fill:#c8e6c9\n+    style EffectPush fill:#fff4e1\n+    style Visual fill:#c8e6c9\n+    style PushEnd fill:#f3e5f5\n+    style PushAction fill:#f3e5f5\n+    style LoopEnd fill:##4b1818\n+    style CheckMove fill:#ffe0b2\n+    style CheckMovePoint fill:#ffe0b2\n+```\n+\n+**流程说明**：\n+1. **START**：单位管理推动循环进入START状态\n+2. **ACTION**：单位循环进入ACTION状态，开始执行行动\n+3. **移动前检查**：单位管理检查移动点数（能否移动）\n+4. **单位移动**：行动协调器调用网格系统进行移动\n+5. **更新移动点数**：通过 DataHandleQueue 推送移动点数变更\n+6. **攻击/治疗**：行动协调器调用技能领域执行技能\n+7. **技能执行**：技能领域的EffectHandler通过DataHandleQueue推送效果数据到目标单位\n+8. **可视化**：行动协调器通知表现层播放效果\n+9. **推动循环**：行动协调器推动循环进入END状态\n+10. **移动点数检查**：单位管理检查是否还有移动点\n+11. **循环或结束**：\n+    - 还有移动点：行动协调器推动循环回到ACTION状态，继续执行\n+    - 无移动点：行动协调器推动循环保持在END状态，结束行动\n+\n+**关键点**：\n+- ✅ **Domain controls Loop**：单位管理通过行动协调器控制循环状态转换\n+- ✅ **反向推动机制**：行动协调器执行完行动后，主动推动循环进入下一个状态\n+- ✅ **行动协调器不处理数值控制**：只负责调用技能领域，不处理效果数据推送\n+- ✅ **EffectHandler负责推送**：技能领域的EffectHandler负责通过DataHandleQueue推送效果数据\n+- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，数据直接修改 UnitData\n+- ✅ **直接修改**：不需要经过\"数值控制管理\"中间层，DataHandleQueue直接修改UnitData\n+\n+### 数值控制流程（通过 DataHandleQueue）\n+\n+```mermaid\n+flowchart LR\n+    ActionCoord[行动协调器<br/>调用技能领域] --> SkillDomain[技能领域<br/>执行技能]\n+    SkillDomain --> EffectHandler[EffectHandler<br/>应用效果]\n+    TerrainDomain[地形领域<br/>执行地形要素] --> EffectHandler[EffectHandler<br/>应用效果]\n+    EffectHandler --> ProcessQueue[DataHandleQueue]\n+    ProcessQueue --> UnitData[UnitData<br/>1:1关系<br/>推送修改]\n+    UnitData --> UpdateState[更新状态<br/>扣血/加buff]\n+    ActionCoord --> TerrainDomain\n+    ActionCoord --> 其他领域\n+    其他领域 --> EffectHandler\n+\n+    style ActionCoord fill:#c8e6c9\n+    style SkillDomain fill:#c8e6c9\n+    style EffectHandler fill:#fff4e1\n+    style ProcessQueue fill:#f3e5f5\n+    style UnitData fill:#e1f5ff\n+    style UpdateState fill:#fff4e1\n+```\n+\n+### 职责划分\n+\n+| 组件 | 职责 | 说明 |\n+|------|------|------|\n+| **行动协调器** | 协调调用 | 调用技能领域/地形领域，不处理数值控制 |\n+| **EffectHandler** | 效果推送 | 通过DataHandleQueue推送效果数据到目标单位 |\n+| **DataHandleQueue** | 数据队列 | 与UnitData是1:1关系，属于单位领域内部 |\n+| **UnitData** | 数据接收 | 通过DataHandleQueue接收并直接处理，无需中间层 |\n+\n+### 设计优势\n+\n+**架构层面**：\n+- ✅ **1:1关系**：DataHandleQueue 与 UnitData 是 1:1 关系，数据直接修改，无需中间层\n+- ✅ **职责分离**：行动协调器（协调调用）与 EffectHandler（数值控制）职责清晰\n+- ✅ **微核心设计**：行动协调器只负责协调，不包含业务规则，易于扩展\n+\n+**数据流层面**：\n+- ✅ **统一接口**：所有数值控制通过统一接口推送，易于维护\n+- ✅ **批量处理**：支持批量处理，减少调用次数\n+- ✅ **数据一致性**：通过队列处理，确保数据变更的一致性\n+\n+**系统集成**：\n+- ✅ **解耦设计**：通过 DataHandleQueue 实现模块间解耦\n+- ✅ **符合架构**：与技能系统的Handler策略模式设计一致\n+\n"
                }
            ],
            "date": 1767016974447,
            "name": "Commit-0",
            "content": "# 战斗系统架构设计\n\n## 设计目标\n\n设计一套完整的回合制战斗系统架构，支持DND规则、回合管理、状态机控制、AI决策，实现战斗流程管理、伤害计算、效果应用，提供数据驱动的配置化战斗系统。\n\n---\n\n## 核心设计理念\n\n### 1. 回合驱动为核心\n\n**本质**：战斗系统的核心是回合流程的驱动和管理\n- 战斗流程 = 回合循环驱动\n- 回合管理 = 先攻计算 → 行动轮 → 回合结束\n- 状态同步 = 回合状态在参与者间同步\n- 流程控制 = 回合流程控制战斗节奏\n\n### 2. 数据驱动架构\n\n**本质**：战斗特性通过配置数据实现，无需修改代码\n- 战斗规则、伤害计算、效果应用 → 通过配置数据定义\n- 回合流程、状态转换 → 通过配置数据调整\n- 新增战斗机制 → 扩展配置数据即可\n- 战斗平衡 → 调整配置数值即可\n\n### 3. 分层架构 + 状态机控制\n\n**本质**：分层架构实现职责分离，状态机控制实现流程管理\n- 多层架构：输入层、决策层、执行层、表现层、管理层\n- 状态机：战斗状态、回合状态、角色状态\n- 解耦设计：层间通过Context和CommunicationBus通信\n\n---\n\n## 整体架构设计\n\n### 分层架构 + 回合驱动\n\n```mermaid\ngraph TB\n    subgraph InputLayer[\"输入层<br/>InputLayer\"]\n        PlayerInput[\"玩家输入<br/>PlayerInput\"]\n        AIInput[\"AI输入<br/>AIInput\"]\n        InputValidator[\"输入验证器<br/>InputValidator\"]\n    end\n    \n    subgraph DecisionLayer[\"决策层<br/>DecisionLayer\"]\n        TurnManager[\"回合管理器<br/>TurnManager\"]\n        ActionSelector[\"行动选择器<br/>ActionSelector\"]\n        TargetSelector[\"目标选择器<br/>TargetSelector\"]\n    end\n    \n    subgraph ExecutionLayer[\"执行层<br/>ExecutionLayer\"]\n        ActionExecutor[\"行动执行器<br/>ActionExecutor\"]\n        DamageCalculator[\"伤害计算器<br/>DamageCalculator\"]\n        EffectApplier[\"效果应用器<br/>EffectApplier\"]\n    end\n    \n    subgraph PresentationLayer[\"表现层<br/>PresentationLayer\"]\n        VisualPlayer[\"视觉播放器<br/>VisualPlayer\"]\n        AudioPlayer[\"音频播放器<br/>AudioPlayer\"]\n        UIManager[\"UI管理器<br/>UIManager\"]\n    end\n    \n    subgraph ManagementLayer[\"管理层<br/>ManagementLayer\"]\n        BattleStateManager[\"战斗状态管理器<br/>BattleStateManager\"]\n        ParticipantManager[\"参与者管理器<br/>ParticipantManager\"]\n        BattleContext[\"战斗上下文<br/>BattleContext\"]\n    end\n    \n    subgraph DataLayer[\"数据层<br/>DataLayer\"]\n        BattleConfig[\"战斗配置<br/>BattleConfig\"]\n        TurnData[\"回合数据<br/>TurnData\"]\n        BattleData[\"战斗数据<br/>BattleData\"]\n    end\n    \n    InputLayer -->|BattleContext<br/>+inputData| DecisionLayer\n    DecisionLayer -->|BattleContext<br/>+decisionData| ExecutionLayer\n    ExecutionLayer -->|BattleContext<br/>+executionData| PresentationLayer\n    PresentationLayer -->|BattleContext<br/>+presentationData| ManagementLayer\n    ManagementLayer -->|状态更新| InputLayer\n    ManagementLayer -->|数据持久化| DataLayer\n    DataLayer -.数据查询.-> DecisionLayer\n    \n    style InputLayer fill:#ffebee\n    style DecisionLayer fill:#fff4e1\n    style ExecutionLayer fill:#c8e6c9\n    style PresentationLayer fill:#e1f5ff\n    style ManagementLayer fill:#f3e5f5\n    style DataLayer fill:#e8f5e9\n```\n\n---\n\n## 分层职责说明\n\n### 输入层（InputLayer）\n- **职责**：接收玩家输入和AI输入\n- **核心组件**：PlayerInput、AIInput、InputValidator\n- **输出**：BattleContext + inputData\n\n### 决策层（DecisionLayer）\n- **职责**：回合管理、行动选择、目标选择\n- **核心组件**：TurnManager、ActionSelector、TargetSelector\n- **输出**：BattleContext + decisionData\n\n### 执行层（ExecutionLayer）\n- **职责**：行动执行、伤害计算、效果应用\n- **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n- **输出**：BattleContext + executionData\n\n### 表现层（PresentationLayer）\n- **职责**：视觉表现、音频播放、UI更新\n- **核心组件**：VisualPlayer、AudioPlayer、UIManager\n- **输出**：BattleContext + presentationData\n\n### 管理层（ManagementLayer）\n- **职责**：战斗状态管理、参与者管理、Context管理\n- **核心组件**：BattleStateManager、ParticipantManager、BattleContext\n- **输出**：状态更新、数据持久化\n\n### 数据层（DataLayer）\n- **职责**：战斗配置、回合数据、战斗数据\n- **核心组件**：BattleConfig、TurnData、BattleData\n- **输出**：配置数据查询\n"
        }
    ]
}