{
    "sourceFile": "游戏编程精粹/1/4.人工智能架构设计.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1764867655799,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764867665004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-﻿# 人工智能架构设计\r\n+# 人工智能架构设计\r\n \r\n > 本文档系统梳理游戏AI开发所需的核心机制，从基础概念到高级架构，为AI系统设计提供完整指导。\r\n \r\n > **⚠️ 重要说明**：本文档主要关注**架构设计思想**，而非具体实现细节。实际开发中应该结合Unity特性和项目需求，灵活应用这些架构模式。前面的1-17个机制（事件驱动、消息、状态机等）是架构的基础组件，已在项目中实现；第18个是整体架构设计分析。\r\n"
                },
                {
                    "date": 1764867672402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-﻿# 人工智能架构设计\r\n+# 人工智能架构设计\r\n \r\n > 本文档系统梳理游戏AI开发所需的核心机制，从基础概念到高级架构，为AI系统设计提供完整指导。\r\n \r\n > **⚠️ 重要说明**：本文档主要关注**架构设计思想**，而非具体实现细节。实际开发中应该结合Unity特性和项目需求，灵活应用这些架构模式。前面的1-17个机制（事件驱动、消息、状态机等）是架构的基础组件，已在项目中实现；第18个是整体架构设计分析。\r\n"
                }
            ],
            "date": 1764867655799,
            "name": "Commit-0",
            "content": "# 人工智能架构设计\r\n\r\n> 本文档系统梳理游戏AI开发所需的核心机制，从基础概念到高级架构，为AI系统设计提供完整指导。\r\n\r\n> **⚠️ 重要说明**：本文档主要关注**架构设计思想**，而非具体实现细节。实际开发中应该结合Unity特性和项目需求，灵活应用这些架构模式。前面的1-17个机制（事件驱动、消息、状态机等）是架构的基础组件，已在项目中实现；第18个是整体架构设计分析。\r\n\r\n## 📋 与Unity/项目的对应关系\r\n\r\n| 架构组件 | Unity对应 | 项目实现 |\r\n|---------|----------|---------|\r\n| **事件驱动** | EventSystem、UnityEvent | CommunicationBus（通讯总线） |\r\n| **消息系统** | 无直接对应 | CommunicationBus（Event/Message/Push/Query） |\r\n| **状态机** | Animator（有限状态机） | FSM系统（基础/下推/并发/层次） |\r\n| **通讯层** | EventSystem | CommunicationBus |\r\n| **技术层** | NavMesh、Physics | 寻路系统、算法集合 |\r\n| **配置层** | ScriptableObject | Lua配置系统 |\r\n\r\n## 🎯 与优化策略的关联\r\n\r\n**参考**：`2/3.游戏AI优化.md` 中的11种优化策略\r\n\r\n| 优化策略 | 架构实现 |\r\n|---------|---------|\r\n| **事件驱动而非轮询** | 通讯层（CommunicationBus）实现事件驱动 |\r\n| **减少重复计算** | 技术层算法结果缓存 |\r\n| **集中协调** | 管理层统一管理 |\r\n| **分帧处理** | 状态机队列、分帧更新 |\r\n| **LOD系统** | 细节级AI（管理层控制） |\r\n\r\n---\r\n\r\n## 📋 AI系统需要构建的核心机制\r\n\r\n### 基础机制篇\r\n\r\n1. [事件驱动与轮询的对比](#1事件驱动与轮询的对比)\r\n   - 事件驱动（Event-Driven）的核心思想与应用\r\n   - 轮询（Polling）的工作原理与场景\r\n   - 两种模式的对比与混合使用建议\r\n\r\n2. [消息概念](#2消息概念)\r\n   - 消息作为事件驱动编程的核心概念\r\n   - 消息传递机制\r\n\r\n3. [状态机](#3状态机)\r\n   - 状态机的核心概念（状态、转换、事件）\r\n   - 项目中的FSM系统（基础、下推、并发、层次状态机）\r\n   - 状态机的优势与应用\r\n\r\n### 消息驱动状态机篇\r\n\r\n4. [一个使用消息的事件驱动的状态机](#4一个使用消息的事件驱动的状态机)\r\n   - 消息驱动状态转换的核心思想\r\n   - 实现方式与优势\r\n\r\n5. [交待时间](#5交待时间)\r\n   - 状态转换的过渡时间处理\r\n   - 延迟消息传递\r\n   - 状态过渡动画时间\r\n\r\n6. [另一个小交待](#6另一个小交待)\r\n   - 边界情况处理（无效状态转换、转换失败、消息丢失）\r\n\r\n### 状态机构建篇\r\n\r\n7. [状态机构建单元](#7状态机构建单元)\r\n   - 状态类（State Class）设计\r\n   - 转换规则（Transition Rules）定义\r\n   - 消息处理器（Message Handler）实现\r\n\r\n8. [状态机消息路由选择](#8状态机消息路由选择)\r\n   - 直接路由、类型路由、标签路由、范围路由\r\n   - 路由选择器实现\r\n\r\n### 消息系统篇\r\n\r\n9. [发送消息](#9发送消息)\r\n   - 基本消息发送（同步/异步）\r\n   - 消息结构定义\r\n   - 批量发送消息\r\n\r\n10. [发送延迟消息](#10发送延迟消息)\r\n    - 延迟消息实现\r\n    - 延迟消息队列管理\r\n    - 应用场景\r\n\r\n11. [定义消息范围](#11定义消息范围)\r\n    - 全局、局部、组、距离范围\r\n    - 范围定义与路由\r\n\r\n12. [记录所有消息活动和状态变迁](#12记录所有消息活动和状态变迁)\r\n    - 日志记录系统\r\n    - 状态变迁追踪\r\n    - 消息活动追踪\r\n    - 分析工具\r\n\r\n### 高级机制篇\r\n\r\n13. [交换状态机](#13交换状态机)\r\n    - 临时替换状态机\r\n    - 状态机升级/降级\r\n    - 状态机模板切换\r\n\r\n14. [多状态机](#14多状态机)\r\n    - 并发状态机（Parallel FSM）\r\n    - 分层状态管理\r\n    - 独立系统状态机\r\n    - 状态机通信\r\n\r\n15. [消息系统实现](#15消息系统实现)\r\n    - 消息系统架构\r\n    - 消息优先级\r\n    - 消息队列管理\r\n\r\n16. [一个状态机队列](#16一个状态机队列)\r\n    - 状态机队列管理器\r\n    - 更新顺序与优先级调度\r\n    - 应用场景\r\n\r\n17. [代码外部脚本化行为](#17代码外部脚本化行为)\r\n    - 配置化决策规则\r\n    - Lua脚本化行为\r\n    - 动态加载行为脚本\r\n    - 热更新支持\r\n\r\n### 架构设计篇\r\n\r\n18. [AI 分层架构设计分析](#ai-分层架构设计分析)\r\n    - 业务层（感知层、决策层、执行层、管理层）\r\n    - 全局支持层（技术层、通讯层）\r\n    - 配置层\r\n\r\n---\r\n\r\n# AI 分层架构设计分析\r\n\r\n```mermaid\r\ngraph LR\r\n    subgraph Config[\"配置层\"]\r\n        direction TB\r\n        ConfigData[\"<b>配置层</b><br/>1. 配置数据<br/>2. 配置文件<br/>3. 配置脚本\"]\r\n    end\r\n    \r\n    subgraph Business[\"业务层\"]\r\n        direction TB\r\n        Perception[\"<b>感知层</b><br/>1. 环境感知<br/>2. 感知数据处理<br/>3. 感知信息传递\"]\r\n        Decision[\"<b>决策层</b><br/>1. 决策逻辑<br/>2. 策略选择<br/>3. 行为规划\"]\r\n        Execution[\"<b>执行层</b><br/>1. 动作执行<br/>2. 状态转换<br/>3. 反馈处理\"]\r\n        Management[\"<b>管理层</b><br/>1. AI生命周期管理<br/>2. 状态管理<br/>3. 资源管理\"]\r\n    end\r\n    \r\n    subgraph Support[\"全局支持层\"]\r\n        direction TB\r\n        Technical[\"<b>技术层</b><br/>1. 算法集合<br/> 寻路、评估、搜索等\"]\r\n        Communication[\"<b>通讯层</b><br/>1. AI间通信<br/>2. 消息传递<br/>3. 事件分发\"]\r\n    end\r\n\r\n    style Config fill:#fff9c4\r\n    style Support fill:#c8e6c9\r\n    style Business fill:#e1f5ff\r\n\r\n```\r\n\r\n## 感知-决策-执行：管道-过滤器架构\r\n\r\n业务层的**感知层 → 决策层 → 执行层**采用**管道-过滤器架构模式**：\r\n\r\n```mermaid\r\ngraph LR\r\n    Env[环境数据] -->|数据输入| Perception[感知层<br/>过滤器1]\r\n    Perception -->|通过通讯层| Communication[通讯层<br/>消息总线/管道]\r\n    Communication -->|消息传递| Decision[决策层<br/>过滤器2]\r\n    Decision -->|通过通讯层| Communication\r\n    Communication -->|消息传递| Execution[执行层<br/>过滤器3]\r\n    Execution -.->|反馈循环| Env\r\n    \r\n    style Perception fill:#e1f5ff\r\n    style Decision fill:#e1f5ff\r\n    style Execution fill:#e1f5ff\r\n    style Communication fill:#c8e6c9\r\n```\r\n\r\n### 管道实现：通讯层\r\n\r\n**通讯层扮演管道的角色**，实现感知-决策-执行之间的数据传递：\r\n\r\n1. **消息总线**：通讯层作为消息总线，连接各个过滤器\r\n2. **解耦通信**：层之间通过消息传递，而非直接调用\r\n3. **事件分发**：感知层产生事件，通过通讯层分发给决策层\r\n4. **消息传递**：决策层产生决策消息，通过通讯层传递给执行层\r\n\r\n### 管道-过滤器架构特点\r\n\r\n1. **数据流处理**：数据在管道（通讯层）中流动，经过各个过滤器处理\r\n2. **过滤器独立**：每个层（感知、决策、执行）是独立的处理单元\r\n3. **管道连接**：通讯层作为管道，连接各个过滤器\r\n4. **解耦设计**：层之间通过消息传递，实现解耦\r\n5. **可组合性**：可以灵活组合不同的过滤器\r\n6. **反馈循环**：执行层可以产生反馈，影响环境数据\r\n\r\n### 数据流\r\n\r\n```\r\n环境数据 \r\n  ↓\r\n[感知层] → 感知消息 → [通讯层/管道] → 感知消息 → [决策层] → 决策消息 → [通讯层/管道] → 决策消息 → [执行层] → 动作执行 → 环境变化\r\n                                                                                                    ↓\r\n                                                                                              反馈循环\r\n```\r\n\r\n**通讯层作为管道**：\r\n- 感知层 → 通讯层：发送感知消息（环境数据、感知结果）\r\n- 通讯层 → 决策层：传递感知消息，触发决策\r\n- 决策层 → 通讯层：发送决策消息（决策结果、行为规划）\r\n- 通讯层 → 执行层：传递决策消息，触发执行\r\n\r\n### 优势\r\n\r\n- ✅ **模块化**：每个层职责单一，易于维护\r\n- ✅ **可复用**：过滤器可以在不同AI中复用\r\n- ✅ **可测试**：每个过滤器可以独立测试\r\n- ✅ **可扩展**：可以轻松添加新的过滤器（如记忆层、学习层）\r\n\r\n---\r\n\r\n## 决策层-技术层：黑板架构模式\r\n\r\n**决策层**和**技术层**之间采用**黑板架构模式（Blackboard Architecture Pattern）**：\r\n\r\n```mermaid\r\ngraph TB\r\n    Decision[决策层<br/>控制器/决策者]\r\n    Blackboard[黑板<br/>共享数据空间]\r\n    \r\n    subgraph Technical[\"技术层（知识源）\"]\r\n        Pathfinding[寻路算法<br/>知识源1]\r\n        Evaluation[评估算法<br/>知识源2]\r\n        Search[搜索算法<br/>知识源3]\r\n        Other[其他算法<br/>知识源N]\r\n    end\r\n    \r\n    Decision -->|读取/写入| Blackboard\r\n    Pathfinding -->|读取/写入| Blackboard\r\n    Evaluation -->|读取/写入| Blackboard\r\n    Search -->|读取/写入| Blackboard\r\n    Other -->|读取/写入| Blackboard\r\n    \r\n    style Decision fill:#e1f5ff\r\n    style Blackboard fill:#ffccbc\r\n    style Technical fill:#c8e6c9\r\n```\r\n\r\n### 黑板架构模式特点\r\n\r\n1. **黑板（Blackboard）**：共享数据空间，存储问题状态、中间结果、最终解\r\n2. **知识源（Knowledge Sources）**：技术层的各种算法（寻路、评估、搜索等）\r\n3. **控制器（Controller）**：决策层决定使用哪些知识源，何时调用\r\n4. **协作求解**：多个知识源通过黑板协作，逐步解决问题\r\n\r\n### 工作流程\r\n\r\n```\r\n1. 决策层将问题/需求写入黑板\r\n   ↓\r\n2. 决策层选择合适的技术层算法（知识源）\r\n   ↓\r\n3. 算法读取黑板数据，处理并写入结果\r\n   ↓\r\n4. 决策层读取黑板结果，继续决策或选择其他算法\r\n   ↓\r\n5. 重复步骤2-4，直到问题解决\r\n```\r\n\r\n### 示例\r\n\r\n**决策场景**：AI需要移动到目标位置\r\n\r\n```\r\n1. 决策层写入黑板：{目标位置: (10, 5), 当前位置: (0, 0)}\r\n   ↓\r\n2. 决策层调用：技术层.寻路算法\r\n   ↓\r\n3. 寻路算法读取黑板，计算路径，写入：{路径: [(1,1), (2,2), ...]}\r\n   ↓\r\n4. 决策层读取路径，调用：技术层.评估算法（评估路径安全性）\r\n   ↓\r\n5. 评估算法读取黑板，评估路径，写入：{路径安全: true}\r\n   ↓\r\n6. 决策层基于黑板数据做出最终决策\r\n```\r\n\r\n### 优势\r\n\r\n- ✅ **解耦**：决策层和技术层通过黑板解耦\r\n- ✅ **灵活**：可以动态选择使用哪些算法\r\n- ✅ **协作**：多个算法可以协作解决复杂问题\r\n- ✅ **可扩展**：可以轻松添加新的算法（知识源）\r\n- ✅ **可测试**：每个知识源可以独立测试\r\n\r\n---\r\n\r\n## 管理层-其他层：微核心架构模式\r\n\r\n**管理层**和其他层（感知层、决策层、执行层）之间采用**微核心架构模式（Microkernel Architecture Pattern）**：\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph Core[\"管理层（核心系统）\"]\r\n        Lifecycle[生命周期管理]\r\n        State[状态管理]\r\n        Resource[资源管理]\r\n        Registry[插件注册表]\r\n    end\r\n    \r\n    subgraph Plugins[\"业务层（插件系统）\"]\r\n        Perception[感知层<br/>插件1]\r\n        Decision[决策层<br/>插件2]\r\n        Execution[执行层<br/>插件3]\r\n    end\r\n    \r\n    Core -->|注册| Registry\r\n    Perception -->|注册到| Registry\r\n    Decision -->|注册到| Registry\r\n    Execution -->|注册到| Registry\r\n    \r\n    Core -->|管理| Perception\r\n    Core -->|管理| Decision\r\n    Core -->|管理| Execution\r\n    \r\n    Core -->|协调| Perception\r\n    Core -->|协调| Decision\r\n    Core -->|协调| Execution\r\n    \r\n    style Core fill:#ff6b6b\r\n    style Plugins fill:#e1f5ff\r\n    style Registry fill:#fff9c4\r\n```\r\n\r\n### 微核心架构模式特点\r\n\r\n1. **核心系统（管理层）**：\r\n   - 提供最小功能集：生命周期管理、状态管理、资源管理\r\n   - 插件注册表：管理所有插件的注册和发现\r\n   - 协调机制：协调插件之间的交互\r\n\r\n2. **插件系统（业务层）**：\r\n   - 感知层插件：环境感知功能\r\n   - 决策层插件：决策逻辑功能\r\n   - 执行层插件：动作执行功能\r\n\r\n3. **插件注册**：\r\n   - 插件向核心系统注册\r\n   - 核心系统管理插件的生命周期\r\n   - 插件可以动态添加、移除\r\n\r\n\r\n---\r\n\r\n## 整体架构依赖关系\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph Config[\"配置层\"]\r\n        ConfigData[配置数据/文件/脚本]\r\n    end\r\n    \r\n    subgraph Business[\"业务层\"]\r\n        Perception[感知层]\r\n        Decision[决策层]\r\n        Execution[执行层]\r\n        Management[管理层]\r\n    end\r\n    \r\n    subgraph Support[\"全局支持层\"]\r\n        Technical[技术层]\r\n        Communication[通讯层]\r\n    end\r\n    \r\n    %% 配置层依赖（所有层都依赖配置层）\r\n    ConfigData -.->|读取配置| Perception\r\n    ConfigData -.->|读取配置| Decision\r\n    ConfigData -.->|读取配置| Execution\r\n    ConfigData -.->|读取配置| Management\r\n    ConfigData -.->|读取配置| Technical\r\n    ConfigData -.->|读取配置| Communication\r\n    \r\n    %% 业务层内部依赖\r\n    Perception -->|管道/通讯层| Decision\r\n    Decision -->|管道/通讯层| Execution\r\n    Execution -.->|反馈| Perception\r\n    \r\n    %% 管理层管理其他层（微核心架构）\r\n    Management -->|管理| Perception\r\n    Management -->|管理| Decision\r\n    Management -->|管理| Execution\r\n    \r\n    %% 决策层-技术层（黑板架构）\r\n    Decision <-->|黑板| Technical\r\n    \r\n    %% 业务层依赖支持层\r\n    Perception -->|使用通讯| Communication\r\n    Decision -->|使用通讯| Communication\r\n    Execution -->|使用通讯| Communication\r\n    \r\n    style Config fill:#fff9c4\r\n    style Business fill:#e1f5ff\r\n    style Support fill:#c8e6c9\r\n```\r\n\r\n### 依赖关系说明\r\n\r\n1. **配置层 → 所有层**：\r\n   - 所有层都依赖配置层读取配置数据\r\n   - 虚线表示配置读取，非运行时依赖\r\n\r\n2. **业务层内部**：\r\n   - 感知层 → 决策层 → 执行层（管道-过滤器模式，通过通讯层）\r\n   - 执行层 → 感知层（反馈循环）\r\n\r\n3. **管理层 → 业务层**：\r\n   - 管理层管理感知层、决策层、执行层的生命周期（微核心架构）\r\n\r\n4. **决策层 ↔ 技术层**：\r\n   - 通过黑板架构模式协作\r\n\r\n5. **业务层 → 支持层**：\r\n   - 业务层使用通讯层进行消息传递\r\n   - 决策层使用技术层进行算法计算\r\n\r\n---\r\n\r\n### 工作流程\r\n\r\n```\r\n1. 系统启动\r\n   ↓\r\n2. 管理层（核心）初始化\r\n   ↓\r\n3. 感知层、决策层、执行层（插件）向管理层注册\r\n   ↓\r\n4. 管理层管理插件的生命周期（Start、Update、Stop）\r\n   ↓\r\n5. 管理层协调插件之间的交互\r\n   ↓\r\n6. 可以动态添加/移除插件（如学习层、记忆层）\r\n```\r\n\r\n### 优势\r\n\r\n- ✅ **核心稳定**：管理层提供稳定的核心功能\r\n- ✅ **插件灵活**：可以动态添加、移除、替换插件\r\n- ✅ **解耦设计**：插件之间通过管理层协调，不直接依赖\r\n- ✅ **可扩展**：可以轻松添加新功能（新插件）\r\n- ✅ **可维护**：插件可以独立开发、测试、部署\r\n- ✅ **符合开闭原则**：对扩展开放，对修改关闭\r\n\r\n### 架构模式总结\r\n\r\n架构采用了**复合型架构设计**，结合了多种架构模式：\r\n\r\n1. **分层架构**：整体结构（配置层、业务层、支持层）\r\n2. **管道-过滤器模式**：感知-决策-执行流程（通讯层作为管道）\r\n3. **黑板架构模式**：决策层-技术层协作\r\n4. **微核心架构模式**：管理层-其他层管理\r\n\r\n这是一个**成熟、灵活、可扩展**的AI架构设计！\r\n\r\n---\r\n\r\n## 开发指导原则\r\n\r\n> **架构的价值在于消灭代码、提高开发效率、指导开发思想**\r\n\r\n### 一、开发约束（什么能做，什么不能做）\r\n\r\n#### ✅ 应该做的\r\n\r\n1. **层间通信必须通过通讯层**\r\n   ```\r\n   ✅ 正确：\r\n   感知层 → 通讯层 → 决策层\r\n   决策层 → 通讯层 → 执行层\r\n   \r\n   ❌ 错误：\r\n   感知层 → 直接调用 → 决策层\r\n   ```\r\n\r\n2. **算法调用必须通过黑板**\r\n   ```\r\n   ✅ 正确：\r\n   决策层 → 写入黑板 → 技术层算法读取 → 写入结果 → 决策层读取\r\n   \r\n   ❌ 错误：\r\n   决策层 → 直接调用 → 技术层算法\r\n   ```\r\n\r\n3. **插件必须向管理层注册**\r\n   ```\r\n   ✅ 正确：\r\n   新插件 → 向管理层注册 → 管理层管理生命周期\r\n   \r\n   ❌ 错误：\r\n   新插件 → 直接创建使用\r\n   ```\r\n\r\n4. **配置必须从配置层读取**\r\n   ```\r\n   ✅ 正确：\r\n   所有层 → 从配置层读取配置\r\n   \r\n   ❌ 错误：\r\n   硬编码配置值\r\n   ```\r\n\r\n#### ❌ 不应该做的\r\n\r\n1. **禁止跨层直接调用**\r\n   - 感知层不能直接调用决策层\r\n   - 决策层不能直接调用执行层\r\n   - 各层之间必须通过通讯层通信\r\n\r\n2. **禁止直接依赖算法**\r\n   - 决策层不能直接依赖技术层的具体算法\r\n   - 必须通过黑板架构模式协作\r\n\r\n3. **禁止绕过管理层**\r\n   - 新功能不能绕过管理层直接实现\r\n   - 必须作为插件向管理层注册\r\n\r\n4. **禁止硬编码配置**\r\n   - 所有配置必须从配置层读取\r\n   - 支持配置热更新\r\n\r\n### 二、开发流程（标准化开发步骤）\r\n\r\n#### 开发新AI功能的标准流程\r\n\r\n```\r\n1. 确定功能归属\r\n   ↓\r\n   属于哪一层？（感知层/决策层/执行层）\r\n   需要哪些算法？（技术层）\r\n   需要哪些配置？（配置层）\r\n   \r\n2. 实现功能模块\r\n   ↓\r\n   如果是新层：实现插件接口，向管理层注册\r\n   如果是新算法：实现知识源接口，向黑板注册\r\n   如果是新配置：添加到配置层\r\n   \r\n3. 建立通信机制\r\n   ↓\r\n   通过通讯层发送/接收消息\r\n   通过黑板读取/写入数据\r\n   \r\n4. 测试和验证\r\n   ↓\r\n   独立测试插件/算法\r\n   集成测试通信机制\r\n   验证配置读取\r\n```\r\n\r\n#### 具体示例：开发\"记忆层\"功能\r\n\r\n```\r\n步骤1：确定归属\r\n- 属于业务层，作为新插件\r\n\r\n步骤2：实现插件\r\n- 实现IPlugin接口\r\n- 实现感知、决策、执行相关方法\r\n- 向管理层注册\r\n\r\n步骤3：建立通信\r\n- 通过通讯层接收感知消息\r\n- 通过通讯层发送记忆消息给决策层\r\n- 通过黑板存储/读取记忆数据\r\n\r\n步骤4：配置支持\r\n- 在配置层添加记忆相关配置\r\n- 支持记忆容量、遗忘速度等配置\r\n\r\n步骤5：测试验证\r\n- 测试记忆存储和读取\r\n- 测试与其他层的通信\r\n- 验证配置生效\r\n```\r\n\r\n### 三、代码规范（统一的代码组织方式）\r\n\r\n#### 1. 目录结构规范\r\n\r\n```\r\nAI系统/\r\n├── Config/              # 配置层\r\n│   ├── AIConfig.lua    # AI配置\r\n│   └── BehaviorConfig.lua  # 行为配置\r\n│\r\n├── Business/           # 业务层\r\n│   ├── Perception/      # 感知层插件\r\n│   ├── Decision/        # 决策层插件\r\n│   ├── Execution/       # 执行层插件\r\n│   └── Management/     # 管理层核心\r\n│\r\n├── Support/            # 支持层\r\n│   ├── Technical/      # 技术层（算法）\r\n│   │   ├── Pathfinding.lua\r\n│   │   ├── Evaluation.lua\r\n│   │   └── Search.lua\r\n│   └── Communication/  # 通讯层\r\n│       ├── MessageBus.lua\r\n│       └── EventDispatch.lua\r\n│\r\n└── Blackboard/         # 黑板\r\n    └── Blackboard.lua\r\n```\r\n\r\n#### 2. 接口规范\r\n\r\n**插件接口（IPlugin）**\r\n```lua\r\n-- 所有业务层插件必须实现此接口\r\nIPlugin = {\r\n    OnRegister = function(self, manager) end,  -- 注册时调用\r\n    OnStart = function(self) end,                -- 启动时调用\r\n    OnUpdate = function(self, dt) end,          -- 更新时调用\r\n    OnStop = function(self) end,                 -- 停止时调用\r\n    OnUnregister = function(self) end,          -- 注销时调用\r\n}\r\n```\r\n\r\n**知识源接口（IKnowledgeSource）**\r\n```lua\r\n-- 所有技术层算法必须实现此接口\r\nIKnowledgeSource = {\r\n    CanProcess = function(self, blackboard) end,  -- 是否可以处理\r\n    Process = function(self, blackboard) end,     -- 处理逻辑\r\n    GetPriority = function(self) end,             -- 优先级\r\n}\r\n```\r\n\r\n#### 3. 命名规范\r\n\r\n- **插件命名**：`XXXLayer`（如：`PerceptionLayer`、`DecisionLayer`）\r\n- **算法命名**：`XXXAlgorithm`（如：`PathfindingAlgorithm`、`EvaluationAlgorithm`）\r\n- **消息命名**：`EMessageType.XXX`（如：`EMessageType.PerceptionData`）\r\n- **配置命名**：`Config.XXX`（如：`Config.AIBehavior`）\r\n\r\n### 四、架构优势总结\r\n\r\n通过遵循这些开发指导原则，架构设计实现了：\r\n\r\n1. **消灭代码**：\r\n   - 通过插件机制复用代码\r\n   - 通过通讯层统一通信，避免重复实现\r\n   - 通过配置化减少硬编码\r\n\r\n2. **提高效率**：\r\n   - 清晰的开发流程，减少决策成本\r\n   - 统一的代码规范，减少理解成本\r\n   - 明确的约束规则，减少错误和返工\r\n\r\n3. **指导思想**：\r\n   - 分层架构指导代码组织\r\n   - 架构模式指导设计思路\r\n   - 开发原则指导具体实现\r\n\r\n**这就是好架构的价值：不是增加代码，而是消灭代码；不是增加复杂度，而是降低复杂度；不是增加约束，而是提供清晰的指导！**\r\n"
        }
    ]
}