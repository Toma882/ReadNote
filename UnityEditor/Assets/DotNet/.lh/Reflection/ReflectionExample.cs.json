{
    "sourceFile": "Reflection/ReflectionExample.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1762517157179,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762517242240,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -74,8 +74,9 @@\n             MethodInfoExample();\r\n             FieldInfoExample();\r\n             AttributeExample();\r\n             DynamicInvocationExample();\r\n+            AssemblyAndAppDomainComparison();\r\n             AssemblyExample();\r\n             \r\n             Debug.Log(\"=== .NET反射API示例结束 ===\");\r\n         }\r\n"
                },
                {
                    "date": 1762517269843,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -820,8 +820,204 @@\n             }\r\n         }\r\n \r\n         /// <summary>\r\n+        /// Assembly 和 AppDomain 区别说明\r\n+        /// 详细解释 Assembly（程序集）和 AppDomain（应用程序域）的概念、区别和关系\r\n+        /// \r\n+        /// 核心区别：\r\n+        /// 1. Assembly（程序集）：\r\n+        ///    - 是代码的物理容器，包含编译后的代码（IL代码、元数据、资源等）\r\n+        ///    - 是 .NET 中代码部署和版本控制的基本单位\r\n+        ///    - 一个程序集可以包含多个类型、命名空间\r\n+        ///    - 程序集是文件（.dll 或 .exe）\r\n+        /// \r\n+        /// 2. AppDomain（应用程序域）：\r\n+        ///    - 是逻辑隔离边界，用于隔离应用程序\r\n+        ///    - 一个 AppDomain 可以包含多个 Assembly\r\n+        ///    - 提供代码隔离、安全边界、独立卸载等功能\r\n+        ///    - 在 .NET Core/.NET 5+ 中，AppDomain 功能受限\r\n+        /// \r\n+        /// 关系：\r\n+        /// - AppDomain 是容器，Assembly 是内容\r\n+        /// - 一个 AppDomain 可以加载多个 Assembly\r\n+        /// - 一个 Assembly 可以被多个 AppDomain 加载（但实例独立）\r\n+        /// - AppDomain.CurrentDomain.GetAssemblies() 获取当前域中所有已加载的程序集\r\n+        /// \r\n+        /// 使用场景：\r\n+        /// - Assembly: 用于反射、类型查找、动态加载代码\r\n+        /// - AppDomain: 用于插件系统、代码隔离、热更新（在 .NET Framework 中）\r\n+        /// </summary>\r\n+        private void AssemblyAndAppDomainComparison()\r\n+        {\r\n+            Debug.Log(\"=== Assembly 和 AppDomain 区别说明 ===\");\r\n+            \r\n+            try\r\n+            {\r\n+                // ========== 基本概念对比 ==========\r\n+                \r\n+                Debug.Log(\"--- 基本概念对比 ---\");\r\n+                Debug.Log(\"Assembly（程序集）:\");\r\n+                Debug.Log(\"  - 是代码的物理容器，包含编译后的代码\");\r\n+                Debug.Log(\"  - 是 .NET 中代码部署和版本控制的基本单位\");\r\n+                Debug.Log(\"  - 一个程序集可以包含多个类型、命名空间\");\r\n+                Debug.Log(\"  - 程序集是文件（.dll 或 .exe）\");\r\n+                Debug.Log(\"  - 包含：IL代码、元数据、资源文件等\");\r\n+                \r\n+                Debug.Log(\"\");\r\n+                Debug.Log(\"AppDomain（应用程序域）:\");\r\n+                Debug.Log(\"  - 是逻辑隔离边界，用于隔离应用程序\");\r\n+                Debug.Log(\"  - 一个 AppDomain 可以包含多个 Assembly\");\r\n+                Debug.Log(\"  - 提供代码隔离、安全边界、独立卸载等功能\");\r\n+                Debug.Log(\"  - 在 .NET Core/.NET 5+ 中，AppDomain 功能受限\");\r\n+                Debug.Log(\"  - 通常一个进程只有一个 AppDomain（默认域）\");\r\n+                \r\n+                // ========== 实际示例对比 ==========\r\n+                \r\n+                Debug.Log(\"--- 实际示例对比 ---\");\r\n+                \r\n+                // 获取当前程序集\r\n+                Assembly currentAssembly = Assembly.GetExecutingAssembly();\r\n+                Debug.Log($\"当前程序集: {currentAssembly.GetName().Name}\");\r\n+                Debug.Log($\"程序集位置: {currentAssembly.Location}\");\r\n+                Debug.Log($\"程序集版本: {currentAssembly.GetName().Version}\");\r\n+                \r\n+                // 获取当前应用程序域\r\n+                AppDomain currentDomain = AppDomain.CurrentDomain;\r\n+                Debug.Log($\"当前应用程序域: {currentDomain.FriendlyName}\");\r\n+                Debug.Log($\"应用程序域ID: {currentDomain.Id}\");\r\n+                Debug.Log($\"基础目录: {currentDomain.BaseDirectory}\");\r\n+                \r\n+                // ========== 关系说明 ==========\r\n+                \r\n+                Debug.Log(\"--- 关系说明 ---\");\r\n+                Debug.Log(\"AppDomain 和 Assembly 的关系：\");\r\n+                Debug.Log(\"  1. AppDomain 是容器，Assembly 是内容\");\r\n+                Debug.Log(\"  2. 一个 AppDomain 可以加载多个 Assembly\");\r\n+                Debug.Log(\"  3. 一个 Assembly 可以被多个 AppDomain 加载（但实例独立）\");\r\n+                Debug.Log(\"  4. AppDomain.CurrentDomain.GetAssemblies() 获取当前域中所有已加载的程序集\");\r\n+                \r\n+                // 演示：一个 AppDomain 包含多个 Assembly\r\n+                Assembly[] assemblies = currentDomain.GetAssemblies();\r\n+                Debug.Log($\"当前 AppDomain 中包含的程序集数量: {assemblies.Length}\");\r\n+                Debug.Log($\"这些程序集都属于同一个 AppDomain: {currentDomain.FriendlyName}\");\r\n+                \r\n+                // ========== 功能对比 ==========\r\n+                \r\n+                Debug.Log(\"--- 功能对比 ---\");\r\n+                Debug.Log(\"Assembly 的主要功能：\");\r\n+                Debug.Log(\"  ✓ 包含类型定义和元数据\");\r\n+                Debug.Log(\"  ✓ 提供类型查找和反射功能\");\r\n+                Debug.Log(\"  ✓ 代码部署和版本控制\");\r\n+                Debug.Log(\"  ✓ 资源文件管理\");\r\n+                Debug.Log(\"  ✓ 程序集引用和依赖\");\r\n+                \r\n+                Debug.Log(\"\");\r\n+                Debug.Log(\"AppDomain 的主要功能：\");\r\n+                Debug.Log(\"  ✓ 代码隔离（不同域中的代码互不影响）\");\r\n+                Debug.Log(\"  ✓ 安全边界（可以设置不同的安全策略）\");\r\n+                Debug.Log(\"  ✓ 独立卸载（可以卸载整个域及其中的程序集）\");\r\n+                Debug.Log(\"  ✓ 配置隔离（每个域可以有独立的配置文件）\");\r\n+                Debug.Log(\"  ⚠️ 在 .NET Core/.NET 5+ 中，大部分功能受限\");\r\n+                \r\n+                // ========== 使用场景对比 ==========\r\n+                \r\n+                Debug.Log(\"--- 使用场景对比 ---\");\r\n+                Debug.Log(\"Assembly 的使用场景：\");\r\n+                Debug.Log(\"  • 反射操作：查找类型、方法、属性等\");\r\n+                Debug.Log(\"  • 动态加载：运行时加载插件或模块\");\r\n+                Debug.Log(\"  • 类型发现：扫描程序集中的所有类型\");\r\n+                Debug.Log(\"  • 元数据查询：获取类型信息、特性等\");\r\n+                Debug.Log(\"  • 程序集版本管理：检查程序集版本和依赖\");\r\n+                \r\n+                Debug.Log(\"\");\r\n+                Debug.Log(\"AppDomain 的使用场景：\");\r\n+                Debug.Log(\"  • 插件系统：隔离插件代码，防止冲突\");\r\n+                Debug.Log(\"  • 热更新：卸载旧域，加载新域（.NET Framework）\");\r\n+                Debug.Log(\"  • 安全隔离：运行不受信任的代码\");\r\n+                Debug.Log(\"  • 多版本共存：在同一进程中运行不同版本的代码\");\r\n+                Debug.Log(\"  ⚠️ 注意：.NET Core/.NET 5+ 中，AppDomain 功能受限，通常只有一个默认域\");\r\n+                \r\n+                // ========== 代码示例 ==========\r\n+                \r\n+                Debug.Log(\"--- 代码示例 ---\");\r\n+                \r\n+                // 示例1: 通过 Assembly 获取类型\r\n+                Debug.Log(\"示例1: 通过 Assembly 获取类型\");\r\n+                Type testClassType = currentAssembly.GetType(\"DotNet.Reflection.TestClass\");\r\n+                if (testClassType != null)\r\n+                {\r\n+                    Debug.Log($\"  从程序集中找到类型: {testClassType.FullName}\");\r\n+                }\r\n+                \r\n+                // 示例2: 通过 AppDomain 获取所有程序集\r\n+                Debug.Log(\"示例2: 通过 AppDomain 获取所有程序集\");\r\n+                Debug.Log($\"  当前域中的程序集数量: {assemblies.Length}\");\r\n+                Debug.Log($\"  前5个程序集:\");\r\n+                foreach (var assembly in assemblies.Take(5))\r\n+                {\r\n+                    Debug.Log($\"    - {assembly.GetName().Name}\");\r\n+                }\r\n+                \r\n+                // 示例3: 查找特定程序集\r\n+                Debug.Log(\"示例3: 在 AppDomain 中查找特定程序集\");\r\n+                Assembly foundAssembly = assemblies.FirstOrDefault(a => \r\n+                    a.GetName().Name.Contains(\"Reflection\"));\r\n+                if (foundAssembly != null)\r\n+                {\r\n+                    Debug.Log($\"  找到程序集: {foundAssembly.GetName().Name}\");\r\n+                    Debug.Log($\"  该程序集属于: {currentDomain.FriendlyName}\");\r\n+                }\r\n+                \r\n+                // ========== 重要注意事项 ==========\r\n+                \r\n+                Debug.LogWarning(\"--- 重要注意事项 ---\");\r\n+                Debug.LogWarning(\"1. .NET Core/.NET 5+ 中的变化：\");\r\n+                Debug.LogWarning(\"   - AppDomain 功能大幅受限\");\r\n+                Debug.LogWarning(\"   - 通常只有一个默认 AppDomain\");\r\n+                Debug.LogWarning(\"   - 无法创建新的 AppDomain\");\r\n+                Debug.LogWarning(\"   - 无法卸载 AppDomain\");\r\n+                Debug.LogWarning(\"   - Assembly 功能基本保持不变\");\r\n+                \r\n+                Debug.LogWarning(\"\");\r\n+                Debug.LogWarning(\"2. Unity 中的特殊情况：\");\r\n+                Debug.LogWarning(\"   - Unity 使用自己的程序集加载机制\");\r\n+                Debug.LogWarning(\"   - 程序集加载时机可能与标准 .NET 不同\");\r\n+                Debug.LogWarning(\"   - AppDomain.CurrentDomain 仍然可用，但功能受限\");\r\n+                Debug.LogWarning(\"   - 建议主要使用 Assembly 进行反射操作\");\r\n+                \r\n+                Debug.LogWarning(\"\");\r\n+                Debug.LogWarning(\"3. 性能考虑：\");\r\n+                Debug.LogWarning(\"   - AppDomain.GetAssemblies() 可能返回大量程序集\");\r\n+                Debug.LogWarning(\"   - 遍历所有程序集查找类型可能很耗时\");\r\n+                Debug.LogWarning(\"   - 建议缓存查找结果\");\r\n+                Debug.LogWarning(\"   - 优先使用 Type.GetType() 而不是遍历程序集\");\r\n+                \r\n+                // ========== 总结 ==========\r\n+                \r\n+                Debug.Log(\"--- 总结 ---\");\r\n+                Debug.Log(\"Assembly vs AppDomain:\");\r\n+                Debug.Log(\"  Assembly = 代码容器（物理）\");\r\n+                Debug.Log(\"  AppDomain = 隔离边界（逻辑）\");\r\n+                Debug.Log(\"\");\r\n+                Debug.Log(\"关系：\");\r\n+                Debug.Log(\"  AppDomain 包含多个 Assembly\");\r\n+                Debug.Log(\"  Assembly 可以被多个 AppDomain 加载\");\r\n+                Debug.Log(\"\");\r\n+                Debug.Log(\"在反射中的使用：\");\r\n+                Debug.Log(\"  - 使用 Assembly 进行类型查找和反射操作\");\r\n+                Debug.Log(\"  - 使用 AppDomain.GetAssemblies() 获取所有已加载的程序集\");\r\n+                Debug.Log(\"  - 然后遍历程序集进行类型查找\");\r\n+                \r\n+            }\r\n+            catch (Exception ex)\r\n+            {\r\n+                Debug.LogError($\"Assembly和AppDomain对比说明出错: {ex.Message}\");\r\n+                Debug.LogError($\"异常类型: {ex.GetType().Name}\");\r\n+            }\r\n+        }\r\n+\r\n+        /// <summary>\r\n         /// Assembly示例\r\n         /// 演示程序集操作和AppDomain.CurrentDomain的使用\r\n         /// \r\n         /// 主要功能：\r\n"
                }
            ],
            "date": 1762517157179,
            "name": "Commit-0",
            "content": "// ReflectionExample.cs\r\n// .NET反射API使用详解示例\r\n// 包含类型信息获取、动态方法调用、属性访问、字段操作、特性处理等\r\n// 每个方法、关键步骤、枚举值均有详细中文注释\r\n// 适合.NET初学者学习和查阅\r\n// \r\n// 主要功能模块：\r\n// 1. Type信息 - 类型元数据获取和分析\r\n// 2. Property信息 - 属性反射和动态访问\r\n// 3. Method信息 - 方法反射和动态调用\r\n// 4. Field信息 - 字段反射和动态访问\r\n// 5. Attribute处理 - 特性获取和自定义特性\r\n// 6. 动态调用 - 运行时方法调用和对象创建\r\n// 7. Assembly操作 - 程序集信息和类型加载\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing UnityEngine;\r\n\r\nnamespace DotNet.Reflection\r\n{\r\n    /// <summary>\r\n    /// .NET反射API使用详解示例\r\n    /// 包含类型信息获取、动态方法调用、属性访问、字段操作、特性处理等\r\n    /// \r\n    /// 重要说明：\r\n    /// - 反射允许在运行时检查和操作类型信息\r\n    /// - 性能考虑：反射操作比直接调用慢，应谨慎使用\r\n    /// - 安全性：反射可以访问私有成员，需要权限控制\r\n    /// - 跨平台注意：反射功能在不同平台基本一致\r\n    /// - 适用场景：插件系统、序列化、依赖注入等\r\n    /// </summary>\r\n    public class ReflectionExample : MonoBehaviour\r\n    {\r\n        [Header(\"反射示例配置\")]\r\n        [Tooltip(\"是否自动运行所有示例代码\")]\r\n        [SerializeField] private bool runExamples = true;\r\n        [Tooltip(\"是否显示详细的反射信息\")]\r\n        [SerializeField] private bool showDetailedInfo = true;\r\n        [Tooltip(\"反射操作超时时间（毫秒）\")]\r\n        [SerializeField] private int reflectionTimeoutMs = 5000;\r\n\r\n        private void Start()\r\n        {\r\n            if (runExamples)\r\n            {\r\n                RunAllExamples();\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// 运行所有反射相关示例\r\n        /// 按顺序执行：Type信息 -> Property信息 -> Method信息 -> Field信息 -> 特性处理 -> 动态调用 -> 程序集操作\r\n        /// \r\n        /// 执行流程：\r\n        /// 1. 基础类型信息获取和分析\r\n        /// 2. 属性反射和动态访问\r\n        /// 3. 方法反射和动态调用\r\n        /// 4. 字段反射和动态访问\r\n        /// 5. 特性获取和自定义特性\r\n        /// 6. 运行时动态调用\r\n        /// 7. 程序集信息和类型加载\r\n        /// </summary>\r\n        private void RunAllExamples()\r\n        {\r\n            Debug.Log(\"=== .NET反射API示例开始 ===\");\r\n            Debug.Log($\"详细信息显示: {showDetailedInfo}\");\r\n            Debug.Log($\"反射超时时间: {reflectionTimeoutMs}毫秒\");\r\n            \r\n            TypeInfoExample();\r\n            PropertyInfoExample();\r\n            MethodInfoExample();\r\n            FieldInfoExample();\r\n            AttributeExample();\r\n            DynamicInvocationExample();\r\n            AssemblyExample();\r\n            \r\n            Debug.Log(\"=== .NET反射API示例结束 ===\");\r\n        }\r\n\r\n        /// <summary>\r\n        /// Type信息示例\r\n        /// 演示如何获取和分析类型的元数据信息\r\n        /// \r\n        /// 主要功能：\r\n        /// - 获取类型基本信息（名称、命名空间、程序集）\r\n        /// - 分析类型特性（类、值类型、接口、枚举等）\r\n        /// - 获取基类和接口信息\r\n        /// - 处理泛型类型\r\n        /// - 类型比较和兼容性检查\r\n        /// \r\n        /// 注意事项：\r\n        /// - typeof()在编译时获取类型，GetType()在运行时获取\r\n        /// - 泛型类型需要区分开放类型和封闭类型\r\n        /// - 类型比较要考虑继承关系\r\n        /// </summary>\r\n        private void TypeInfoExample()\r\n        {\r\n            Debug.Log(\"--- Type信息示例 ---\");\r\n            \r\n            try\r\n            {\r\n                // ========== 获取类型信息 ==========\r\n                \r\n                // typeof操作符：编译时获取类型\r\n                // 参数说明：T - 类型参数\r\n                // 返回值：Type - 类型对象\r\n                // 注意事项：编译时确定，性能最好\r\n                Type stringType = typeof(string);\r\n                Type intType = typeof(int);\r\n                Type listType = typeof(List<>);\r\n                Type currentType = GetType();\r\n                \r\n                // GetType()方法：运行时获取类型\r\n                // 参数说明：无\r\n                // 返回值：Type - 当前对象的类型\r\n                // 注意事项：运行时确定，需要对象实例\r\n                Type runtimeStringType = \"Hello\".GetType();\r\n                \r\n                Debug.Log($\"字符串类型名称: {stringType.Name}\");\r\n                Debug.Log($\"字符串类型全名: {stringType.FullName}\");\r\n                Debug.Log($\"字符串类型命名空间: {stringType.Namespace}\");\r\n                Debug.Log($\"字符串类型程序集: {stringType.Assembly.GetName().Name}\");\r\n                Debug.Log($\"字符串类型模块: {stringType.Module.Name}\");\r\n                \r\n                // ========== 类型特性分析 ==========\r\n                \r\n                // 检查类型的基本特性\r\n                // 参数说明：无\r\n                // 返回值：bool - 是否具有指定特性\r\n                Debug.Log($\"字符串是类: {stringType.IsClass}\");\r\n                Debug.Log($\"字符串是值类型: {stringType.IsValueType}\");\r\n                Debug.Log($\"字符串是接口: {stringType.IsInterface}\");\r\n                Debug.Log($\"字符串是枚举: {stringType.IsEnum}\");\r\n                Debug.Log($\"字符串是数组: {stringType.IsArray}\");\r\n                Debug.Log($\"字符串是泛型: {stringType.IsGenericType}\");\r\n                Debug.Log($\"字符串是抽象类: {stringType.IsAbstract}\");\r\n                Debug.Log($\"字符串是密封类: {stringType.IsSealed}\");\r\n                Debug.Log($\"字符串是静态类: {stringType.IsStatic()}\");\r\n                \r\n                // ========== 基类和接口信息 ==========\r\n                \r\n                // 获取基类信息\r\n                // 参数说明：无\r\n                // 返回值：Type - 基类类型，如果没有则为null\r\n                Type baseType = currentType.BaseType;\r\n                Debug.Log($\"当前类型基类: {baseType?.Name}\");\r\n                Debug.Log($\"当前类型基类全名: {baseType?.FullName}\");\r\n                \r\n                // 获取实现的接口\r\n                // 参数说明：无\r\n                // 返回值：Type[] - 接口类型数组\r\n                Type[] interfaces = currentType.GetInterfaces();\r\n                Debug.Log($\"当前类型实现的接口数量: {interfaces.Length}\");\r\n                foreach (Type interfaceType in interfaces)\r\n                {\r\n                    Debug.Log($\"  接口: {interfaceType.Name} ({interfaceType.FullName})\");\r\n                }\r\n                \r\n                // ========== 泛型类型处理 ==========\r\n                \r\n                // 开放泛型类型（未指定类型参数）\r\n                Debug.Log($\"开放泛型列表类型: {listType.Name}\");\r\n                Debug.Log($\"开放泛型类型定义: {listType.GetGenericTypeDefinition().Name}\");\r\n                \r\n                // 封闭泛型类型（已指定类型参数）\r\n                Type genericListType = typeof(List<string>);\r\n                Debug.Log($\"封闭泛型列表类型: {genericListType.Name}\");\r\n                Debug.Log($\"封闭泛型类型定义: {genericListType.GetGenericTypeDefinition().Name}\");\r\n                \r\n                // 获取泛型参数\r\n                // 参数说明：无\r\n                // 返回值：Type[] - 泛型参数类型数组\r\n                Type[] genericArguments = genericListType.GetGenericArguments();\r\n                Debug.Log($\"泛型参数: {string.Join(\", \", genericArguments.Select(t => t.Name))}\");\r\n                \r\n                // 检查是否为泛型类型\r\n                Debug.Log($\"List<>是泛型类型: {listType.IsGenericType}\");\r\n                Debug.Log($\"List<string>是泛型类型: {genericListType.IsGenericType}\");\r\n                Debug.Log($\"List<>是泛型类型定义: {listType.IsGenericTypeDefinition}\");\r\n                Debug.Log($\"List<string>是泛型类型定义: {genericListType.IsGenericTypeDefinition}\");\r\n                \r\n                // ========== 类型比较 ==========\r\n                \r\n                // 直接类型比较\r\n                Type type1 = typeof(string);\r\n                Type type2 = \"Hello\".GetType();\r\n                Debug.Log($\"类型比较结果: {type1 == type2}\");\r\n                Debug.Log($\"类型引用相等: {ReferenceEquals(type1, type2)}\");\r\n                \r\n                // 类型兼容性检查\r\n                // 参数说明：type - 要检查的类型\r\n                // 返回值：bool - 是否兼容\r\n                Debug.Log($\"string是否可分配给object: {typeof(object).IsAssignableFrom(typeof(string))}\");\r\n                Debug.Log($\"int是否可分配给object: {typeof(object).IsAssignableFrom(typeof(int))}\");\r\n                Debug.Log($\"string是否可分配给int: {typeof(int).IsAssignableFrom(typeof(string))}\");\r\n                \r\n                // ========== 数组类型处理 ==========\r\n                \r\n                // 获取数组类型信息\r\n                Type arrayType = typeof(int[]);\r\n                Debug.Log($\"数组类型: {arrayType.Name}\");\r\n                Debug.Log($\"数组元素类型: {arrayType.GetElementType().Name}\");\r\n                Debug.Log($\"数组维度: {arrayType.GetArrayRank()}\");\r\n                \r\n                // 多维数组\r\n                Type multiArrayType = typeof(int[,]);\r\n                Debug.Log($\"多维数组类型: {multiArrayType.Name}\");\r\n                Debug.Log($\"多维数组元素类型: {multiArrayType.GetElementType().Name}\");\r\n                Debug.Log($\"多维数组维度: {multiArrayType.GetArrayRank()}\");\r\n                \r\n                // ========== 嵌套类型处理 ==========\r\n                \r\n                // 获取嵌套类型\r\n                // 参数说明：name - 嵌套类型名称, bindingAttr - 绑定标志\r\n                // 返回值：Type - 嵌套类型，如果不存在则为null\r\n                Type[] nestedTypes = currentType.GetNestedTypes(BindingFlags.Public | BindingFlags.NonPublic);\r\n                Debug.Log($\"嵌套类型数量: {nestedTypes.Length}\");\r\n                foreach (Type nestedType in nestedTypes)\r\n                {\r\n                    Debug.Log($\"  嵌套类型: {nestedType.Name} ({(nestedType.IsPublic ? \"公共\" : \"私有\")})\");\r\n                }\r\n                \r\n                // ========== 类型成员统计 ==========\r\n                \r\n                if (showDetailedInfo)\r\n                {\r\n                    // 获取所有成员信息\r\n                    MemberInfo[] members = currentType.GetMembers(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);\r\n                    Debug.Log($\"当前类型成员总数: {members.Length}\");\r\n                    \r\n                    var memberTypes = members.GroupBy(m => m.MemberType).ToDictionary(g => g.Key, g => g.Count());\r\n                    foreach (var memberType in memberTypes)\r\n                    {\r\n                        Debug.Log($\"  {memberType.Key}: {memberType.Value}个\");\r\n                    }\r\n                }\r\n                \r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogError($\"Type信息操作出错: {ex.Message}\");\r\n                Debug.LogError($\"异常类型: {ex.GetType().Name}\");\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Property信息示例\r\n        /// 演示如何通过反射获取和操作属性\r\n        /// \r\n        /// 主要功能：\r\n        /// - 获取类型的所有属性\r\n        /// - 动态读取和设置属性值\r\n        /// - 分析属性特性（可读、可写、索引器等）\r\n        /// - 处理私有和静态属性\r\n        /// - 获取属性上的特性\r\n        /// \r\n        /// 注意事项：\r\n        /// - 属性访问比字段访问慢\r\n        /// - 需要检查CanRead和CanWrite\r\n        /// - 索引器属性需要参数\r\n        /// - 静态属性不需要实例\r\n        /// </summary>\r\n        private void PropertyInfoExample()\r\n        {\r\n            Debug.Log(\"--- Property信息示例 ---\");\r\n            \r\n            try\r\n            {\r\n                // ========== 创建测试对象 ==========\r\n                \r\n                // 创建测试对象实例\r\n                var testObject = new TestClass\r\n                {\r\n                    Name = \"测试对象\",\r\n                    Age = 25,\r\n                    Email = \"test@example.com\"\r\n                };\r\n                \r\n                // 获取对象类型\r\n                Type objectType = testObject.GetType();\r\n                Debug.Log($\"测试对象类型: {objectType.Name}\");\r\n                \r\n                // ========== 获取公共属性 ==========\r\n                \r\n                // 获取所有公共实例属性\r\n                // 参数说明：bindingAttr - 绑定标志\r\n                // 返回值：PropertyInfo[] - 属性信息数组\r\n                PropertyInfo[] properties = objectType.GetProperties();\r\n                Debug.Log($\"公共属性数量: {properties.Length}\");\r\n                \r\n                foreach (PropertyInfo property in properties)\r\n                {\r\n                    Debug.Log($\"属性: {property.Name}\");\r\n                    Debug.Log($\"  类型: {property.PropertyType.Name}\");\r\n                    Debug.Log($\"  可读: {property.CanRead}, 可写: {property.CanWrite}\");\r\n                    Debug.Log($\"  声明类型: {property.DeclaringType?.Name}\");\r\n                    Debug.Log($\"  反射类型: {property.ReflectedType?.Name}\");\r\n                    \r\n                    // 获取属性值\r\n                    if (property.CanRead)\r\n                    {\r\n                        try\r\n                        {\r\n                            // GetValue: 获取属性值\r\n                            // 参数说明：obj - 对象实例, index - 索引参数（可选）\r\n                            // 返回值：object - 属性值\r\n                            object value = property.GetValue(testObject);\r\n                            Debug.Log($\"  当前值: {value ?? \"null\"}\");\r\n                        }\r\n                        catch (Exception ex)\r\n                        {\r\n                            Debug.LogWarning($\"  获取属性值失败: {ex.Message}\");\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // ========== 获取特定属性 ==========\r\n                \r\n                // 获取特定名称的属性\r\n                // 参数说明：name - 属性名称, bindingAttr - 绑定标志\r\n                // 返回值：PropertyInfo - 属性信息，如果不存在则为null\r\n                PropertyInfo nameProperty = objectType.GetProperty(\"Name\");\r\n                if (nameProperty != null)\r\n                {\r\n                    Debug.Log($\"找到Name属性: {nameProperty.PropertyType.Name}\");\r\n                    \r\n                    // 设置属性值\r\n                    if (nameProperty.CanWrite)\r\n                    {\r\n                        // SetValue: 设置属性值\r\n                        // 参数说明：obj - 对象实例, value - 新值, index - 索引参数（可选）\r\n                        // 返回值：void\r\n                        nameProperty.SetValue(testObject, \"新名称\");\r\n                        Debug.Log($\"设置后的Name值: {nameProperty.GetValue(testObject)}\");\r\n                    }\r\n                }\r\n                \r\n                // ========== 获取所有属性（包括私有） ==========\r\n                \r\n                // 使用BindingFlags获取所有属性\r\n                // BindingFlags枚举值：\r\n                // - Public: 公共成员\r\n                // - NonPublic: 非公共成员\r\n                // - Instance: 实例成员\r\n                // - Static: 静态成员\r\n                // - DeclaredOnly: 仅在声明类型中查找\r\n                PropertyInfo[] allProperties = objectType.GetProperties(\r\n                    BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);\r\n                Debug.Log($\"所有属性数量（包括私有和静态）: {allProperties.Length}\");\r\n                \r\n                foreach (PropertyInfo property in allProperties)\r\n                {\r\n                    string accessModifier = property.GetMethod?.IsPublic == true ? \"公共\" : \"私有\";\r\n                    string memberType = property.GetMethod?.IsStatic == true ? \"静态\" : \"实例\";\r\n                    Debug.Log($\"  {property.Name} ({accessModifier}{memberType})\");\r\n                }\r\n                \r\n                // ========== 属性特性处理 ==========\r\n                \r\n                // 获取属性上的特性\r\n                foreach (PropertyInfo property in properties)\r\n                {\r\n                    // GetCustomAttributes: 获取自定义特性\r\n                    // 参数说明：inherit - 是否继承, attributeType - 特性类型（可选）\r\n                    // 返回值：object[] - 特性数组\r\n                    var attributes = property.GetCustomAttributes(true);\r\n                    if (attributes.Length > 0)\r\n                    {\r\n                        Debug.Log($\"属性 {property.Name} 的特性:\");\r\n                        foreach (var attribute in attributes)\r\n                        {\r\n                            Debug.Log($\"  {attribute.GetType().Name}\");\r\n                            \r\n                            // 获取特性属性\r\n                            Type attributeType = attribute.GetType();\r\n                            PropertyInfo[] attributeProperties = attributeType.GetProperties();\r\n                            foreach (PropertyInfo attrProp in attributeProperties)\r\n                            {\r\n                                if (attrProp.CanRead)\r\n                                {\r\n                                    object attrValue = attrProp.GetValue(attribute);\r\n                                    Debug.Log($\"    {attrProp.Name}: {attrValue}\");\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // ========== 索引器属性处理 ==========\r\n                \r\n                // 检查是否有索引器属性\r\n                PropertyInfo[] indexers = objectType.GetProperties()\r\n                    .Where(p => p.GetIndexParameters().Length > 0)\r\n                    .ToArray();\r\n                \r\n                Debug.Log($\"索引器属性数量: {indexers.Length}\");\r\n                foreach (PropertyInfo indexer in indexers)\r\n                {\r\n                    Debug.Log($\"索引器: {indexer.Name}\");\r\n                    ParameterInfo[] parameters = indexer.GetIndexParameters();\r\n                    Debug.Log($\"  参数数量: {parameters.Length}\");\r\n                    foreach (ParameterInfo param in parameters)\r\n                    {\r\n                        Debug.Log($\"    参数: {param.Name} ({param.ParameterType.Name})\");\r\n                    }\r\n                }\r\n                \r\n                // ========== 静态属性处理 ==========\r\n                \r\n                // 获取静态属性\r\n                PropertyInfo[] staticProperties = objectType.GetProperties(BindingFlags.Public | BindingFlags.Static);\r\n                Debug.Log($\"静态属性数量: {staticProperties.Length}\");\r\n                \r\n                foreach (PropertyInfo staticProp in staticProperties)\r\n                {\r\n                    Debug.Log($\"静态属性: {staticProp.Name}\");\r\n                    if (staticProp.CanRead)\r\n                    {\r\n                        // 静态属性不需要实例，传入null\r\n                        object staticValue = staticProp.GetValue(null);\r\n                        Debug.Log($\"  值: {staticValue}\");\r\n                    }\r\n                }\r\n                \r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogError($\"Property信息操作出错: {ex.Message}\");\r\n                Debug.LogError($\"异常类型: {ex.GetType().Name}\");\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Method信息示例\r\n        /// 演示如何通过反射获取和分析方法信息\r\n        /// \r\n        /// 主要功能：\r\n        /// - 获取类型的所有方法\r\n        /// - 分析方法的参数和返回值\r\n        /// - 动态调用方法\r\n        /// - 处理构造函数\r\n        /// - 获取方法特性\r\n        /// \r\n        /// 注意事项：\r\n        /// - 方法调用比直接调用慢很多\r\n        /// - 需要正确处理参数类型和数量\r\n        /// - 构造函数是特殊的方法\r\n        /// - 泛型方法需要特殊处理\r\n        /// </summary>\r\n        private void MethodInfoExample()\r\n        {\r\n            Debug.Log(\"--- Method信息示例 ---\");\r\n            \r\n            try\r\n            {\r\n                // ========== 创建测试对象 ==========\r\n                \r\n                var testObject = new TestClass\r\n                {\r\n                    Name = \"方法测试对象\",\r\n                    Age = 30\r\n                };\r\n                \r\n                Type objectType = testObject.GetType();\r\n                \r\n                // ========== 获取公共方法 ==========\r\n                \r\n                // 获取所有公共方法\r\n                // 参数说明：bindingAttr - 绑定标志\r\n                // 返回值：MethodInfo[] - 方法信息数组\r\n                MethodInfo[] methods = objectType.GetMethods();\r\n                Debug.Log($\"公共方法数量: {methods.Length}\");\r\n                \r\n                foreach (MethodInfo method in methods)\r\n                {\r\n                    Debug.Log($\"方法: {method.Name}\");\r\n                    Debug.Log($\"  返回类型: {method.ReturnType.Name}\");\r\n                    Debug.Log($\"  声明类型: {method.DeclaringType?.Name}\");\r\n                    Debug.Log($\"  是静态: {method.IsStatic}\");\r\n                    Debug.Log($\"  是抽象: {method.IsAbstract}\");\r\n                    Debug.Log($\"  是虚方法: {method.IsVirtual}\");\r\n                    Debug.Log($\"  是构造函数: {method.IsConstructor}\");\r\n                    \r\n                    // 获取方法参数\r\n                    ParameterInfo[] parameters = method.GetParameters();\r\n                    Debug.Log($\"  参数数量: {parameters.Length}\");\r\n                    foreach (ParameterInfo param in parameters)\r\n                    {\r\n                        string paramInfo = $\"{param.ParameterType.Name} {param.Name}\";\r\n                        if (param.HasDefaultValue)\r\n                        {\r\n                            paramInfo += $\" = {param.DefaultValue}\";\r\n                        }\r\n                        if (param.IsOut)\r\n                        {\r\n                            paramInfo += \" [out]\";\r\n                        }\r\n                        if (param.IsIn)\r\n                        {\r\n                            paramInfo += \" [in]\";\r\n                        }\r\n                        Debug.Log($\"    参数: {paramInfo}\");\r\n                    }\r\n                }\r\n                \r\n                // ========== 获取特定方法 ==========\r\n                \r\n                // 获取特定名称的方法\r\n                // 参数说明：name - 方法名称, bindingAttr - 绑定标志, binder - 绑定器, types - 参数类型数组, modifiers - 参数修饰符\r\n                // 返回值：MethodInfo - 方法信息，如果不存在则为null\r\n                MethodInfo calculateMethod = objectType.GetMethod(\"Calculate\", new Type[] { typeof(int), typeof(int) });\r\n                if (calculateMethod != null)\r\n                {\r\n                    Debug.Log($\"找到Calculate方法: {calculateMethod.Name}\");\r\n                    \r\n                    // 动态调用方法\r\n                    // 参数说明：obj - 对象实例, parameters - 参数数组\r\n                    // 返回值：object - 方法返回值\r\n                    object result = calculateMethod.Invoke(testObject, new object[] { 10, 20 });\r\n                    Debug.Log($\"Calculate(10, 20) = {result}\");\r\n                }\r\n                \r\n                // ========== 构造函数处理 ==========\r\n                \r\n                // 获取构造函数\r\n                // 参数说明：bindingAttr - 绑定标志, binder - 绑定器, types - 参数类型数组, modifiers - 参数修饰符\r\n                // 返回值：ConstructorInfo[] - 构造函数信息数组\r\n                ConstructorInfo[] constructors = objectType.GetConstructors();\r\n                Debug.Log($\"构造函数数量: {constructors.Length}\");\r\n                \r\n                foreach (ConstructorInfo constructor in constructors)\r\n                {\r\n                    Debug.Log($\"构造函数: {constructor.Name}\");\r\n                    Debug.Log($\"  是公共: {constructor.IsPublic}\");\r\n                    Debug.Log($\"  是静态: {constructor.IsStatic}\");\r\n                    \r\n                    ParameterInfo[] ctorParams = constructor.GetParameters();\r\n                    Debug.Log($\"  参数数量: {ctorParams.Length}\");\r\n                    foreach (ParameterInfo param in ctorParams)\r\n                    {\r\n                        Debug.Log($\"    参数: {param.ParameterType.Name} {param.Name}\");\r\n                    }\r\n                }\r\n                \r\n                // 动态创建对象\r\n                ConstructorInfo parameterizedCtor = objectType.GetConstructor(new Type[] { typeof(string), typeof(int) });\r\n                if (parameterizedCtor != null)\r\n                {\r\n                    // 参数说明：parameters - 参数数组\r\n                    // 返回值：object - 创建的对象实例\r\n                    object newInstance = parameterizedCtor.Invoke(new object[] { \"动态创建的对象\", 42 });\r\n                    Debug.Log($\"动态创建的对象: {newInstance}\");\r\n                }\r\n                \r\n                // ========== 泛型方法处理 ==========\r\n                \r\n                // 检查泛型方法\r\n                MethodInfo[] genericMethods = methods.Where(m => m.IsGenericMethod).ToArray();\r\n                Debug.Log($\"泛型方法数量: {genericMethods.Length}\");\r\n                \r\n                foreach (MethodInfo genericMethod in genericMethods)\r\n                {\r\n                    Debug.Log($\"泛型方法: {genericMethod.Name}\");\r\n                    Type[] genericParams = genericMethod.GetGenericArguments();\r\n                    Debug.Log($\"  泛型参数: {string.Join(\", \", genericParams.Select(t => t.Name))}\");\r\n                }\r\n                \r\n                // ========== 方法重载处理 ==========\r\n                \r\n                // 获取重载方法\r\n                MethodInfo[] overloadedMethods = methods.Where(m => m.Name == \"Process\").ToArray();\r\n                Debug.Log($\"Process方法重载数量: {overloadedMethods.Length}\");\r\n                \r\n                foreach (MethodInfo overload in overloadedMethods)\r\n                {\r\n                    ParameterInfo[] overloadParams = overload.GetParameters();\r\n                    string paramList = string.Join(\", \", overloadParams.Select(p => p.ParameterType.Name));\r\n                    Debug.Log($\"  Process({paramList})\");\r\n                }\r\n                \r\n                // ========== 方法特性处理 ==========\r\n                \r\n                foreach (MethodInfo method in methods)\r\n                {\r\n                    var attributes = method.GetCustomAttributes(true);\r\n                    if (attributes.Length > 0)\r\n                    {\r\n                        Debug.Log($\"方法 {method.Name} 的特性:\");\r\n                        foreach (var attribute in attributes)\r\n                        {\r\n                            Debug.Log($\"  {attribute.GetType().Name}\");\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // ========== 性能测试 ==========\r\n                \r\n                if (showDetailedInfo)\r\n                {\r\n                    var stopwatch = System.Diagnostics.Stopwatch.StartNew();\r\n                    for (int i = 0; i < 1000; i++)\r\n                    {\r\n                        calculateMethod?.Invoke(testObject, new object[] { i, i + 1 });\r\n                    }\r\n                    stopwatch.Stop();\r\n                    Debug.Log($\"1000次反射方法调用耗时: {stopwatch.ElapsedMilliseconds}ms\");\r\n                    \r\n                    // 直接调用对比\r\n                    stopwatch.Restart();\r\n                    for (int i = 0; i < 1000; i++)\r\n                    {\r\n                        testObject.Calculate(i, i + 1);\r\n                    }\r\n                    stopwatch.Stop();\r\n                    Debug.Log($\"1000次直接方法调用耗时: {stopwatch.ElapsedMilliseconds}ms\");\r\n                }\r\n                \r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogError($\"Method信息操作出错: {ex.Message}\");\r\n                Debug.LogError($\"异常类型: {ex.GetType().Name}\");\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Field信息示例\r\n        /// </summary>\r\n        private void FieldInfoExample()\r\n        {\r\n            Debug.Log(\"--- Field信息示例 ---\");\r\n            \r\n            try\r\n            {\r\n                // 创建测试对象\r\n                var testObject = new TestClass\r\n                {\r\n                    Name = \"字段测试对象\"\r\n                };\r\n                \r\n                Type objectType = testObject.GetType();\r\n                \r\n                // 获取所有字段（包括私有）\r\n                FieldInfo[] allFields = objectType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);\r\n                Debug.Log($\"所有字段数量: {allFields.Length}\");\r\n                \r\n                foreach (FieldInfo field in allFields)\r\n                {\r\n                    Debug.Log($\"字段: {field.Name}, 类型: {field.FieldType.Name}\");\r\n                    Debug.Log($\"  访问修饰符: {(field.IsPublic ? \"public\" : \"private\")}\");\r\n                    Debug.Log($\"  是静态: {field.IsStatic}\");\r\n                    Debug.Log($\"  是只读: {field.IsInitOnly}\");\r\n                    \r\n                    // 获取字段值\r\n                    object value = field.GetValue(testObject);\r\n                    Debug.Log($\"  当前值: {value}\");\r\n                }\r\n                \r\n                // 获取公共字段\r\n                FieldInfo[] publicFields = objectType.GetFields();\r\n                Debug.Log($\"公共字段数量: {publicFields.Length}\");\r\n                \r\n                // 设置字段值\r\n                FieldInfo privateField = allFields.FirstOrDefault(f => f.Name == \"privateField\");\r\n                if (privateField != null)\r\n                {\r\n                    Debug.Log($\"设置私有字段 {privateField.Name} 的值\");\r\n                    privateField.SetValue(testObject, \"通过反射设置的私有字段值\");\r\n                    \r\n                    object newValue = privateField.GetValue(testObject);\r\n                    Debug.Log($\"设置后的值: {newValue}\");\r\n                }\r\n                \r\n                // 静态字段\r\n                FieldInfo[] staticFields = objectType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);\r\n                Debug.Log($\"静态字段数量: {staticFields.Length}\");\r\n                \r\n                foreach (FieldInfo field in staticFields)\r\n                {\r\n                    Debug.Log($\"静态字段: {field.Name}\");\r\n                    object value = field.GetValue(null); // 静态字段不需要实例\r\n                    Debug.Log($\"  值: {value}\");\r\n                }\r\n                \r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogError($\"Field信息操作出错: {ex.Message}\");\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// 特性示例\r\n        /// </summary>\r\n        private void AttributeExample()\r\n        {\r\n            Debug.Log(\"--- 特性示例 ---\");\r\n            \r\n            try\r\n            {\r\n                // 获取类型上的特性\r\n                Type currentType = GetType();\r\n                var typeAttributes = currentType.GetCustomAttributes(true);\r\n                Debug.Log($\"当前类型特性数量: {typeAttributes.Length}\");\r\n                \r\n                foreach (var attribute in typeAttributes)\r\n                {\r\n                    Debug.Log($\"类型特性: {attribute.GetType().Name}\");\r\n                }\r\n                \r\n                // 获取方法上的特性\r\n                MethodInfo[] methods = currentType.GetMethods();\r\n                foreach (MethodInfo method in methods)\r\n                {\r\n                    var methodAttributes = method.GetCustomAttributes(true);\r\n                    if (methodAttributes.Length > 0)\r\n                    {\r\n                        Debug.Log($\"方法 {method.Name} 的特性:\");\r\n                        foreach (var attribute in methodAttributes)\r\n                        {\r\n                            Debug.Log($\"  {attribute.GetType().Name}\");\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // 获取属性上的特性\r\n                PropertyInfo[] properties = currentType.GetProperties();\r\n                foreach (PropertyInfo property in properties)\r\n                {\r\n                    var propertyAttributes = property.GetCustomAttributes(true);\r\n                    if (propertyAttributes.Length > 0)\r\n                    {\r\n                        Debug.Log($\"属性 {property.Name} 的特性:\");\r\n                        foreach (var attribute in propertyAttributes)\r\n                        {\r\n                            Debug.Log($\"  {attribute.GetType().Name}\");\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // 检查特定特性\r\n                bool hasHeaderAttribute = currentType.GetCustomAttribute<HeaderAttribute>() != null;\r\n                Debug.Log($\"当前类型是否有Header特性: {hasHeaderAttribute}\");\r\n                \r\n                // 获取特性参数\r\n                var headerAttribute = currentType.GetCustomAttribute<HeaderAttribute>();\r\n                if (headerAttribute != null)\r\n                {\r\n                    Debug.Log($\"Header特性值: {headerAttribute.header}\");\r\n                }\r\n                \r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogError($\"特性操作出错: {ex.Message}\");\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// 动态调用示例\r\n        /// </summary>\r\n        private void DynamicInvocationExample()\r\n        {\r\n            Debug.Log(\"--- 动态调用示例 ---\");\r\n            \r\n            try\r\n            {\r\n                // 动态创建对象\r\n                Type testClassType = typeof(TestClass);\r\n                object testObject = Activator.CreateInstance(testClassType);\r\n                Debug.Log($\"动态创建的对象类型: {testObject.GetType().Name}\");\r\n                \r\n                // 动态设置属性\r\n                PropertyInfo nameProperty = testClassType.GetProperty(\"Name\");\r\n                nameProperty?.SetValue(testObject, \"动态设置的名字\");\r\n                \r\n                PropertyInfo ageProperty = testClassType.GetProperty(\"Age\");\r\n                ageProperty?.SetValue(testObject, 35);\r\n                \r\n                // 动态获取属性值\r\n                string name = (string)nameProperty?.GetValue(testObject);\r\n                int age = (int)ageProperty?.GetValue(testObject);\r\n                Debug.Log($\"动态获取的值: {name}, {age}岁\");\r\n                \r\n                // 动态调用方法\r\n                MethodInfo calculateMethod = testClassType.GetMethod(\"Calculate\");\r\n                if (calculateMethod != null)\r\n                {\r\n                    object result = calculateMethod.Invoke(testObject, new object[] { 20, 10 });\r\n                    Debug.Log($\"动态调用Calculate(20, 10)结果: {result}\");\r\n                }\r\n                \r\n                // 动态调用构造函数\r\n                ConstructorInfo[] constructors = testClassType.GetConstructors();\r\n                Debug.Log($\"构造函数数量: {constructors.Length}\");\r\n                \r\n                foreach (ConstructorInfo constructor in constructors)\r\n                {\r\n                    ParameterInfo[] parameters = constructor.GetParameters();\r\n                    string paramList = string.Join(\", \", parameters.Select(p => $\"{p.ParameterType.Name} {p.Name}\"));\r\n                    Debug.Log($\"构造函数: {paramList}\");\r\n                }\r\n                \r\n                // 调用带参数的构造函数\r\n                ConstructorInfo paramConstructor = testClassType.GetConstructor(new Type[] { typeof(string), typeof(int) });\r\n                if (paramConstructor != null)\r\n                {\r\n                    object paramObject = paramConstructor.Invoke(new object[] { \"构造函数参数\", 42 });\r\n                    Debug.Log($\"通过构造函数创建的对象: {paramObject}\");\r\n                }\r\n                \r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogError($\"动态调用操作出错: {ex.Message}\");\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// Assembly示例\r\n        /// 演示程序集操作和AppDomain.CurrentDomain的使用\r\n        /// \r\n        /// 主要功能：\r\n        /// - 获取当前程序集信息\r\n        /// - 使用AppDomain.CurrentDomain获取所有已加载的程序集\r\n        /// - 遍历程序集查找类型\r\n        /// - 程序集信息查询和分析\r\n        /// - 动态加载程序集\r\n        /// \r\n        /// 注意事项：\r\n        /// - AppDomain.CurrentDomain.GetAssemblies() 返回所有已加载的程序集\r\n        /// - 遍历所有程序集可能很耗时，建议缓存结果\r\n        /// - 某些程序集可能无法完全加载，需要处理异常\r\n        /// - 在Unity中，程序集加载时机可能与.NET标准不同\r\n        /// </summary>\r\n        private void AssemblyExample()\r\n        {\r\n            Debug.Log(\"--- Assembly示例 ---\");\r\n            \r\n            try\r\n            {\r\n                // ========== 获取当前程序集 ==========\r\n                \r\n                // Assembly.GetExecutingAssembly(): 获取当前正在执行的程序集\r\n                // 参数说明：无\r\n                // 返回值：Assembly - 当前程序集对象\r\n                // 注意事项：返回包含当前代码的程序集\r\n                Assembly currentAssembly = Assembly.GetExecutingAssembly();\r\n                Debug.Log($\"当前程序集名称: {currentAssembly.GetName().Name}\");\r\n                Debug.Log($\"当前程序集版本: {currentAssembly.GetName().Version}\");\r\n                Debug.Log($\"当前程序集位置: {currentAssembly.Location}\");\r\n                Debug.Log($\"当前程序集是否动态: {currentAssembly.IsDynamic}\");\r\n                \r\n                // 获取程序集中的所有类型\r\n                // GetTypes(): 获取程序集中定义的所有类型\r\n                // 参数说明：无\r\n                // 返回值：Type[] - 类型数组\r\n                // 注意事项：可能抛出ReflectionTypeLoadException\r\n                Type[] types = currentAssembly.GetTypes();\r\n                Debug.Log($\"程序集中的类型数量: {types.Length}\");\r\n                \r\n                // 查找特定类型\r\n                // GetType(string name): 根据完整类型名查找类型\r\n                // 参数说明：name - 类型的完整名称（包括命名空间）\r\n                // 返回值：Type - 类型对象，如果不存在则为null\r\n                Type testClassType = currentAssembly.GetType(\"DotNet.Reflection.TestClass\");\r\n                if (testClassType != null)\r\n                {\r\n                    Debug.Log($\"找到TestClass类型: {testClassType.FullName}\");\r\n                }\r\n                \r\n                // ========== AppDomain.CurrentDomain 使用 ==========\r\n                \r\n                // AppDomain.CurrentDomain: 获取当前应用程序域\r\n                // 参数说明：无\r\n                // 返回值：AppDomain - 当前应用程序域对象\r\n                // 注意事项：应用程序域是.NET中应用程序的隔离边界\r\n                AppDomain currentDomain = AppDomain.CurrentDomain;\r\n                Debug.Log($\"当前应用程序域名称: {currentDomain.FriendlyName}\");\r\n                Debug.Log($\"应用程序域ID: {currentDomain.Id}\");\r\n                Debug.Log($\"基础目录: {currentDomain.BaseDirectory}\");\r\n                \r\n                // GetAssemblies(): 获取当前应用程序域中所有已加载的程序集\r\n                // 参数说明：无\r\n                // 返回值：Assembly[] - 程序集数组\r\n                // 注意事项：\r\n                // - 这是反射操作中最常用的方法之一\r\n                // - 返回所有已加载的程序集，数量可能很大\r\n                // - 遍历所有程序集可能很耗时，建议缓存结果\r\n                // - 用于查找类型、方法等反射操作\r\n                Assembly[] assemblies = currentDomain.GetAssemblies();\r\n                Debug.Log($\"当前域中的程序集数量: {assemblies.Length}\");\r\n                \r\n                // ========== 程序集信息查询 ==========\r\n                \r\n                if (showDetailedInfo)\r\n                {\r\n                    // 显示前10个程序集详细信息\r\n                    Debug.Log(\"--- 前10个程序集详细信息 ---\");\r\n                    for (int i = 0; i < Math.Min(10, assemblies.Length); i++)\r\n                    {\r\n                        Assembly assembly = assemblies[i];\r\n                        AssemblyName assemblyName = assembly.GetName();\r\n                        Debug.Log($\"程序集 {i + 1}: {assemblyName.Name}\");\r\n                        Debug.Log($\"  完整名称: {assembly.FullName}\");\r\n                        Debug.Log($\"  版本: {assemblyName.Version}\");\r\n                        Debug.Log($\"  位置: {assembly.Location}\");\r\n                        Debug.Log($\"  是否动态: {assembly.IsDynamic}\");\r\n                    }\r\n                }\r\n                \r\n                // ========== 按名称查找程序集 ==========\r\n                \r\n                // 查找Unity相关程序集\r\n                Assembly[] unityAssemblies = assemblies.Where(a => \r\n                    a.GetName().Name.Contains(\"UnityEngine\") || \r\n                    a.GetName().Name.Contains(\"Unity\")).ToArray();\r\n                Debug.Log($\"Unity相关程序集数量: {unityAssemblies.Length}\");\r\n                \r\n                foreach (var unityAssembly in unityAssemblies.Take(5))\r\n                {\r\n                    Debug.Log($\"  - {unityAssembly.GetName().Name}\");\r\n                }\r\n                \r\n                // ========== 从所有程序集中查找类型 ==========\r\n                \r\n                Debug.Log(\"--- 从所有程序集中查找类型 ---\");\r\n                \r\n                // 方法1: 遍历所有程序集查找类型\r\n                string targetTypeName = \"System.String\";\r\n                Type foundType = null;\r\n                \r\n                foreach (Assembly assembly in assemblies)\r\n                {\r\n                    try\r\n                    {\r\n                        foundType = assembly.GetType(targetTypeName);\r\n                        if (foundType != null)\r\n                        {\r\n                            Debug.Log($\"找到类型 {targetTypeName} 在程序集: {assembly.GetName().Name}\");\r\n                            break;\r\n                        }\r\n                    }\r\n                    catch (ReflectionTypeLoadException ex)\r\n                    {\r\n                        // 某些程序集可能无法完全加载，只检查已加载的类型\r\n                        if (ex.Types != null)\r\n                        {\r\n                            foreach (var type in ex.Types)\r\n                            {\r\n                                if (type != null && type.FullName == targetTypeName)\r\n                                {\r\n                                    foundType = type;\r\n                                    Debug.Log($\"找到类型 {targetTypeName} 在程序集: {assembly.GetName().Name} (部分加载)\");\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    catch\r\n                    {\r\n                        // 忽略其他错误\r\n                    }\r\n                }\r\n                \r\n                // 方法2: 使用 Type.GetType (更高效)\r\n                Type stringType = Type.GetType(targetTypeName);\r\n                if (stringType != null)\r\n                {\r\n                    Debug.Log($\"Type.GetType 找到类型: {stringType.Name}\");\r\n                }\r\n                \r\n                // ========== 查找命名空间下的所有类型 ==========\r\n                \r\n                Debug.Log(\"--- 查找命名空间下的类型 ---\");\r\n                string targetNamespace = \"UnityEngine\";\r\n                int typeCount = 0;\r\n                \r\n                foreach (Assembly assembly in assemblies)\r\n                {\r\n                    try\r\n                    {\r\n                        Type[] assemblyTypes = assembly.GetTypes();\r\n                        var namespaceTypes = assemblyTypes.Where(t => \r\n                            t != null &&\r\n                            t.Namespace == targetNamespace && \r\n                            t.IsPublic && \r\n                            !t.IsAbstract).Take(10);\r\n                        \r\n                        foreach (var type in namespaceTypes)\r\n                        {\r\n                            Debug.Log($\"  {targetNamespace}.{type.Name}\");\r\n                            typeCount++;\r\n                        }\r\n                    }\r\n                    catch (ReflectionTypeLoadException ex)\r\n                    {\r\n                        // 某些程序集可能无法完全加载，只加载可用的类型\r\n                        if (ex.Types != null)\r\n                        {\r\n                            foreach (var type in ex.Types.Where(t => t != null && t.Namespace == targetNamespace).Take(10))\r\n                            {\r\n                                Debug.Log($\"  {targetNamespace}.{type.Name}\");\r\n                                typeCount++;\r\n                            }\r\n                        }\r\n                    }\r\n                    catch\r\n                    {\r\n                        // 忽略其他错误\r\n                    }\r\n                }\r\n                Debug.Log($\"找到 {targetNamespace} 命名空间下的类型数量: {typeCount}\");\r\n                \r\n                // ========== 查找实现特定接口或继承特定基类的类型 ==========\r\n                \r\n                Debug.Log(\"--- 查找继承特定基类的类型 ---\");\r\n                Type componentBaseType = typeof(Component);\r\n                int componentTypeCount = 0;\r\n                \r\n                foreach (Assembly assembly in assemblies)\r\n                {\r\n                    try\r\n                    {\r\n                        Type[] assemblyTypes = assembly.GetTypes();\r\n                        var componentTypes = assemblyTypes.Where(t => \r\n                            t != null &&\r\n                            componentBaseType.IsAssignableFrom(t) && \r\n                            !t.IsAbstract && \r\n                            t.IsClass).Take(5);\r\n                        \r\n                        foreach (var type in componentTypes)\r\n                        {\r\n                            Debug.Log($\"  继承Component的类型: {type.Name}\");\r\n                            componentTypeCount++;\r\n                        }\r\n                    }\r\n                    catch (ReflectionTypeLoadException)\r\n                    {\r\n                        // 忽略部分加载的程序集\r\n                    }\r\n                    catch\r\n                    {\r\n                        // 忽略其他错误\r\n                    }\r\n                }\r\n                Debug.Log($\"找到继承Component的类型总数: {componentTypeCount}\");\r\n                \r\n                // ========== 程序集依赖关系 ==========\r\n                \r\n                Debug.Log(\"--- 程序集引用关系 ---\");\r\n                AssemblyName[] referencedAssemblies = currentAssembly.GetReferencedAssemblies();\r\n                Debug.Log($\"当前程序集引用的程序集数量: {referencedAssemblies.Length}\");\r\n                \r\n                foreach (var refAssembly in referencedAssemblies.Take(5))\r\n                {\r\n                    Debug.Log($\"  引用: {refAssembly.Name} v{refAssembly.Version}\");\r\n                }\r\n                \r\n                // ========== 查找包含特定类型的程序集 ==========\r\n                \r\n                Debug.Log(\"--- 查找包含特定类型的程序集 ---\");\r\n                string searchTypeName = \"String\";\r\n                \r\n                foreach (Assembly assembly in assemblies)\r\n                {\r\n                    try\r\n                    {\r\n                        Type[] assemblyTypes = assembly.GetTypes();\r\n                        if (assemblyTypes.Any(t => t != null && t.Name == searchTypeName))\r\n                        {\r\n                            Debug.Log($\"包含{searchTypeName}类型的程序集: {assembly.GetName().Name}\");\r\n                            break;\r\n                        }\r\n                    }\r\n                    catch (ReflectionTypeLoadException ex)\r\n                    {\r\n                        // 检查部分加载的类型\r\n                        if (ex.Types != null && ex.Types.Any(t => t != null && t.Name == searchTypeName))\r\n                        {\r\n                            Debug.Log($\"包含{searchTypeName}类型的程序集: {assembly.GetName().Name} (部分加载)\");\r\n                            break;\r\n                        }\r\n                    }\r\n                    catch\r\n                    {\r\n                        // 忽略错误\r\n                    }\r\n                }\r\n                \r\n                // ========== 程序集特性查询 ==========\r\n                \r\n                Debug.Log(\"--- 程序集特性查询 ---\");\r\n                object[] attributes = currentAssembly.GetCustomAttributes(false);\r\n                Debug.Log($\"当前程序集的自定义特性数量: {attributes.Length}\");\r\n                \r\n                foreach (var attr in attributes.Take(5))\r\n                {\r\n                    Debug.Log($\"  特性: {attr.GetType().Name}\");\r\n                }\r\n                \r\n                // ========== 动态加载程序集 ==========\r\n                \r\n                Debug.Log(\"--- 动态加载程序集 ---\");\r\n                // 注意：在Unity中，程序集加载时机可能与.NET标准不同\r\n                // Unity通常会自动加载所有程序集，所以很少需要手动加载\r\n                \r\n                try\r\n                {\r\n                    // Assembly.Load(string assemblyString): 根据程序集名称加载\r\n                    // 参数说明：assemblyString - 程序集的显示名称\r\n                    // 返回值：Assembly - 加载的程序集\r\n                    // 注意事项：如果程序集已加载，返回已加载的实例\r\n                    Assembly loadedAssembly = Assembly.Load(\"System.Core\");\r\n                    Debug.Log($\"动态加载的程序集: {loadedAssembly.GetName().Name}\");\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    Debug.Log($\"动态加载程序集失败: {ex.Message}\");\r\n                }\r\n                \r\n                // ========== 实用示例：查找所有MonoBehaviour子类 ==========\r\n                \r\n                if (showDetailedInfo)\r\n                {\r\n                    Debug.Log(\"--- 实用示例：查找MonoBehaviour子类 ---\");\r\n                    Type monoBehaviourType = typeof(MonoBehaviour);\r\n                    List<string> monoBehaviourTypes = new List<string>();\r\n                    \r\n                    foreach (Assembly assembly in assemblies)\r\n                    {\r\n                        try\r\n                        {\r\n                            Type[] assemblyTypes = assembly.GetTypes();\r\n                            var mbTypes = assemblyTypes.Where(t => \r\n                                t != null &&\r\n                                monoBehaviourType.IsAssignableFrom(t) && \r\n                                t.IsClass && \r\n                                !t.IsAbstract &&\r\n                                t != monoBehaviourType);\r\n                            \r\n                            foreach (var type in mbTypes.Take(5))\r\n                            {\r\n                                monoBehaviourTypes.Add($\"{type.Namespace}.{type.Name}\");\r\n                            }\r\n                        }\r\n                        catch\r\n                        {\r\n                            // 忽略错误\r\n                        }\r\n                    }\r\n                    \r\n                    Debug.Log($\"找到MonoBehaviour子类数量: {monoBehaviourTypes.Count}\");\r\n                    foreach (var typeName in monoBehaviourTypes.Take(10))\r\n                    {\r\n                        Debug.Log($\"  - {typeName}\");\r\n                    }\r\n                }\r\n                \r\n                // ========== 性能考虑和最佳实践 ==========\r\n                \r\n                Debug.LogWarning(\"⚠️ AppDomain.CurrentDomain.GetAssemblies() 使用注意事项：\");\r\n                Debug.LogWarning(\"1. GetAssemblies() 返回所有已加载的程序集，数量可能很大\");\r\n                Debug.LogWarning(\"2. 遍历所有程序集和类型可能很耗时，建议缓存结果\");\r\n                Debug.LogWarning(\"3. 某些程序集可能无法完全加载，需要处理 ReflectionTypeLoadException\");\r\n                Debug.LogWarning(\"4. 在Unity中，程序集加载时机可能与.NET标准不同\");\r\n                Debug.LogWarning(\"5. 使用 Type.GetType() 通常比遍历程序集更高效\");\r\n                Debug.LogWarning(\"6. 考虑使用字典缓存类型查找结果以提高性能\");\r\n                \r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Debug.LogError($\"Assembly操作出错: {ex.Message}\");\r\n                Debug.LogError($\"异常类型: {ex.GetType().Name}\");\r\n                Debug.LogError($\"堆栈跟踪: {ex.StackTrace}\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 测试类\r\n    /// </summary>\r\n    [Serializable]\r\n    public class TestClass\r\n    {\r\n        [Header(\"测试属性\")]\r\n        public string Name { get; set; }\r\n        \r\n        [Range(0, 100)]\r\n        public int Age { get; set; }\r\n        \r\n        public string Email { get; set; }\r\n        \r\n        private string privateField = \"私有字段\";\r\n        \r\n        public static string staticField = \"静态字段\";\r\n        \r\n        public TestClass()\r\n        {\r\n            Debug.Log(\"TestClass默认构造函数被调用\");\r\n        }\r\n        \r\n        public TestClass(string name, int age)\r\n        {\r\n            Name = name;\r\n            Age = age;\r\n            Debug.Log($\"TestClass带参数构造函数被调用: {name}, {age}\");\r\n        }\r\n        \r\n        public int Calculate(int a, int b)\r\n        {\r\n            Debug.Log($\"Calculate方法被调用: {a} + {b}\");\r\n            return a + b;\r\n        }\r\n        \r\n        public void Process()\r\n        {\r\n            Debug.Log(\"Process方法被调用（无参数）\");\r\n        }\r\n        \r\n        public void Process(string message)\r\n        {\r\n            Debug.Log($\"Process方法被调用（有参数）: {message}\");\r\n        }\r\n        \r\n        public override string ToString()\r\n        {\r\n            return $\"TestClass: {Name}, {Age}岁\";\r\n        }\r\n    }\r\n} "
        }
    ]
}