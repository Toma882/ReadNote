# 🎯 Lua设计模式库 - 完整指南

## 📋 概述

这是一个功能完整的Lua设计模式库，涵盖了从基础到高级的各种设计模式实现。每个模式都经过精心设计，确保易用性、可扩展性和高性能。

**🎯 设计理念：** 将复杂的设计模式封装成简单易用的工具，让开发者专注于业务逻辑，而不是架构细节。

---

## 🏗️ 架构分类

### 核心模式分类
```
Pattern Library (设计模式库)
├── Creational (创建型模式) - 对象创建的艺术
│   ├── Singleton (单例模式) - 唯一的范围接口，不能继承，无法限制作用域
│   ├── Factory (工厂模式) - 对象的创建工厂，可以根据条件创建不同类型的对象(策略工厂)
│   ├── AbstractFactory (抽象工厂模式) - 创建一系列相关对象，确保它们相互兼容
│   ├── Builder (建造者模式) - 分层分步骤构建复杂对象，避免构造函数参数过多导致难以维护
│   └── Prototype (原型模式) - 通过克隆现有对象来创建新对象，减少初始化开销避免。重复赋值
├── Structural (结构型模式) - 对象组合的艺术
│   ├── Adapter (适配器模式) - 在构建项目时，为了让其他模块可以使用开发时的系统，抽象出公共接口的类来适配不同的环境/模块
│   ├── Bridge (桥接模式) - 通过反向依赖（依赖注入），让同一个抽象类可以使用不同的实现，从而产生不同的表达结果
│   ├── Composite (组合模式) - 利用里氏替换原则，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理
│   ├── Decorator (装饰器模式) - 使用数据驱动模式加执行字典迭代效果，比装饰器更加灵活，动态增强功能而不修改原对象
│   ├── Facade (外观模式) - 对外提供一个统一的接口，隐藏内部的复杂实现，简化客户端使用
│   ├── Flyweight (享元模式) - 享元工厂缓存相同依赖的对象，请求时检查缓存，存在则复用，不存在则创建并缓存，多个客户端共享同一对象减少内存占用。
│   └── Proxy (代理模式) - 可用钩子方法+策略模式替代，避免代理模式滥用
├── Behavioral (行为型模式) - 对象交互的艺术
│   ├── ChainOfResponsibility (责任链模式) - 链式请求处理，每个节点可以决定是否处理请求，或者将请求传递给下一个节点
│   ├── Command (命令模式) - 将请求封装成对象(指令类)，使得指令类可以传递，存储，重做，撤销等操作
│   ├── Interpreter (解释器模式) - 使用组合模式+策略模式，将复杂表达式分解为简单表达式，每个表达式可以独立计算，最终组合成复杂表达式。（公式计算，表达式解析，脚本系统，虚拟机等）
│   ├── Iterator (迭代器模式) - 使用组合模式+策略模式，将复杂对象拆分为多个可递归节点组件，实现统一生命周期管理
│   ├── Mediator (中介者模式) - 微内核架构思维，让多个对象之间通过中介者进行交互，而不是直接交互，减少对象间的直接依赖，提高系统的灵活性和可维护性。
│   ├── Memento (备忘录模式) - 监控对象状态，当对象状态发生变化时，备忘录模式可以记录对象的当前状态，并在需要时恢复到该状态。
│   ├── Observer (观察者模式) - 事件分发系统是其运用
│   ├── State (状态模式) - 关注状态变化后, 但是状态机可以兼顾切换时机和状态变化后处理。
│   ├── Strategy (策略模式) - 解决一类问题的不同解决方案，可通过变量选择不同的策略来解决问题。
│   ├── TemplateMethod (模板方法模式) - 稳定的执行流，通过钩子方法来实现灵活的扩展。
│   └── Visitor (访问者模式) - 可用策略模式+表驱动模式替代, 其原生原理实现及其复杂且不易理解，不推荐使用。
└── Advanced (高级模式) - 游戏开发专用模式
    ├── Component (组件模式)  - Unity 的 GameObject 组件系统是其最好的理解了
    ├── EventDriven (事件驱动模式) - 事件分发系统是其运用，但是有更高维度的方案 通讯总线
    ├── StateMachine (状态机模式) - 关注控制状态切换时机，具有流动性，可传递性，可组合性。
    ├── ServiceLocator (服务定位器模式) - 服务定位器模式是一种服务注册和获取的解决方案，通过服务定位器模式，可以实现服务的高效注册和获取，避免服务注册和获取的重复代码。
    ├── ObjectPool (对象池模式) - 减少创建对象，减少内存碎片 与 避免GC。
    ├── DataDriven (数据驱动模式) - 通过数据驱动业务逻辑，避免硬编码。
    ├── ReactiveProgramming (响应式编程模式) 
    ├── DependencyInjection (依赖注入模式) 
    ├── DirtyFlag (脏标记模式) - 通过标记避免不必要的计算。
    ├── DoubleBuffer (双缓冲模式) - 使用两个缓冲区避免渲染冲突。
    ├── DataLocality (数据局部性模式) - 通过组织数据布局提高缓存效率。
    └── Bytecode (字节码模式) - 创建一套"翻译字典"（OPCODES），将高级语言翻译成字典中的操作，然后执行。编译器负责翻译，虚拟机负责查字典执行
```

---

## 🏭 创建型模式 (Creational Patterns)

### 🔒 **单例模式 (Singleton)**
**用途：** 确保一个类只有一个实例，并提供全局访问点
**作用：** 
- 游戏管理器
- 配置管理器
- 资源管理器
- 日志系统

**适用场景：**
- 需要全局唯一实例
- 资源管理
- 配置管理

```lua
local singleton = SingletonPattern.New()
local instance1 = singleton:GetInstance()
local instance2 = singleton:GetInstance()
print(instance1 == instance2)  -- true，同一个实例
```

### 🏭 **工厂模式 (Factory)**
**用途：** 根据条件创建不同类型的对象
**作用：**
- 游戏对象创建
- 武器系统
- 敌人生成
- 道具创建

**适用场景：**
- 需要根据条件创建对象
- 对象创建逻辑复杂
- 支持扩展新类型

```lua
local factory = FactoryPattern.New()
local weapon = factory:CreateWeapon("sword")
local enemy = factory:CreateEnemy("goblin")
```

### 🏭🏭 **抽象工厂模式 (AbstractFactory)**
**用途：** 创建一系列相关对象，确保它们相互兼容
**作用：**
- 游戏主题系统
- UI风格系统
- 关卡风格
- 种族系统

**适用场景：**
- 需要创建相关对象族
- 确保对象兼容性
- 支持多种风格

```lua
local factory = AbstractFactoryPattern.New()
local medievalFactory = factory:CreateFactory("medieval")
local sword = medievalFactory:CreateWeapon()
local armor = medievalFactory:CreateArmor()
```

### 🏗️ **建造者模式 (Builder)**
**用途：** 分步骤构建复杂对象
**作用：**
- 角色创建
- 关卡构建
- 配置构建
- 复杂对象组装

**适用场景：**
- 对象构建过程复杂
- 需要分步骤构建
- 支持不同构建方式

```lua
local builder = BuilderPattern.New()
local character = builder:SetName("英雄")
    :SetClass("战士")
    :SetLevel(10)
    :SetEquipment("铁剑")
    :Build()
```

### 🧬 **原型模式 (Prototype)**
**用途：** 通过克隆现有对象来创建新对象
**作用：**
- 对象复制
- 模板系统
- 快速创建
- 减少初始化开销

**适用场景：**
- 对象创建开销大
- 需要对象副本
- 模板系统

```lua
local prototype = PrototypePattern.New()
local original = prototype:Create("template")
local clone = original:Clone()
```

---

## 🏗️ 结构型模式 (Structural Patterns)

### 🔌 **适配器模式 (Adapter)**
**用途：** 让不兼容的接口能够协同工作
**作用：**
- 第三方库集成
- 旧系统适配
- 接口统一
- 兼容性处理

**适用场景：**
- 集成第三方库
- 系统升级兼容
- 接口不匹配

```lua
local adapter = AdapterPattern.New()
local newInterface = adapter:Adapt(oldSystem)
newInterface:NewMethod()
```

### 🌉 **桥接模式 (Bridge)**
**用途：** 将抽象与实现分离，使它们可以独立变化
**作用：**
- 平台抽象
- 渲染器抽象
- 数据库抽象
- 网络抽象

**适用场景：**
- 需要支持多平台
- 抽象与实现分离
- 避免继承爆炸

```lua
local bridge = BridgePattern.New()
local renderer = bridge:CreateRenderer("OpenGL")
local shape = bridge:CreateShape("Circle", renderer)
```

### 🧩 **组合模式 (Composite)**
**用途：** 将对象组合成树形结构，统一处理单个对象和组合对象
**作用：**
- 场景图系统
- UI组件树
- 文件系统
- 游戏对象层次

**适用场景：**
- 树形结构
- 部分-整体关系
- 统一处理接口

```lua
local composite = CompositePattern.New()
local root = composite:CreateComponent("root")
local child1 = composite:CreateComponent("child1")
root:Add(child1)
root:Operation()  -- 递归调用所有子组件
```

### 🎨 **装饰器模式 (Decorator)**
**用途：** 动态地给对象添加新功能
**作用：**
- 装备系统
- 技能增强
- 状态效果
- 功能扩展

**适用场景：**
- 需要动态添加功能
- 避免继承爆炸
- 功能组合

```lua
local decorator = DecoratorPattern.New()
local baseWeapon = decorator:CreateWeapon("剑")
local fireWeapon = decorator:AddFireEffect(baseWeapon)
local iceWeapon = decorator:AddIceEffect(fireWeapon)
```

### 🏛️ **外观模式 (Facade)**
**用途：** 为复杂子系统提供简单接口
**作用：**
- 系统封装
- 简化接口
- 降低耦合
- 统一入口

**适用场景：**
- 复杂系统封装
- 简化客户端使用
- 降低系统耦合

```lua
local facade = FacadePattern.New()
-- 复杂的子系统操作被封装成简单接口
facade:StartGame()
facade:SaveGame()
facade:LoadGame()
```

### 🦋 **享元模式 (Flyweight)**
**用途：** 通过共享减少内存使用
**作用：**
- 纹理共享
- 模型共享
- 配置共享
- 资源优化

**适用场景：**
- 大量相似对象
- 内存优化
- 资源共享

```lua
local flyweight = FlyweightPattern.New()
local texture1 = flyweight:GetTexture("grass")
local texture2 = flyweight:GetTexture("grass")  -- 共享同一个纹理
```

### 🎭 **代理模式 (Proxy)**
**用途：** 控制对其他对象的访问
**作用：**
- 权限控制
- 延迟加载
- 缓存代理
- 安全控制

**适用场景：**
- 访问控制
- 延迟加载
- 缓存优化

```lua
local proxy = ProxyPattern.New()
local realObject = proxy:GetObject()  -- 可能延迟加载
proxy:CheckPermission("read")  -- 权限检查
```

---

## 🎭 行为型模式 (Behavioral Patterns)

### 🔗 **责任链模式 (ChainOfResponsibility)**
**用途：** 将请求沿着处理者链进行传递，直到被处理
**作用：**
- 事件处理
- 权限验证
- 异常处理
- 请求过滤

**适用场景：**
- 多个对象处理请求
- 请求处理顺序不确定
- 动态处理链

```lua
local chain = ChainOfResponsibilityPattern.New()
chain:AddHandler(handler1)
chain:AddHandler(handler2)
chain:HandleRequest(request)
```

### 📝 **命令模式 (Command)**
**用途：** 将请求封装成对象，支持请求排队、记录日志、撤销等操作
**作用：**
- 撤销/重做系统
- 宏命令
- 队列处理
- 日志记录

**适用场景：**
- 需要撤销功能
- 命令排队
- 宏操作

```lua
local command = CommandPattern.New()
local moveCommand = command:CreateMoveCommand(unit, target)
command:Execute(moveCommand)
command:Undo()  -- 撤销操作
```

### 🔤 **解释器模式 (Interpreter)**
**用途：** 为语言创建解释器
**作用：**
- 脚本系统
- 配置解析
- 规则引擎
- 表达式求值

**适用场景：**
- 简单语言解析
- 规则引擎
- 表达式计算

```lua
local interpreter = InterpreterPattern.New()
local result = interpreter:Interpret("1 + 2 * 3")
```

### 🔄 **迭代器模式 (Iterator)**
**用途：** 提供一种方法顺序访问集合中的元素，而不暴露其内部表示
**作用：**
- 集合遍历
- 自定义遍历
- 遍历算法
- 集合封装

**适用场景：**
- 集合遍历
- 自定义遍历逻辑
- 集合封装

```lua
local iterator = IteratorPattern.New()
local collection = iterator:CreateCollection()
for item in collection:Iterator() do
    print(item)
end
```

### 🤝 **中介者模式 (Mediator)**
**用途：** 封装对象间的交互，降低它们之间的耦合度
**作用：**
- 聊天系统
- 游戏系统协调
- UI组件协调
- 模块间通信

**适用场景：**
- 对象间复杂交互
- 降低耦合
- 集中控制

```lua
local mediator = MediatorPattern.New()
mediator:RegisterComponent(component1)
mediator:RegisterComponent(component2)
component1:SendMessage("hello", mediator)
```

### 💾 **备忘录模式 (Memento)**
**用途：** 在不破坏封装的前提下，捕获并外部化对象的内部状态
**作用：**
- 游戏存档
- 撤销系统
- 状态恢复
- 快照系统

**适用场景：**
- 状态保存
- 撤销功能
- 快照系统

```lua
local memento = MementoPattern.New()
local originator = memento:CreateOriginator()
local savedState = originator:SaveState()
originator:RestoreState(savedState)
```

### 👀 **观察者模式 (Observer)**
**用途：** 定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者都会得到通知
**作用：**
- 事件系统
- 数据绑定
- 消息通知
- 状态同步

**适用场景：**
- 事件通知
- 数据同步
- 松耦合通信

```lua
local observer = ObserverPattern.New()
observer:Subscribe(subscriber1)
observer:Subscribe(subscriber2)
observer:Notify("event occurred")
```

### 🔄 **状态模式 (State)**
**用途：** 让对象在其内部状态改变时改变其行为
**作用：**
- 游戏状态管理
- 角色状态
- 系统状态
- 工作流状态

**适用场景：**
- 对象状态变化
- 状态相关行为
- 状态机实现

```lua
local state = StatePattern.New()
local context = state:CreateContext()
context:SetState(state:CreateState("idle"))
context:Request()  -- 根据当前状态执行不同行为
```

### 🎯 **策略模式 (Strategy)**
**用途：** 定义一系列算法，使它们可以互相替换，算法的变化不会影响使用算法的客户
**作用：**
- AI行为选择
- 算法选择
- 支付方式
- 排序算法

**适用场景：**
- 算法选择
- 行为选择
- 避免条件判断

```lua
local strategy = StrategyPattern.New()
local context = strategy:CreateContext()
context:SetStrategy(strategy:CreateStrategy("aggressive"))
context:ExecuteStrategy()
```

### 📋 **模板方法模式 (TemplateMethod)**
**用途：** 在父类中定义算法骨架，让子类重写特定步骤
**作用：**
- 算法框架
- 流程控制
- 代码复用
- 扩展点定义

**适用场景：**
- 算法框架
- 流程模板
- 代码复用

```lua
local template = TemplateMethodPattern.New()
local concreteClass = template:CreateConcreteClass()
concreteClass:TemplateMethod()  -- 调用模板方法
```

### 👥 **访问者模式 (Visitor)**
**用途：** 在不改变数据结构的前提下，定义作用于其元素的新操作
**作用：**
- 数据操作
- 统计功能
- 导出功能
- 功能扩展

**适用场景：**
- 数据结构稳定
- 操作经常变化
- 功能扩展

```lua
local visitor = VisitorPattern.New()
local element = visitor:CreateElement()
local concreteVisitor = visitor:CreateVisitor()
element:Accept(concreteVisitor)
```

---

## 🚀 高级模式 (Advanced Patterns)

### 🧩 **组件模式 (Component)**
**用途：** 将游戏对象分解为可重用的组件
**作用：**
- 游戏对象系统
- 模块化设计
- 功能组合
- 系统解耦

**适用场景：**
- 复杂游戏对象
- 功能模块化
- 系统解耦

```lua
local component = ComponentPattern.New()
local gameObject = component:CreateGameObject()
gameObject:AddComponent("Transform")
gameObject:AddComponent("Renderer")
gameObject:AddComponent("Collider")
```

### 📡 **事件驱动模式 (EventDriven)**
**用途：** 通过事件进行松耦合的通信
**作用：**
- 系统解耦
- 异步通信
- 消息传递
- 响应式系统

**适用场景：**
- 系统解耦
- 异步处理
- 消息系统

```lua
local eventSystem = EventDrivenPattern.New()
eventSystem:Subscribe("playerMove", handler)
eventSystem:Publish("playerMove", {x = 100, y = 200})
```

### 🎮 **状态机模式 (StateMachine)**
**用途：** 管理复杂的状态转换逻辑
**作用：**
- 角色状态管理
- 游戏流程控制
- AI状态管理
- 系统状态控制

**适用场景：**
- 复杂状态管理
- 状态转换逻辑
- 流程控制

```lua
local stateMachine = StateMachinePattern.New()
stateMachine:AddState("idle")
stateMachine:AddState("walking")
stateMachine:AddTransition("idle", "walking", "startWalking")
stateMachine:ChangeState("idle")
```

### 🏢 **服务定位器模式 (ServiceLocator)**
**用途：** 提供全局的服务访问点
**作用：**
- 服务管理
- 依赖管理
- 全局访问
- 服务注册

**适用场景：**
- 全局服务访问
- 服务管理
- 依赖注入

```lua
local serviceLocator = ServiceLocatorPattern.New()
serviceLocator:Register("audioService", audioService)
local audio = serviceLocator:GetService("audioService")
```

### 🏊 **对象池模式 (ObjectPool)**
**用途：** 重用对象以减少创建和销毁的开销
**作用：**
- 性能优化
- 内存管理
- 对象复用
- 垃圾回收优化

**适用场景：**
- 频繁创建销毁
- 性能优化
- 内存管理

```lua
local objectPool = ObjectPoolPattern.New()
local bullet = objectPool:GetObject("bullet")
-- 使用子弹
objectPool:ReturnObject(bullet)
```

### 📊 **数据驱动模式 (DataDriven)**
**用途：** 通过数据配置驱动系统行为
**作用：**
- 配置管理
- 数据驱动
- 系统配置
- 行为配置

**适用场景：**
- 配置驱动
- 数据驱动
- 系统配置

```lua
local dataDriven = DataDrivenPattern.New()
dataDriven:LoadConfig("weapon_config.json")
local weapon = dataDriven:CreateWeapon("sword")
```

### ⚡ **响应式编程模式 (ReactiveProgramming)**
**用途：** 通过数据流和变化传播来简化编程
**作用：**
- 数据流处理
- 变化传播
- 异步处理
- 事件流

**适用场景：**
- 数据流处理
- 变化响应
- 异步编程

```lua
local reactive = ReactiveProgrammingPattern.New()
local stream = reactive:CreateStream()
stream:Subscribe(function(value) print("Value changed:", value) end)
stream:Next(100)
```

### 💉 **依赖注入模式 (DependencyInjection)**
**用途：** 通过外部注入依赖，降低组件间的耦合
**作用：**
- 依赖管理
- 解耦设计
- 测试友好
- 配置灵活

**适用场景：**
- 依赖管理
- 系统解耦
- 测试友好

```lua
local di = DependencyInjectionPattern.New()
di:Register("database", databaseService)
di:Register("logger", loggerService)
local service = di:CreateService(MyService)
```

### 🚩 **脏标记模式 (DirtyFlag)**
**用途：** 通过标记避免不必要的计算
**作用：**
- 性能优化
- 缓存管理
- 计算优化
- 更新控制

**适用场景：**
- 性能优化
- 缓存管理
- 计算优化

```lua
local dirtyFlag = DirtyFlagPattern.New()
local object = dirtyFlag:CreateObject()
object:MarkDirty()
if object:IsDirty() then
    object:Update()
    object:ClearDirty()
end
```

### 🔄 **双缓冲模式 (DoubleBuffer)**
**用途：** 使用两个缓冲区避免渲染冲突
**作用：**
- 渲染优化
- 动画平滑
- 避免闪烁
- 性能提升

**适用场景：**
- 渲染系统
- 动画系统
- 避免闪烁

```lua
local doubleBuffer = DoubleBufferPattern.New()
local buffer = doubleBuffer:CreateBuffer()
buffer:SwapBuffers()
buffer:DrawToBackBuffer()
```

### 📍 **数据局部性模式 (DataLocality)**
**用途：** 通过组织数据布局提高缓存效率
**作用：**
- 性能优化
- 缓存优化
- 内存访问优化
- 系统性能

**适用场景：**
- 性能优化
- 缓存优化
- 内存访问优化

```lua
local dataLocality = DataLocalityPattern.New()
local optimizedArray = dataLocality:CreateOptimizedArray()
-- 数据按访问模式组织，提高缓存命中率
```

### 💻 **字节码模式 (Bytecode)**
**用途：** 通过字节码实现脚本系统
**作用：**
- 脚本系统
- 虚拟机
- 性能优化
- 跨平台

**适用场景：**
- 脚本系统
- 性能优化
- 跨平台

```lua
local bytecode = BytecodePattern.New()
local script = bytecode:Compile("print('Hello World')")
bytecode:Execute(script)
```

---

## 🚀 使用指南

### 快速开始
```lua
-- 1. 选择合适的设计模式
local pattern = PatternFactory.Create(PatternTypes.SINGLETON)

-- 2. 创建模式实例
local instance = pattern:Create()

-- 3. 使用模式功能
instance:DoSomething()
```

### 模式选择建议
- **对象创建**: 使用创建型模式
- **对象组合**: 使用结构型模式
- **对象交互**: 使用行为型模式
- **游戏开发**: 使用高级模式

### 最佳实践
- **单一职责**: 每个模式只负责一个方面
- **开闭原则**: 对扩展开放，对修改关闭
- **依赖倒置**: 依赖抽象而非具体实现
- **接口隔离**: 客户端不应该依赖不需要的接口

---

## 📈 模式对比

| 模式类型 | 主要用途 | 复杂度 | 适用场景 | 性能影响 |
|----------|----------|--------|----------|----------|
| **创建型** | 对象创建 | 低-中 | 对象创建逻辑 | 低 |
| **结构型** | 对象组合 | 中 | 对象关系 | 低-中 |
| **行为型** | 对象交互 | 中-高 | 对象通信 | 中 |
| **高级** | 游戏开发 | 高 | 复杂系统 | 中-高 |

---

## 🔧 扩展开发

### 添加新的设计模式
1. 继承基础模式接口
2. 实现必要的方法
3. 在工厂中注册
4. 添加使用示例

### 自定义模式实现
```lua
local CustomPattern = BaseClass(IPattern)

function CustomPattern:ctor()
    -- 初始化代码
end

function CustomPattern:Execute()
    -- 模式执行逻辑
end
```

---

## 📚 总结

这个设计模式库提供了：

✅ **完整的模式覆盖** - 从基础到高级的完整覆盖  
✅ **游戏开发优化** - 针对游戏开发的专用模式  
✅ **易用性设计** - 统一的接口和工厂创建  
✅ **扩展性架构** - 易于添加新的设计模式  
✅ **实用性强** - 实际项目中的应用场景  

**🎯 核心价值：** 让开发者专注于业务逻辑，而不是架构设计的复杂细节。

---

*支持Lua 5.1+ | 完整设计模式 | 游戏开发优化 | 易于扩展 | 🚀 架构设计最佳实践*
