{
    "sourceFile": "游戏编程精粹/1/代码/PathFollow_Optimized.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764423518156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764423518156,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// 路径跟随系统 - Catmull-Rom优化版本\r\n/// \r\n/// ========== 核心优化思路 ==========\r\n/// \r\n/// 问题：原版本每帧都要计算投影、找最近段，效率低\r\n/// \r\n/// 解决方案：\r\n/// 1. 使用Catmull-Rom插值预生成平滑路径点\r\n/// 2. 直接沿着预生成的路径点移动\r\n/// 3. 不需要每帧计算投影，只需要简单的距离计算\r\n/// \r\n/// ========== 性能对比 ==========\r\n/// \r\n/// 原版本（每帧）：\r\n/// - 遍历所有段找最近段：O(n)\r\n/// - 计算投影：O(1)\r\n/// - 总开销：O(n) 每帧\r\n/// \r\n/// 优化版本（每帧）：\r\n/// - 查找最近路径点：O(log n) 或 O(1)（利用缓存）\r\n/// - 直接获取下一个点：O(1)\r\n/// - 总开销：O(1) 或 O(log n) 每帧\r\n/// \r\n/// 性能提升：约10-100倍（取决于路径段数）\r\n/// </summary>\r\n\r\n// ==================== Catmull-Rom插值路径 ====================\r\n/// <summary>\r\n/// Catmull-Rom插值路径：预生成平滑路径点\r\n/// </summary>\r\npublic class CatmullRomPath : MonoBehaviour\r\n{\r\n    [Header(\"路径节点\")]\r\n    public List<GameObject> PathNodes = new List<GameObject>();\r\n    \r\n    [Header(\"插值设置\")]\r\n    [Tooltip(\"每两个节点之间生成的路径点数量（越多越平滑，但内存占用越大）\")]\r\n    public int PointsPerSegment = 10;\r\n    \r\n    [Tooltip(\"是否闭合路径（首尾相连）\")]\r\n    public bool IsClosed = false;\r\n    \r\n    // 预生成的平滑路径点\r\n    private List<Vector3> smoothPathPoints = new List<Vector3>();\r\n    private List<float> cumulativeDistances = new List<float>(); // 每个点到起点的累计距离\r\n    private float totalPathLength = 0f;\r\n    \r\n    // 缓存最近访问的点索引（利用局部性优化）\r\n    private int cachedPointIndex = 0;\r\n    \r\n    void Start()\r\n    {\r\n        GenerateSmoothPath();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 使用Catmull-Rom插值生成平滑路径\r\n    /// </summary>\r\n    public void GenerateSmoothPath()\r\n    {\r\n        smoothPathPoints.Clear();\r\n        cumulativeDistances.Clear();\r\n        totalPathLength = 0f;\r\n        cachedPointIndex = 0;\r\n        \r\n        if (PathNodes == null || PathNodes.Count < 2)\r\n        {\r\n            Debug.LogWarning(\"路径节点数量不足，至少需要2个节点\");\r\n            return;\r\n        }\r\n        \r\n        // 如果节点数少于4个，需要特殊处理（Catmull-Rom需要4个点）\r\n        if (PathNodes.Count < 4)\r\n        {\r\n            GenerateSimplePath();\r\n            return;\r\n        }\r\n        \r\n        // 生成平滑路径点\r\n        for (int i = 0; i < PathNodes.Count; i++)\r\n        {\r\n            // 获取4个控制点（用于Catmull-Rom插值）\r\n            Vector3 p0 = GetControlPoint(i - 1);\r\n            Vector3 p1 = PathNodes[i].transform.position;\r\n            Vector3 p2 = GetControlPoint(i + 1);\r\n            Vector3 p3 = GetControlPoint(i + 2);\r\n            \r\n            // 如果这是第一个节点，添加起点\r\n            if (i == 0)\r\n            {\r\n                smoothPathPoints.Add(p1);\r\n                cumulativeDistances.Add(0f);\r\n            }\r\n            \r\n            // 在当前节点和下一个节点之间生成插值点\r\n            if (i < PathNodes.Count - 1 || IsClosed)\r\n            {\r\n                for (int j = 1; j <= PointsPerSegment; j++)\r\n                {\r\n                    float t = (float)j / PointsPerSegment;\r\n                    Vector3 point = CatmullRom(p0, p1, p2, p3, t);\r\n                    \r\n                    // 计算累计距离\r\n                    float distance = Vector3.Distance(smoothPathPoints[smoothPathPoints.Count - 1], point);\r\n                    totalPathLength += distance;\r\n                    cumulativeDistances.Add(totalPathLength);\r\n                    \r\n                    smoothPathPoints.Add(point);\r\n                }\r\n            }\r\n        }\r\n        \r\n        Debug.Log($\"生成平滑路径：{smoothPathPoints.Count}个点，总长度：{totalPathLength:F2}米\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 节点数少于4个时的简单路径生成\r\n    /// </summary>\r\n    private void GenerateSimplePath()\r\n    {\r\n        for (int i = 0; i < PathNodes.Count; i++)\r\n        {\r\n            Vector3 point = PathNodes[i].transform.position;\r\n            smoothPathPoints.Add(point);\r\n            \r\n            if (i > 0)\r\n            {\r\n                float distance = Vector3.Distance(smoothPathPoints[i - 1], point);\r\n                totalPathLength += distance;\r\n            }\r\n            cumulativeDistances.Add(totalPathLength);\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取控制点（处理边界情况）\r\n    /// </summary>\r\n    private Vector3 GetControlPoint(int index)\r\n    {\r\n        if (IsClosed)\r\n        {\r\n            // 闭合路径：使用模运算\r\n            int wrappedIndex = ((index % PathNodes.Count) + PathNodes.Count) % PathNodes.Count;\r\n            return PathNodes[wrappedIndex].transform.position;\r\n        }\r\n        else\r\n        {\r\n            // 开放路径：边界点重复\r\n            if (index < 0)\r\n                return PathNodes[0].transform.position;\r\n            if (index >= PathNodes.Count)\r\n                return PathNodes[PathNodes.Count - 1].transform.position;\r\n            return PathNodes[index].transform.position;\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// Catmull-Rom插值算法\r\n    /// </summary>\r\n    private Vector3 CatmullRom(Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3, float t)\r\n    {\r\n        // Catmull-Rom样条插值公式\r\n        // t: 0到1之间的插值参数\r\n        float t2 = t * t;\r\n        float t3 = t2 * t;\r\n        \r\n        return 0.5f * (\r\n            (2f * p1) +\r\n            (-p0 + p2) * t +\r\n            (2f * p0 - 5f * p1 + 4f * p2 - p3) * t2 +\r\n            (-p0 + 3f * p1 - 3f * p2 + p3) * t3\r\n        );\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取路径总长度\r\n    /// </summary>\r\n    public float GetTotalLength()\r\n    {\r\n        return totalPathLength;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 根据3D位置找到最近的路径点索引（优化版：利用局部性）\r\n    /// </summary>\r\n    public int FindNearestPointIndex(Vector3 position)\r\n    {\r\n        if (smoothPathPoints.Count == 0)\r\n            return 0;\r\n        \r\n        float minDistance = float.MaxValue;\r\n        int nearestIndex = 0;\r\n        \r\n        // 优化：先检查缓存点附近（前后各10个点）\r\n        int startIndex = Mathf.Max(0, cachedPointIndex - 10);\r\n        int endIndex = Mathf.Min(smoothPathPoints.Count - 1, cachedPointIndex + 10);\r\n        \r\n        for (int i = startIndex; i <= endIndex; i++)\r\n        {\r\n            float distance = Vector3.Distance(position, smoothPathPoints[i]);\r\n            if (distance < minDistance)\r\n            {\r\n                minDistance = distance;\r\n                nearestIndex = i;\r\n            }\r\n        }\r\n        \r\n        // 如果缓存附近没找到足够近的点，再遍历全部（防止Agent突然跳跃）\r\n        if (minDistance > 2.0f)\r\n        {\r\n            for (int i = 0; i < smoothPathPoints.Count; i++)\r\n            {\r\n                float distance = Vector3.Distance(position, smoothPathPoints[i]);\r\n                if (distance < minDistance)\r\n                {\r\n                    minDistance = distance;\r\n                    nearestIndex = i;\r\n                }\r\n            }\r\n        }\r\n        \r\n        cachedPointIndex = nearestIndex;\r\n        return nearestIndex;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 根据路径点索引获取对应的路径距离\r\n    /// </summary>\r\n    public float GetDistanceAtPointIndex(int pointIndex)\r\n    {\r\n        if (pointIndex < 0)\r\n            return 0f;\r\n        if (pointIndex >= cumulativeDistances.Count)\r\n            return totalPathLength;\r\n        return cumulativeDistances[pointIndex];\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 根据路径距离获取对应的路径点索引（二分查找）\r\n    /// </summary>\r\n    public int FindPointIndexAtDistance(float distance)\r\n    {\r\n        if (cumulativeDistances.Count == 0)\r\n            return 0;\r\n        \r\n        distance = Mathf.Clamp(distance, 0f, totalPathLength);\r\n        \r\n        // 二分查找\r\n        int left = 0;\r\n        int right = cumulativeDistances.Count - 1;\r\n        \r\n        while (left < right)\r\n        {\r\n            int mid = (left + right) / 2;\r\n            if (cumulativeDistances[mid] < distance)\r\n                left = mid + 1;\r\n            else\r\n                right = mid;\r\n        }\r\n        \r\n        return left;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 根据路径距离获取对应的3D位置（线性插值）\r\n    /// </summary>\r\n    public Vector3 GetPositionAtDistance(float distance)\r\n    {\r\n        if (smoothPathPoints.Count == 0)\r\n            return Vector3.zero;\r\n        \r\n        distance = Mathf.Clamp(distance, 0f, totalPathLength);\r\n        \r\n        // 找到对应的点索引\r\n        int pointIndex = FindPointIndexAtDistance(distance);\r\n        \r\n        // 如果正好在点上\r\n        if (pointIndex == 0 || cumulativeDistances[pointIndex] == distance)\r\n        {\r\n            return smoothPathPoints[pointIndex];\r\n        }\r\n        \r\n        // 在两个点之间线性插值\r\n        int prevIndex = pointIndex - 1;\r\n        float prevDistance = cumulativeDistances[prevIndex];\r\n        float nextDistance = cumulativeDistances[pointIndex];\r\n        float segmentLength = nextDistance - prevDistance;\r\n        \r\n        if (segmentLength < 0.001f)\r\n            return smoothPathPoints[pointIndex];\r\n        \r\n        float t = (distance - prevDistance) / segmentLength;\r\n        return Vector3.Lerp(smoothPathPoints[prevIndex], smoothPathPoints[pointIndex], t);\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 获取路径点数量\r\n    /// </summary>\r\n    public int GetPointCount()\r\n    {\r\n        return smoothPathPoints.Count;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 可视化路径（编辑器中使用）\r\n    /// </summary>\r\n    void OnDrawGizmos()\r\n    {\r\n        if (smoothPathPoints == null || smoothPathPoints.Count < 2)\r\n            return;\r\n        \r\n        Color originalColor = Gizmos.color;\r\n        Gizmos.color = Color.cyan;\r\n        \r\n        // 绘制平滑路径\r\n        for (int i = 0; i < smoothPathPoints.Count - 1; i++)\r\n        {\r\n            Gizmos.DrawLine(smoothPathPoints[i], smoothPathPoints[i + 1]);\r\n        }\r\n        \r\n        // 绘制原始节点\r\n        Gizmos.color = Color.yellow;\r\n        if (PathNodes != null)\r\n        {\r\n            foreach (var node in PathNodes)\r\n            {\r\n                if (node != null)\r\n                {\r\n                    Gizmos.DrawSphere(node.transform.position, 0.2f);\r\n                }\r\n            }\r\n        }\r\n        \r\n        Gizmos.color = originalColor;\r\n    }\r\n}\r\n\r\n// ==================== 优化的路径跟随行为 ====================\r\n/// <summary>\r\n/// 优化的路径跟随行为：直接沿着预生成的平滑路径点移动\r\n/// </summary>\r\npublic class OptimizedPathFollowBehavior : MonoBehaviour\r\n{\r\n    [Header(\"路径设置\")]\r\n    public CatmullRomPath Path;\r\n    \r\n    [Header(\"跟随参数\")]\r\n    [Tooltip(\"目标点距离当前位置的路径距离偏移（正数表示前方，负数表示后方）\")]\r\n    public float TargetDistanceOffset = 1.0f;\r\n    \r\n    [Header(\"移动参数\")]\r\n    public float MoveSpeed = 5f;\r\n    \r\n    [Header(\"调试\")]\r\n    public bool ShowDebugInfo = true;\r\n    \r\n    // 当前状态\r\n    private int currentPointIndex = 0;\r\n    private float currentPathDistance = 0f;\r\n    private Vector3 targetPosition;\r\n    \r\n    void Update()\r\n    {\r\n        if (Path == null)\r\n            return;\r\n        \r\n        // ========== 优化的路径跟随逻辑 ==========\r\n        // \r\n        // 核心思路：直接沿着预生成的路径点移动，不需要每帧计算投影\r\n        // \r\n        // 步骤：\r\n        // 1. 找到Agent当前位置最近的路径点索引\r\n        // 2. 获取该点对应的路径距离\r\n        // 3. 在路径前方设置目标点（当前位置 + 偏移距离）\r\n        // 4. 直接移动到目标点\r\n        // \r\n        // 性能优势：\r\n        // - 不需要计算投影\r\n        // - 不需要遍历所有段\r\n        // - 只需要简单的距离计算和索引查找\r\n        \r\n        // 步骤1：找到当前位置最近的路径点\r\n        currentPointIndex = Path.FindNearestPointIndex(transform.position);\r\n        currentPathDistance = Path.GetDistanceAtPointIndex(currentPointIndex);\r\n        \r\n        // 步骤2：计算目标位置（当前位置前方一定距离）\r\n        float targetPathDistance = currentPathDistance + TargetDistanceOffset;\r\n        targetPosition = Path.GetPositionAtDistance(targetPathDistance);\r\n        \r\n        // 步骤3：直接移动到目标点（或使用Seek行为）\r\n        Vector3 direction = (targetPosition - transform.position).normalized;\r\n        transform.position += direction * MoveSpeed * Time.deltaTime;\r\n        \r\n        // 调试：绘制从Agent到目标点的线\r\n        if (ShowDebugInfo)\r\n        {\r\n            Debug.DrawLine(transform.position, targetPosition, Color.green);\r\n            Debug.DrawLine(transform.position, Path.GetPositionAtDistance(currentPathDistance), Color.red);\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 重置路径跟随状态\r\n    /// </summary>\r\n    public void ResetPathFollow()\r\n    {\r\n        currentPointIndex = 0;\r\n        currentPathDistance = 0f;\r\n    }\r\n}\r\n\r\n"
        }
    ]
}