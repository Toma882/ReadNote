# 🎯 原创设计模式

## 📋 概述

本文档记录项目中原创或创新的设计模式，这些模式在传统设计模式库中不存在，或是对传统模式的创新组合和扩展。这些模式经过实际项目验证，具有独特的价值和适用场景。

---

## 🆕 原创设计模式列表

### 1. Context (上下文模式) ⭐ **原创模式：接口参数归一化**

**核心定义：**
- **接口参数归一化**：所有系统统一使用 `context` 作为函数参数，实现接口稳定性
- **防呆设计**：通过统一的 Context 参数，避免参数顺序错误、参数遗漏等问题
- **简单一致 > 复杂优化**：直接创建 Context，利用 Lua 5.4 分代 GC 自动优化，零心智负担
- **向后兼容**：Context 内部可任意扩展，新增字段不破坏接口，不影响旧代码

**核心价值：**
- **接口稳定**：新增字段不破坏接口，向后兼容，接口长期稳定
- **语义清晰**：自解释的参数命名（如 `context.source`、`context.target`），易于理解
- **跨系统传递**：Context 在调用链中传递，零成本集成，信息逐步累积
- **信息累积**：逐步积累流程数据，完整追踪整个调用链的信息

**核心特点：**
- **接口归一化**：所有系统统一使用 `context` 作为函数参数，接口一致
- **参数灵活性**：Context 内部可任意扩展，不破坏接口
- **零心智负担**：统一标准，直接创建 table，Lua 5.4 自动优化 GC
- **防呆设计**：避免参数顺序错误、参数遗漏、参数类型错误等问题
- **渐进式增强**：功能可以逐步添加到 Context 中，不影响现有代码

**使用规则：**
- ✅ **使用 Context**：参数>3个、可能扩展、需长期稳定、跨系统传递
- ❌ **直接传参**：数学函数、参数固定、局部工具函数、简单计算

**适用场景：**
- 需要统一接口的系统（如 CommunicationBus、Skill、Effect 等）
- 需要跨系统传递数据的场景
- 需要长期稳定接口的系统
- 参数可能扩展的函数
- 需要完整追踪调用链信息的场景

**流程图：**
```mermaid
flowchart TD
    A[函数调用] --> B[创建 Context<br/>统一参数接口]
    B --> C[填充基础信息<br/>source/target/data等]
    C --> D[调用系统A<br/>传递 Context]
    D --> E[系统A处理<br/>增强 Context 信息]
    E --> F[调用系统B<br/>传递 Context]
    F --> G[系统B处理<br/>继续增强 Context]
    G --> H[调用系统C<br/>传递 Context]
    H --> I[系统C处理<br/>完成处理]
    I --> J[返回结果<br/>Context 信息完整]
    
    K[接口稳定] -.->|新增字段| B
    L[向后兼容] -.->|不影响旧代码| B
    M[信息累积] -.->|逐步增强| E
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
    style K fill:#c8e6c9
    style L fill:#c8e6c9
    style M fill:#c8e6c9
```

---

### 2. Pipeline-Filter (管道-过滤器模式)

**核心定义：**
- 将复杂处理流程分解为多个独立的过滤器
- 通过管道连接过滤器，数据在管道中流动
- 每个过滤器专注于单一职责

**核心特点：**
- **数据流处理**：数据在管道中单向流动
- **过滤器独立**：每个过滤器可独立开发、测试、替换
- **组合灵活**：通过组合不同过滤器实现复杂流程
- **易于扩展**：新增过滤器不影响现有流程

**适用场景：**
- 数据处理流水线
- 数据转换流程
- 多步骤验证流程
- 日志处理系统

**流程图：**
```mermaid
flowchart LR
    A[输入数据] --> B[过滤器1]
    B -->|管道| C[过滤器2]
    C -->|管道| D[过滤器3]
    D -->|管道| E[过滤器N]
    E --> F[输出数据]
    
    style B fill:#e1f5ff
    style C fill:#e1f5ff
    style D fill:#e1f5ff
    style E fill:#e1f5ff
```

---

### 3. Domain Controls Loop (领域控制循环模式)

**核心定义：**
- **Domain控制循环**：Domain是领域核心，拥有循环机制来推进业务流程
- **循环是Domain的工具**：循环不是主导，Domain才是主导，循环服务于Domain
- **协调器推动循环**：Domain管理通过协调器控制循环状态转换，协调器执行完业务后，主动推动循环进入下一个状态
- **多层循环架构**：支持多层Domain循环（如战斗循环→回合循环→单位循环），每层Domain独立管理自己的循环

**核心特点：**
- **Domain主导**：Domain是领域核心，拥有循环机制，循环是Domain的工具
- **协调器控制**：Domain管理通过协调器控制循环状态转换
- **主动推动**：协调器执行完业务后，主动推动循环进入下一个状态（反向推动）
- **多层嵌套**：支持多层Domain循环，父Domain调用子Domain，子Domain完成业务后返回
- **状态维护**：每层循环维护自己的状态，驱动下层循环

**适用场景：**
- 领域驱动设计
- 业务逻辑复杂的系统（如战斗系统、回合制游戏）
- 需要多层循环管理的场景
- 需要领域层独立测试的场景

**流程图：**

#### Domain与循环的关系
```mermaid
graph TB
    subgraph BattleDomain["战斗Domain<br/>Battle Domain"]
        BattleManagement[战斗管理<br/>结算奖励/同步任务]
        BattleLoop["战斗循环<br/>BattleLoop"]
        BattleManagement -->|控制| BattleLoop
        BattleLoop -->|推进| BattleManagement
        
        subgraph RoundDomain["回合Domain<br/>Round Domain"]
            RoundManagement[回合管理<br/>行动值排序/单位行动顺序]
            RoundLoop["回合循环<br/>RoundLoop"]
            RoundManagement -->|控制| RoundLoop
            RoundLoop -->|推进| RoundManagement
            
            subgraph UnitDomain["单位Domain<br/>Unit Domain"]
                UnitManagement[单位管理<br/>移动/施法/选择技能对象]
                UnitLoop["单位循环<br/>UnitLoop"]
                UnitManagement -->|控制| UnitLoop
                UnitLoop -->|推进| UnitManagement
            end
        end
    end
    
    style BattleDomain fill:#ffebee
    style RoundDomain fill:#fff4e1
    style UnitDomain fill:#e1f5ff
    style BattleLoop fill:#f3e5f5
    style RoundLoop fill:#f3e5f5
    style UnitLoop fill:#f3e5f5
```


#### 协调器推动循环流程
```mermaid
flowchart TD
    LoopPreparing[LoopPreparing<br/>战斗准备] --> InitBattle[初始化战斗数据<br/>战斗管理初始化]
    
    InitBattle --> LoopProgress[LoopProgress<br/>战斗进行中]
    
    LoopProgress --> CallRound[调用回合领域<br/>回合协调器调用回合领域]
    
    CallRound --> RoundAction[回合领域执行回合<br/>回合领域完成回合]
    
    RoundAction --> PushProgress[回合协调器推动循环<br/>推动到IN_PROGRESS状态继续]
    
    PushProgress --> CheckEnd{检查战斗结束条件<br/>战斗管理检查}
    
    CheckEnd -->|未结束| CallRound
    CheckEnd -->|已结束| PushEnd[回合协调器推动循环<br/>推动到ENDED状态]
    
    PushEnd --> LoopEnd[LoopEnd<br/>战斗结束]
    
    LoopEnd --> Reward[结算奖励<br/>奖励管理结算奖励]
    Reward --> Task[同步任务<br/>任务管理同步任务]
    Task --> Complete[战斗完成]
    
    style LoopPreparing fill:#ffebee
    style LoopProgress fill:#ffebee
    style CallRound fill:#c8e6c9
    style RoundAction fill:#c8e6c9
    style PushProgress fill:#f3e5f5
    style PushEnd fill:#f3e5f5
    style LoopEnd fill:#ffebee
    style CheckEnd fill:#ffe0b2
```

---

### 4. Microkernel (微内核模式)

**核心定义：**
- 核心系统提供最小功能集
- 通过插件机制扩展功能
- 核心与插件解耦，支持动态加载

**核心特点：**
- **最小核心**：核心只提供基础功能
- **插件扩展**：功能通过插件动态添加
- **热插拔**：支持运行时加载/卸载插件
- **松耦合**：插件之间相互独立

**适用场景：**
- 需要动态扩展的系统
- 插件化架构
- 可配置的系统
- 框架设计

**流程图：**
```mermaid
flowchart TD
    A[客户端请求] --> B[微内核接收]
    B --> C[核心功能处理]
    C --> D{需要插件?}
    D -->|是| E[查找插件]
    D -->|否| F[返回结果]
    E --> G{插件是否存在?}
    G -->|是| H[调用插件]
    G -->|否| I[使用默认处理]
    H --> J[插件处理]
    J --> F
    I --> F
    
    style B fill:#e1f5ff
    style E fill:#fff4e1
```

---

### 5. Formula System (公式系统)

**核心定义：**
- 三层架构：字符串解析 → Lua函数编译 → 执行
- 支持动态公式计算
- 通过编译优化性能

**核心特点：**
- **三层架构**：解析层、编译层、执行层
- **动态编译**：字符串公式编译为 Lua 函数
- **性能优化**：编译后执行，避免重复解析
- **缓存机制**：编译结果缓存，提高效率

**适用场景：**
- 动态公式计算
- 规则引擎
- 配置驱动的计算
- 技能系统

**流程图：**

#### 三级公式架构 + 职责分离
```mermaid
graph TB
    subgraph ProgrammerLayer["基础设施层"]
        FunctionRegistry["函数注册表<br/>RegisterFunction<br/>一级公式函数"]
        ParserEngine["解析引擎<br/>FormulaParserBase<br/>公式解析和编译"]
        CacheSystem["缓存系统<br/>FormulaCache<br/>编译结果缓存"]
    end
    
    subgraph DesignerLayer["配置层"]
        Level1Formula["一级公式<br/>ATTR/EQUIPMENT_BONUS<br/>基础获取函数"]
        Level2Formula["二级公式<br/>@Category_Name<br/>派生计算"]
        Level3Formula["三级公式<br/>#FinalResult<br/>综合效果计算"]
    end
    
    subgraph RuntimeLayer["计算层"]
        ParamContainer["参数容器<br/>Param.Create<br/>链式参数传递"]
        FormulaCalculator["公式计算器<br/>CalculateFormula<br/>执行公式计算"]
        ResultCache["结果缓存<br/>计算结果缓存"]
    end
    
    ProgrammerLayer -->|提供基础设施| DesignerLayer
    DesignerLayer -->|注册公式| RuntimeLayer
    RuntimeLayer -->|计算公式| ResultCache
    
    style ProgrammerLayer fill:#e1f5ff
    style DesignerLayer fill:#fff4e1
    style RuntimeLayer fill:#c8e6c9
```

#### 三级公式数据流（计算合成）
```mermaid
graph TD
    L3[三级公式<br/>#TotalDamage] -->|依赖| L2A[二级公式<br/>Combat_AttackPower]
    L3 -->|依赖| L2B[二级公式<br/>Combat_CriticalMultiplier]
    
    L2A -->|依赖| L1A[一级公式<br/>ATTR]
    L2A -->|依赖| L1B[一级公式<br/>EQUIPMENT_BONUS]
    L2B -->|依赖| L1C[一级公式<br/>SKILL_BONUS]
    
    L1A -.->|计算合成| L2A
    L1B -.->|计算合成| L2A
    L1C -.->|计算合成| L2B
    
    L2A -.->|计算合成| L3
    L2B -.->|计算合成| L3
    
    style L3 fill:#c8e6c9
    style L2A fill:#fff4e1
    style L2B fill:#fff4e1
    style L1A fill:#e1f5ff
    style L1B fill:#e1f5ff
    style L1C fill:#e1f5ff
```

#### 三层解析和执行流程
```mermaid
flowchart TD
    A[输入公式字符串] --> B[解析层: 词法/语法分析]
    B --> C{识别公式级别}
    C -->|一级公式| D1[FUNC基础获取函数]
    C -->|二级公式| D2[CategoryName<br/>派生计算]
    C -->|三级公式| D3[#FinalResult<br/>综合效果计算]
    
    D1 --> E{是否已编译?}
    D2 --> E
    D3 --> E
    
    E -->|是| F[从缓存获取]
    E -->|否| G[编译层: 生成 Lua 函数]
    G --> H[缓存编译结果]
    H --> F
    
    F --> I[执行层: 执行计算]
    I --> J{公式级别}
    J -->|一级公式| K[执行基础获取]
    J -->|二级公式| L[执行派生计算<br/>依赖一级公式结果]
    J -->|三级公式| M[执行综合效果<br/>依赖一级和二级公式结果]
    
    K --> N[返回一级结果]
    L --> O[返回二级结果<br/>合成一级结果]
    M --> P[返回三级结果<br/>合成一级和二级结果]
    
    style B fill:#e1f5ff
    style G fill:#fff4e1
    style I fill:#c8e6c9
    style L fill:#ffccbc
    style M fill:#ffccbc
```

**三级公式核心特性：**
- ✅ **三级分层**：一级 → 二级 → 三级，逐层计算合成
- ✅ **职责分离**：程序员提供一级函数，策划编写二级和三级公式
- ✅ **字符匹配**：通过字符匹配规则识别公式级别（#三级、@二级、FUNC一级）
- ✅ **计算合成**：一级公式结果合成二级公式，二级公式结果合成三级公式
- ✅ **自动缓存**：编译结果自动缓存，提升性能

---

### 6. CommunicationBus (通讯总线) ⭐ **原创：多频道架构**

**核心定义：**
- 统一的通讯总线系统，通过多频道架构提供多种通信模式
- 四种频道：发布-订阅、点对点、数据推送、请求-响应
- 统一接口层路由到不同频道

**核心特点：**
- **多频道架构**：EventChannel、MessageChannel、PushChannel、QueryChannel
- **统一接口**：CommunicationBus 提供统一入口
- **路由机制**：根据通信类型自动路由到对应频道
- **解耦设计**：应用层不直接依赖具体频道实现

**适用场景：**
- 需要多种通信模式的系统
- 事件驱动架构
- 模块间解耦通信
- 游戏开发中的各种通信需求

**流程图：**
```mermaid
flowchart TD
    A[客户端请求] --> B[CommunicationBus 统一接口]
    B --> C{通信类型}
    C -->|发布-订阅| D[EventChannel<br/>广播事件]
    C -->|点对点| E[MessageChannel<br/>消息传递]
    C -->|数据推送| F[PushChannel<br/>推送数据]
    C -->|请求-响应| G[QueryChannel<br/>查询响应]
    D --> H[通知所有订阅者]
    E --> I[发送给目标]
    F --> J[处理数据队列]
    G --> K[执行查询并返回]
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
```

---

### 7. Template Configuration (模板化配置模式)

**核心定义：**
- 通过模板ID完成完整配置
- 模板自动查找组件并初始化
- 同一个模板支持不同的参数配置

**核心特点：**
- **模板驱动**：一个模板ID即可完成完整配置
- **自动查找**：系统自动查找所需组件，无需手动添加
- **参数化配置**：同一个模板可以有不同的参数配置
- **统一流程**：所有类型使用统一的初始化流程

**适用场景：**
- 需要快速配置相似对象的系统
- 数据驱动的配置系统
- 组件自动初始化场景
- 交互系统、技能系统等

**流程图：**

#### 三层架构 + 模板方法模式
```mermaid
graph TB
    subgraph ConfigLayer["配置层<br/>Unity Inspector"]
        ItemLifecycle["ItemLifecycle组件<br/>interactionTemplateId"]
        TemplateConfig["模板配置<br/>EInteractionTypeTemplate"]
    end
    
    subgraph TemplateLayer["模板层<br/>InteractionUtil"]
        TemplateRegistry["模板注册表<br/>EInteractionTypeTemplate"]
        ComponentFinder["组件查找器<br/>自动查找所需组件"]
        InitOrchestrator["初始化编排器<br/>统一初始化流程"]
    end
    
    subgraph InitLayer["初始化层<br/>InteractionInit"]
        InitStrategies["初始化策略组<br/>InterationInit[ComponentType]"]
        ParamConfig["参数配置<br/>参数化配置支持"]
    end
    
    subgraph UnityLayer["Unity组件层"]
        TopDownComponents["TopDown组件<br/>PickableItem/KeyOperatedZone等"]
        FeedbackComponents["反馈组件<br/>MMFeedbacks/粒子系统等"]
    end
    
    ConfigLayer -->|读取模板ID| TemplateLayer
    TemplateLayer -->|查找模板| TemplateRegistry
    TemplateRegistry -->|查找组件| ComponentFinder
    ComponentFinder -->|获取组件列表| InitOrchestrator
    InitOrchestrator -->|调用初始化| InitLayer
    InitLayer -->|执行策略| InitStrategies
    InitStrategies -->|配置组件| UnityLayer
    
    style ConfigLayer fill:#fff9c4
    style TemplateLayer fill:#e1f5ff
    style InitLayer fill:#fff4e1
    style UnityLayer fill:#c8e6c9
```

#### 模板方法数据流
```mermaid
graph TD
    Start[Unity Inspector<br/>配置interactionTemplateId] -->|1. 读取模板ID| Template[模板层<br/>查找EInteractionTypeTemplate]
    Template -->|2. 获取组件类型| Component[组件查找器<br/>自动查找所需组件]
    Component -->|3. 获取组件列表| Orchestrator[初始化编排器<br/>统一初始化流程]
    Orchestrator -->|4. 调用初始化策略| Init[初始化层<br/>InterationInit]
    Init -->|5. 配置组件参数| Unity[Unity组件层<br/>完成配置]
    
    style Template fill:#e1f5ff
    style Component fill:#fff4e1
    style Init fill:#c8e6c9
    style Unity fill:#c8e6c9
```

**模板化核心特性：**
- ✅ **模板驱动**：一个模板ID即可完成完整配置
- ✅ **自动查找**：系统自动查找所需组件，无需手动添加
- ✅ **统一流程**：所有交互类型使用统一的初始化流程
- ✅ **参数化配置**：同一个模板可以有不同的参数配置
- ✅ **策略模式**：每个组件类型对应一个初始化策略
- ✅ **外观模式**：隐藏复杂的初始化逻辑，提供简单的配置接口

---

### 8. Condition-Action Decoupling (条件-动作解耦模式)

**核心定义：**
- 条件与动作完全解耦
- 通过枚举ID建立映射关系
- 支持1对多、多对1、多对多的灵活绑定

**核心特点：**
- **完全解耦**：条件检查和动作执行独立
- **灵活绑定**：支持多种绑定关系（1对1、1对多、多对1、多对多）
- **映射表管理**：通过映射表管理条件-动作关系
- **易于扩展**：新增条件或动作不影响现有逻辑

**适用场景：**
- 触发器系统
- 规则引擎
- 事件响应系统
- 条件驱动的行为系统

**流程图：**
```mermaid
flowchart TD
    A[触发事件] --> B[查找条件映射表]
    B --> C[检查条件ID]
    C --> D{条件是否满足?}
    D -->|是| E[查找动作映射表]
    D -->|否| F[跳过执行]
    E --> G[执行对应动作]
    G --> H[完成处理]
    F --> I[等待下次触发]
    
    style B fill:#e1f5ff
    style D fill:#fff4e1
```

---

### 9. Handler Strategy (Handler策略模式)

**核心定义：**
- 通过Handler组件的顺序执行实现复杂流程
- 每个Handler专注单一职责
- 使用统一的Context传递数据

**核心特点：**
- **策略组合**：Handler组件灵活组合
- **管道执行**：Handler按顺序执行，逐步增强Context
- **单一职责**：每个Handler专注单一功能
- **易于扩展**：新增Handler不影响现有流程

**适用场景：**
- 技能系统
- 效果系统
- 多步骤处理流程
- 需要灵活组合的处理系统

**流程图：**
```mermaid
flowchart TD
    A[创建Context] --> B[Handler1处理]
    B --> C[增强Context数据]
    C --> D[Handler2处理]
    D --> E[增强Context数据]
    E --> F[Handler3处理]
    F --> G[增强Context数据]
    G --> H[HandlerN处理]
    H --> I[完成处理]
    
    style A fill:#e1f5ff
    style C fill:#fff4e1
    style E fill:#fff4e1
    style G fill:#fff4e1
```

---

### 10. Real-time Fetch (实时获取模式)

**核心定义：**
- 每次获取数据时实时计算，不依赖缓存
- 遍历所有子系统收集最新数据
- 零dirty标记，避免数据同步问题

**核心特点：**
- **实时计算**：每次获取都是最新数据
- **零dirty标记**：不依赖dirty标记机制
- **按需计算**：只计算需要的属性
- **数据一致性**：保证数据始终是最新的

**适用场景：**
- 属性计算系统
- 多子系统数据汇总
- 需要实时准确数据的场景
- 避免数据同步问题的系统

**流程图：**
```mermaid
flowchart TD
    A[GetAttribute请求] --> B[获取基础属性]
    B --> C[遍历子系统列表]
    C --> D[子系统1: 获取属性]
    D --> E[子系统2: 获取属性]
    E --> F[子系统N: 获取属性]
    F --> G[汇总计算]
    G --> H[返回最终结果]
    
    style A fill:#e1f5ff
    style C fill:#fff4e1
    style G fill:#c8e6c9
```

---

### 11. DataHandleQueue (数据队列解耦模式) ⭐ **原创：责任链 + 队列解耦 + 推送链**

**核心定义：**
- 通过队列实现模块间解耦通信，支持数据推送和查询委托两种机制
- **责任链特性**：多个处理器按顺序处理数据，每个处理器检查是否有自己需要处理的数据类型
- **推送链特性**：处理一个数据类型时可以触发下一个数据类型的推送，形成链式数据流
- 模块通过队列发送和接收数据，不直接相互调用
- 处理器映射表管理不同类型的处理，查询委托表管理查询接口

**核心特点：**
- **双重机制**：
  - **数据推送机制**：PushData + ProcessDataHandler，用于数据变化通知
  - **查询委托机制**：SetQueryDelegate，用于统一查询接口
- **责任链处理**：
  - 多个处理器（handlers）按顺序排列
  - 每个处理器检查是否有自己需要处理的数据类型
  - 如果有数据，就处理并可能提前返回
  - 如果没有，就继续传递给下一个处理器（通过遍历机制）
- **推送链机制**：
  - 处理数据类型A时，可以推送数据类型B，形成链式处理
  - 支持复杂的数据依赖关系，实现数据驱动的级联处理
  - 推送链中的每个环节相互独立，解耦设计
  - 典型应用：装备安装 → 专长安装 → 技能数据 → 效果数据
- **队列解耦**：模块间通过队列通信，不直接依赖
- **处理器映射**：通过 SetProcessHandleMapping 注册处理器映射表
- **查询统一**：通过 SetQueryDelegate 统一管理查询接口
- **模块独立**：模块可以独立开发、测试，通过队列解耦

**使用方式（以 UnitData 为例）：**
1. **初始化**：创建 DataHandleQueue，将所有子系统添加为 Handler
2. **注册处理器**：各子系统通过 `SetProcessHandleMapping()` 注册数据处理器
3. **注册查询**：通过 `SetQueryDelegate(queryId, function)` 注册查询函数
4. **数据推送**：外部系统通过 `PushData(dataType, data)` 推送数据变化
5. **处理数据**：调用 `ProcessDataHandler()` 批量处理队列中的数据

**适用场景：**
- 多子系统协同的系统（如 UnitData 管理装备、技能、状态等子系统）
- 模块间解耦通信
- 需要统一查询接口的系统
- 数据变化需要通知多个模块的场景
- 复杂的数据依赖关系（通过推送链实现级联处理）
- 数据驱动的业务逻辑（装备→专长→技能→效果的链式处理）

**流程图：**
```mermaid
flowchart TD
    A[外部系统/子系统] --> B[PushData<br/>推送数据变化]
    B --> C[DataHandleQueue<br/>数据队列]
    C --> D[ProcessDataHandler<br/>开始责任链处理]
    
    D --> E[遍历处理器列表]
    E --> F[处理器1: ProcessDataHandler]
    F --> G{检查是否有<br/>需要处理的数据?}
    G -->|有| H[处理数据]
    G -->|无| I[继续下一个处理器]
    
    H --> J[OnDataHandler<br/>遍历processHandlerMapping]
    J --> K[HandleAllData<br/>处理队列数据]
    K --> L{处理时是否<br/>触发推送链?}
    L -->|是| M[PushData<br/>推送下一个数据类型]
    L -->|否| N[完成处理]
    M --> C
    
    I --> O[处理器2: ProcessDataHandler]
    O --> P{检查是否有<br/>需要处理的数据?}
    P -->|有| Q[处理数据]
    P -->|无| R[继续下一个处理器]
    Q --> J
    
    R --> S[处理器N: ProcessDataHandler]
    S --> T{检查是否有<br/>需要处理的数据?}
    T -->|有| U[处理数据]
    T -->|无| V[责任链结束]
    U --> J
    
    W[推送链示例] --> X[EquipInstall<br/>装备安装]
    X -->|处理时推送| Y[FeatInstall<br/>专长安装]
    Y -->|处理时推送| Z[SkillData<br/>技能数据]
    Z -->|处理时推送| AA[EffectData<br/>效果数据]
    AA --> AB[链式处理完成]
    
    AC[外部查询] --> AD[QueryData<br/>查询数据]
    AD --> AE[查找查询委托表]
    AE --> AF[找到对应委托函数]
    AF --> AG[执行查询并返回]
    
    AH[初始化] --> AI[AddHandler<br/>添加子系统到责任链]
    AI --> AJ[SetProcessHandleMapping<br/>注册处理器映射表]
    AJ --> AK[SetQueryDelegate<br/>注册查询]
    
    style C fill:#e1f5ff
    style D fill:#fff4e1
    style G fill:#ffccbc
    style L fill:#ffccbc
    style M fill:#c8e6c9
    style W fill:#f3e5f5
    style AI fill:#c8e6c9
```

---

### 12. Effective Range (有效范围优化模式) ⭐ **原创：智能范围限制**

**核心定义：**
- 只处理玩家周围有效范围内的数据，大幅降低计算和内存开销
- 通过智能范围限制，实现2268倍性能提升
- 结合位图优化和Shader可视化，实现高性能网格系统

**核心特点：**
- **智能范围**：只处理有效范围内的数据，忽略无效区域
- **性能提升**：内存占用从1000000降低到441，2268倍提升
- **位图优化**：O(1)复杂度查询，85%性能提升
- **Shader可视化**：单DrawCall渲染，极低开销

**适用场景：**
- 大型网格系统
- 空间查询系统
- 碰撞检测系统
- 需要处理大量空间数据的场景

**流程图：**
```mermaid
flowchart TD
    A[网格查询请求] --> B[计算有效范围]
    B --> C{数据在有效范围内?}
    C -->|是| D[位图O1查询]
    C -->|否| E[跳过处理]
    D --> F[返回结果]
    E --> G[不处理]
    
    H[Shader可视化] --> I[单DrawCall渲染]
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
    style D fill:#c8e6c9
```

---

### 13. Delegate Pattern Pathfinding (委托模式寻路) ⭐ **原创：算法无关性设计**

**核心定义：**
- 通过委托模式消除硬编码，实现算法无关性设计
- 支持6种寻路算法，智能推荐最优算法
- 统一数据结构，零拆装箱，高性能

**核心特点：**
- **算法无关**：通过委托模式消除硬编码，算法可替换
- **智能推荐**：根据网格大小、权重情况、精度要求自动推荐最优算法
- **零拆装箱**：统一数据结构，避免性能损耗
- **灵活扩展**：新增算法不影响现有代码

**适用场景：**
- 寻路系统
- 路径规划系统
- 需要多种算法选择的场景
- 算法性能对比和优化

**流程图：**
```mermaid
flowchart TD
    A[寻路请求] --> B[分析场景参数]
    B --> C[智能推荐算法]
    C --> D{算法类型}
    D -->|A*| E[执行A*算法]
    D -->|JPS| F[执行JPS算法]
    D -->|BFS| G[执行BFS算法]
    D -->|其他| H[执行其他算法]
    E --> I[返回路径]
    F --> I
    G --> I
    H --> I
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
    style D fill:#ffccbc
```

---

### 14. Scope Mechanism (作用域机制) ⭐ **原创：多维度消息过滤**

**核心定义：**
- 通过四种作用域类型过滤消息接收者
- 实现精确的消息路由，避免不必要的消息传递
- 支持全局、局部、组、距离等多种作用域

**核心特点：**
- **四种作用域**：Global、Local、Group、Range
- **精确过滤**：根据作用域类型精确过滤接收者
- **性能优化**：避免不必要的消息传递和处理
- **灵活配置**：支持多种作用域组合使用

**适用场景：**
- 事件系统
- 消息系统
- 需要精确消息路由的场景
- 多人游戏中的消息分发

**流程图：**
```mermaid
flowchart TD
    A[发送消息] --> B[指定作用域类型]
    B --> C{作用域类型}
    C -->|Global| D[所有订阅者]
    C -->|Local| E[局部范围订阅者]
    C -->|Group| F[同组订阅者]
    C -->|Range| G[距离范围内订阅者]
    D --> H[过滤并发送]
    E --> H
    F --> H
    G --> H
    H --> I[接收者处理消息]
    
    style B fill:#e1f5ff
    style C fill:#fff4e1
    style H fill:#c8e6c9
```

---

### 15. Lifecycle Bridge (生命周期桥接模式) ⭐ **原创：C#-Lua自动映射**

**核心定义：**
- 通过自动映射机制实现C#和Lua之间的生命周期桥接
- 统一生命周期管理，支持所有Unity生命周期事件
- 通过mappingName自动映射Lua函数，零配置

**核心特点：**
- **自动映射**：通过mappingName自动映射Lua函数
- **完整生命周期**：支持所有Unity生命周期事件
- **零配置**：无需手动配置映射关系
- **编辑器工具**：自动生成对应的Lua函数文件

**适用场景：**
- C#-Lua混合架构
- Unity生命周期管理
- 需要C#和Lua交互的场景
- 快速开发原型

**流程图：**
```mermaid
flowchart TD
    A[C# MonoLifecycle] --> B[设置mappingName]
    B --> C[Unity生命周期事件]
    C --> D[自动查找Lua函数]
    D --> E{函数是否存在?}
    E -->|是| F[调用Lua函数]
    E -->|否| G[跳过]
    F --> H[Lua处理逻辑]
    H --> I[返回结果]
    
    J[编辑器工具] --> K[自动生成Lua函数模板]
    
    style B fill:#e1f5ff
    style D fill:#fff4e1
    style K fill:#c8e6c9
```

---

## 📊 原创模式分类

### 原创设计模式分类

```
原创设计模式 (Original Design Patterns)
├── Context (上下文模式) ⭐ - 接口参数归一化，防呆设计，向后兼容，利用 Lua 5.4 分代 GC（完全原创）
├── CommunicationBus (通讯总线模式) ⭐ - 多频道架构，统一路由（原创组合）
├── DataHandleQueue (数据队列解耦模式) ⭐ - 责任链 + 队列解耦 + 推送链，三重机制（原创组合）
├── EffectiveRange (有效范围优化模式) ⭐ - 智能范围限制，2268倍性能提升（原创优化）
├── DelegatePatternPathfinding (委托模式寻路) ⭐ - 算法无关性设计，智能推荐（原创设计）
├── ScopeMechanism (作用域机制) ⭐ - 多维度消息过滤，精确路由（原创机制）
├── LifecycleBridge (生命周期桥接模式) ⭐ - C#-Lua自动映射，零配置（原创桥接）
├── TemplateConfiguration (模板化配置模式) - 模板驱动，自动初始化（创新应用）
├── HandlerStrategy (Handler策略模式) - Handler组合，管道执行（创新应用）
├── RealTimeFetch (实时获取模式) - 实时计算，零dirty标记（创新思路）
└── ConditionActionDecoupling (条件-动作解耦模式) - 条件动作分离，灵活绑定（创新应用）

传统模式创新应用 (Innovative Applications of Traditional Patterns)
├── PipelineFilter (管道-过滤器模式) - 数据流处理，过滤器组合
├── DomainControlsLoop (领域控制循环模式) - 领域驱动，循环处理
├── Microkernel (微内核模式) - 最小核心，插件扩展
└── FormulaSystem (公式系统模式) - 三层架构，动态编译
```

---

## 🎯 原创模式价值评估

### 完全原创模式 ⭐⭐⭐
1. **Context (上下文模式)** - 完全原创，接口参数归一化+防呆设计+向后兼容，利用 Lua 5.4 分代 GC 支持其设计价值
2. **CommunicationBus (通讯总线模式)** - 原创多频道架构设计
3. **DataHandleQueue (数据队列解耦模式)** - 原创组合：责任链+队列解耦+推送链，三重机制
4. **Effective Range (有效范围优化模式)** - 原创智能范围限制，2268倍性能提升
5. **Delegate Pattern Pathfinding (委托模式寻路)** - 原创算法无关性设计
6. **Scope Mechanism (作用域机制)** - 原创多维度消息过滤
7. **Lifecycle Bridge (生命周期桥接模式)** - 原创C#-Lua自动映射

### 创新应用模式 ⭐⭐
4. **Template Configuration (模板化配置模式)** - 模板驱动的创新应用
5. **Handler Strategy (Handler策略模式)** - Handler组合的创新应用
6. **Real-time Fetch (实时获取模式)** - 零dirty标记的创新思路
7. **Condition-Action Decoupling (条件-动作解耦模式)** - 条件动作分离的创新应用

### 传统模式创新应用 ⭐
8. **Pipeline-Filter (管道-过滤器模式)** - 传统模式的项目应用
9. **Domain Controls Loop (领域控制循环模式)** - DDD模式的项目应用
10. **Microkernel (微内核模式)** - 传统模式的项目应用
11. **Formula System (公式系统模式)** - 编译模式的创新应用

---

## 💡 设计思路总结

### 核心设计理念
1. **解构结构** - 将复杂系统分解为简单组件
2. **统一接口** - 通过统一入口简化调用
3. **渐进式增强** - 功能可逐步添加，不破坏现有结构
4. **数据驱动** - 通过配置数据驱动行为
5. **状态管理** - 统一管理状态，避免分散

### 设计原则
- **单一职责** - 每个组件专注单一功能
- **开闭原则** - 对扩展开放，对修改关闭
- **依赖倒置** - 依赖抽象而非具体实现
- **接口隔离** - 提供最小必要接口
- **里氏替换** - 子类可替换父类

---

## 📝 原创模式的价值

### 核心价值
1. **解决实际问题** - 这些模式都来自实际项目需求，解决了传统模式无法很好解决的问题
2. **经过验证** - 所有模式都在项目中实际使用，经过验证
3. **可复用** - 模式设计通用，可在其他项目中复用
4. **创新组合** - 通过组合传统模式，创造出新的解决方案

### 与传统模式的区别
- **Context模式**：传统模式中没有接口参数归一化的设计理念，Context 模式通过统一使用 context 参数实现接口稳定性、防呆设计、向后兼容，并利用 Lua 5.4 分代 GC 支持其设计价值
- **CommunicationBus**：传统事件总线只有发布-订阅，这里创新性地组合了4种通信模式，并增加了作用域机制和推送链
- **DataHandleQueue**：责任链+队列解耦+推送链的三重组合，解决了多子系统协同和级联处理的问题
- **Effective Range**：传统网格系统处理全量数据，这里通过智能范围限制实现2268倍性能提升
- **Delegate Pattern Pathfinding**：传统寻路系统硬编码算法，这里通过委托模式实现算法无关性，支持智能推荐
- **Scope Mechanism**：传统消息系统只有全局广播，这里创新性地实现了4种作用域类型，精确过滤消息
- **Lifecycle Bridge**：传统C#-Lua桥接需要手动配置，这里通过自动映射实现零配置桥接

### 应用建议
1. 在项目初期考虑使用这些原创模式
2. 根据项目需求选择合适的模式组合
3. 理解模式的核心思想，而非照搬实现
4. 根据实际情况调整和优化模式实现
