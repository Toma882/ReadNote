{
    "sourceFile": "模块架构设计/原创设计模式.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 30,
            "patches": [
                {
                    "date": 1767267284480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767267289694,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n 本文档记录项目中原创或创新的设计模式，这些模式在传统设计模式库中不存在，或是对传统模式的创新组合和扩展。这些模式经过实际项目验证，具有独特的价值和适用场景。\r\n \r\n ---\r\n \r\n-## 🆕 可补充的设计模式\r\n+## 🆕 原创设计模式列表\r\n \r\n ### 1. Context (上下文模式) ⭐ **自创模式**\r\n \r\n **核心定义：**\r\n"
                },
                {
                    "date": 1767267296234,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n ---\r\n \r\n ## 🆕 原创设计模式列表\r\n \r\n-### 1. Context (上下文模式) ⭐ **自创模式**\r\n+### 1. Context (上下文模式) ⭐ **原创模式**\r\n \r\n **核心定义：**\r\n - 通过统一的上下文接口，实现渐进式增强和状态维护\r\n - 提供统一接口，隐藏内部复杂性\r\n"
                },
                {
                    "date": 1767267321425,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -199,9 +199,9 @@\n ```\r\n \r\n ---\r\n \r\n-### 6. CommunicationBus (通讯总线模式) ⭐ **多频道架构**\r\n+### 6. CommunicationBus (通讯总线模式) ⭐ **原创：多频道架构**\r\n \r\n **核心定义：**\r\n - 统一的通讯总线系统，通过多频道架构提供多种通信模式\r\n - 四种频道：发布-订阅、点对点、数据推送、请求-响应\r\n@@ -387,9 +387,9 @@\n ```\r\n \r\n ---\r\n \r\n-### 11. DataHandleQueue (数据队列解耦模式) ⭐ **责任链 + 队列解耦**\r\n+### 11. DataHandleQueue (数据队列解耦模式) ⭐ **原创：责任链 + 队列解耦**\r\n \r\n **核心定义：**\r\n - 通过队列实现模块间解耦通信，支持数据推送和查询委托两种机制\r\n - **责任链特性**：多个处理器按顺序处理数据，每个处理器检查是否有自己需要处理的数据类型\r\n@@ -470,47 +470,49 @@\n ```\r\n \r\n ---\r\n \r\n-## 📊 模式分类建议\r\n+## 📊 原创模式分类\r\n \r\n-### 新增分类：Architectural Patterns (架构模式)\r\n+### 原创设计模式分类\r\n \r\n ```\r\n-Architectural Patterns (架构模式) - 系统级架构设计\r\n-├── Context (上下文模式) ⭐ - 统一接口，渐进式增强，状态维护\r\n-├── CommunicationBus (通讯总线模式) ⭐ - 多频道架构，统一路由\r\n+原创设计模式 (Original Design Patterns)\r\n+├── Context (上下文模式) ⭐ - 统一接口，渐进式增强，状态维护（完全原创）\r\n+├── CommunicationBus (通讯总线模式) ⭐ - 多频道架构，统一路由（原创组合）\r\n+├── DataHandleQueue (数据队列解耦模式) ⭐ - 责任链 + 队列解耦，双重机制（原创组合）\r\n+├── TemplateConfiguration (模板化配置模式) - 模板驱动，自动初始化（创新应用）\r\n+├── HandlerStrategy (Handler策略模式) - Handler组合，管道执行（创新应用）\r\n+├── RealTimeFetch (实时获取模式) - 实时计算，零dirty标记（创新思路）\r\n+└── ConditionActionDecoupling (条件-动作解耦模式) - 条件动作分离，灵活绑定（创新应用）\r\n+\r\n+传统模式创新应用 (Innovative Applications of Traditional Patterns)\r\n ├── PipelineFilter (管道-过滤器模式) - 数据流处理，过滤器组合\r\n-├── TemplateConfiguration (模板化配置模式) - 模板驱动，自动初始化\r\n-├── ConditionActionDecoupling (条件-动作解耦模式) - 条件动作分离，灵活绑定\r\n-├── HandlerStrategy (Handler策略模式) - Handler组合，管道执行\r\n-├── RealTimeFetch (实时获取模式) - 实时计算，零dirty标记\r\n-├── DataHandleQueue (数据队列解耦模式) ⭐ - 责任链 + 队列解耦，双重机制\r\n ├── DomainControlsLoop (领域控制循环模式) - 领域驱动，循环处理\r\n ├── Microkernel (微内核模式) - 最小核心，插件扩展\r\n └── FormulaSystem (公式系统模式) - 三层架构，动态编译\r\n ```\r\n \r\n ---\r\n \r\n-## 🎯 推荐优先级\r\n+## 🎯 原创模式价值评估\r\n \r\n-### 高优先级（建议立即添加）⭐\r\n-1. **Context (上下文模式)** - 用户自创，核心设计模式\r\n-2. **CommunicationBus (通讯总线模式)** - 多频道架构，统一通信接口\r\n-3. **Template Configuration (模板化配置模式)** - 模板驱动，自动初始化\r\n+### 完全原创模式 ⭐⭐⭐\r\n+1. **Context (上下文模式)** - 完全原创，统一接口+渐进式增强+状态维护\r\n+2. **CommunicationBus (通讯总线模式)** - 原创多频道架构设计\r\n+3. **DataHandleQueue (数据队列解耦模式)** - 原创组合：责任链+队列解耦\r\n \r\n-### 中优先级（可考虑添加）\r\n-4. **Handler Strategy (Handler策略模式)** - Handler组合，灵活扩展\r\n-5. **Real-time Fetch (实时获取模式)** - 实时计算，零dirty标记\r\n-6. **Condition-Action Decoupling (条件-动作解耦模式)** - 条件动作分离\r\n-7. **Pipeline-Filter (管道-过滤器模式)** - 常见架构模式，实用性强\r\n-8. **DataHandleQueue (数据队列解耦模式)** ⭐ - 责任链 + 队列解耦，双重机制\r\n+### 创新应用模式 ⭐⭐\r\n+4. **Template Configuration (模板化配置模式)** - 模板驱动的创新应用\r\n+5. **Handler Strategy (Handler策略模式)** - Handler组合的创新应用\r\n+6. **Real-time Fetch (实时获取模式)** - 零dirty标记的创新思路\r\n+7. **Condition-Action Decoupling (条件-动作解耦模式)** - 条件动作分离的创新应用\r\n \r\n-### 低优先级（可选）\r\n-9. **Microkernel (微内核模式)** - 框架设计常用\r\n-10. **Formula System (公式系统模式)** - 特定场景很有价值\r\n-11. **Domain Controls Loop (领域控制循环模式)** - 特定于 DDD 场景\r\n+### 传统模式创新应用 ⭐\r\n+8. **Pipeline-Filter (管道-过滤器模式)** - 传统模式的项目应用\r\n+9. **Domain Controls Loop (领域控制循环模式)** - DDD模式的项目应用\r\n+10. **Microkernel (微内核模式)** - 传统模式的项目应用\r\n+11. **Formula System (公式系统模式)** - 编译模式的创新应用\r\n \r\n ---\r\n \r\n ## 💡 设计思路总结\r\n"
                },
                {
                    "date": 1767267329936,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -532,10 +532,22 @@\n - **里氏替换** - 子类可替换父类\r\n \r\n ---\r\n \r\n-## 📝 下一步行动\r\n+## 📝 原创模式的价值\r\n \r\n-1. 将 Context 模式添加到设计模式库（高优先级）\r\n-2. 为每个新模式创建详细的流程图\r\n-3. 补充实际应用场景和代码示例\r\n-4. 更新设计模式分类体系\r\n+### 核心价值\r\n+1. **解决实际问题** - 这些模式都来自实际项目需求，解决了传统模式无法很好解决的问题\r\n+2. **经过验证** - 所有模式都在项目中实际使用，经过验证\r\n+3. **可复用** - 模式设计通用，可在其他项目中复用\r\n+4. **创新组合** - 通过组合传统模式，创造出新的解决方案\r\n+\r\n+### 与传统模式的区别\r\n+- **Context模式**：传统模式中没有统一的上下文管理+渐进式增强模式\r\n+- **CommunicationBus**：传统事件总线只有发布-订阅，这里创新性地组合了4种通信模式\r\n+- **DataHandleQueue**：责任链+队列解耦的组合，解决了多子系统协同的问题\r\n+\r\n+### 应用建议\r\n+1. 在项目初期考虑使用这些原创模式\r\n+2. 根据项目需求选择合适的模式组合\r\n+3. 理解模式的核心思想，而非照搬实现\r\n+4. 根据实际情况调整和优化模式实现\r\n"
                },
                {
                    "date": 1767267416038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -470,8 +470,204 @@\n ```\r\n \r\n ---\r\n \r\n+### 12. Push Chain (推送链模式) ⭐ **原创：链式数据流**\r\n+\r\n+**核心定义：**\r\n+- 在数据处理过程中，处理一个数据类型时可以触发下一个数据类型的推送\r\n+- 形成链式数据流，实现数据驱动的级联处理\r\n+- 支持复杂的数据依赖关系处理\r\n+\r\n+**核心特点：**\r\n+- **链式触发**：处理数据类型A时，可以推送数据类型B，形成链式处理\r\n+- **数据驱动**：通过配置定义推送链关系，无需硬编码\r\n+- **自动级联**：数据变化自动触发后续处理\r\n+- **解耦设计**：推送链中的每个环节相互独立\r\n+\r\n+**适用场景：**\r\n+- 复杂的数据依赖关系\r\n+- 级联数据更新\r\n+- 数据驱动的业务逻辑\r\n+- 装备→专长→技能→效果的链式处理\r\n+\r\n+**流程图：**\r\n+```mermaid\r\n+flowchart LR\r\n+    A[初始触发<br/>EquipInstall] -->|处理时推送| B[FeatInstall<br/>专长安装]\r\n+    B -->|处理时推送| C[SkillData<br/>技能数据]\r\n+    C -->|处理时推送| D[EffectData<br/>效果数据]\r\n+    D --> E[链式处理完成]\r\n+    \r\n+    style A fill:#e1f5ff\r\n+    style B fill:#fff4e1\r\n+    style C fill:#fff4e1\r\n+    style D fill:#fff4e1\r\n+    style E fill:#c8e6c9\r\n+```\r\n+\r\n+---\r\n+\r\n+### 13. Effective Range (有效范围优化模式) ⭐ **原创：智能范围限制**\r\n+\r\n+**核心定义：**\r\n+- 只处理玩家周围有效范围内的数据，大幅降低计算和内存开销\r\n+- 通过智能范围限制，实现2268倍性能提升\r\n+- 结合位图优化和Shader可视化，实现高性能网格系统\r\n+\r\n+**核心特点：**\r\n+- **智能范围**：只处理有效范围内的数据，忽略无效区域\r\n+- **性能提升**：内存占用从1000000降低到441，2268倍提升\r\n+- **位图优化**：O(1)复杂度查询，85%性能提升\r\n+- **Shader可视化**：单DrawCall渲染，极低开销\r\n+\r\n+**适用场景：**\r\n+- 大型网格系统\r\n+- 空间查询系统\r\n+- 碰撞检测系统\r\n+- 需要处理大量空间数据的场景\r\n+\r\n+**流程图：**\r\n+```mermaid\r\n+flowchart TD\r\n+    A[网格查询请求] --> B[计算有效范围]\r\n+    B --> C{数据在有效范围内?}\r\n+    C -->|是| D[位图O(1)查询]\r\n+    C -->|否| E[跳过处理]\r\n+    D --> F[返回结果]\r\n+    E --> G[不处理]\r\n+    \r\n+    H[Shader可视化] --> I[单DrawCall渲染]\r\n+    \r\n+    style B fill:#e1f5ff\r\n+    style C fill:#fff4e1\r\n+    style D fill:#c8e6c9\r\n+```\r\n+\r\n+---\r\n+\r\n+### 14. Delegate Pattern Pathfinding (委托模式寻路) ⭐ **原创：算法无关性设计**\r\n+\r\n+**核心定义：**\r\n+- 通过委托模式消除硬编码，实现算法无关性设计\r\n+- 支持6种寻路算法，智能推荐最优算法\r\n+- 统一数据结构，零拆装箱，高性能\r\n+\r\n+**核心特点：**\r\n+- **算法无关**：通过委托模式消除硬编码，算法可替换\r\n+- **智能推荐**：根据网格大小、权重情况、精度要求自动推荐最优算法\r\n+- **零拆装箱**：统一数据结构，避免性能损耗\r\n+- **灵活扩展**：新增算法不影响现有代码\r\n+\r\n+**适用场景：**\r\n+- 寻路系统\r\n+- 路径规划系统\r\n+- 需要多种算法选择的场景\r\n+- 算法性能对比和优化\r\n+\r\n+**流程图：**\r\n+```mermaid\r\n+flowchart TD\r\n+    A[寻路请求] --> B[分析场景参数]\r\n+    B --> C[智能推荐算法]\r\n+    C --> D{算法类型}\r\n+    D -->|A*| E[执行A*算法]\r\n+    D -->|JPS| F[执行JPS算法]\r\n+    D -->|BFS| G[执行BFS算法]\r\n+    D -->|其他| H[执行其他算法]\r\n+    E --> I[返回路径]\r\n+    F --> I\r\n+    G --> I\r\n+    H --> I\r\n+    \r\n+    style B fill:#e1f5ff\r\n+    style C fill:#fff4e1\r\n+    style D fill:#ffccbc\r\n+```\r\n+\r\n+---\r\n+\r\n+### 15. Scope Mechanism (作用域机制) ⭐ **原创：多维度消息过滤**\r\n+\r\n+**核心定义：**\r\n+- 通过四种作用域类型过滤消息接收者\r\n+- 实现精确的消息路由，避免不必要的消息传递\r\n+- 支持全局、局部、组、距离等多种作用域\r\n+\r\n+**核心特点：**\r\n+- **四种作用域**：Global、Local、Group、Range\r\n+- **精确过滤**：根据作用域类型精确过滤接收者\r\n+- **性能优化**：避免不必要的消息传递和处理\r\n+- **灵活配置**：支持多种作用域组合使用\r\n+\r\n+**适用场景：**\r\n+- 事件系统\r\n+- 消息系统\r\n+- 需要精确消息路由的场景\r\n+- 多人游戏中的消息分发\r\n+\r\n+**流程图：**\r\n+```mermaid\r\n+flowchart TD\r\n+    A[发送消息] --> B[指定作用域类型]\r\n+    B --> C{作用域类型}\r\n+    C -->|Global| D[所有订阅者]\r\n+    C -->|Local| E[局部范围订阅者]\r\n+    C -->|Group| F[同组订阅者]\r\n+    C -->|Range| G[距离范围内订阅者]\r\n+    D --> H[过滤并发送]\r\n+    E --> H\r\n+    F --> H\r\n+    G --> H\r\n+    H --> I[接收者处理消息]\r\n+    \r\n+    style B fill:#e1f5ff\r\n+    style C fill:#fff4e1\r\n+    style H fill:#c8e6c9\r\n+```\r\n+\r\n+---\r\n+\r\n+### 16. Lifecycle Bridge (生命周期桥接模式) ⭐ **原创：C#-Lua自动映射**\r\n+\r\n+**核心定义：**\r\n+- 通过自动映射机制实现C#和Lua之间的生命周期桥接\r\n+- 统一生命周期管理，支持所有Unity生命周期事件\r\n+- 通过mappingName自动映射Lua函数，零配置\r\n+\r\n+**核心特点：**\r\n+- **自动映射**：通过mappingName自动映射Lua函数\r\n+- **完整生命周期**：支持所有Unity生命周期事件\r\n+- **零配置**：无需手动配置映射关系\r\n+- **编辑器工具**：自动生成对应的Lua函数文件\r\n+\r\n+**适用场景：**\r\n+- C#-Lua混合架构\r\n+- Unity生命周期管理\r\n+- 需要C#和Lua交互的场景\r\n+- 快速开发原型\r\n+\r\n+**流程图：**\r\n+```mermaid\r\n+flowchart TD\r\n+    A[C# MonoLifecycle] --> B[设置mappingName]\r\n+    B --> C[Unity生命周期事件]\r\n+    C --> D[自动查找Lua函数]\r\n+    D --> E{函数是否存在?}\r\n+    E -->|是| F[调用Lua函数]\r\n+    E -->|否| G[跳过]\r\n+    F --> H[Lua处理逻辑]\r\n+    H --> I[返回结果]\r\n+    \r\n+    J[编辑器工具] --> K[自动生成Lua函数模板]\r\n+    \r\n+    style B fill:#e1f5ff\r\n+    style D fill:#fff4e1\r\n+    style K fill:#c8e6c9\r\n+```\r\n+\r\n+---\r\n+\r\n ## 📊 原创模式分类\r\n \r\n ### 原创设计模式分类\r\n \r\n"
                },
                {
                    "date": 1767267429116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -675,8 +675,13 @@\n 原创设计模式 (Original Design Patterns)\r\n ├── Context (上下文模式) ⭐ - 统一接口，渐进式增强，状态维护（完全原创）\r\n ├── CommunicationBus (通讯总线模式) ⭐ - 多频道架构，统一路由（原创组合）\r\n ├── DataHandleQueue (数据队列解耦模式) ⭐ - 责任链 + 队列解耦，双重机制（原创组合）\r\n+├── PushChain (推送链模式) ⭐ - 链式数据流，级联处理（原创机制）\r\n+├── EffectiveRange (有效范围优化模式) ⭐ - 智能范围限制，2268倍性能提升（原创优化）\r\n+├── DelegatePatternPathfinding (委托模式寻路) ⭐ - 算法无关性设计，智能推荐（原创设计）\r\n+├── ScopeMechanism (作用域机制) ⭐ - 多维度消息过滤，精确路由（原创机制）\r\n+├── LifecycleBridge (生命周期桥接模式) ⭐ - C#-Lua自动映射，零配置（原创桥接）\r\n ├── TemplateConfiguration (模板化配置模式) - 模板驱动，自动初始化（创新应用）\r\n ├── HandlerStrategy (Handler策略模式) - Handler组合，管道执行（创新应用）\r\n ├── RealTimeFetch (实时获取模式) - 实时计算，零dirty标记（创新思路）\r\n └── ConditionActionDecoupling (条件-动作解耦模式) - 条件动作分离，灵活绑定（创新应用）\r\n@@ -695,8 +700,13 @@\n ### 完全原创模式 ⭐⭐⭐\r\n 1. **Context (上下文模式)** - 完全原创，统一接口+渐进式增强+状态维护\r\n 2. **CommunicationBus (通讯总线模式)** - 原创多频道架构设计\r\n 3. **DataHandleQueue (数据队列解耦模式)** - 原创组合：责任链+队列解耦\r\n+4. **Push Chain (推送链模式)** - 原创链式数据流机制\r\n+5. **Effective Range (有效范围优化模式)** - 原创智能范围限制，2268倍性能提升\r\n+6. **Delegate Pattern Pathfinding (委托模式寻路)** - 原创算法无关性设计\r\n+7. **Scope Mechanism (作用域机制)** - 原创多维度消息过滤\r\n+8. **Lifecycle Bridge (生命周期桥接模式)** - 原创C#-Lua自动映射\r\n \r\n ### 创新应用模式 ⭐⭐\r\n 4. **Template Configuration (模板化配置模式)** - 模板驱动的创新应用\r\n 5. **Handler Strategy (Handler策略模式)** - Handler组合的创新应用\r\n"
                },
                {
                    "date": 1767267437579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -748,10 +748,15 @@\n 4. **创新组合** - 通过组合传统模式，创造出新的解决方案\r\n \r\n ### 与传统模式的区别\r\n - **Context模式**：传统模式中没有统一的上下文管理+渐进式增强模式\r\n-- **CommunicationBus**：传统事件总线只有发布-订阅，这里创新性地组合了4种通信模式\r\n+- **CommunicationBus**：传统事件总线只有发布-订阅，这里创新性地组合了4种通信模式，并增加了作用域机制和推送链\r\n - **DataHandleQueue**：责任链+队列解耦的组合，解决了多子系统协同的问题\r\n+- **Push Chain**：传统数据处理是独立的，这里创新性地实现了链式数据流，支持级联处理\r\n+- **Effective Range**：传统网格系统处理全量数据，这里通过智能范围限制实现2268倍性能提升\r\n+- **Delegate Pattern Pathfinding**：传统寻路系统硬编码算法，这里通过委托模式实现算法无关性，支持智能推荐\r\n+- **Scope Mechanism**：传统消息系统只有全局广播，这里创新性地实现了4种作用域类型，精确过滤消息\r\n+- **Lifecycle Bridge**：传统C#-Lua桥接需要手动配置，这里通过自动映射实现零配置桥接\r\n \r\n ### 应用建议\r\n 1. 在项目初期考虑使用这些原创模式\r\n 2. 根据项目需求选择合适的模式组合\r\n"
                },
                {
                    "date": 1767267570147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -387,13 +387,14 @@\n ```\r\n \r\n ---\r\n \r\n-### 11. DataHandleQueue (数据队列解耦模式) ⭐ **原创：责任链 + 队列解耦**\r\n+### 11. DataHandleQueue (数据队列解耦模式) ⭐ **原创：责任链 + 队列解耦 + 推送链**\r\n \r\n **核心定义：**\r\n - 通过队列实现模块间解耦通信，支持数据推送和查询委托两种机制\r\n - **责任链特性**：多个处理器按顺序处理数据，每个处理器检查是否有自己需要处理的数据类型\r\n+- **推送链特性**：处理一个数据类型时可以触发下一个数据类型的推送，形成链式数据流\r\n - 模块通过队列发送和接收数据，不直接相互调用\r\n - 处理器映射表管理不同类型的处理，查询委托表管理查询接口\r\n \r\n **核心特点：**\r\n@@ -404,8 +405,13 @@\n   - 多个处理器（handlers）按顺序排列\r\n   - 每个处理器检查是否有自己需要处理的数据类型\r\n   - 如果有数据，就处理并可能提前返回\r\n   - 如果没有，就继续传递给下一个处理器（通过遍历机制）\r\n+- **推送链机制**：\r\n+  - 处理数据类型A时，可以推送数据类型B，形成链式处理\r\n+  - 支持复杂的数据依赖关系，实现数据驱动的级联处理\r\n+  - 推送链中的每个环节相互独立，解耦设计\r\n+  - 典型应用：装备安装 → 专长安装 → 技能数据 → 效果数据\r\n - **队列解耦**：模块间通过队列通信，不直接依赖\r\n - **处理器映射**：通过 SetProcessHandleMapping 注册处理器映射表\r\n - **查询统一**：通过 SetQueryDelegate 统一管理查询接口\r\n - **模块独立**：模块可以独立开发、测试，通过队列解耦\r\n"
                },
                {
                    "date": 1767267584773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -427,8 +427,10 @@\n - 多子系统协同的系统（如 UnitData 管理装备、技能、状态等子系统）\r\n - 模块间解耦通信\r\n - 需要统一查询接口的系统\r\n - 数据变化需要通知多个模块的场景\r\n+- 复杂的数据依赖关系（通过推送链实现级联处理）\r\n+- 数据驱动的业务逻辑（装备→专长→技能→效果的链式处理）\r\n \r\n **流程图：**\r\n ```mermaid\r\n flowchart TD\r\n@@ -438,42 +440,52 @@\n     \r\n     D --> E[遍历处理器列表]\r\n     E --> F[处理器1: ProcessDataHandler]\r\n     F --> G{检查是否有<br/>需要处理的数据?}\r\n-    G -->|有| H[处理数据并返回]\r\n+    G -->|有| H[处理数据]\r\n     G -->|无| I[继续下一个处理器]\r\n     \r\n-    I --> J[处理器2: ProcessDataHandler]\r\n-    J --> K{检查是否有<br/>需要处理的数据?}\r\n-    K -->|有| L[处理数据并返回]\r\n-    K -->|无| M[继续下一个处理器]\r\n+    H --> J[OnDataHandler<br/>遍历processHandlerMapping]\r\n+    J --> K[HandleAllData<br/>处理队列数据]\r\n+    K --> L{处理时是否<br/>触发推送链?}\r\n+    L -->|是| M[PushData<br/>推送下一个数据类型]\r\n+    L -->|否| N[完成处理]\r\n+    M --> C\r\n     \r\n-    M --> N[处理器N: ProcessDataHandler]\r\n-    N --> O{检查是否有<br/>需要处理的数据?}\r\n-    O -->|有| P[处理数据]\r\n-    O -->|无| Q[责任链结束]\r\n+    I --> O[处理器2: ProcessDataHandler]\r\n+    O --> P{检查是否有<br/>需要处理的数据?}\r\n+    P -->|有| Q[处理数据]\r\n+    P -->|无| R[继续下一个处理器]\r\n+    Q --> J\r\n     \r\n-    H --> R[OnDataHandler<br/>遍历processHandlerMapping]\r\n-    L --> R\r\n-    P --> R\r\n-    R --> S[HandleAllData<br/>处理队列数据]\r\n-    S --> T[调用对应处理函数]\r\n+    R --> S[处理器N: ProcessDataHandler]\r\n+    S --> T{检查是否有<br/>需要处理的数据?}\r\n+    T -->|有| U[处理数据]\r\n+    T -->|无| V[责任链结束]\r\n+    U --> J\r\n     \r\n-    U[外部查询] --> V[QueryData<br/>查询数据]\r\n-    V --> W[查找查询委托表]\r\n-    W --> X[找到对应委托函数]\r\n-    X --> Y[执行查询并返回]\r\n+    W[推送链示例] --> X[EquipInstall<br/>装备安装]\r\n+    X -->|处理时推送| Y[FeatInstall<br/>专长安装]\r\n+    Y -->|处理时推送| Z[SkillData<br/>技能数据]\r\n+    Z -->|处理时推送| AA[EffectData<br/>效果数据]\r\n+    AA --> AB[链式处理完成]\r\n     \r\n-    Z[初始化] --> AA[AddHandler<br/>添加子系统到责任链]\r\n-    AA --> BB[SetProcessHandleMapping<br/>注册处理器映射表]\r\n-    BB --> CC[SetQueryDelegate<br/>注册查询]\r\n+    AC[外部查询] --> AD[QueryData<br/>查询数据]\r\n+    AD --> AE[查找查询委托表]\r\n+    AE --> AF[找到对应委托函数]\r\n+    AF --> AG[执行查询并返回]\r\n     \r\n+    AH[初始化] --> AI[AddHandler<br/>添加子系统到责任链]\r\n+    AI --> AJ[SetProcessHandleMapping<br/>注册处理器映射表]\r\n+    AJ --> AK[SetQueryDelegate<br/>注册查询]\r\n+    \r\n     style C fill:#e1f5ff\r\n     style D fill:#fff4e1\r\n     style G fill:#ffccbc\r\n-    style K fill:#ffccbc\r\n-    style O fill:#ffccbc\r\n-    style AA fill:#c8e6c9\r\n+    style L fill:#ffccbc\r\n+    style M fill:#c8e6c9\r\n+    style W fill:#f3e5f5\r\n+    style AI fill:#c8e6c9\r\n ```\r\n \r\n ---\r\n \r\n"
                },
                {
                    "date": 1767267592050,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -488,44 +488,8 @@\n ```\r\n \r\n ---\r\n \r\n-### 12. Push Chain (推送链模式) ⭐ **原创：链式数据流**\r\n-\r\n-**核心定义：**\r\n-- 在数据处理过程中，处理一个数据类型时可以触发下一个数据类型的推送\r\n-- 形成链式数据流，实现数据驱动的级联处理\r\n-- 支持复杂的数据依赖关系处理\r\n-\r\n-**核心特点：**\r\n-- **链式触发**：处理数据类型A时，可以推送数据类型B，形成链式处理\r\n-- **数据驱动**：通过配置定义推送链关系，无需硬编码\r\n-- **自动级联**：数据变化自动触发后续处理\r\n-- **解耦设计**：推送链中的每个环节相互独立\r\n-\r\n-**适用场景：**\r\n-- 复杂的数据依赖关系\r\n-- 级联数据更新\r\n-- 数据驱动的业务逻辑\r\n-- 装备→专长→技能→效果的链式处理\r\n-\r\n-**流程图：**\r\n-```mermaid\r\n-flowchart LR\r\n-    A[初始触发<br/>EquipInstall] -->|处理时推送| B[FeatInstall<br/>专长安装]\r\n-    B -->|处理时推送| C[SkillData<br/>技能数据]\r\n-    C -->|处理时推送| D[EffectData<br/>效果数据]\r\n-    D --> E[链式处理完成]\r\n-    \r\n-    style A fill:#e1f5ff\r\n-    style B fill:#fff4e1\r\n-    style C fill:#fff4e1\r\n-    style D fill:#fff4e1\r\n-    style E fill:#c8e6c9\r\n-```\r\n-\r\n----\r\n-\r\n ### 13. Effective Range (有效范围优化模式) ⭐ **原创：智能范围限制**\r\n \r\n **核心定义：**\r\n - 只处理玩家周围有效范围内的数据，大幅降低计算和内存开销\r\n"
                },
                {
                    "date": 1767267602740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -488,9 +488,9 @@\n ```\r\n \r\n ---\r\n \r\n-### 13. Effective Range (有效范围优化模式) ⭐ **原创：智能范围限制**\r\n+### 12. Effective Range (有效范围优化模式) ⭐ **原创：智能范围限制**\r\n \r\n **核心定义：**\r\n - 只处理玩家周围有效范围内的数据，大幅降低计算和内存开销\r\n - 通过智能范围限制，实现2268倍性能提升\r\n@@ -526,9 +526,9 @@\n ```\r\n \r\n ---\r\n \r\n-### 14. Delegate Pattern Pathfinding (委托模式寻路) ⭐ **原创：算法无关性设计**\r\n+### 13. Delegate Pattern Pathfinding (委托模式寻路) ⭐ **原创：算法无关性设计**\r\n \r\n **核心定义：**\r\n - 通过委托模式消除硬编码，实现算法无关性设计\r\n - 支持6种寻路算法，智能推荐最优算法\r\n"
                },
                {
                    "date": 1767267612546,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -608,9 +608,9 @@\n ```\r\n \r\n ---\r\n \r\n-### 16. Lifecycle Bridge (生命周期桥接模式) ⭐ **原创：C#-Lua自动映射**\r\n+### 15. Lifecycle Bridge (生命周期桥接模式) ⭐ **原创：C#-Lua自动映射**\r\n \r\n **核心定义：**\r\n - 通过自动映射机制实现C#和Lua之间的生命周期桥接\r\n - 统一生命周期管理，支持所有Unity生命周期事件\r\n"
                },
                {
                    "date": 1767267626210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -567,9 +567,9 @@\n ```\r\n \r\n ---\r\n \r\n-### 15. Scope Mechanism (作用域机制) ⭐ **原创：多维度消息过滤**\r\n+### 14. Scope Mechanism (作用域机制) ⭐ **原创：多维度消息过滤**\r\n \r\n **核心定义：**\r\n - 通过四种作用域类型过滤消息接收者\r\n - 实现精确的消息路由，避免不必要的消息传递\r\n@@ -656,10 +656,9 @@\n ```\r\n 原创设计模式 (Original Design Patterns)\r\n ├── Context (上下文模式) ⭐ - 统一接口，渐进式增强，状态维护（完全原创）\r\n ├── CommunicationBus (通讯总线模式) ⭐ - 多频道架构，统一路由（原创组合）\r\n-├── DataHandleQueue (数据队列解耦模式) ⭐ - 责任链 + 队列解耦，双重机制（原创组合）\r\n-├── PushChain (推送链模式) ⭐ - 链式数据流，级联处理（原创机制）\r\n+├── DataHandleQueue (数据队列解耦模式) ⭐ - 责任链 + 队列解耦 + 推送链，三重机制（原创组合）\r\n ├── EffectiveRange (有效范围优化模式) ⭐ - 智能范围限制，2268倍性能提升（原创优化）\r\n ├── DelegatePatternPathfinding (委托模式寻路) ⭐ - 算法无关性设计，智能推荐（原创设计）\r\n ├── ScopeMechanism (作用域机制) ⭐ - 多维度消息过滤，精确路由（原创机制）\r\n ├── LifecycleBridge (生命周期桥接模式) ⭐ - C#-Lua自动映射，零配置（原创桥接）\r\n"
                },
                {
                    "date": 1767267638559,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -680,14 +680,13 @@\n \r\n ### 完全原创模式 ⭐⭐⭐\r\n 1. **Context (上下文模式)** - 完全原创，统一接口+渐进式增强+状态维护\r\n 2. **CommunicationBus (通讯总线模式)** - 原创多频道架构设计\r\n-3. **DataHandleQueue (数据队列解耦模式)** - 原创组合：责任链+队列解耦\r\n-4. **Push Chain (推送链模式)** - 原创链式数据流机制\r\n-5. **Effective Range (有效范围优化模式)** - 原创智能范围限制，2268倍性能提升\r\n-6. **Delegate Pattern Pathfinding (委托模式寻路)** - 原创算法无关性设计\r\n-7. **Scope Mechanism (作用域机制)** - 原创多维度消息过滤\r\n-8. **Lifecycle Bridge (生命周期桥接模式)** - 原创C#-Lua自动映射\r\n+3. **DataHandleQueue (数据队列解耦模式)** - 原创组合：责任链+队列解耦+推送链，三重机制\r\n+4. **Effective Range (有效范围优化模式)** - 原创智能范围限制，2268倍性能提升\r\n+5. **Delegate Pattern Pathfinding (委托模式寻路)** - 原创算法无关性设计\r\n+6. **Scope Mechanism (作用域机制)** - 原创多维度消息过滤\r\n+7. **Lifecycle Bridge (生命周期桥接模式)** - 原创C#-Lua自动映射\r\n \r\n ### 创新应用模式 ⭐⭐\r\n 4. **Template Configuration (模板化配置模式)** - 模板驱动的创新应用\r\n 5. **Handler Strategy (Handler策略模式)** - Handler组合的创新应用\r\n@@ -730,10 +729,9 @@\n \r\n ### 与传统模式的区别\r\n - **Context模式**：传统模式中没有统一的上下文管理+渐进式增强模式\r\n - **CommunicationBus**：传统事件总线只有发布-订阅，这里创新性地组合了4种通信模式，并增加了作用域机制和推送链\r\n-- **DataHandleQueue**：责任链+队列解耦的组合，解决了多子系统协同的问题\r\n-- **Push Chain**：传统数据处理是独立的，这里创新性地实现了链式数据流，支持级联处理\r\n+- **DataHandleQueue**：责任链+队列解耦+推送链的三重组合，解决了多子系统协同和级联处理的问题\r\n - **Effective Range**：传统网格系统处理全量数据，这里通过智能范围限制实现2268倍性能提升\r\n - **Delegate Pattern Pathfinding**：传统寻路系统硬编码算法，这里通过委托模式实现算法无关性，支持智能推荐\r\n - **Scope Mechanism**：传统消息系统只有全局广播，这里创新性地实现了4种作用域类型，精确过滤消息\r\n - **Lifecycle Bridge**：传统C#-Lua桥接需要手动配置，这里通过自动映射实现零配置桥接\r\n"
                },
                {
                    "date": 1767267735004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,26 +7,39 @@\n ---\r\n \r\n ## 🆕 原创设计模式列表\r\n \r\n-### 1. Context (上下文模式) ⭐ **原创模式**\r\n+### 1. Context (上下文模式) ⭐ **原创模式：接口参数归一化**\r\n \r\n **核心定义：**\r\n-- 通过统一的上下文接口，实现渐进式增强和状态维护\r\n-- 提供统一接口，隐藏内部复杂性\r\n-- 支持状态的统一管理和传递\r\n+- **接口参数归一化**：所有系统统一使用 `context` 作为函数参数，实现接口稳定性\r\n+- **防呆设计**：通过统一的 Context 参数，避免参数顺序错误、参数遗漏等问题\r\n+- **简单一致 > 复杂优化**：直接创建 Context，利用 Lua 5.4 分代 GC 自动优化，零心智负担\r\n+- **向后兼容**：Context 内部可任意扩展，新增字段不破坏接口，不影响旧代码\r\n \r\n+**核心价值：**\r\n+- **接口稳定**：新增字段不破坏接口，向后兼容，接口长期稳定\r\n+- **语义清晰**：自解释的参数命名（如 `context.source`、`context.target`），易于理解\r\n+- **跨系统传递**：Context 在调用链中传递，零成本集成，信息逐步累积\r\n+- **信息累积**：逐步积累流程数据，完整追踪整个调用链的信息\r\n+\r\n **核心特点：**\r\n-- **统一接口**：所有操作通过 Context 统一入口\r\n-- **渐进式增强**：功能可以逐步添加到 Context 中\r\n-- **状态维护**：Context 维护系统状态，避免状态分散\r\n-- **解耦设计**：客户端不直接依赖具体实现\r\n+- **接口归一化**：所有系统统一使用 `context` 作为函数参数，接口一致\r\n+- **参数灵活性**：Context 内部可任意扩展，不破坏接口\r\n+- **零心智负担**：统一标准，直接创建 table，Lua 5.4 自动优化 GC\r\n+- **防呆设计**：避免参数顺序错误、参数遗漏、参数类型错误等问题\r\n+- **渐进式增强**：功能可以逐步添加到 Context 中，不影响现有代码\r\n \r\n+**使用规则：**\r\n+- ✅ **使用 Context**：参数>3个、可能扩展、需长期稳定、跨系统传递\r\n+- ❌ **直接传参**：数学函数、参数固定、局部工具函数、简单计算\r\n+\r\n **适用场景：**\r\n-- 需要统一管理多个子系统\r\n-- 需要维护全局状态\r\n-- 需要渐进式扩展功能\r\n-- 需要简化客户端调用\r\n+- 需要统一接口的系统（如 CommunicationBus、Skill、Effect 等）\r\n+- 需要跨系统传递数据的场景\r\n+- 需要长期稳定接口的系统\r\n+- 参数可能扩展的函数\r\n+- 需要完整追踪调用链信息的场景\r\n \r\n **流程图：**\r\n ```mermaid\r\n flowchart TD\r\n"
                },
                {
                    "date": 1767267743139,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,26 +42,58 @@\n \r\n **流程图：**\r\n ```mermaid\r\n flowchart TD\r\n-    A[客户端请求] --> B[Context 统一入口]\r\n-    B --> C[维护系统状态]\r\n-    C --> D{功能类型}\r\n-    D -->|功能A| E[调用子系统A]\r\n-    D -->|功能B| F[调用子系统B]\r\n-    D -->|功能C| G[调用子系统C]\r\n-    E --> H[更新 Context 状态]\r\n-    F --> H\r\n-    G --> H\r\n-    H --> I[返回结果给客户端]\r\n+    A[函数调用] --> B[创建 Context<br/>统一参数接口]\r\n+    B --> C[填充基础信息<br/>source/target/data等]\r\n+    C --> D[调用系统A<br/>传递 Context]\r\n+    D --> E[系统A处理<br/>增强 Context 信息]\r\n+    E --> F[调用系统B<br/>传递 Context]\r\n+    F --> G[系统B处理<br/>继续增强 Context]\r\n+    G --> H[调用系统C<br/>传递 Context]\r\n+    H --> I[系统C处理<br/>完成处理]\r\n+    I --> J[返回结果<br/>Context 信息完整]\r\n     \r\n-    J[渐进式增强] -.->|动态添加| B\r\n+    K[接口稳定] -.->|新增字段| B\r\n+    L[向后兼容] -.->|不影响旧代码| B\r\n+    M[信息累积] -.->|逐步增强| E\r\n     \r\n     style B fill:#e1f5ff\r\n     style C fill:#fff4e1\r\n-    style J fill:#c8e6c9\r\n+    style K fill:#c8e6c9\r\n+    style L fill:#c8e6c9\r\n+    style M fill:#c8e6c9\r\n ```\r\n \r\n+**实际应用示例：**\r\n+```lua\r\n+-- CommunicationBus 使用 Context\r\n+local context = {\r\n+    channelType = ChannelType.Event,\r\n+    broadcastId = EEvent.PlayerLevelUp,\r\n+    scopeType = ScopeType.Global\r\n+}\r\n+CommunicationBus:Broadcast(context, {level = 10})\r\n+\r\n+-- Skill 系统使用 Context\r\n+local skillContext = {\r\n+    caster = unit,\r\n+    target = target,\r\n+    skillId = skillId,\r\n+    -- 逐步增强，添加更多信息\r\n+}\r\n+SkillBase:Execute(skillContext)\r\n+\r\n+-- Effect 系统使用 Context\r\n+local effectContext = {\r\n+    source = source,\r\n+    target = target,\r\n+    effectId = effectId,\r\n+    -- 信息在调用链中累积\r\n+}\r\n+EffectSystem:Apply(effectContext)\r\n+```\r\n+\r\n ---\r\n \r\n ### 2. Pipeline-Filter (管道-过滤器模式)\r\n \r\n"
                },
                {
                    "date": 1767267753584,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -723,9 +723,9 @@\n \r\n ## 🎯 原创模式价值评估\r\n \r\n ### 完全原创模式 ⭐⭐⭐\r\n-1. **Context (上下文模式)** - 完全原创，统一接口+渐进式增强+状态维护\r\n+1. **Context (上下文模式)** - 完全原创，接口参数归一化+防呆设计+向后兼容，利用 Lua 5.4 分代 GC 支持其设计价值\r\n 2. **CommunicationBus (通讯总线模式)** - 原创多频道架构设计\r\n 3. **DataHandleQueue (数据队列解耦模式)** - 原创组合：责任链+队列解耦+推送链，三重机制\r\n 4. **Effective Range (有效范围优化模式)** - 原创智能范围限制，2268倍性能提升\r\n 5. **Delegate Pattern Pathfinding (委托模式寻路)** - 原创算法无关性设计\r\n@@ -772,9 +772,9 @@\n 3. **可复用** - 模式设计通用，可在其他项目中复用\r\n 4. **创新组合** - 通过组合传统模式，创造出新的解决方案\r\n \r\n ### 与传统模式的区别\r\n-- **Context模式**：传统模式中没有统一的上下文管理+渐进式增强模式\r\n+- **Context模式**：传统模式中没有接口参数归一化的设计理念，Context 模式通过统一使用 context 参数实现接口稳定性、防呆设计、向后兼容，并利用 Lua 5.4 分代 GC 支持其设计价值\r\n - **CommunicationBus**：传统事件总线只有发布-订阅，这里创新性地组合了4种通信模式，并增加了作用域机制和推送链\r\n - **DataHandleQueue**：责任链+队列解耦+推送链的三重组合，解决了多子系统协同和级联处理的问题\r\n - **Effective Range**：传统网格系统处理全量数据，这里通过智能范围限制实现2268倍性能提升\r\n - **Delegate Pattern Pathfinding**：传统寻路系统硬编码算法，这里通过委托模式实现算法无关性，支持智能推荐\r\n"
                },
                {
                    "date": 1767267760914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -699,9 +699,9 @@\n ### 原创设计模式分类\r\n \r\n ```\r\n 原创设计模式 (Original Design Patterns)\r\n-├── Context (上下文模式) ⭐ - 统一接口，渐进式增强，状态维护（完全原创）\r\n+├── Context (上下文模式) ⭐ - 接口参数归一化，防呆设计，向后兼容，利用 Lua 5.4 分代 GC（完全原创）\r\n ├── CommunicationBus (通讯总线模式) ⭐ - 多频道架构，统一路由（原创组合）\r\n ├── DataHandleQueue (数据队列解耦模式) ⭐ - 责任链 + 队列解耦 + 推送链，三重机制（原创组合）\r\n ├── EffectiveRange (有效范围优化模式) ⭐ - 智能范围限制，2268倍性能提升（原创优化）\r\n ├── DelegatePatternPathfinding (委托模式寻路) ⭐ - 算法无关性设计，智能推荐（原创设计）\r\n"
                },
                {
                    "date": 1767267803994,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -557,9 +557,9 @@\n ```mermaid\r\n flowchart TD\r\n     A[网格查询请求] --> B[计算有效范围]\r\n     B --> C{数据在有效范围内?}\r\n-    C -->|是| D[位图O(1)查询]\r\n+    C -->|是| D[位图O1查询]\r\n     C -->|否| E[跳过处理]\r\n     D --> F[返回结果]\r\n     E --> G[不处理]\r\n     \r\n"
                },
                {
                    "date": 1767267839586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -244,9 +244,9 @@\n ```\r\n \r\n ---\r\n \r\n-### 6. CommunicationBus (通讯总线模式) ⭐ **原创：多频道架构**\r\n+### 6. CommunicationBus (通讯总线) ⭐ **原创：多频道架构**\r\n \r\n **核心定义：**\r\n - 统一的通讯总线系统，通过多频道架构提供多种通信模式\r\n - 四种频道：发布-订阅、点对点、数据推送、请求-响应\r\n"
                },
                {
                    "date": 1767267913660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,37 +63,8 @@\n     style L fill:#c8e6c9\r\n     style M fill:#c8e6c9\r\n ```\r\n \r\n-**实际应用示例：**\r\n-```lua\r\n--- CommunicationBus 使用 Context\r\n-local context = {\r\n-    channelType = ChannelType.Event,\r\n-    broadcastId = EEvent.PlayerLevelUp,\r\n-    scopeType = ScopeType.Global\r\n-}\r\n-CommunicationBus:Broadcast(context, {level = 10})\r\n-\r\n--- Skill 系统使用 Context\r\n-local skillContext = {\r\n-    caster = unit,\r\n-    target = target,\r\n-    skillId = skillId,\r\n-    -- 逐步增强，添加更多信息\r\n-}\r\n-SkillBase:Execute(skillContext)\r\n-\r\n--- Effect 系统使用 Context\r\n-local effectContext = {\r\n-    source = source,\r\n-    target = target,\r\n-    effectId = effectId,\r\n-    -- 信息在调用链中累积\r\n-}\r\n-EffectSystem:Apply(effectContext)\r\n-```\r\n-\r\n ---\r\n \r\n ### 2. Pipeline-Filter (管道-过滤器模式)\r\n \r\n@@ -133,37 +104,55 @@\n \r\n ### 3. Domain Controls Loop (领域控制循环模式)\r\n \r\n **核心定义：**\r\n-- 领域逻辑控制循环流程\r\n-- 将控制权交给领域层，而非基础设施层\r\n-- 实现领域驱动设计的核心循环\r\n+- **Domain控制循环**：Domain是领域核心，拥有循环机制来推进业务流程\r\n+- **循环是Domain的工具**：循环不是主导，Domain才是主导，循环服务于Domain\r\n+- **协调器推动循环**：Domain管理通过协调器控制循环状态转换，协调器执行完业务后，主动推动循环进入下一个状态\r\n+- **多层循环架构**：支持多层Domain循环（如战斗循环→回合循环→单位循环），每层Domain独立管理自己的循环\r\n \r\n **核心特点：**\r\n-- **领域主导**：领域逻辑控制整个流程\r\n-- **循环处理**：支持循环处理多个领域事件\r\n-- **解耦基础设施**：领域层不依赖具体实现\r\n-- **测试友好**：领域逻辑可独立测试\r\n+- **Domain主导**：Domain是领域核心，拥有循环机制，循环是Domain的工具\r\n+- **协调器控制**：Domain管理通过协调器控制循环状态转换\r\n+- **主动推动**：协调器执行完业务后，主动推动循环进入下一个状态（反向推动）\r\n+- **多层嵌套**：支持多层Domain循环，父Domain调用子Domain，子Domain完成业务后返回\r\n+- **状态维护**：每层循环维护自己的状态，驱动下层循环\r\n \r\n **适用场景：**\r\n - 领域驱动设计\r\n-- 业务逻辑复杂的系统\r\n+- 业务逻辑复杂的系统（如战斗系统、回合制游戏）\r\n+- 需要多层循环管理的场景\r\n - 需要领域层独立测试的场景\r\n \r\n **流程图：**\r\n ```mermaid\r\n flowchart TD\r\n-    A[外部事件] --> B[领域层接收]\r\n-    B --> C[领域逻辑处理]\r\n-    C --> D[产生领域事件]\r\n-    D --> E{是否有后续处理?}\r\n-    E -->|是| F[触发下一个领域逻辑]\r\n-    E -->|否| G[完成处理]\r\n-    F --> C\r\n-    G --> H[返回结果]\r\n+    A[外部事件] --> B[Domain管理<br/>领域管理]\r\n+    B --> C[协调器<br/>Coordinator]\r\n+    C --> D[执行业务逻辑]\r\n+    D --> E[业务完成]\r\n+    E --> F[协调器主动推动循环<br/>反向推动]\r\n+    F --> G[循环进入下一个状态]\r\n+    G --> H{循环是否完成?}\r\n+    H -->|否| I[Domain管理继续控制]\r\n+    H -->|是| J[Domain完成]\r\n+    I --> C\r\n     \r\n+    K[多层循环示例] --> L[战斗Domain<br/>BattleDomain]\r\n+    L --> M[战斗循环<br/>BattleLoop]\r\n+    M --> N[回合Domain<br/>RoundDomain]\r\n+    N --> O[回合循环<br/>RoundLoop]\r\n+    O --> P[单位Domain<br/>UnitDomain]\r\n+    P --> Q[单位循环<br/>UnitLoop]\r\n+    \r\n+    R[Domain控制循环] -.->|Domain拥有循环| M\r\n+    R -.->|Domain拥有循环| O\r\n+    R -.->|Domain拥有循环| Q\r\n+    \r\n     style B fill:#e1f5ff\r\n     style C fill:#fff4e1\r\n+    style F fill:#c8e6c9\r\n+    style R fill:#f3e5f5\r\n ```\r\n \r\n ---\r\n \r\n"
                },
                {
                    "date": 1767267982064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -123,36 +123,93 @@\n - 需要多层循环管理的场景\r\n - 需要领域层独立测试的场景\r\n \r\n **流程图：**\r\n+\r\n+#### Domain与循环的关系\r\n ```mermaid\r\n+graph TB\r\n+    subgraph BattleDomain[\"战斗Domain<br/>Battle Domain\"]\r\n+        BattleManagement[战斗管理<br/>结算奖励/同步任务]\r\n+        BattleLoop[\"战斗循环<br/>BattleLoop\"]\r\n+        BattleManagement -->|控制| BattleLoop\r\n+        BattleLoop -->|推进| BattleManagement\r\n+        \r\n+        subgraph RoundDomain[\"回合Domain<br/>Round Domain\"]\r\n+            RoundManagement[回合管理<br/>行动值排序/单位行动顺序]\r\n+            RoundLoop[\"回合循环<br/>RoundLoop\"]\r\n+            RoundManagement -->|控制| RoundLoop\r\n+            RoundLoop -->|推进| RoundManagement\r\n+            \r\n+            subgraph UnitDomain[\"单位Domain<br/>Unit Domain\"]\r\n+                UnitManagement[单位管理<br/>移动/施法/选择技能对象]\r\n+                UnitLoop[\"单位循环<br/>UnitLoop\"]\r\n+                UnitManagement -->|控制| UnitLoop\r\n+                UnitLoop -->|推进| UnitManagement\r\n+            end\r\n+        end\r\n+    end\r\n+    \r\n+    style BattleDomain fill:#ffebee\r\n+    style RoundDomain fill:#fff4e1\r\n+    style UnitDomain fill:#e1f5ff\r\n+    style BattleLoop fill:#f3e5f5\r\n+    style RoundLoop fill:#f3e5f5\r\n+    style UnitLoop fill:#f3e5f5\r\n+```\r\n+\r\n+#### Domain协作关系\r\n+```mermaid\r\n+graph TB\r\n+    BattleDomain[战斗Domain<br/>Battle Domain]\r\n+    RoundDomain[回合Domain<br/>Round Domain]\r\n+    UnitDomain[单位Domain<br/>Unit Domain]\r\n+    \r\n+    BattleDomain -->|1. 调用| RoundDomain\r\n+    RoundDomain -->|2. 返回| BattleDomain\r\n+    RoundDomain -->|3. 调用| UnitDomain\r\n+    UnitDomain -->|4. 返回| RoundDomain\r\n+    \r\n+    BattleDomain -.->|包含| RoundDomain\r\n+    RoundDomain -.->|包含| UnitDomain\r\n+    \r\n+    style BattleDomain fill:#ffebee\r\n+    style RoundDomain fill:#fff4e1\r\n+    style UnitDomain fill:#e1f5ff\r\n+```\r\n+\r\n+#### 协调器推动循环流程\r\n+```mermaid\r\n flowchart TD\r\n-    A[外部事件] --> B[Domain管理<br/>领域管理]\r\n-    B --> C[协调器<br/>Coordinator]\r\n-    C --> D[执行业务逻辑]\r\n-    D --> E[业务完成]\r\n-    E --> F[协调器主动推动循环<br/>反向推动]\r\n-    F --> G[循环进入下一个状态]\r\n-    G --> H{循环是否完成?}\r\n-    H -->|否| I[Domain管理继续控制]\r\n-    H -->|是| J[Domain完成]\r\n-    I --> C\r\n+    LoopPreparing[LoopPreparing<br/>战斗准备] --> InitBattle[初始化战斗数据<br/>战斗管理初始化]\r\n     \r\n-    K[多层循环示例] --> L[战斗Domain<br/>BattleDomain]\r\n-    L --> M[战斗循环<br/>BattleLoop]\r\n-    M --> N[回合Domain<br/>RoundDomain]\r\n-    N --> O[回合循环<br/>RoundLoop]\r\n-    O --> P[单位Domain<br/>UnitDomain]\r\n-    P --> Q[单位循环<br/>UnitLoop]\r\n+    InitBattle --> LoopProgress[LoopProgress<br/>战斗进行中]\r\n     \r\n-    R[Domain控制循环] -.->|Domain拥有循环| M\r\n-    R -.->|Domain拥有循环| O\r\n-    R -.->|Domain拥有循环| Q\r\n+    LoopProgress --> CallRound[调用回合领域<br/>回合协调器调用回合领域]\r\n     \r\n-    style B fill:#e1f5ff\r\n-    style C fill:#fff4e1\r\n-    style F fill:#c8e6c9\r\n-    style R fill:#f3e5f5\r\n+    CallRound --> RoundAction[回合领域执行回合<br/>回合领域完成回合]\r\n+    \r\n+    RoundAction --> PushProgress[回合协调器推动循环<br/>推动到IN_PROGRESS状态继续]\r\n+    \r\n+    PushProgress --> CheckEnd{检查战斗结束条件<br/>战斗管理检查}\r\n+    \r\n+    CheckEnd -->|未结束| CallRound\r\n+    CheckEnd -->|已结束| PushEnd[回合协调器推动循环<br/>推动到ENDED状态]\r\n+    \r\n+    PushEnd --> LoopEnd[LoopEnd<br/>战斗结束]\r\n+    \r\n+    LoopEnd --> Reward[结算奖励<br/>奖励管理结算奖励]\r\n+    Reward --> Task[同步任务<br/>任务管理同步任务]\r\n+    Task --> Complete[战斗完成]\r\n+    \r\n+    style LoopPreparing fill:#ffebee\r\n+    style LoopProgress fill:#ffebee\r\n+    style CallRound fill:#c8e6c9\r\n+    style RoundAction fill:#c8e6c9\r\n+    style PushProgress fill:#f3e5f5\r\n+    style PushEnd fill:#f3e5f5\r\n+    style LoopEnd fill:#ffebee\r\n+    style CheckEnd fill:#ffe0b2\r\n ```\r\n \r\n ---\r\n \r\n"
                },
                {
                    "date": 1767268125204,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -349,22 +349,70 @@\n - 组件自动初始化场景\r\n - 交互系统、技能系统等\r\n \r\n **流程图：**\r\n+\r\n+#### 三层架构 + 模板方法模式\r\n ```mermaid\r\n-flowchart TD\r\n-    A[配置模板ID] --> B[查找模板配置]\r\n-    B --> C[获取组件类型列表]\r\n-    C --> D[自动查找所需组件]\r\n-    D --> E[获取参数配置]\r\n-    E --> F[调用初始化策略]\r\n-    F --> G[配置组件参数]\r\n-    G --> H[完成初始化]\r\n+graph TB\r\n+    subgraph ConfigLayer[\"配置层<br/>Unity Inspector\"]\r\n+        ItemLifecycle[\"ItemLifecycle组件<br/>interactionTemplateId\"]\r\n+        TemplateConfig[\"模板配置<br/>EInteractionTypeTemplate\"]\r\n+    end\r\n     \r\n-    style B fill:#e1f5ff\r\n-    style D fill:#fff4e1\r\n+    subgraph TemplateLayer[\"模板层<br/>InteractionUtil\"]\r\n+        TemplateRegistry[\"模板注册表<br/>EInteractionTypeTemplate\"]\r\n+        ComponentFinder[\"组件查找器<br/>自动查找所需组件\"]\r\n+        InitOrchestrator[\"初始化编排器<br/>统一初始化流程\"]\r\n+    end\r\n+    \r\n+    subgraph InitLayer[\"初始化层<br/>InteractionInit\"]\r\n+        InitStrategies[\"初始化策略组<br/>InterationInit[ComponentType]\"]\r\n+        ParamConfig[\"参数配置<br/>参数化配置支持\"]\r\n+    end\r\n+    \r\n+    subgraph UnityLayer[\"Unity组件层\"]\r\n+        TopDownComponents[\"TopDown组件<br/>PickableItem/KeyOperatedZone等\"]\r\n+        FeedbackComponents[\"反馈组件<br/>MMFeedbacks/粒子系统等\"]\r\n+    end\r\n+    \r\n+    ConfigLayer -->|读取模板ID| TemplateLayer\r\n+    TemplateLayer -->|查找模板| TemplateRegistry\r\n+    TemplateRegistry -->|查找组件| ComponentFinder\r\n+    ComponentFinder -->|获取组件列表| InitOrchestrator\r\n+    InitOrchestrator -->|调用初始化| InitLayer\r\n+    InitLayer -->|执行策略| InitStrategies\r\n+    InitStrategies -->|配置组件| UnityLayer\r\n+    \r\n+    style ConfigLayer fill:#fff9c4\r\n+    style TemplateLayer fill:#e1f5ff\r\n+    style InitLayer fill:#fff4e1\r\n+    style UnityLayer fill:#c8e6c9\r\n ```\r\n \r\n+#### 模板方法数据流\r\n+```mermaid\r\n+graph TD\r\n+    Start[Unity Inspector<br/>配置interactionTemplateId] -->|1. 读取模板ID| Template[模板层<br/>查找EInteractionTypeTemplate]\r\n+    Template -->|2. 获取组件类型| Component[组件查找器<br/>自动查找所需组件]\r\n+    Component -->|3. 获取组件列表| Orchestrator[初始化编排器<br/>统一初始化流程]\r\n+    Orchestrator -->|4. 调用初始化策略| Init[初始化层<br/>InterationInit]\r\n+    Init -->|5. 配置组件参数| Unity[Unity组件层<br/>完成配置]\r\n+    \r\n+    style Template fill:#e1f5ff\r\n+    style Component fill:#fff4e1\r\n+    style Init fill:#c8e6c9\r\n+    style Unity fill:#c8e6c9\r\n+```\r\n+\r\n+**模板化核心特性：**\r\n+- ✅ **模板驱动**：一个模板ID即可完成完整配置\r\n+- ✅ **自动查找**：系统自动查找所需组件，无需手动添加\r\n+- ✅ **统一流程**：所有交互类型使用统一的初始化流程\r\n+- ✅ **参数化配置**：同一个模板可以有不同的参数配置\r\n+- ✅ **策略模式**：每个组件类型对应一个初始化策略\r\n+- ✅ **外观模式**：隐藏复杂的初始化逻辑，提供简单的配置接口\r\n+\r\n ---\r\n \r\n ### 8. Condition-Action Decoupling (条件-动作解耦模式)\r\n \r\n"
                },
                {
                    "date": 1767268158016,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -252,9 +252,9 @@\n ```\r\n \r\n ---\r\n \r\n-### 5. Formula System (公式系统模式)\r\n+### 5. Formula System (公式系统)\r\n \r\n **核心定义：**\r\n - 三层架构：字符串解析 → Lua函数编译 → 执行\r\n - 支持动态公式计算\r\n"
                },
                {
                    "date": 1767268211653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,24 +272,106 @@\n - 配置驱动的计算\r\n - 技能系统\r\n \r\n **流程图：**\r\n+\r\n+#### 三级公式架构 + 职责分离\r\n ```mermaid\r\n+graph TB\r\n+    subgraph ProgrammerLayer[\"基础设施层\"]\r\n+        FunctionRegistry[\"函数注册表<br/>RegisterFunction<br/>一级公式函数\"]\r\n+        ParserEngine[\"解析引擎<br/>FormulaParserBase<br/>公式解析和编译\"]\r\n+        CacheSystem[\"缓存系统<br/>FormulaCache<br/>编译结果缓存\"]\r\n+    end\r\n+    \r\n+    subgraph DesignerLayer[\"配置层\"]\r\n+        Level1Formula[\"一级公式<br/>ATTR/EQUIPMENT_BONUS<br/>基础获取函数\"]\r\n+        Level2Formula[\"二级公式<br/>@Category_Name<br/>派生计算\"]\r\n+        Level3Formula[\"三级公式<br/>#FinalResult<br/>综合效果计算\"]\r\n+    end\r\n+    \r\n+    subgraph RuntimeLayer[\"计算层\"]\r\n+        ParamContainer[\"参数容器<br/>Param.Create<br/>链式参数传递\"]\r\n+        FormulaCalculator[\"公式计算器<br/>CalculateFormula<br/>执行公式计算\"]\r\n+        ResultCache[\"结果缓存<br/>计算结果缓存\"]\r\n+    end\r\n+    \r\n+    ProgrammerLayer -->|提供基础设施| DesignerLayer\r\n+    DesignerLayer -->|注册公式| RuntimeLayer\r\n+    RuntimeLayer -->|计算公式| ResultCache\r\n+    \r\n+    style ProgrammerLayer fill:#e1f5ff\r\n+    style DesignerLayer fill:#fff4e1\r\n+    style RuntimeLayer fill:#c8e6c9\r\n+```\r\n+\r\n+#### 三级公式数据流（计算合成）\r\n+```mermaid\r\n+graph TD\r\n+    L3[三级公式<br/>#TotalDamage] -->|依赖| L2A[二级公式<br/>Combat_AttackPower]\r\n+    L3 -->|依赖| L2B[二级公式<br/>Combat_CriticalMultiplier]\r\n+    \r\n+    L2A -->|依赖| L1A[一级公式<br/>ATTR]\r\n+    L2A -->|依赖| L1B[一级公式<br/>EQUIPMENT_BONUS]\r\n+    L2B -->|依赖| L1C[一级公式<br/>SKILL_BONUS]\r\n+    \r\n+    L1A -.->|计算合成| L2A\r\n+    L1B -.->|计算合成| L2A\r\n+    L1C -.->|计算合成| L2B\r\n+    \r\n+    L2A -.->|计算合成| L3\r\n+    L2B -.->|计算合成| L3\r\n+    \r\n+    style L3 fill:#c8e6c9\r\n+    style L2A fill:#fff4e1\r\n+    style L2B fill:#fff4e1\r\n+    style L1A fill:#e1f5ff\r\n+    style L1B fill:#e1f5ff\r\n+    style L1C fill:#e1f5ff\r\n+```\r\n+\r\n+#### 三层解析和执行流程\r\n+```mermaid\r\n flowchart TD\r\n     A[输入公式字符串] --> B[解析层: 词法/语法分析]\r\n-    B --> C{是否已编译?}\r\n-    C -->|是| D[从缓存获取]\r\n-    C -->|否| E[编译层: 生成 Lua 函数]\r\n-    E --> F[缓存编译结果]\r\n-    F --> D\r\n-    D --> G[执行层: 执行 Lua 函数]\r\n-    G --> H[返回计算结果]\r\n+    B --> C{识别公式级别}\r\n+    C -->|一级公式| D1[FUNC(args)<br/>基础获取函数]\r\n+    C -->|二级公式| D2[@Category_Name<br/>派生计算]\r\n+    C -->|三级公式| D3[#FinalResult<br/>综合效果计算]\r\n     \r\n+    D1 --> E{是否已编译?}\r\n+    D2 --> E\r\n+    D3 --> E\r\n+    \r\n+    E -->|是| F[从缓存获取]\r\n+    E -->|否| G[编译层: 生成 Lua 函数]\r\n+    G --> H[缓存编译结果]\r\n+    H --> F\r\n+    \r\n+    F --> I[执行层: 执行计算]\r\n+    I --> J{公式级别}\r\n+    J -->|一级公式| K[执行基础获取]\r\n+    J -->|二级公式| L[执行派生计算<br/>依赖一级公式结果]\r\n+    J -->|三级公式| M[执行综合效果<br/>依赖一级和二级公式结果]\r\n+    \r\n+    K --> N[返回一级结果]\r\n+    L --> O[返回二级结果<br/>合成一级结果]\r\n+    M --> P[返回三级结果<br/>合成一级和二级结果]\r\n+    \r\n     style B fill:#e1f5ff\r\n-    style E fill:#fff4e1\r\n-    style G fill:#c8e6c9\r\n+    style G fill:#fff4e1\r\n+    style I fill:#c8e6c9\r\n+    style L fill:#ffccbc\r\n+    style M fill:#ffccbc\r\n ```\r\n \r\n+**三级公式核心特性：**\r\n+- ✅ **三级分层**：一级 → 二级 → 三级，逐层计算合成\r\n+- ✅ **职责分离**：程序员提供一级函数，策划编写二级和三级公式\r\n+- ✅ **字符匹配**：通过字符匹配规则识别公式级别（#三级、@二级、FUNC一级）\r\n+- ✅ **计算合成**：一级公式结果合成二级公式，二级公式结果合成三级公式\r\n+- ✅ **自动缓存**：编译结果自动缓存，提升性能\r\n+\r\n ---\r\n \r\n ### 6. CommunicationBus (通讯总线) ⭐ **原创：多频道架构**\r\n \r\n"
                },
                {
                    "date": 1767268231379,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -333,9 +333,9 @@\n ```mermaid\r\n flowchart TD\r\n     A[输入公式字符串] --> B[解析层: 词法/语法分析]\r\n     B --> C{识别公式级别}\r\n-    C -->|一级公式| D1[FUNC(args)<br/>基础获取函数]\r\n+    C -->|一级公式| D1[FUNC/>基础获取函数]\r\n     C -->|二级公式| D2[@Category_Name<br/>派生计算]\r\n     C -->|三级公式| D3[#FinalResult<br/>综合效果计算]\r\n     \r\n     D1 --> E{是否已编译?}\r\n"
                },
                {
                    "date": 1767268236574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -333,9 +333,9 @@\n ```mermaid\r\n flowchart TD\r\n     A[输入公式字符串] --> B[解析层: 词法/语法分析]\r\n     B --> C{识别公式级别}\r\n-    C -->|一级公式| D1[FUNC/>基础获取函数]\r\n+    C -->|一级公式| D1[FUNC基础获取函数]\r\n     C -->|二级公式| D2[@Category_Name<br/>派生计算]\r\n     C -->|三级公式| D3[#FinalResult<br/>综合效果计算]\r\n     \r\n     D1 --> E{是否已编译?}\r\n"
                },
                {
                    "date": 1767268245483,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -334,9 +334,9 @@\n flowchart TD\r\n     A[输入公式字符串] --> B[解析层: 词法/语法分析]\r\n     B --> C{识别公式级别}\r\n     C -->|一级公式| D1[FUNC基础获取函数]\r\n-    C -->|二级公式| D2[@Category_Name<br/>派生计算]\r\n+    C -->|二级公式| D2[Category_Name<br/>派生计算]\r\n     C -->|三级公式| D3[#FinalResult<br/>综合效果计算]\r\n     \r\n     D1 --> E{是否已编译?}\r\n     D2 --> E\r\n"
                },
                {
                    "date": 1767268250880,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -334,9 +334,9 @@\n flowchart TD\r\n     A[输入公式字符串] --> B[解析层: 词法/语法分析]\r\n     B --> C{识别公式级别}\r\n     C -->|一级公式| D1[FUNC基础获取函数]\r\n-    C -->|二级公式| D2[Category_Name<br/>派生计算]\r\n+    C -->|二级公式| D2[CategoryName<br/>派生计算]\r\n     C -->|三级公式| D3[#FinalResult<br/>综合效果计算]\r\n     \r\n     D1 --> E{是否已编译?}\r\n     D2 --> E\r\n"
                },
                {
                    "date": 1767268318310,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,27 +156,8 @@\n     style RoundLoop fill:#f3e5f5\r\n     style UnitLoop fill:#f3e5f5\r\n ```\r\n \r\n-#### Domain协作关系\r\n-```mermaid\r\n-graph TB\r\n-    BattleDomain[战斗Domain<br/>Battle Domain]\r\n-    RoundDomain[回合Domain<br/>Round Domain]\r\n-    UnitDomain[单位Domain<br/>Unit Domain]\r\n-    \r\n-    BattleDomain -->|1. 调用| RoundDomain\r\n-    RoundDomain -->|2. 返回| BattleDomain\r\n-    RoundDomain -->|3. 调用| UnitDomain\r\n-    UnitDomain -->|4. 返回| RoundDomain\r\n-    \r\n-    BattleDomain -.->|包含| RoundDomain\r\n-    RoundDomain -.->|包含| UnitDomain\r\n-    \r\n-    style BattleDomain fill:#ffebee\r\n-    style RoundDomain fill:#fff4e1\r\n-    style UnitDomain fill:#e1f5ff\r\n-```\r\n \r\n #### 协调器推动循环流程\r\n ```mermaid\r\n flowchart TD\r\n"
                }
            ],
            "date": 1767267284480,
            "name": "Commit-0",
            "content": "# 🎯 原创设计模式\r\n\r\n## 📋 概述\r\n\r\n本文档记录项目中原创或创新的设计模式，这些模式在传统设计模式库中不存在，或是对传统模式的创新组合和扩展。这些模式经过实际项目验证，具有独特的价值和适用场景。\r\n\r\n---\r\n\r\n## 🆕 可补充的设计模式\r\n\r\n### 1. Context (上下文模式) ⭐ **自创模式**\r\n\r\n**核心定义：**\r\n- 通过统一的上下文接口，实现渐进式增强和状态维护\r\n- 提供统一接口，隐藏内部复杂性\r\n- 支持状态的统一管理和传递\r\n\r\n**核心特点：**\r\n- **统一接口**：所有操作通过 Context 统一入口\r\n- **渐进式增强**：功能可以逐步添加到 Context 中\r\n- **状态维护**：Context 维护系统状态，避免状态分散\r\n- **解耦设计**：客户端不直接依赖具体实现\r\n\r\n**适用场景：**\r\n- 需要统一管理多个子系统\r\n- 需要维护全局状态\r\n- 需要渐进式扩展功能\r\n- 需要简化客户端调用\r\n\r\n**流程图：**\r\n```mermaid\r\nflowchart TD\r\n    A[客户端请求] --> B[Context 统一入口]\r\n    B --> C[维护系统状态]\r\n    C --> D{功能类型}\r\n    D -->|功能A| E[调用子系统A]\r\n    D -->|功能B| F[调用子系统B]\r\n    D -->|功能C| G[调用子系统C]\r\n    E --> H[更新 Context 状态]\r\n    F --> H\r\n    G --> H\r\n    H --> I[返回结果给客户端]\r\n    \r\n    J[渐进式增强] -.->|动态添加| B\r\n    \r\n    style B fill:#e1f5ff\r\n    style C fill:#fff4e1\r\n    style J fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n### 2. Pipeline-Filter (管道-过滤器模式)\r\n\r\n**核心定义：**\r\n- 将复杂处理流程分解为多个独立的过滤器\r\n- 通过管道连接过滤器，数据在管道中流动\r\n- 每个过滤器专注于单一职责\r\n\r\n**核心特点：**\r\n- **数据流处理**：数据在管道中单向流动\r\n- **过滤器独立**：每个过滤器可独立开发、测试、替换\r\n- **组合灵活**：通过组合不同过滤器实现复杂流程\r\n- **易于扩展**：新增过滤器不影响现有流程\r\n\r\n**适用场景：**\r\n- 数据处理流水线\r\n- 数据转换流程\r\n- 多步骤验证流程\r\n- 日志处理系统\r\n\r\n**流程图：**\r\n```mermaid\r\nflowchart LR\r\n    A[输入数据] --> B[过滤器1]\r\n    B -->|管道| C[过滤器2]\r\n    C -->|管道| D[过滤器3]\r\n    D -->|管道| E[过滤器N]\r\n    E --> F[输出数据]\r\n    \r\n    style B fill:#e1f5ff\r\n    style C fill:#e1f5ff\r\n    style D fill:#e1f5ff\r\n    style E fill:#e1f5ff\r\n```\r\n\r\n---\r\n\r\n### 3. Domain Controls Loop (领域控制循环模式)\r\n\r\n**核心定义：**\r\n- 领域逻辑控制循环流程\r\n- 将控制权交给领域层，而非基础设施层\r\n- 实现领域驱动设计的核心循环\r\n\r\n**核心特点：**\r\n- **领域主导**：领域逻辑控制整个流程\r\n- **循环处理**：支持循环处理多个领域事件\r\n- **解耦基础设施**：领域层不依赖具体实现\r\n- **测试友好**：领域逻辑可独立测试\r\n\r\n**适用场景：**\r\n- 领域驱动设计\r\n- 业务逻辑复杂的系统\r\n- 需要领域层独立测试的场景\r\n\r\n**流程图：**\r\n```mermaid\r\nflowchart TD\r\n    A[外部事件] --> B[领域层接收]\r\n    B --> C[领域逻辑处理]\r\n    C --> D[产生领域事件]\r\n    D --> E{是否有后续处理?}\r\n    E -->|是| F[触发下一个领域逻辑]\r\n    E -->|否| G[完成处理]\r\n    F --> C\r\n    G --> H[返回结果]\r\n    \r\n    style B fill:#e1f5ff\r\n    style C fill:#fff4e1\r\n```\r\n\r\n---\r\n\r\n### 4. Microkernel (微内核模式)\r\n\r\n**核心定义：**\r\n- 核心系统提供最小功能集\r\n- 通过插件机制扩展功能\r\n- 核心与插件解耦，支持动态加载\r\n\r\n**核心特点：**\r\n- **最小核心**：核心只提供基础功能\r\n- **插件扩展**：功能通过插件动态添加\r\n- **热插拔**：支持运行时加载/卸载插件\r\n- **松耦合**：插件之间相互独立\r\n\r\n**适用场景：**\r\n- 需要动态扩展的系统\r\n- 插件化架构\r\n- 可配置的系统\r\n- 框架设计\r\n\r\n**流程图：**\r\n```mermaid\r\nflowchart TD\r\n    A[客户端请求] --> B[微内核接收]\r\n    B --> C[核心功能处理]\r\n    C --> D{需要插件?}\r\n    D -->|是| E[查找插件]\r\n    D -->|否| F[返回结果]\r\n    E --> G{插件是否存在?}\r\n    G -->|是| H[调用插件]\r\n    G -->|否| I[使用默认处理]\r\n    H --> J[插件处理]\r\n    J --> F\r\n    I --> F\r\n    \r\n    style B fill:#e1f5ff\r\n    style E fill:#fff4e1\r\n```\r\n\r\n---\r\n\r\n### 5. Formula System (公式系统模式)\r\n\r\n**核心定义：**\r\n- 三层架构：字符串解析 → Lua函数编译 → 执行\r\n- 支持动态公式计算\r\n- 通过编译优化性能\r\n\r\n**核心特点：**\r\n- **三层架构**：解析层、编译层、执行层\r\n- **动态编译**：字符串公式编译为 Lua 函数\r\n- **性能优化**：编译后执行，避免重复解析\r\n- **缓存机制**：编译结果缓存，提高效率\r\n\r\n**适用场景：**\r\n- 动态公式计算\r\n- 规则引擎\r\n- 配置驱动的计算\r\n- 技能系统\r\n\r\n**流程图：**\r\n```mermaid\r\nflowchart TD\r\n    A[输入公式字符串] --> B[解析层: 词法/语法分析]\r\n    B --> C{是否已编译?}\r\n    C -->|是| D[从缓存获取]\r\n    C -->|否| E[编译层: 生成 Lua 函数]\r\n    E --> F[缓存编译结果]\r\n    F --> D\r\n    D --> G[执行层: 执行 Lua 函数]\r\n    G --> H[返回计算结果]\r\n    \r\n    style B fill:#e1f5ff\r\n    style E fill:#fff4e1\r\n    style G fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n### 6. CommunicationBus (通讯总线模式) ⭐ **多频道架构**\r\n\r\n**核心定义：**\r\n- 统一的通讯总线系统，通过多频道架构提供多种通信模式\r\n- 四种频道：发布-订阅、点对点、数据推送、请求-响应\r\n- 统一接口层路由到不同频道\r\n\r\n**核心特点：**\r\n- **多频道架构**：EventChannel、MessageChannel、PushChannel、QueryChannel\r\n- **统一接口**：CommunicationBus 提供统一入口\r\n- **路由机制**：根据通信类型自动路由到对应频道\r\n- **解耦设计**：应用层不直接依赖具体频道实现\r\n\r\n**适用场景：**\r\n- 需要多种通信模式的系统\r\n- 事件驱动架构\r\n- 模块间解耦通信\r\n- 游戏开发中的各种通信需求\r\n\r\n**流程图：**\r\n```mermaid\r\nflowchart TD\r\n    A[客户端请求] --> B[CommunicationBus 统一接口]\r\n    B --> C{通信类型}\r\n    C -->|发布-订阅| D[EventChannel<br/>广播事件]\r\n    C -->|点对点| E[MessageChannel<br/>消息传递]\r\n    C -->|数据推送| F[PushChannel<br/>推送数据]\r\n    C -->|请求-响应| G[QueryChannel<br/>查询响应]\r\n    D --> H[通知所有订阅者]\r\n    E --> I[发送给目标]\r\n    F --> J[处理数据队列]\r\n    G --> K[执行查询并返回]\r\n    \r\n    style B fill:#e1f5ff\r\n    style C fill:#fff4e1\r\n```\r\n\r\n---\r\n\r\n### 7. Template Configuration (模板化配置模式)\r\n\r\n**核心定义：**\r\n- 通过模板ID完成完整配置\r\n- 模板自动查找组件并初始化\r\n- 同一个模板支持不同的参数配置\r\n\r\n**核心特点：**\r\n- **模板驱动**：一个模板ID即可完成完整配置\r\n- **自动查找**：系统自动查找所需组件，无需手动添加\r\n- **参数化配置**：同一个模板可以有不同的参数配置\r\n- **统一流程**：所有类型使用统一的初始化流程\r\n\r\n**适用场景：**\r\n- 需要快速配置相似对象的系统\r\n- 数据驱动的配置系统\r\n- 组件自动初始化场景\r\n- 交互系统、技能系统等\r\n\r\n**流程图：**\r\n```mermaid\r\nflowchart TD\r\n    A[配置模板ID] --> B[查找模板配置]\r\n    B --> C[获取组件类型列表]\r\n    C --> D[自动查找所需组件]\r\n    D --> E[获取参数配置]\r\n    E --> F[调用初始化策略]\r\n    F --> G[配置组件参数]\r\n    G --> H[完成初始化]\r\n    \r\n    style B fill:#e1f5ff\r\n    style D fill:#fff4e1\r\n```\r\n\r\n---\r\n\r\n### 8. Condition-Action Decoupling (条件-动作解耦模式)\r\n\r\n**核心定义：**\r\n- 条件与动作完全解耦\r\n- 通过枚举ID建立映射关系\r\n- 支持1对多、多对1、多对多的灵活绑定\r\n\r\n**核心特点：**\r\n- **完全解耦**：条件检查和动作执行独立\r\n- **灵活绑定**：支持多种绑定关系（1对1、1对多、多对1、多对多）\r\n- **映射表管理**：通过映射表管理条件-动作关系\r\n- **易于扩展**：新增条件或动作不影响现有逻辑\r\n\r\n**适用场景：**\r\n- 触发器系统\r\n- 规则引擎\r\n- 事件响应系统\r\n- 条件驱动的行为系统\r\n\r\n**流程图：**\r\n```mermaid\r\nflowchart TD\r\n    A[触发事件] --> B[查找条件映射表]\r\n    B --> C[检查条件ID]\r\n    C --> D{条件是否满足?}\r\n    D -->|是| E[查找动作映射表]\r\n    D -->|否| F[跳过执行]\r\n    E --> G[执行对应动作]\r\n    G --> H[完成处理]\r\n    F --> I[等待下次触发]\r\n    \r\n    style B fill:#e1f5ff\r\n    style D fill:#fff4e1\r\n```\r\n\r\n---\r\n\r\n### 9. Handler Strategy (Handler策略模式)\r\n\r\n**核心定义：**\r\n- 通过Handler组件的顺序执行实现复杂流程\r\n- 每个Handler专注单一职责\r\n- 使用统一的Context传递数据\r\n\r\n**核心特点：**\r\n- **策略组合**：Handler组件灵活组合\r\n- **管道执行**：Handler按顺序执行，逐步增强Context\r\n- **单一职责**：每个Handler专注单一功能\r\n- **易于扩展**：新增Handler不影响现有流程\r\n\r\n**适用场景：**\r\n- 技能系统\r\n- 效果系统\r\n- 多步骤处理流程\r\n- 需要灵活组合的处理系统\r\n\r\n**流程图：**\r\n```mermaid\r\nflowchart TD\r\n    A[创建Context] --> B[Handler1处理]\r\n    B --> C[增强Context数据]\r\n    C --> D[Handler2处理]\r\n    D --> E[增强Context数据]\r\n    E --> F[Handler3处理]\r\n    F --> G[增强Context数据]\r\n    G --> H[HandlerN处理]\r\n    H --> I[完成处理]\r\n    \r\n    style A fill:#e1f5ff\r\n    style C fill:#fff4e1\r\n    style E fill:#fff4e1\r\n    style G fill:#fff4e1\r\n```\r\n\r\n---\r\n\r\n### 10. Real-time Fetch (实时获取模式)\r\n\r\n**核心定义：**\r\n- 每次获取数据时实时计算，不依赖缓存\r\n- 遍历所有子系统收集最新数据\r\n- 零dirty标记，避免数据同步问题\r\n\r\n**核心特点：**\r\n- **实时计算**：每次获取都是最新数据\r\n- **零dirty标记**：不依赖dirty标记机制\r\n- **按需计算**：只计算需要的属性\r\n- **数据一致性**：保证数据始终是最新的\r\n\r\n**适用场景：**\r\n- 属性计算系统\r\n- 多子系统数据汇总\r\n- 需要实时准确数据的场景\r\n- 避免数据同步问题的系统\r\n\r\n**流程图：**\r\n```mermaid\r\nflowchart TD\r\n    A[GetAttribute请求] --> B[获取基础属性]\r\n    B --> C[遍历子系统列表]\r\n    C --> D[子系统1: 获取属性]\r\n    D --> E[子系统2: 获取属性]\r\n    E --> F[子系统N: 获取属性]\r\n    F --> G[汇总计算]\r\n    G --> H[返回最终结果]\r\n    \r\n    style A fill:#e1f5ff\r\n    style C fill:#fff4e1\r\n    style G fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n### 11. DataHandleQueue (数据队列解耦模式) ⭐ **责任链 + 队列解耦**\r\n\r\n**核心定义：**\r\n- 通过队列实现模块间解耦通信，支持数据推送和查询委托两种机制\r\n- **责任链特性**：多个处理器按顺序处理数据，每个处理器检查是否有自己需要处理的数据类型\r\n- 模块通过队列发送和接收数据，不直接相互调用\r\n- 处理器映射表管理不同类型的处理，查询委托表管理查询接口\r\n\r\n**核心特点：**\r\n- **双重机制**：\r\n  - **数据推送机制**：PushData + ProcessDataHandler，用于数据变化通知\r\n  - **查询委托机制**：SetQueryDelegate，用于统一查询接口\r\n- **责任链处理**：\r\n  - 多个处理器（handlers）按顺序排列\r\n  - 每个处理器检查是否有自己需要处理的数据类型\r\n  - 如果有数据，就处理并可能提前返回\r\n  - 如果没有，就继续传递给下一个处理器（通过遍历机制）\r\n- **队列解耦**：模块间通过队列通信，不直接依赖\r\n- **处理器映射**：通过 SetProcessHandleMapping 注册处理器映射表\r\n- **查询统一**：通过 SetQueryDelegate 统一管理查询接口\r\n- **模块独立**：模块可以独立开发、测试，通过队列解耦\r\n\r\n**使用方式（以 UnitData 为例）：**\r\n1. **初始化**：创建 DataHandleQueue，将所有子系统添加为 Handler\r\n2. **注册处理器**：各子系统通过 `SetProcessHandleMapping()` 注册数据处理器\r\n3. **注册查询**：通过 `SetQueryDelegate(queryId, function)` 注册查询函数\r\n4. **数据推送**：外部系统通过 `PushData(dataType, data)` 推送数据变化\r\n5. **处理数据**：调用 `ProcessDataHandler()` 批量处理队列中的数据\r\n\r\n**适用场景：**\r\n- 多子系统协同的系统（如 UnitData 管理装备、技能、状态等子系统）\r\n- 模块间解耦通信\r\n- 需要统一查询接口的系统\r\n- 数据变化需要通知多个模块的场景\r\n\r\n**流程图：**\r\n```mermaid\r\nflowchart TD\r\n    A[外部系统/子系统] --> B[PushData<br/>推送数据变化]\r\n    B --> C[DataHandleQueue<br/>数据队列]\r\n    C --> D[ProcessDataHandler<br/>开始责任链处理]\r\n    \r\n    D --> E[遍历处理器列表]\r\n    E --> F[处理器1: ProcessDataHandler]\r\n    F --> G{检查是否有<br/>需要处理的数据?}\r\n    G -->|有| H[处理数据并返回]\r\n    G -->|无| I[继续下一个处理器]\r\n    \r\n    I --> J[处理器2: ProcessDataHandler]\r\n    J --> K{检查是否有<br/>需要处理的数据?}\r\n    K -->|有| L[处理数据并返回]\r\n    K -->|无| M[继续下一个处理器]\r\n    \r\n    M --> N[处理器N: ProcessDataHandler]\r\n    N --> O{检查是否有<br/>需要处理的数据?}\r\n    O -->|有| P[处理数据]\r\n    O -->|无| Q[责任链结束]\r\n    \r\n    H --> R[OnDataHandler<br/>遍历processHandlerMapping]\r\n    L --> R\r\n    P --> R\r\n    R --> S[HandleAllData<br/>处理队列数据]\r\n    S --> T[调用对应处理函数]\r\n    \r\n    U[外部查询] --> V[QueryData<br/>查询数据]\r\n    V --> W[查找查询委托表]\r\n    W --> X[找到对应委托函数]\r\n    X --> Y[执行查询并返回]\r\n    \r\n    Z[初始化] --> AA[AddHandler<br/>添加子系统到责任链]\r\n    AA --> BB[SetProcessHandleMapping<br/>注册处理器映射表]\r\n    BB --> CC[SetQueryDelegate<br/>注册查询]\r\n    \r\n    style C fill:#e1f5ff\r\n    style D fill:#fff4e1\r\n    style G fill:#ffccbc\r\n    style K fill:#ffccbc\r\n    style O fill:#ffccbc\r\n    style AA fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 📊 模式分类建议\r\n\r\n### 新增分类：Architectural Patterns (架构模式)\r\n\r\n```\r\nArchitectural Patterns (架构模式) - 系统级架构设计\r\n├── Context (上下文模式) ⭐ - 统一接口，渐进式增强，状态维护\r\n├── CommunicationBus (通讯总线模式) ⭐ - 多频道架构，统一路由\r\n├── PipelineFilter (管道-过滤器模式) - 数据流处理，过滤器组合\r\n├── TemplateConfiguration (模板化配置模式) - 模板驱动，自动初始化\r\n├── ConditionActionDecoupling (条件-动作解耦模式) - 条件动作分离，灵活绑定\r\n├── HandlerStrategy (Handler策略模式) - Handler组合，管道执行\r\n├── RealTimeFetch (实时获取模式) - 实时计算，零dirty标记\r\n├── DataHandleQueue (数据队列解耦模式) ⭐ - 责任链 + 队列解耦，双重机制\r\n├── DomainControlsLoop (领域控制循环模式) - 领域驱动，循环处理\r\n├── Microkernel (微内核模式) - 最小核心，插件扩展\r\n└── FormulaSystem (公式系统模式) - 三层架构，动态编译\r\n```\r\n\r\n---\r\n\r\n## 🎯 推荐优先级\r\n\r\n### 高优先级（建议立即添加）⭐\r\n1. **Context (上下文模式)** - 用户自创，核心设计模式\r\n2. **CommunicationBus (通讯总线模式)** - 多频道架构，统一通信接口\r\n3. **Template Configuration (模板化配置模式)** - 模板驱动，自动初始化\r\n\r\n### 中优先级（可考虑添加）\r\n4. **Handler Strategy (Handler策略模式)** - Handler组合，灵活扩展\r\n5. **Real-time Fetch (实时获取模式)** - 实时计算，零dirty标记\r\n6. **Condition-Action Decoupling (条件-动作解耦模式)** - 条件动作分离\r\n7. **Pipeline-Filter (管道-过滤器模式)** - 常见架构模式，实用性强\r\n8. **DataHandleQueue (数据队列解耦模式)** ⭐ - 责任链 + 队列解耦，双重机制\r\n\r\n### 低优先级（可选）\r\n9. **Microkernel (微内核模式)** - 框架设计常用\r\n10. **Formula System (公式系统模式)** - 特定场景很有价值\r\n11. **Domain Controls Loop (领域控制循环模式)** - 特定于 DDD 场景\r\n\r\n---\r\n\r\n## 💡 设计思路总结\r\n\r\n### 核心设计理念\r\n1. **解构结构** - 将复杂系统分解为简单组件\r\n2. **统一接口** - 通过统一入口简化调用\r\n3. **渐进式增强** - 功能可逐步添加，不破坏现有结构\r\n4. **数据驱动** - 通过配置数据驱动行为\r\n5. **状态管理** - 统一管理状态，避免分散\r\n\r\n### 设计原则\r\n- **单一职责** - 每个组件专注单一功能\r\n- **开闭原则** - 对扩展开放，对修改关闭\r\n- **依赖倒置** - 依赖抽象而非具体实现\r\n- **接口隔离** - 提供最小必要接口\r\n- **里氏替换** - 子类可替换父类\r\n\r\n---\r\n\r\n## 📝 下一步行动\r\n\r\n1. 将 Context 模式添加到设计模式库（高优先级）\r\n2. 为每个新模式创建详细的流程图\r\n3. 补充实际应用场景和代码示例\r\n4. 更新设计模式分类体系\r\n"
        }
    ]
}