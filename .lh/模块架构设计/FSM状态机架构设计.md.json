{
    "sourceFile": "模块架构设计/FSM状态机架构设计.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1767203720043,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1767203720043,
            "name": "Commit-0",
            "content": "# FSM状态机架构设计\r\n\r\n## 设计目标\r\n\r\n设计一套完整的状态机系统，支持多种状态机类型（基础状态机、下推状态机、并发状态机、层次状态机），实现状态切换、事件监听、状态栈管理、子状态机管理，提供灵活的状态管理解决方案。\r\n\r\n---\r\n\r\n## 核心设计理念\r\n\r\n### 1. 状态模式为核心\r\n\r\n**本质**：状态机系统的核心是状态模式的应用\r\n- 状态切换 = 当前状态退出 → 新状态进入\r\n- 状态更新 = 当前状态的Update方法持续调用\r\n- 状态管理 = 状态注册、查找、切换的统一管理\r\n- 状态隔离 = 每个状态独立管理自己的逻辑\r\n\r\n### 2. 多态状态机架构\r\n\r\n**本质**：通过继承实现多种状态机类型，满足不同场景需求\r\n- 基础状态机 = 简单的状态切换，适用于单一系统\r\n- 下推状态机 = 状态栈管理，适用于菜单系统、暂停恢复\r\n- 并发状态机 = 多子状态机并行，适用于多系统协同\r\n- 层次状态机 = 状态嵌套，适用于复杂状态管理\r\n\r\n### 3. 对象池管理 + 事件驱动\r\n\r\n**本质**：状态机使用对象池管理，通过事件系统实现解耦\r\n- 对象池管理 = 状态机实例复用，减少GC压力\r\n- 事件驱动 = 状态变化通过事件通知，实现解耦\r\n- 生命周期管理 = 状态进入/退出/暂停/恢复的标准化流程\r\n\r\n---\r\n\r\n## 整体架构设计\r\n\r\n### 四类状态机架构 + 状态模式\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph BaseFSM[\"基础状态机<br/>FSMKit\"]\r\n        StateRegistry[\"状态注册表<br/>stateDict\"]\r\n        CurrentState[\"当前状态<br/>currentState\"]\r\n        EventSystem[\"事件系统<br/>OnStateChanged\"]\r\n    end\r\n    \r\n    subgraph PDAFSM[\"下推状态机<br/>FSM_PDAKit\"]\r\n        StateStack[\"状态栈<br/>stateStack\"]\r\n        PushState[\"推入状态<br/>PushState\"]\r\n        PopState[\"弹出状态<br/>PopState\"]\r\n    end\r\n    \r\n    subgraph ParallelFSM[\"并发状态机<br/>ParallelFSMKit\"]\r\n        SubFSMList[\"子状态机列表<br/>subFSMList\"]\r\n        ParallelUpdate[\"并行更新<br/>Update所有子FSM\"]\r\n    end\r\n    \r\n    subgraph HierarchicalFSM[\"层次状态机<br/>HierarchicalFSMKit\"]\r\n        ParentState[\"父状态<br/>parentState\"]\r\n        SubFSMMap[\"子FSM映射<br/>subFSMMap[stateId]\"]\r\n        AutoActivate[\"自动激活<br/>父状态进入时激活子FSM\"]\r\n    end\r\n    \r\n    BaseFSM -->|继承| PDAFSM\r\n    BaseFSM -->|继承| ParallelFSM\r\n    BaseFSM -->|继承| HierarchicalFSM\r\n    \r\n    style BaseFSM fill:#e1f5ff\r\n    style PDAFSM fill:#fff4e1\r\n    style ParallelFSM fill:#c8e6c9\r\n    style HierarchicalFSM fill:#f3e5f5\r\n```\r\n\r\n### 状态切换数据流\r\n\r\n```mermaid\r\ngraph LR\r\n    Start[状态切换请求<br/>ChangeState] -->|1. 退出当前状态| Exit[当前状态退出<br/>Exit]\r\n    Exit -->|2. 触发事件| Event[事件通知<br/>OnStateChanged]\r\n    Event -->|3. 查找新状态| Find[查找新状态<br/>stateDict[stateId]]\r\n    Find -->|4. 进入新状态| Enter[新状态进入<br/>Enter]\r\n    Enter -->|5. 更新当前状态| Update[更新当前状态<br/>currentState]\r\n    Update -->|6. 持续更新| Loop[状态更新循环<br/>Update]\r\n    \r\n    style Exit fill:#ffebee\r\n    style Enter fill:#c8e6c9\r\n    style Loop fill:#e1f5ff\r\n```\r\n\r\n**数据流特性**：\r\n- ✅ **状态隔离**：每个状态独立管理自己的逻辑\r\n- ✅ **标准化流程**：退出 → 切换 → 进入 → 更新\r\n- ✅ **事件驱动**：状态变化通过事件通知\r\n- ✅ **生命周期管理**：状态进入/退出/暂停/恢复的完整生命周期\r\n\r\n---\r\n\r\n## 基础状态机架构设计\r\n\r\n### 核心职责\r\n\r\n状态注册管理 + 状态切换 + 状态更新 + 事件通知\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph FSMKit[\"FSMKit基础状态机\"]\r\n        StateRegistry[\"状态注册表<br/>stateDict[stateId] = StateClass\"]\r\n        CurrentState[\"当前状态<br/>currentState\"]\r\n        StateInstance[\"状态实例<br/>stateInstance\"]\r\n        EventSystem[\"事件系统<br/>eventListeners\"]\r\n    end\r\n    \r\n    subgraph StateBase[\"状态基类<br/>FSMState\"]\r\n        EnterMethod[\"Enter方法<br/>进入状态\"]\r\n        UpdateMethod[\"Update方法<br/>更新状态\"]\r\n        ExitMethod[\"Exit方法<br/>退出状态\"]\r\n        PauseMethod[\"Pause方法<br/>暂停状态\"]\r\n        ResumeMethod[\"Resume方法<br/>恢复状态\"]\r\n    end\r\n    \r\n    FSMKit -->|管理| StateRegistry\r\n    FSMKit -->|切换| CurrentState\r\n    CurrentState -->|调用| StateInstance\r\n    StateInstance -->|继承| StateBase\r\n    \r\n    style FSMKit fill:#e1f5ff\r\n    style StateBase fill:#fff4e1\r\n```\r\n\r\n### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[初始化状态机] --> Register[注册状态<br/>AddState]\r\n    Register --> ChangeState[切换状态<br/>ChangeState]\r\n    \r\n    ChangeState --> CheckCurrent{当前状态<br/>是否存在?}\r\n    CheckCurrent -->|是| ExitCurrent[退出当前状态<br/>Exit]\r\n    CheckCurrent -->|否| FindNew[查找新状态<br/>stateDict[stateId]]\r\n    \r\n    ExitCurrent --> TriggerEvent1[触发事件<br/>OnStateChanged]\r\n    TriggerEvent1 --> FindNew\r\n    \r\n    FindNew --> CheckNew{新状态<br/>是否存在?}\r\n    CheckNew -->|是| CreateInstance[创建状态实例<br/>StateClass.New]\r\n    CheckNew -->|否| Error[错误：状态不存在]\r\n    \r\n    CreateInstance --> EnterNew[进入新状态<br/>Enter]\r\n    EnterNew --> UpdateCurrent[更新当前状态<br/>currentState = newState]\r\n    UpdateCurrent --> TriggerEvent2[触发事件<br/>OnStateChanged]\r\n    TriggerEvent2 --> UpdateLoop[更新循环<br/>UpdateCurrentState]\r\n    \r\n    UpdateLoop -->|持续调用| UpdateMethod[状态Update方法]\r\n    \r\n    style CheckCurrent fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style CheckNew fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style EnterNew fill:#c8e6c9\r\n    style UpdateLoop fill:#e1f5ff\r\n```\r\n\r\n---\r\n\r\n## 下推状态机架构设计\r\n\r\n### 核心职责\r\n\r\n状态栈管理 + 状态推入/弹出 + 状态暂停/恢复\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph PDAFSM[\"FSM_PDAKit下推状态机\"]\r\n        StateStack[\"状态栈<br/>stateStack\"]\r\n        CurrentState[\"当前状态<br/>currentState\"]\r\n        PushState[\"推入状态<br/>PushState\"]\r\n        PopState[\"弹出状态<br/>PopState\"]\r\n    end\r\n    \r\n    subgraph StackOperation[\"栈操作\"]\r\n        Push[推入操作<br/>暂停当前状态<br/>推入新状态]\r\n        Pop[弹出操作<br/>退出当前状态<br/>恢复旧状态]\r\n    end\r\n    \r\n    PDAFSM -->|使用| StateStack\r\n    StateStack -->|执行| StackOperation\r\n    \r\n    style PDAFSM fill:#fff4e1\r\n    style StackOperation fill:#c8e6c9\r\n```\r\n\r\n### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[推入状态请求<br/>PushState] --> PauseCurrent[暂停当前状态<br/>Pause]\r\n    PauseCurrent --> PushToStack[推入栈<br/>stateStack.push(currentState)]\r\n    PushToStack --> ChangeToNew[切换到新状态<br/>ChangeState]\r\n    \r\n    PopRequest[弹出状态请求<br/>PopState] --> ExitCurrent[退出当前状态<br/>Exit]\r\n    ExitCurrent --> PopFromStack[从栈弹出<br/>stateStack.pop]\r\n    PopFromStack --> ResumeOld[恢复旧状态<br/>Resume]\r\n    ResumeOld --> SetCurrent[设置当前状态<br/>currentState = oldState]\r\n    \r\n    style PauseCurrent fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style PopFromStack fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style ChangeToNew fill:#c8e6c9\r\n    style ResumeOld fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 并发状态机架构设计\r\n\r\n### 核心职责\r\n\r\n多子状态机管理 + 并行更新 + 生命周期同步\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph ParallelFSM[\"ParallelFSMKit并发状态机\"]\r\n        SubFSMList[\"子状态机列表<br/>subFSMList\"]\r\n        AddSubFSM[\"添加子FSM<br/>AddSubFSM\"]\r\n        UpdateAll[\"更新所有子FSM<br/>Update\"]\r\n    end\r\n    \r\n    subgraph SubFSMs[\"子状态机组\"]\r\n        SubFSM1[\"子FSM1<br/>CharacterFSM\"]\r\n        SubFSM2[\"子FSM2<br/>AnimationFSM\"]\r\n        SubFSM3[\"子FSM3<br/>AIFSM\"]\r\n    end\r\n    \r\n    ParallelFSM -->|管理| SubFSMList\r\n    SubFSMList -->|包含| SubFSMs\r\n    ParallelFSM -->|更新| UpdateAll\r\n    UpdateAll -->|并行调用| SubFSMs\r\n    \r\n    style ParallelFSM fill:#c8e6c9\r\n    style SubFSMs fill:#e1f5ff\r\n```\r\n\r\n### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[创建并发状态机] --> AddSubFSM1[添加子FSM1<br/>AddSubFSM]\r\n    AddSubFSM1 --> AddSubFSM2[添加子FSM2<br/>AddSubFSM]\r\n    AddSubFSM2 --> AddSubFSM3[添加子FSM3<br/>AddSubFSM]\r\n    \r\n    UpdateRequest[更新请求<br/>Update] --> Loop[遍历子FSM列表]\r\n    Loop --> UpdateSubFSM1[更新子FSM1<br/>Update]\r\n    Loop --> UpdateSubFSM2[更新子FSM2<br/>Update]\r\n    Loop --> UpdateSubFSM3[更新子FSM3<br/>Update]\r\n    \r\n    UpdateSubFSM1 --> Complete[更新完成]\r\n    UpdateSubFSM2 --> Complete\r\n    UpdateSubFSM3 --> Complete\r\n    \r\n    style Loop fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style UpdateSubFSM1 fill:#c8e6c9\r\n    style UpdateSubFSM2 fill:#c8e6c9\r\n    style UpdateSubFSM3 fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 层次状态机架构设计\r\n\r\n### 核心职责\r\n\r\n状态嵌套管理 + 子FSM自动激活 + 父子状态同步\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph HierarchicalFSM[\"HierarchicalFSMKit层次状态机\"]\r\n        ParentState[\"父状态<br/>parentState\"]\r\n        SubFSMMap[\"子FSM映射<br/>subFSMMap[stateId]\"]\r\n        AutoActivate[\"自动激活机制<br/>父状态进入时激活子FSM\"]\r\n    end\r\n    \r\n    subgraph StateSubFSM[\"状态-子FSM关联\"]\r\n        MoveState[\"移动状态<br/>MoveState\"]\r\n        MoveSubFSM[\"移动子FSM<br/>AnimationFSM\"]\r\n        AttackState[\"攻击状态<br/>AttackState\"]\r\n        AttackSubFSM[\"攻击子FSM<br/>CombatFSM\"]\r\n    end\r\n    \r\n    HierarchicalFSM -->|管理| SubFSMMap\r\n    SubFSMMap -->|关联| StateSubFSM\r\n    HierarchicalFSM -->|自动激活| AutoActivate\r\n    AutoActivate -->|触发| StateSubFSM\r\n    \r\n    style HierarchicalFSM fill:#f3e5f5\r\n    style StateSubFSM fill:#e1f5ff\r\n```\r\n\r\n### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[切换父状态<br/>ChangeState] --> ExitOld[退出旧父状态<br/>Exit]\r\n    ExitOld --> DeactivateOld[停用旧子FSM<br/>Reset]\r\n    DeactivateOld --> EnterNew[进入新父状态<br/>Enter]\r\n    EnterNew --> CheckSubFSM{是否有子FSM?<br/>subFSMMap[stateId]}\r\n    CheckSubFSM -->|是| ActivateSubFSM[激活子FSM<br/>Reset + ChangeState]\r\n    CheckSubFSM -->|否| Continue[继续执行]\r\n    ActivateSubFSM --> Continue\r\n    \r\n    UpdateRequest[更新请求<br/>Update] --> UpdateParent[更新父状态<br/>Update]\r\n    UpdateParent --> CheckSubFSM2{是否有子FSM?}\r\n    CheckSubFSM2 -->|是| UpdateSubFSM[更新子FSM<br/>Update]\r\n    CheckSubFSM2 -->|否| Complete[更新完成]\r\n    UpdateSubFSM --> Complete\r\n    \r\n    style CheckSubFSM fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style CheckSubFSM2 fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style ActivateSubFSM fill:#c8e6c9\r\n    style UpdateSubFSM fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 架构模式分析\r\n\r\n### 状态模式（State Pattern）\r\n\r\n**核心思想**：状态封装行为，状态机管理状态切换\r\n\r\n```mermaid\r\ngraph TB\r\n    Context[上下文<br/>FSMKit]\r\n    StateInterface[状态接口<br/>FSMState]\r\n    \r\n    ConcreteState1[具体状态1<br/>IdleState]\r\n    ConcreteState2[具体状态2<br/>MoveState]\r\n    ConcreteState3[具体状态3<br/>AttackState]\r\n    \r\n    Context -->|管理| StateInterface\r\n    StateInterface -->|实现| ConcreteState1\r\n    StateInterface -->|实现| ConcreteState2\r\n    StateInterface -->|实现| ConcreteState3\r\n    \r\n    style Context fill:#f3e5f5\r\n    style StateInterface fill:#e1f5ff\r\n    style ConcreteState1 fill:#c8e6c9\r\n    style ConcreteState2 fill:#c8e6c9\r\n    style ConcreteState3 fill:#c8e6c9\r\n```\r\n\r\n**优势**：\r\n- ✅ **状态隔离**：每个状态独立管理自己的逻辑\r\n- ✅ **易于扩展**：新增状态只需添加新的状态类\r\n- ✅ **消除条件判断**：状态切换逻辑清晰，避免大量if-else\r\n\r\n### 对象池模式（Object Pool Pattern）\r\n\r\n**核心思想**：状态机实例复用，减少GC压力\r\n\r\n```mermaid\r\ngraph LR\r\n    Request[请求状态机<br/>FSMKit.Pop] --> CheckPool{检查对象池<br/>pool}\r\n    CheckPool -->|池中有| Reuse[复用实例<br/>Reset]\r\n    CheckPool -->|池中无| Create[创建新实例<br/>New]\r\n    Reuse --> Return[返回状态机]\r\n    Create --> Return\r\n    \r\n    Release[释放状态机<br/>Push] --> Reset[重置状态机<br/>Reset]\r\n    Reset --> ReturnToPool[归还到池<br/>pool.push]\r\n    \r\n    style CheckPool fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style Reuse fill:#c8e6c9\r\n    style ReturnToPool fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 数据流设计\r\n\r\n### 状态切换数据流\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Client as 客户端\r\n    participant FSM as FSMKit\r\n    participant CurrentState as 当前状态\r\n    participant NewState as 新状态\r\n    participant EventSystem as 事件系统\r\n    \r\n    Client->>FSM: ChangeState(newStateId)\r\n    FSM->>CurrentState: Exit()\r\n    CurrentState-->>FSM: 退出完成\r\n    FSM->>EventSystem: OnStateChanged(oldState, newStateId)\r\n    FSM->>FSM: 查找新状态 stateDict[newStateId]\r\n    FSM->>NewState: New() 创建实例\r\n    FSM->>NewState: Enter()\r\n    NewState-->>FSM: 进入完成\r\n    FSM->>FSM: currentState = newState\r\n    FSM->>EventSystem: OnStateChanged(oldState, newState)\r\n    FSM-->>Client: 切换完成\r\n```\r\n\r\n### 并发状态机更新数据流\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Client as 客户端\r\n    participant ParallelFSM as ParallelFSMKit\r\n    participant SubFSM1 as 子FSM1\r\n    participant SubFSM2 as 子FSM2\r\n    participant SubFSM3 as 子FSM3\r\n    \r\n    Client->>ParallelFSM: Update(dt)\r\n    ParallelFSM->>SubFSM1: Update(dt)\r\n    ParallelFSM->>SubFSM2: Update(dt)\r\n    ParallelFSM->>SubFSM3: Update(dt)\r\n    SubFSM1-->>ParallelFSM: 更新完成\r\n    SubFSM2-->>ParallelFSM: 更新完成\r\n    SubFSM3-->>ParallelFSM: 更新完成\r\n    ParallelFSM-->>Client: 更新完成\r\n```\r\n\r\n---\r\n\r\n## 架构验证\r\n\r\n### 流程合理性验证\r\n\r\n从架构可验证：\r\n- ✅ **数据流完整**：状态切换 → 退出 → 进入 → 更新（完整流程）\r\n- ✅ **职责清晰**：基础状态机、下推状态机、并发状态机、层次状态机职责明确\r\n- ✅ **解耦设计**：通过状态模式和事件系统实现解耦\r\n- ✅ **生命周期管理**：状态进入/退出/暂停/恢复的完整生命周期\r\n\r\n### 扩展性验证\r\n\r\n从架构可验证：\r\n- ✅ **状态模式**：新增状态只需添加新的状态类\r\n- ✅ **多态设计**：通过继承实现多种状态机类型\r\n- ✅ **事件系统**：支持状态变化的事件监听\r\n- ✅ **对象池管理**：状态机实例复用，减少GC压力\r\n\r\n### 易用性验证\r\n\r\n从架构可验证：\r\n- ✅ **统一接口**：所有状态机类型使用统一的接口\r\n- ✅ **标准化流程**：状态切换流程标准化\r\n- ✅ **事件驱动**：状态变化通过事件通知\r\n- ✅ **调试支持**：提供调试日志和调试信息\r\n\r\n---\r\n\r\n## 开发指导原则\r\n\r\n### 一、开发约束（什么能做，什么不能做）\r\n\r\n#### ✅ 应该做的\r\n\r\n1. **状态必须继承FSMState**\r\n   ```\r\n   ✅ 正确：\r\n   local MyState = BaseClass(FSMState)\r\n   \r\n   ❌ 错误：\r\n   不继承FSMState的状态类\r\n   ```\r\n\r\n2. **状态切换必须通过ChangeState**\r\n   ```\r\n   ✅ 正确：\r\n   fsm:ChangeState(newStateId)\r\n   \r\n   ❌ 错误：\r\n   直接修改currentState\r\n   ```\r\n\r\n3. **状态机必须使用对象池**\r\n   ```\r\n   ✅ 正确：\r\n   local fsm = FSMKit.Pop(type)\r\n   -- 使用后\r\n   fsm:Push()\r\n   \r\n   ❌ 错误：\r\n   直接创建状态机实例\r\n   ```\r\n\r\n#### ❌ 不应该做的\r\n\r\n1. **禁止直接修改状态机内部状态**\r\n   - 必须通过ChangeState切换状态\r\n   - 不能直接修改currentState\r\n\r\n2. **禁止在状态Update中执行耗时操作**\r\n   - Update方法应该快速执行\r\n   - 耗时操作应该异步处理\r\n\r\n3. **禁止状态之间直接依赖**\r\n   - 状态之间应该通过状态机通信\r\n   - 不能直接调用其他状态的方法\r\n\r\n### 二、开发流程（标准化开发步骤）\r\n\r\n#### 开发新状态的流程\r\n\r\n```\r\n1. 定义状态枚举\r\n   ↓\r\n   ECharacterState = { Idle = 1, Move = 2 }\r\n   \r\n2. 创建状态类\r\n   ↓\r\n   local IdleState = BaseClass(FSMState)\r\n   function IdleState:Enter() end\r\n   function IdleState:Update() end\r\n   function IdleState:Exit() end\r\n   \r\n3. 注册状态\r\n   ↓\r\n   fsm:AddState(ECharacterState.Idle, IdleState)\r\n   \r\n4. 切换状态\r\n   ↓\r\n   fsm:ChangeState(ECharacterState.Idle)\r\n```\r\n\r\n---\r\n\r\n## 总结\r\n\r\n### 架构设计价值\r\n\r\n该架构设计文档的价值在于：\r\n- ✅ **思路解构**：完整解构状态机系统的搭建思路\r\n- ✅ **流程验证**：从架构层面验证流程合理性\r\n- ✅ **模式分析**：分析状态模式、对象池模式的应用\r\n- ✅ **开发指导**：为后续详细设计和实现提供清晰指导\r\n\r\n### 设计原则\r\n\r\n- ✅ **状态模式为核心**：状态封装行为，状态机管理状态切换\r\n- ✅ **多态状态机架构**：通过继承实现多种状态机类型\r\n- ✅ **对象池管理 + 事件驱动**：状态机实例复用，状态变化通过事件通知\r\n- ✅ **生命周期管理**：状态进入/退出/暂停/恢复的标准化流程\r\n\r\n### 架构特点\r\n\r\n- ✅ **状态隔离**：每个状态独立管理自己的逻辑\r\n- ✅ **灵活扩展**：支持基础、下推、并发、层次四种状态机类型\r\n- ✅ **事件驱动**：状态变化通过事件通知，实现解耦\r\n- ✅ **性能优化**：对象池管理，减少GC压力\r\n\r\n细节实现是后续开发阶段的工作，当前架构设计已足够指导整个状态机系统的开发。\r\n"
        }
    ]
}