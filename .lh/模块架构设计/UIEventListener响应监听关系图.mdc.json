{
    "sourceFile": "模块架构设计/UIEventListener响应监听关系图.mdc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 9,
            "patches": [
                {
                    "date": 1767363593458,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767363608745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -304,16 +304,22 @@\n ```\n \n ## 优化效果对比\n \n-| 指标 | 当前方案 | 优化方案（静态管理器） |\n+| 指标 | 当前方案 | 优化方案（静态管理器+按需协程） |\n |------|---------|---------------------|\n-| **协程数量** | N个（每个实例1个） | 1个（全局唯一） |\n-| **CPU消耗** | N × 20次/秒 | 1 × 10次/秒 |\n+| **协程数量** | N个（每个实例1个） | 1个（全局唯一，按需启动） |\n+| **CPU消耗** | N × 20次/秒 | M × 10次/秒（M=需要协程的实例数） |\n | **内存占用** | N个协程对象 | 1个协程对象 + HashSet |\n | **调度开销** | N个协程调度 | 1个协程调度 |\n | **检查频率** | 每0.05秒 | 可统一调整（建议0.1秒） |\n+| **按需启动** | ❌ 所有实例都启动协程 | ✅ 只有需要协程事件的实例才启动 |\n \n+**说明**：\n+- M = 需要协程事件的 Listener 数量（通常远小于 N）\n+- 如果100个UI元素中只有10个需要Press/Continue事件，则只有10个会启动协程检查\n+- 其他90个只需要Click事件的，不会启动协程，直接处理Click事件\n+\n ## 实现建议\n \n 1. **静态管理器设计**\n    - 使用静态类，不依赖实例\n"
                },
                {
                    "date": 1767363759982,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -243,32 +243,38 @@\n ```mermaid\n graph TB\n     subgraph PressCoroutineManager[\"PressCoroutineManager（静态类）\"]\n         ActiveListeners[activeListeners<br/>HashSet<UIEventListener>]\n-        GlobalCoroutine[globalCoroutine<br/>Coroutine]\n+        GlobalCoroutine[globalCoroutine<br/>唯一协程<br/>由静态类控制]\n         CoroutineHost[coroutineHost<br/>MonoBehaviour]\n         LockObj[lockObj<br/>线程锁]\n-        NeedCoroutine[NeedCoroutine方法<br/>判断是否需要协程]\n+        StartCoroutine[启动协程<br/>静态类统一控制]\n+        StopCoroutine[停止协程<br/>静态类统一控制]\n     end\n     \n     subgraph UIEventListener[\"UIEventListener实例\"]\n         EventTypes[注册的事件类型<br/>Click/Press/Continue等]\n-        OnPointerDown -->|判断是否需要协程| NeedCoroutine\n-        NeedCoroutine -->|需要| Register[Register到管理器]\n-        NeedCoroutine -->|不需要| Skip[跳过注册]\n+        TimePointManager[时间点管理<br/>Press时间点/Continue间隔等]\n+        OnPointerDown -->|判断是否需要协程| CheckNeed[检查是否需要协程]\n+        CheckNeed -->|需要| Register[Register到管理器]\n+        CheckNeed -->|不需要| Skip[跳过注册]\n+        Register -->|通知管理器| StartCoroutine\n         OnPointerUp -->|已注册则| Unregister[Unregister]\n         OnDisable -->|已注册则| Unregister\n-        UpdatePressState[UpdatePressState方法<br/>被管理器调用]\n+        Unregister -->|通知管理器| StopCoroutine\n+        UpdateTimeCheck[UpdateTimeCheck方法<br/>被管理器调用<br/>检查自己的时间点]\n     end\n     \n-    PressCoroutineManager -->|启动| GlobalCoroutine\n-    GlobalCoroutine -->|每0.1秒遍历| ActiveListeners\n-    ActiveListeners -->|调用| UpdatePressState\n+    PressCoroutineManager -->|启动唯一协程| GlobalCoroutine\n+    GlobalCoroutine -->|每帧/固定间隔遍历| ActiveListeners\n+    ActiveListeners -->|调用| UpdateTimeCheck\n+    UpdateTimeCheck -->|检查时间点| TimePointManager\n+    TimePointManager -->|触发事件| EventCallbacks[事件回调]\n     \n     style PressCoroutineManager fill:#c8e6c9\n     style GlobalCoroutine fill:#fff4e1\n     style ActiveListeners fill:#e1f5ff\n-    style NeedCoroutine fill:#ffebee\n+    style TimePointManager fill:#ffebee\n ```\n \n ### 数据流\n \n@@ -276,22 +282,30 @@\n sequenceDiagram\n     participant User as 用户操作\n     participant Listener as UIEventListener\n     participant Manager as PressCoroutineManager\n-    participant Coroutine as 全局协程\n+    participant Coroutine as 全局协程（唯一）\n     participant Callback as 事件回调\n     \n     User->>Listener: 按下UI元素\n     Listener->>Listener: 判断是否需要协程<br/>检查是否注册了Press/Continue事件\n     alt 需要协程\n-        Listener->>Manager: Register(this)\n+        Listener->>Listener: 获取自己的checkInterval<br/>（如：0.1秒、0.2秒等）\n+        Listener->>Manager: Register(this, checkInterval)\n+        Manager->>Manager: 创建ListenerInfo<br/>记录checkInterval和lastCheckTime\n         Manager->>Coroutine: 启动全局协程（如果未启动）\n         \n-        loop 每0.1秒\n+        loop 每0.05秒（统一检查间隔）\n             Coroutine->>Manager: 遍历activeListeners\n-            Manager->>Listener: UpdatePressState()\n-            Listener->>Listener: 检查长按/持续事件\n-            Listener->>Callback: 触发事件\n+            Manager->>Manager: 检查每个Listener的时间点<br/>currentTime - lastCheckTime >= checkInterval?\n+            alt 到达时间点\n+                Manager->>Listener: UpdatePressState()\n+                Listener->>Listener: 检查长按/持续事件\n+                Listener->>Callback: 触发事件\n+                Manager->>Manager: 更新lastCheckTime\n+            else 未到达时间点\n+                Manager->>Manager: 跳过，不调用\n+            end\n         end\n         \n         User->>Listener: 抬起UI元素\n         Listener->>Manager: Unregister(this)\n"
                },
                {
                    "date": 1767363766336,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -336,28 +336,45 @@\n ## 实现建议\n \n 1. **静态管理器设计**\n    - 使用静态类，不依赖实例\n-   - 使用HashSet存储活跃监听器（O(1)查找和删除）\n+   - 使用HashSet存储活跃监听器信息（ListenerInfo）\n    - 使用锁保护线程安全\n+   - **唯一协程**：所有协程由静态类统一控制，只有一个全局协程\n \n-2. **按需协程判断**\n+2. **ListenerInfo 数据结构**\n+   ```lua\n+   ListenerInfo = {\n+       listener = UIEventListener,  -- 监听器实例\n+       checkInterval = 0.1,          -- 检查间隔（由Listener配置）\n+       lastCheckTime = 0,             -- 上次检查时间\n+       pressStartTime = 0             -- 按下开始时间\n+   }\n+   ```\n+\n+3. **协程统一管理**\n+   - **全局协程**：静态类运行唯一协程，统一检查间隔（如：每0.05秒）\n+   - **时间点判断**：遍历 activeListeners，检查每个 Listener 是否到达自己的时间点\n+   - **按需调用**：只有到达时间点的 Listener 才调用 UpdatePressState\n+\n+4. **按需协程判断**\n    - **判断条件**：检查 Listener 是否注册了需要协程的事件（Press、Continue 等）\n    - **实现方式**：在 OnPointerDown 时调用 `NeedCoroutine()` 方法判断\n-   - **优化效果**：只有需要协程事件的 Listener 才会启动协程，减少不必要的协程\n+   - **优化效果**：只有需要协程事件的 Listener 才会注册到管理器\n \n-3. **生命周期管理**\n-   - OnPointerDown 时：判断是否需要协程，需要则注册\n+5. **时间点配置**\n+   - **统一检查间隔**：静态类协程统一检查间隔（如：每0.05秒）\n+   - **各自时间点**：每个 Listener 可以配置自己的 checkInterval（如：0.1秒、0.2秒）\n+   - **时间点判断**：`currentTime - lastCheckTime >= checkInterval` 时调用 UpdatePressState\n+\n+6. **生命周期管理**\n+   - OnPointerDown 时：判断是否需要协程，需要则注册（传入 checkInterval）\n    - OnPointerUp 时：已注册的才需要注销\n    - OnDisable 时：已注册的才需要注销（防止内存泄漏）\n \n-4. **检查频率优化**\n-   - 从0.05秒增加到0.1秒（减少50%检查次数）\n-   - 可以根据需要调整\n-\n-5. **状态更新方法**\n+7. **状态更新方法**\n    - 每个UIEventListener提供UpdatePressState方法\n-   - 由管理器统一调用，避免直接访问私有字段\n+   - 由管理器按时间点调用，避免直接访问私有字段\n \n-6. **事件类型判断**\n+8. **事件类型判断**\n    - 需要协程的事件：Press、Continue、LongPress 等需要持续检查的事件\n    - 不需要协程的事件：Click、PointerDown、PointerUp 等一次性事件\n"
                },
                {
                    "date": 1767363791803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,62 +132,69 @@\n ### 方案1：静态协程管理器（推荐）\n \n ```mermaid\n graph TB\n-    subgraph StaticManager[\"静态协程管理器\"]\n-        Manager[PressCoroutineManager<br/>单例管理器]\n-        ActiveSet[活跃监听器集合<br/>HashSet<UIEventListener>]\n-        GlobalCoroutine[全局协程<br/>唯一协程]\n-        NeedCoroutineCheck[判断是否需要协程<br/>检查事件类型]\n+    subgraph StaticManager[\"静态协程管理器（唯一控制协程）\"]\n+        Manager[PressCoroutineManager<br/>静态类]\n+        ActiveSet[活跃监听器集合<br/>HashSet<ListenerInfo>]\n+        GlobalCoroutine[全局协程<br/>唯一协程<br/>由静态类控制]\n+        CheckInterval[统一检查间隔<br/>每0.05秒]\n     end\n     \n+    subgraph ListenerInfo[\"ListenerInfo（各自时间点）\"]\n+        Info1[Listener1<br/>checkInterval: 0.1秒<br/>lastCheckTime]\n+        Info2[Listener2<br/>checkInterval: 0.2秒<br/>lastCheckTime]\n+        Info3[Listener3<br/>checkInterval: 0.1秒<br/>lastCheckTime]\n+    end\n+    \n     subgraph UIEventListenerInstances[\"UIEventListener实例组\"]\n-        Listener1[UIEventListener实例1<br/>需要Press/Continue事件]\n-        Listener2[UIEventListener实例2<br/>只需要Click事件]\n-        Listener3[UIEventListener实例3<br/>需要Press/Continue事件]\n+        Listener1[UIEventListener实例1<br/>checkInterval: 0.1秒]\n+        Listener2[UIEventListener实例2<br/>checkInterval: 0.2秒]\n+        Listener3[UIEventListener实例3<br/>checkInterval: 0.1秒]\n         ListenerN[UIEventListener实例N<br/>只需要Click事件]\n     end\n     \n     subgraph EventFlow[\"事件流程\"]\n-        OnPointerDown1[OnPointerDown1] -->|判断是否需要协程| NeedCoroutineCheck\n+        OnPointerDown1[OnPointerDown1] -->|判断是否需要协程| NeedCoroutineCheck[NeedCoroutine检查]\n         OnPointerDown2[OnPointerDown2] -->|判断是否需要协程| NeedCoroutineCheck\n         OnPointerDown3[OnPointerDown3] -->|判断是否需要协程| NeedCoroutineCheck\n         OnPointerDownN[OnPointerDownN] -->|判断是否需要协程| NeedCoroutineCheck\n         \n-        NeedCoroutineCheck -->|需要协程| Register[Register到管理器]\n+        NeedCoroutineCheck -->|需要协程| Register[Register到管理器<br/>传入checkInterval]\n         NeedCoroutineCheck -->|不需要协程| Skip[跳过注册]\n         \n-        Register -->|启动协程| Manager\n+        Register -->|创建ListenerInfo| Manager\n+        Manager -->|启动唯一协程| GlobalCoroutine\n         Skip -->|不启动协程| NoCoroutine[不启动协程]\n         \n         OnPointerUp1[OnPointerUp1] -->|Unregister| Manager\n-        OnPointerUp2[OnPointerUp2] -->|无需注销| NoUnregister[无需注销]\n+        OnPointerUp2[OnPointerUp2] -->|Unregister| Manager\n         OnPointerUp3[OnPointerUp3] -->|Unregister| Manager\n-        OnPointerUpN[OnPointerUpN] -->|无需注销| NoUnregister\n+        OnPointerUpN[OnPointerUpN] -->|无需注销| NoUnregister[无需注销]\n     end\n     \n-    Manager -->|遍历检查| ActiveSet\n-    ActiveSet -->|UpdatePressState| Listener1\n-    ActiveSet -->|UpdatePressState| Listener3\n+    GlobalCoroutine -->|每0.05秒遍历| ActiveSet\n+    ActiveSet -->|检查时间点| ListenerInfo\n+    ListenerInfo -->|到达时间点则调用| UpdatePressState[UpdatePressState]\n     \n-    GlobalCoroutine -->|每0.1秒| Manager\n-    \n     style Manager fill:#c8e6c9\n     style GlobalCoroutine fill:#fff4e1\n     style ActiveSet fill:#e1f5ff\n-    style NeedCoroutineCheck fill:#ffebee\n+    style ListenerInfo fill:#ffebee\n ```\n \n **核心设计**：\n-- ✅ **按需启动协程**：判断 Listener 是否需要协程事件（Press/Continue），只有需要时才注册到管理器\n-- ✅ **动态管理**：OnPointerDown 时判断是否需要协程，需要则注册；OnPointerUp 时判断是否需要注销\n-- ✅ **协程数量优化**：只有需要协程事件的 Listener 才会启动协程，减少不必要的协程\n+- ✅ **静态类统一控制**：所有协程由静态类统一控制，只有一个全局协程\n+- ✅ **各自时间点**：每个 Listener 配置自己的 checkInterval（如：0.1秒、0.2秒）\n+- ✅ **统一检查间隔**：静态类协程统一检查间隔（如：每0.05秒），但根据各自时间点判断是否调用\n+- ✅ **按需启动**：判断 Listener 是否需要协程事件，只有需要时才注册到管理器\n \n **实现要点**：\n-1. **判断是否需要协程**：检查 Listener 是否注册了需要协程的事件（Press、Continue 等）\n-2. **按需注册**：OnPointerDown 时，只有需要协程的 Listener 才注册到管理器\n-3. **按需注销**：OnPointerUp 时，只有已注册的 Listener 才需要注销\n-4. **协程管理**：管理器维护活跃监听器集合，当集合为空时停止协程\n+1. **静态类统一管理**：所有协程由 PressCoroutineManager 静态类统一控制\n+2. **ListenerInfo 数据结构**：存储 listener、checkInterval、lastCheckTime\n+3. **时间点判断**：遍历时检查 `currentTime - lastCheckTime >= checkInterval`，到达时间点才调用\n+4. **按需注册**：OnPointerDown 时，需要协程的 Listener 才注册（传入 checkInterval）\n+5. **协程管理**：管理器维护活跃监听器集合，当集合为空时停止协程\n \n ### 方案2：基于时间的延迟检查\n \n ```mermaid\n"
                },
                {
                    "date": 1767363811349,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -295,29 +295,27 @@\n     \n     User->>Listener: 按下UI元素\n     Listener->>Listener: 判断是否需要协程<br/>检查是否注册了Press/Continue事件\n     alt 需要协程\n-        Listener->>Listener: 获取自己的checkInterval<br/>（如：0.1秒、0.2秒等）\n-        Listener->>Manager: Register(this, checkInterval)\n-        Manager->>Manager: 创建ListenerInfo<br/>记录checkInterval和lastCheckTime\n-        Manager->>Coroutine: 启动全局协程（如果未启动）\n+        Listener->>Listener: 初始化自己的时间点管理<br/>Press时间点/Continue间隔等\n+        Listener->>Manager: Register(this)\n+        Manager->>Manager: 检查是否需要启动协程<br/>如果activeListeners为空则启动\n+        Manager->>Coroutine: 启动全局协程（由静态类控制）\n         \n-        loop 每0.05秒（统一检查间隔）\n+        loop 全局协程每帧/固定间隔（由静态类控制）\n             Coroutine->>Manager: 遍历activeListeners\n-            Manager->>Manager: 检查每个Listener的时间点<br/>currentTime - lastCheckTime >= checkInterval?\n-            alt 到达时间点\n-                Manager->>Listener: UpdatePressState()\n-                Listener->>Listener: 检查长按/持续事件\n-                Listener->>Callback: 触发事件\n-                Manager->>Manager: 更新lastCheckTime\n-            else 未到达时间点\n-                Manager->>Manager: 跳过，不调用\n+            Manager->>Listener: UpdateTimeCheck()<br/>让Listener检查自己的时间点\n+            Listener->>Listener: 检查自己的Press时间点<br/>检查自己的Continue间隔\n+            alt 达到时间点\n+                Listener->>Callback: 触发Press/Continue事件\n+                Listener->>Listener: 更新自己的时间点状态\n             end\n         end\n         \n         User->>Listener: 抬起UI元素\n         Listener->>Manager: Unregister(this)\n-        Manager->>Coroutine: 如果集合为空，停止协程\n+        Manager->>Manager: 检查是否需要停止协程<br/>如果activeListeners为空则停止\n+        Manager->>Coroutine: 如果集合为空，停止协程（由静态类控制）\n     else 不需要协程\n         Listener->>Listener: 不注册，直接处理Click事件\n         User->>Listener: 抬起UI元素\n         Listener->>Callback: 触发Click事件\n@@ -325,21 +323,23 @@\n ```\n \n ## 优化效果对比\n \n-| 指标 | 当前方案 | 优化方案（静态管理器+按需协程） |\n+| 指标 | 当前方案 | 优化方案（静态管理器+各自时间点） |\n |------|---------|---------------------|\n-| **协程数量** | N个（每个实例1个） | 1个（全局唯一，按需启动） |\n-| **CPU消耗** | N × 20次/秒 | M × 10次/秒（M=需要协程的实例数） |\n-| **内存占用** | N个协程对象 | 1个协程对象 + HashSet |\n+| **协程数量** | N个（每个实例1个） | 1个（全局唯一，由静态类控制） |\n+| **CPU消耗** | N × 20次/秒 | 统一检查间隔 × 到达时间点的实例数 |\n+| **内存占用** | N个协程对象 | 1个协程对象 + HashSet<ListenerInfo> |\n | **调度开销** | N个协程调度 | 1个协程调度 |\n-| **检查频率** | 每0.05秒 | 可统一调整（建议0.1秒） |\n-| **按需启动** | ❌ 所有实例都启动协程 | ✅ 只有需要协程事件的实例才启动 |\n+| **检查频率** | 每0.05秒（各自独立） | 统一检查间隔（如：0.05秒）+ 各自时间点判断 |\n+| **时间点控制** | ❌ 各自独立协程 | ✅ 静态类统一控制，各自配置时间点 |\n+| **按需启动** | ❌ 所有实例都启动协程 | ✅ 只有需要协程事件的实例才注册 |\n \n **说明**：\n-- M = 需要协程事件的 Listener 数量（通常远小于 N）\n-- 如果100个UI元素中只有10个需要Press/Continue事件，则只有10个会启动协程检查\n-- 其他90个只需要Click事件的，不会启动协程，直接处理Click事件\n+- **统一检查间隔**：静态类协程统一检查间隔（如：每0.05秒）\n+- **各自时间点**：每个 Listener 配置自己的 checkInterval（如：0.1秒、0.2秒）\n+- **时间点判断**：遍历时检查 `currentTime - lastCheckTime >= checkInterval`，到达时间点才调用\n+- **优化效果**：如果100个UI元素中只有10个需要Press/Continue事件，则只有10个会注册到管理器，但只有一个全局协程在运行\n \n ## 实现建议\n \n 1. **静态管理器设计**\n"
                },
                {
                    "date": 1767363832586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -341,47 +341,55 @@\n - **优化效果**：如果100个UI元素中只有10个需要Press/Continue事件，则只有10个会注册到管理器，但只有一个全局协程在运行\n \n ## 实现建议\n \n-1. **静态管理器设计**\n-   - 使用静态类，不依赖实例\n-   - 使用HashSet存储活跃监听器信息（ListenerInfo）\n+1. **静态管理器设计（核心）**\n+   - 使用静态类，统一管理所有协程\n+   - **唯一协程**：只有一个全局协程，由静态类控制启动/停止\n+   - 使用HashSet存储活跃监听器（O(1)查找和删除）\n    - 使用锁保护线程安全\n-   - **唯一协程**：所有协程由静态类统一控制，只有一个全局协程\n+   - **协程控制**：当第一个 Listener 注册时启动协程，当所有 Listener 注销后停止协程\n \n-2. **ListenerInfo 数据结构**\n-   ```lua\n-   ListenerInfo = {\n-       listener = UIEventListener,  -- 监听器实例\n-       checkInterval = 0.1,          -- 检查间隔（由Listener配置）\n-       lastCheckTime = 0,             -- 上次检查时间\n-       pressStartTime = 0             -- 按下开始时间\n-   }\n-   ```\n+2. **时间点管理（由各 Listener 自己管理）**\n+   - **Press 时间点**：每个 Listener 记录自己的 Press 触发时间点（如按下后 0.5 秒）\n+   - **Continue 间隔**：每个 Listener 记录自己的 Continue 触发间隔（如每 0.1 秒）\n+   - **UpdateTimeCheck**：由全局协程调用，让 Listener 自己检查是否达到时间点\n+   - **灵活性**：每个 Listener 可以有不同的时间点配置\n \n-3. **协程统一管理**\n-   - **全局协程**：静态类运行唯一协程，统一检查间隔（如：每0.05秒）\n-   - **时间点判断**：遍历 activeListeners，检查每个 Listener 是否到达自己的时间点\n-   - **按需调用**：只有到达时间点的 Listener 才调用 UpdatePressState\n+3. **协程职责**\n+   - **全局协程**：只负责遍历 activeListeners，调用每个 Listener 的 UpdateTimeCheck 方法\n+   - **检查频率**：由静态类统一控制（如每帧或每 0.05 秒）\n+   - **不管理时间点**：协程不判断时间点，只负责调用 Listener 的检查方法\n \n 4. **按需协程判断**\n    - **判断条件**：检查 Listener 是否注册了需要协程的事件（Press、Continue 等）\n    - **实现方式**：在 OnPointerDown 时调用 `NeedCoroutine()` 方法判断\n    - **优化效果**：只有需要协程事件的 Listener 才会注册到管理器\n \n-5. **时间点配置**\n-   - **统一检查间隔**：静态类协程统一检查间隔（如：每0.05秒）\n-   - **各自时间点**：每个 Listener 可以配置自己的 checkInterval（如：0.1秒、0.2秒）\n-   - **时间点判断**：`currentTime - lastCheckTime >= checkInterval` 时调用 UpdatePressState\n-\n-6. **生命周期管理**\n-   - OnPointerDown 时：判断是否需要协程，需要则注册（传入 checkInterval）\n+5. **生命周期管理**\n+   - OnPointerDown 时：判断是否需要协程，需要则注册到管理器\n    - OnPointerUp 时：已注册的才需要注销\n    - OnDisable 时：已注册的才需要注销（防止内存泄漏）\n \n-7. **状态更新方法**\n-   - 每个UIEventListener提供UpdatePressState方法\n-   - 由管理器按时间点调用，避免直接访问私有字段\n+6. **时间点检查示例**\n+   ```lua\n+   -- Listener 内部管理时间点\n+   function UIEventListener:UpdateTimeCheck()\n+       local currentTime = Time.time\n+       \n+       -- 检查 Press 时间点\n+       if self.needPress and currentTime >= self.pressTimePoint then\n+           self:TriggerPressEvent()\n+           self.pressTimePoint = nil  -- 只触发一次\n+       end\n+       \n+       -- 检查 Continue 间隔\n+       if self.needContinue and currentTime >= self.nextContinueTime then\n+           self:TriggerContinueEvent()\n+           self.nextContinueTime = currentTime + self.continueInterval\n+       end\n+   end\n+   ```\n \n-8. **事件类型判断**\n+7. **事件类型判断**\n    - 需要协程的事件：Press、Continue、LongPress 等需要持续检查的事件\n    - 不需要协程的事件：Click、PointerDown、PointerUp 等一次性事件\n"
                },
                {
                    "date": 1767363860532,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,395 +1,47 @@\n # UIEventListener 响应监听关系图\n \n-## 当前架构：响应监听关系\n+## 架构设计\n \n ```mermaid\n graph TB\n-    subgraph UnityEventSystem[\"Unity事件系统\"]\n-        PointerDown[PointerDown事件]\n-        PointerUp[PointerUp事件]\n-        PointerClick[PointerClick事件]\n-        PointerEnter[PointerEnter事件]\n-        PointerExit[PointerExit事件]\n-        BeginDrag[BeginDrag事件]\n-        Drag[Drag事件]\n-        EndDrag[EndDrag事件]\n-    end\n-    \n-    subgraph UIEventListenerInstances[\"UIEventListener实例组\"]\n-        Listener1[UIEventListener实例1<br/>协程1]\n-        Listener2[UIEventListener实例2<br/>协程2]\n-        Listener3[UIEventListener实例3<br/>协程3]\n-        ListenerN[UIEventListener实例N<br/>协程N]\n-    end\n-    \n-    subgraph EventHandlers[\"事件处理器\"]\n-        OnPointerDown[OnPointerDown]\n-        OnPointerUp[OnPointerUp]\n-        OnPointerClick[OnPointerClick]\n-        OnPointerEnter[OnPointerEnter]\n-        OnPointerExit[OnPointerExit]\n-        OnBeginDrag[OnBeginDrag]\n-        OnDrag[OnDrag]\n-        OnEndDrag[OnEndDrag]\n-    end\n-    \n-    subgraph Coroutines[\"协程处理\"]\n-        PressCoroutine1[PressCoroutine1<br/>每0.05秒检查]\n-        PressCoroutine2[PressCoroutine2<br/>每0.05秒检查]\n-        PressCoroutine3[PressCoroutine3<br/>每0.05秒检查]\n-        PressCoroutineN[PressCoroutineN<br/>每0.05秒检查]\n-    end\n-    \n-    subgraph EventCallbacks[\"事件回调\"]\n-        ClickCallbacks[Click回调]\n-        PressCallbacks[Press回调]\n-        ContinueCallbacks[Continue回调]\n-        OtherCallbacks[其他回调]\n-    end\n-    \n-    subgraph UpperSystems[\"上层系统\"]\n-        GuideSystem[引导系统<br/>ClickDetector等]\n-        UISystem[UI系统]\n-        GameLogic[游戏逻辑]\n-    end\n-    \n-    UnityEventSystem -->|事件分发| UIEventListenerInstances\n-    UIEventListenerInstances -->|实现接口| EventHandlers\n-    \n-    OnPointerDown -->|启动协程| Coroutines\n-    OnPointerUp -->|停止协程| Coroutines\n-    \n-    Coroutines -->|触发事件| EventCallbacks\n-    EventHandlers -->|触发事件| EventCallbacks\n-    \n-    EventCallbacks -->|回调通知| UpperSystems\n-    \n-    style UIEventListenerInstances fill:#ffebee\n-    style Coroutines fill:#fff4e1\n-    style EventCallbacks fill:#c8e6c9\n-    style UpperSystems fill:#e1f5ff\n-```\n-\n-## 当前问题分析\n-\n-### 1. 协程数量问题\n-\n-```mermaid\n-graph LR\n-    UserAction[用户按下N个UI元素] -->|每个实例启动| Coroutine1[协程1]\n-    UserAction -->|每个实例启动| Coroutine2[协程2]\n-    UserAction -->|每个实例启动| Coroutine3[协程3]\n-    UserAction -->|每个实例启动| CoroutineN[协程N]\n-    \n-    Coroutine1 -->|每0.05秒| Check1[检查1]\n-    Coroutine2 -->|每0.05秒| Check2[检查2]\n-    Coroutine3 -->|每0.05秒| Check3[检查3]\n-    CoroutineN -->|每0.05秒| CheckN[检查N]\n-    \n-    Check1 --> CPU[CPU消耗：N个协程<br/>每0.05秒执行一次]\n-    Check2 --> CPU\n-    Check3 --> CPU\n-    CheckN --> CPU\n-    \n-    style CPU fill:#ffcdd2\n-```\n-\n-**问题**：\n-- 如果有100个UI元素同时按下，会有100个协程在运行\n-- 每个协程每0.05秒执行一次，CPU消耗大\n-- 协程调度开销：Unity需要管理大量协程的生命周期\n-\n-### 2. 事件监听关系\n-\n-```mermaid\n-graph TB\n-    subgraph EventFlow[\"事件流转\"]\n-        UnityEvent[Unity事件] --> Listener[UIEventListener]\n-        Listener -->|AddListener注册| Callback1[回调1]\n-        Listener -->|AddListener注册| Callback2[回调2]\n-        Listener -->|AddListener注册| CallbackN[回调N]\n-        \n-        Callback1 --> GuideSystem[引导系统]\n-        Callback2 --> UISystem[UI系统]\n-        CallbackN --> GameLogic[游戏逻辑]\n-    end\n-    \n-    subgraph CoroutineFlow[\"协程流转\"]\n-        OnPointerDown -->|启动| PressCoroutine\n-        PressCoroutine -->|每0.05秒| CheckState[检查状态]\n-        CheckState -->|触发| ContinueEvent[Continue事件]\n-        CheckState -->|触发| PressEvent[Press事件]\n-        ContinueEvent --> Callback1\n-        PressEvent --> Callback2\n-    end\n-    \n-    style PressCoroutine fill:#fff4e1\n-    style CheckState fill:#ffcdd2\n-```\n-\n-## 优化方案对比\n-\n-### 方案1：静态协程管理器（推荐）\n-\n-```mermaid\n-graph TB\n-    subgraph StaticManager[\"静态协程管理器（唯一控制协程）\"]\n-        Manager[PressCoroutineManager<br/>静态类]\n-        ActiveSet[活跃监听器集合<br/>HashSet<ListenerInfo>]\n-        GlobalCoroutine[全局协程<br/>唯一协程<br/>由静态类控制]\n-        CheckInterval[统一检查间隔<br/>每0.05秒]\n-    end\n-    \n-    subgraph ListenerInfo[\"ListenerInfo（各自时间点）\"]\n-        Info1[Listener1<br/>checkInterval: 0.1秒<br/>lastCheckTime]\n-        Info2[Listener2<br/>checkInterval: 0.2秒<br/>lastCheckTime]\n-        Info3[Listener3<br/>checkInterval: 0.1秒<br/>lastCheckTime]\n-    end\n-    \n-    subgraph UIEventListenerInstances[\"UIEventListener实例组\"]\n-        Listener1[UIEventListener实例1<br/>checkInterval: 0.1秒]\n-        Listener2[UIEventListener实例2<br/>checkInterval: 0.2秒]\n-        Listener3[UIEventListener实例3<br/>checkInterval: 0.1秒]\n-        ListenerN[UIEventListener实例N<br/>只需要Click事件]\n-    end\n-    \n-    subgraph EventFlow[\"事件流程\"]\n-        OnPointerDown1[OnPointerDown1] -->|判断是否需要协程| NeedCoroutineCheck[NeedCoroutine检查]\n-        OnPointerDown2[OnPointerDown2] -->|判断是否需要协程| NeedCoroutineCheck\n-        OnPointerDown3[OnPointerDown3] -->|判断是否需要协程| NeedCoroutineCheck\n-        OnPointerDownN[OnPointerDownN] -->|判断是否需要协程| NeedCoroutineCheck\n-        \n-        NeedCoroutineCheck -->|需要协程| Register[Register到管理器<br/>传入checkInterval]\n-        NeedCoroutineCheck -->|不需要协程| Skip[跳过注册]\n-        \n-        Register -->|创建ListenerInfo| Manager\n-        Manager -->|启动唯一协程| GlobalCoroutine\n-        Skip -->|不启动协程| NoCoroutine[不启动协程]\n-        \n-        OnPointerUp1[OnPointerUp1] -->|Unregister| Manager\n-        OnPointerUp2[OnPointerUp2] -->|Unregister| Manager\n-        OnPointerUp3[OnPointerUp3] -->|Unregister| Manager\n-        OnPointerUpN[OnPointerUpN] -->|无需注销| NoUnregister[无需注销]\n-    end\n-    \n-    GlobalCoroutine -->|每0.05秒遍历| ActiveSet\n-    ActiveSet -->|检查时间点| ListenerInfo\n-    ListenerInfo -->|到达时间点则调用| UpdatePressState[UpdatePressState]\n-    \n-    style Manager fill:#c8e6c9\n-    style GlobalCoroutine fill:#fff4e1\n-    style ActiveSet fill:#e1f5ff\n-    style ListenerInfo fill:#ffebee\n-```\n-\n-**核心设计**：\n-- ✅ **静态类统一控制**：所有协程由静态类统一控制，只有一个全局协程\n-- ✅ **各自时间点**：每个 Listener 配置自己的 checkInterval（如：0.1秒、0.2秒）\n-- ✅ **统一检查间隔**：静态类协程统一检查间隔（如：每0.05秒），但根据各自时间点判断是否调用\n-- ✅ **按需启动**：判断 Listener 是否需要协程事件，只有需要时才注册到管理器\n-\n-**实现要点**：\n-1. **静态类统一管理**：所有协程由 PressCoroutineManager 静态类统一控制\n-2. **ListenerInfo 数据结构**：存储 listener、checkInterval、lastCheckTime\n-3. **时间点判断**：遍历时检查 `currentTime - lastCheckTime >= checkInterval`，到达时间点才调用\n-4. **按需注册**：OnPointerDown 时，需要协程的 Listener 才注册（传入 checkInterval）\n-5. **协程管理**：管理器维护活跃监听器集合，当集合为空时停止协程\n-\n-### 方案2：基于时间的延迟检查\n-\n-```mermaid\n-graph TB\n-    subgraph TimeBasedCheck[\"基于时间的检查\"]\n-        OnPointerDown -->|记录时间| StartTime[开始时间]\n-        OnPointerUp -->|检查时间差| TimeCheck[时间检查]\n-        \n-        TimeCheck -->|时间差 > pressTime| TriggerPress[触发Press事件]\n-        TimeCheck -->|时间差 < pressTime| NoPress[不触发]\n-    end\n-    \n-    subgraph ContinueEvent[\"Continue事件处理\"]\n-        OnPointerDown -->|启动定时器| Timer[定时器<br/>每0.1秒触发]\n-        Timer -->|触发| ContinueEvent[Continue事件]\n-        OnPointerUp -->|停止定时器| StopTimer[停止定时器]\n-    end\n-    \n-    style Timer fill:#fff4e1\n-    style TimeCheck fill:#c8e6c9\n-```\n-\n-**优势**：\n-- ✅ 不需要协程，使用Unity的InvokeRepeating\n-- ✅ 更轻量，但需要额外的定时器管理\n-\n-**劣势**：\n-- ❌ 需要额外的定时器管理逻辑\n-- ❌ 不如协程灵活\n-\n-### 方案3：事件驱动（不推荐）\n-\n-```mermaid\n-graph TB\n-    subgraph EventDriven[\"事件驱动\"]\n-        OnPointerDown -->|记录状态| State[状态记录]\n-        Update[Unity Update] -->|每帧检查| CheckAll[检查所有按下状态]\n-        CheckAll -->|触发事件| Events[触发事件]\n-    end\n-    \n-    style CheckAll fill:#ffcdd2\n-```\n-\n-**劣势**：\n-- ❌ 需要在某个MonoBehaviour的Update中检查\n-- ❌ 耦合度高\n-- ❌ 不如协程管理器清晰\n-\n-## 推荐方案：静态协程管理器\n-\n-### 架构设计\n-\n-```mermaid\n-graph TB\n     subgraph PressCoroutineManager[\"PressCoroutineManager（静态类）\"]\n         ActiveListeners[activeListeners<br/>HashSet<UIEventListener>]\n-        GlobalCoroutine[globalCoroutine<br/>唯一协程<br/>由静态类控制]\n-        CoroutineHost[coroutineHost<br/>MonoBehaviour]\n-        LockObj[lockObj<br/>线程锁]\n-        StartCoroutine[启动协程<br/>静态类统一控制]\n-        StopCoroutine[停止协程<br/>静态类统一控制]\n+        GlobalCoroutine[globalCoroutine<br/>唯一协程<br/>由静态类控制启动/停止]\n     end\n     \n     subgraph UIEventListener[\"UIEventListener实例\"]\n-        EventTypes[注册的事件类型<br/>Click/Press/Continue等]\n-        TimePointManager[时间点管理<br/>Press时间点/Continue间隔等]\n+        TimePointManager[时间点管理<br/>Press时间点/Continue间隔等<br/>由各自Listener管理]\n         OnPointerDown -->|判断是否需要协程| CheckNeed[检查是否需要协程]\n         CheckNeed -->|需要| Register[Register到管理器]\n         CheckNeed -->|不需要| Skip[跳过注册]\n-        Register -->|通知管理器| StartCoroutine\n+        Register -->|通知管理器| StartCoroutine[启动协程<br/>如果未启动]\n         OnPointerUp -->|已注册则| Unregister[Unregister]\n-        OnDisable -->|已注册则| Unregister\n-        Unregister -->|通知管理器| StopCoroutine\n+        Unregister -->|通知管理器| StopCoroutine[停止协程<br/>如果集合为空]\n         UpdateTimeCheck[UpdateTimeCheck方法<br/>被管理器调用<br/>检查自己的时间点]\n     end\n     \n+    subgraph EventCallbacks[\"事件回调\"]\n+        PressEvent[Press事件]\n+        ContinueEvent[Continue事件]\n+        ClickEvent[Click事件]\n+    end\n+    \n     PressCoroutineManager -->|启动唯一协程| GlobalCoroutine\n     GlobalCoroutine -->|每帧/固定间隔遍历| ActiveListeners\n     ActiveListeners -->|调用| UpdateTimeCheck\n     UpdateTimeCheck -->|检查时间点| TimePointManager\n-    TimePointManager -->|触发事件| EventCallbacks[事件回调]\n+    TimePointManager -->|触发事件| EventCallbacks\n     \n     style PressCoroutineManager fill:#c8e6c9\n     style GlobalCoroutine fill:#fff4e1\n     style ActiveListeners fill:#e1f5ff\n     style TimePointManager fill:#ffebee\n ```\n \n-### 数据流\n+## 核心设计说明\n \n-```mermaid\n-sequenceDiagram\n-    participant User as 用户操作\n-    participant Listener as UIEventListener\n-    participant Manager as PressCoroutineManager\n-    participant Coroutine as 全局协程（唯一）\n-    participant Callback as 事件回调\n-    \n-    User->>Listener: 按下UI元素\n-    Listener->>Listener: 判断是否需要协程<br/>检查是否注册了Press/Continue事件\n-    alt 需要协程\n-        Listener->>Listener: 初始化自己的时间点管理<br/>Press时间点/Continue间隔等\n-        Listener->>Manager: Register(this)\n-        Manager->>Manager: 检查是否需要启动协程<br/>如果activeListeners为空则启动\n-        Manager->>Coroutine: 启动全局协程（由静态类控制）\n-        \n-        loop 全局协程每帧/固定间隔（由静态类控制）\n-            Coroutine->>Manager: 遍历activeListeners\n-            Manager->>Listener: UpdateTimeCheck()<br/>让Listener检查自己的时间点\n-            Listener->>Listener: 检查自己的Press时间点<br/>检查自己的Continue间隔\n-            alt 达到时间点\n-                Listener->>Callback: 触发Press/Continue事件\n-                Listener->>Listener: 更新自己的时间点状态\n-            end\n-        end\n-        \n-        User->>Listener: 抬起UI元素\n-        Listener->>Manager: Unregister(this)\n-        Manager->>Manager: 检查是否需要停止协程<br/>如果activeListeners为空则停止\n-        Manager->>Coroutine: 如果集合为空，停止协程（由静态类控制）\n-    else 不需要协程\n-        Listener->>Listener: 不注册，直接处理Click事件\n-        User->>Listener: 抬起UI元素\n-        Listener->>Callback: 触发Click事件\n-    end\n-```\n+**静态类统一控制**：所有协程由 `PressCoroutineManager` 静态类统一控制，只有一个全局协程。当第一个 Listener 注册时启动协程，当所有 Listener 注销后停止协程。\n \n-## 优化效果对比\n+**时间点各自管理**：每个 Listener 自己管理 Press 时间点、Continue 间隔等。全局协程只负责遍历 activeListeners，调用每个 Listener 的 `UpdateTimeCheck()` 方法，让 Listener 自己检查是否达到时间点。\n \n-| 指标 | 当前方案 | 优化方案（静态管理器+各自时间点） |\n-|------|---------|---------------------|\n-| **协程数量** | N个（每个实例1个） | 1个（全局唯一，由静态类控制） |\n-| **CPU消耗** | N × 20次/秒 | 统一检查间隔 × 到达时间点的实例数 |\n-| **内存占用** | N个协程对象 | 1个协程对象 + HashSet<ListenerInfo> |\n-| **调度开销** | N个协程调度 | 1个协程调度 |\n-| **检查频率** | 每0.05秒（各自独立） | 统一检查间隔（如：0.05秒）+ 各自时间点判断 |\n-| **时间点控制** | ❌ 各自独立协程 | ✅ 静态类统一控制，各自配置时间点 |\n-| **按需启动** | ❌ 所有实例都启动协程 | ✅ 只有需要协程事件的实例才注册 |\n-\n-**说明**：\n-- **统一检查间隔**：静态类协程统一检查间隔（如：每0.05秒）\n-- **各自时间点**：每个 Listener 配置自己的 checkInterval（如：0.1秒、0.2秒）\n-- **时间点判断**：遍历时检查 `currentTime - lastCheckTime >= checkInterval`，到达时间点才调用\n-- **优化效果**：如果100个UI元素中只有10个需要Press/Continue事件，则只有10个会注册到管理器，但只有一个全局协程在运行\n-\n-## 实现建议\n-\n-1. **静态管理器设计（核心）**\n-   - 使用静态类，统一管理所有协程\n-   - **唯一协程**：只有一个全局协程，由静态类控制启动/停止\n-   - 使用HashSet存储活跃监听器（O(1)查找和删除）\n-   - 使用锁保护线程安全\n-   - **协程控制**：当第一个 Listener 注册时启动协程，当所有 Listener 注销后停止协程\n-\n-2. **时间点管理（由各 Listener 自己管理）**\n-   - **Press 时间点**：每个 Listener 记录自己的 Press 触发时间点（如按下后 0.5 秒）\n-   - **Continue 间隔**：每个 Listener 记录自己的 Continue 触发间隔（如每 0.1 秒）\n-   - **UpdateTimeCheck**：由全局协程调用，让 Listener 自己检查是否达到时间点\n-   - **灵活性**：每个 Listener 可以有不同的时间点配置\n-\n-3. **协程职责**\n-   - **全局协程**：只负责遍历 activeListeners，调用每个 Listener 的 UpdateTimeCheck 方法\n-   - **检查频率**：由静态类统一控制（如每帧或每 0.05 秒）\n-   - **不管理时间点**：协程不判断时间点，只负责调用 Listener 的检查方法\n-\n-4. **按需协程判断**\n-   - **判断条件**：检查 Listener 是否注册了需要协程的事件（Press、Continue 等）\n-   - **实现方式**：在 OnPointerDown 时调用 `NeedCoroutine()` 方法判断\n-   - **优化效果**：只有需要协程事件的 Listener 才会注册到管理器\n-\n-5. **生命周期管理**\n-   - OnPointerDown 时：判断是否需要协程，需要则注册到管理器\n-   - OnPointerUp 时：已注册的才需要注销\n-   - OnDisable 时：已注册的才需要注销（防止内存泄漏）\n-\n-6. **时间点检查示例**\n-   ```lua\n-   -- Listener 内部管理时间点\n-   function UIEventListener:UpdateTimeCheck()\n-       local currentTime = Time.time\n-       \n-       -- 检查 Press 时间点\n-       if self.needPress and currentTime >= self.pressTimePoint then\n-           self:TriggerPressEvent()\n-           self.pressTimePoint = nil  -- 只触发一次\n-       end\n-       \n-       -- 检查 Continue 间隔\n-       if self.needContinue and currentTime >= self.nextContinueTime then\n-           self:TriggerContinueEvent()\n-           self.nextContinueTime = currentTime + self.continueInterval\n-       end\n-   end\n-   ```\n-\n-7. **事件类型判断**\n-   - 需要协程的事件：Press、Continue、LongPress 等需要持续检查的事件\n-   - 不需要协程的事件：Click、PointerDown、PointerUp 等一次性事件\n+**按需注册**：OnPointerDown 时判断是否需要协程（检查是否注册了 Press/Continue 事件），只有需要时才注册到管理器。\n"
                },
                {
                    "date": 1767363936225,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,40 +3,63 @@\n ## 架构设计\n \n ```mermaid\n graph TB\n-    subgraph PressCoroutineManager[\"PressCoroutineManager（静态类）\"]\n-        ActiveListeners[activeListeners<br/>HashSet<UIEventListener>]\n-        GlobalCoroutine[globalCoroutine<br/>唯一协程<br/>由静态类控制启动/停止]\n+    subgraph UserAction[\"用户操作\"]\n+        PressDown[按下UI元素]\n+        PressUp[抬起UI元素]\n     end\n     \n     subgraph UIEventListener[\"UIEventListener实例\"]\n-        TimePointManager[时间点管理<br/>Press时间点/Continue间隔等<br/>由各自Listener管理]\n-        OnPointerDown -->|判断是否需要协程| CheckNeed[检查是否需要协程]\n-        CheckNeed -->|需要| Register[Register到管理器]\n-        CheckNeed -->|不需要| Skip[跳过注册]\n-        Register -->|通知管理器| StartCoroutine[启动协程<br/>如果未启动]\n-        OnPointerUp -->|已注册则| Unregister[Unregister]\n-        Unregister -->|通知管理器| StopCoroutine[停止协程<br/>如果集合为空]\n-        UpdateTimeCheck[UpdateTimeCheck方法<br/>被管理器调用<br/>检查自己的时间点]\n+        OnPointerDown[OnPointerDown事件]\n+        NeedCoroutine[判断是否需要协程<br/>检查Press/Continue事件]\n+        Register[Register到管理器]\n+        OnPointerUp[OnPointerUp事件]\n+        Unregister[Unregister从管理器]\n+        UpdateTimeCheck[UpdateTimeCheck方法<br/>检查Press时间点<br/>检查Continue间隔]\n+        PressTimePoint[Press时间点<br/>如：按下后0.5秒]\n+        ContinueInterval[Continue间隔<br/>如：每0.1秒]\n     end\n     \n+    subgraph PressCoroutineManager[\"PressCoroutineManager（静态类）\"]\n+        ActiveListeners[activeListeners<br/>HashSet<UIEventListener>]\n+        GlobalCoroutine[globalCoroutine<br/>唯一协程<br/>每帧/0.05秒遍历]\n+        StartCoroutine[启动协程<br/>第一个Listener注册时]\n+        StopCoroutine[停止协程<br/>所有Listener注销后]\n+    end\n+    \n     subgraph EventCallbacks[\"事件回调\"]\n-        PressEvent[Press事件]\n-        ContinueEvent[Continue事件]\n-        ClickEvent[Click事件]\n+        PressEvent[触发Press事件]\n+        ContinueEvent[触发Continue事件]\n+        ClickEvent[触发Click事件]\n     end\n     \n-    PressCoroutineManager -->|启动唯一协程| GlobalCoroutine\n-    GlobalCoroutine -->|每帧/固定间隔遍历| ActiveListeners\n+    PressDown --> OnPointerDown\n+    OnPointerDown --> NeedCoroutine\n+    NeedCoroutine -->|需要协程| Register\n+    NeedCoroutine -->|不需要协程| ClickEvent\n+    Register --> ActiveListeners\n+    Register -->|如果集合为空| StartCoroutine\n+    StartCoroutine --> GlobalCoroutine\n+    \n+    GlobalCoroutine -->|遍历| ActiveListeners\n     ActiveListeners -->|调用| UpdateTimeCheck\n-    UpdateTimeCheck -->|检查时间点| TimePointManager\n-    TimePointManager -->|触发事件| EventCallbacks\n+    UpdateTimeCheck -->|检查| PressTimePoint\n+    UpdateTimeCheck -->|检查| ContinueInterval\n+    PressTimePoint -->|达到时间点| PressEvent\n+    ContinueInterval -->|达到间隔| ContinueEvent\n     \n+    PressUp --> OnPointerUp\n+    OnPointerUp -->|已注册则| Unregister\n+    Unregister --> ActiveListeners\n+    Unregister -->|如果集合为空| StopCoroutine\n+    StopCoroutine --> GlobalCoroutine\n+    \n     style PressCoroutineManager fill:#c8e6c9\n     style GlobalCoroutine fill:#fff4e1\n     style ActiveListeners fill:#e1f5ff\n-    style TimePointManager fill:#ffebee\n+    style UpdateTimeCheck fill:#ffebee\n+    style UserAction fill:#fff4e1\n ```\n \n ## 核心设计说明\n \n"
                },
                {
                    "date": 1767363999772,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,18 +14,21 @@\n         NeedCoroutine[判断是否需要协程<br/>检查Press/Continue事件]\n         Register[Register到管理器]\n         OnPointerUp[OnPointerUp事件]\n         Unregister[Unregister从管理器]\n-        UpdateTimeCheck[UpdateTimeCheck方法<br/>检查Press时间点<br/>检查Continue间隔]\n-        PressTimePoint[Press时间点<br/>如：按下后0.5秒]\n-        ContinueInterval[Continue间隔<br/>如：每0.1秒]\n+        UpdateTimeCheck[UpdateTimeCheck方法<br/>被协程调用]\n+        PressTimePoint[Press时间点<br/>pressStartTime + 0.5秒]\n+        ContinueInterval[Continue间隔<br/>nextContinueTime + 0.1秒]\n+        CheckPressTime[检查Press时间点<br/>currentTime >= pressTimePoint?]\n+        CheckContinueTime[检查Continue间隔<br/>currentTime >= nextContinueTime?]\n     end\n     \n     subgraph PressCoroutineManager[\"PressCoroutineManager（静态类）\"]\n         ActiveListeners[activeListeners<br/>HashSet<UIEventListener>]\n         GlobalCoroutine[globalCoroutine<br/>唯一协程<br/>每帧/0.05秒遍历]\n         StartCoroutine[启动协程<br/>第一个Listener注册时]\n         StopCoroutine[停止协程<br/>所有Listener注销后]\n+        LoopCheck[协程循环<br/>遍历activeListeners]\n     end\n     \n     subgraph EventCallbacks[\"事件回调\"]\n         PressEvent[触发Press事件]\n@@ -40,15 +43,23 @@\n     Register --> ActiveListeners\n     Register -->|如果集合为空| StartCoroutine\n     StartCoroutine --> GlobalCoroutine\n     \n-    GlobalCoroutine -->|遍历| ActiveListeners\n+    GlobalCoroutine -->|每帧/0.05秒| LoopCheck\n+    LoopCheck -->|遍历| ActiveListeners\n     ActiveListeners -->|调用| UpdateTimeCheck\n-    UpdateTimeCheck -->|检查| PressTimePoint\n-    UpdateTimeCheck -->|检查| ContinueInterval\n-    PressTimePoint -->|达到时间点| PressEvent\n-    ContinueInterval -->|达到间隔| ContinueEvent\n     \n+    UpdateTimeCheck --> CheckPressTime\n+    UpdateTimeCheck --> CheckContinueTime\n+    \n+    CheckPressTime -->|是| PressEvent\n+    CheckPressTime -->|否| SkipPress[跳过Press]\n+    \n+    CheckContinueTime -->|是| ContinueEvent\n+    CheckContinueTime -->|否| SkipContinue[跳过Continue]\n+    \n+    ContinueEvent -->|更新| ContinueInterval\n+    \n     PressUp --> OnPointerUp\n     OnPointerUp -->|已注册则| Unregister\n     Unregister --> ActiveListeners\n     Unregister -->|如果集合为空| StopCoroutine\n@@ -58,8 +69,10 @@\n     style GlobalCoroutine fill:#fff4e1\n     style ActiveListeners fill:#e1f5ff\n     style UpdateTimeCheck fill:#ffebee\n     style UserAction fill:#fff4e1\n+    style CheckPressTime fill:#ffcdd2\n+    style CheckContinueTime fill:#ffcdd2\n ```\n \n ## 核心设计说明\n \n"
                }
            ],
            "date": 1767363593458,
            "name": "Commit-0",
            "content": "# UIEventListener 响应监听关系图\n\n## 当前架构：响应监听关系\n\n```mermaid\ngraph TB\n    subgraph UnityEventSystem[\"Unity事件系统\"]\n        PointerDown[PointerDown事件]\n        PointerUp[PointerUp事件]\n        PointerClick[PointerClick事件]\n        PointerEnter[PointerEnter事件]\n        PointerExit[PointerExit事件]\n        BeginDrag[BeginDrag事件]\n        Drag[Drag事件]\n        EndDrag[EndDrag事件]\n    end\n    \n    subgraph UIEventListenerInstances[\"UIEventListener实例组\"]\n        Listener1[UIEventListener实例1<br/>协程1]\n        Listener2[UIEventListener实例2<br/>协程2]\n        Listener3[UIEventListener实例3<br/>协程3]\n        ListenerN[UIEventListener实例N<br/>协程N]\n    end\n    \n    subgraph EventHandlers[\"事件处理器\"]\n        OnPointerDown[OnPointerDown]\n        OnPointerUp[OnPointerUp]\n        OnPointerClick[OnPointerClick]\n        OnPointerEnter[OnPointerEnter]\n        OnPointerExit[OnPointerExit]\n        OnBeginDrag[OnBeginDrag]\n        OnDrag[OnDrag]\n        OnEndDrag[OnEndDrag]\n    end\n    \n    subgraph Coroutines[\"协程处理\"]\n        PressCoroutine1[PressCoroutine1<br/>每0.05秒检查]\n        PressCoroutine2[PressCoroutine2<br/>每0.05秒检查]\n        PressCoroutine3[PressCoroutine3<br/>每0.05秒检查]\n        PressCoroutineN[PressCoroutineN<br/>每0.05秒检查]\n    end\n    \n    subgraph EventCallbacks[\"事件回调\"]\n        ClickCallbacks[Click回调]\n        PressCallbacks[Press回调]\n        ContinueCallbacks[Continue回调]\n        OtherCallbacks[其他回调]\n    end\n    \n    subgraph UpperSystems[\"上层系统\"]\n        GuideSystem[引导系统<br/>ClickDetector等]\n        UISystem[UI系统]\n        GameLogic[游戏逻辑]\n    end\n    \n    UnityEventSystem -->|事件分发| UIEventListenerInstances\n    UIEventListenerInstances -->|实现接口| EventHandlers\n    \n    OnPointerDown -->|启动协程| Coroutines\n    OnPointerUp -->|停止协程| Coroutines\n    \n    Coroutines -->|触发事件| EventCallbacks\n    EventHandlers -->|触发事件| EventCallbacks\n    \n    EventCallbacks -->|回调通知| UpperSystems\n    \n    style UIEventListenerInstances fill:#ffebee\n    style Coroutines fill:#fff4e1\n    style EventCallbacks fill:#c8e6c9\n    style UpperSystems fill:#e1f5ff\n```\n\n## 当前问题分析\n\n### 1. 协程数量问题\n\n```mermaid\ngraph LR\n    UserAction[用户按下N个UI元素] -->|每个实例启动| Coroutine1[协程1]\n    UserAction -->|每个实例启动| Coroutine2[协程2]\n    UserAction -->|每个实例启动| Coroutine3[协程3]\n    UserAction -->|每个实例启动| CoroutineN[协程N]\n    \n    Coroutine1 -->|每0.05秒| Check1[检查1]\n    Coroutine2 -->|每0.05秒| Check2[检查2]\n    Coroutine3 -->|每0.05秒| Check3[检查3]\n    CoroutineN -->|每0.05秒| CheckN[检查N]\n    \n    Check1 --> CPU[CPU消耗：N个协程<br/>每0.05秒执行一次]\n    Check2 --> CPU\n    Check3 --> CPU\n    CheckN --> CPU\n    \n    style CPU fill:#ffcdd2\n```\n\n**问题**：\n- 如果有100个UI元素同时按下，会有100个协程在运行\n- 每个协程每0.05秒执行一次，CPU消耗大\n- 协程调度开销：Unity需要管理大量协程的生命周期\n\n### 2. 事件监听关系\n\n```mermaid\ngraph TB\n    subgraph EventFlow[\"事件流转\"]\n        UnityEvent[Unity事件] --> Listener[UIEventListener]\n        Listener -->|AddListener注册| Callback1[回调1]\n        Listener -->|AddListener注册| Callback2[回调2]\n        Listener -->|AddListener注册| CallbackN[回调N]\n        \n        Callback1 --> GuideSystem[引导系统]\n        Callback2 --> UISystem[UI系统]\n        CallbackN --> GameLogic[游戏逻辑]\n    end\n    \n    subgraph CoroutineFlow[\"协程流转\"]\n        OnPointerDown -->|启动| PressCoroutine\n        PressCoroutine -->|每0.05秒| CheckState[检查状态]\n        CheckState -->|触发| ContinueEvent[Continue事件]\n        CheckState -->|触发| PressEvent[Press事件]\n        ContinueEvent --> Callback1\n        PressEvent --> Callback2\n    end\n    \n    style PressCoroutine fill:#fff4e1\n    style CheckState fill:#ffcdd2\n```\n\n## 优化方案对比\n\n### 方案1：静态协程管理器（推荐）\n\n```mermaid\ngraph TB\n    subgraph StaticManager[\"静态协程管理器\"]\n        Manager[PressCoroutineManager<br/>单例管理器]\n        ActiveSet[活跃监听器集合<br/>HashSet<UIEventListener>]\n        GlobalCoroutine[全局协程<br/>唯一协程]\n        NeedCoroutineCheck[判断是否需要协程<br/>检查事件类型]\n    end\n    \n    subgraph UIEventListenerInstances[\"UIEventListener实例组\"]\n        Listener1[UIEventListener实例1<br/>需要Press/Continue事件]\n        Listener2[UIEventListener实例2<br/>只需要Click事件]\n        Listener3[UIEventListener实例3<br/>需要Press/Continue事件]\n        ListenerN[UIEventListener实例N<br/>只需要Click事件]\n    end\n    \n    subgraph EventFlow[\"事件流程\"]\n        OnPointerDown1[OnPointerDown1] -->|判断是否需要协程| NeedCoroutineCheck\n        OnPointerDown2[OnPointerDown2] -->|判断是否需要协程| NeedCoroutineCheck\n        OnPointerDown3[OnPointerDown3] -->|判断是否需要协程| NeedCoroutineCheck\n        OnPointerDownN[OnPointerDownN] -->|判断是否需要协程| NeedCoroutineCheck\n        \n        NeedCoroutineCheck -->|需要协程| Register[Register到管理器]\n        NeedCoroutineCheck -->|不需要协程| Skip[跳过注册]\n        \n        Register -->|启动协程| Manager\n        Skip -->|不启动协程| NoCoroutine[不启动协程]\n        \n        OnPointerUp1[OnPointerUp1] -->|Unregister| Manager\n        OnPointerUp2[OnPointerUp2] -->|无需注销| NoUnregister[无需注销]\n        OnPointerUp3[OnPointerUp3] -->|Unregister| Manager\n        OnPointerUpN[OnPointerUpN] -->|无需注销| NoUnregister\n    end\n    \n    Manager -->|遍历检查| ActiveSet\n    ActiveSet -->|UpdatePressState| Listener1\n    ActiveSet -->|UpdatePressState| Listener3\n    \n    GlobalCoroutine -->|每0.1秒| Manager\n    \n    style Manager fill:#c8e6c9\n    style GlobalCoroutine fill:#fff4e1\n    style ActiveSet fill:#e1f5ff\n    style NeedCoroutineCheck fill:#ffebee\n```\n\n**核心设计**：\n- ✅ **按需启动协程**：判断 Listener 是否需要协程事件（Press/Continue），只有需要时才注册到管理器\n- ✅ **动态管理**：OnPointerDown 时判断是否需要协程，需要则注册；OnPointerUp 时判断是否需要注销\n- ✅ **协程数量优化**：只有需要协程事件的 Listener 才会启动协程，减少不必要的协程\n\n**实现要点**：\n1. **判断是否需要协程**：检查 Listener 是否注册了需要协程的事件（Press、Continue 等）\n2. **按需注册**：OnPointerDown 时，只有需要协程的 Listener 才注册到管理器\n3. **按需注销**：OnPointerUp 时，只有已注册的 Listener 才需要注销\n4. **协程管理**：管理器维护活跃监听器集合，当集合为空时停止协程\n\n### 方案2：基于时间的延迟检查\n\n```mermaid\ngraph TB\n    subgraph TimeBasedCheck[\"基于时间的检查\"]\n        OnPointerDown -->|记录时间| StartTime[开始时间]\n        OnPointerUp -->|检查时间差| TimeCheck[时间检查]\n        \n        TimeCheck -->|时间差 > pressTime| TriggerPress[触发Press事件]\n        TimeCheck -->|时间差 < pressTime| NoPress[不触发]\n    end\n    \n    subgraph ContinueEvent[\"Continue事件处理\"]\n        OnPointerDown -->|启动定时器| Timer[定时器<br/>每0.1秒触发]\n        Timer -->|触发| ContinueEvent[Continue事件]\n        OnPointerUp -->|停止定时器| StopTimer[停止定时器]\n    end\n    \n    style Timer fill:#fff4e1\n    style TimeCheck fill:#c8e6c9\n```\n\n**优势**：\n- ✅ 不需要协程，使用Unity的InvokeRepeating\n- ✅ 更轻量，但需要额外的定时器管理\n\n**劣势**：\n- ❌ 需要额外的定时器管理逻辑\n- ❌ 不如协程灵活\n\n### 方案3：事件驱动（不推荐）\n\n```mermaid\ngraph TB\n    subgraph EventDriven[\"事件驱动\"]\n        OnPointerDown -->|记录状态| State[状态记录]\n        Update[Unity Update] -->|每帧检查| CheckAll[检查所有按下状态]\n        CheckAll -->|触发事件| Events[触发事件]\n    end\n    \n    style CheckAll fill:#ffcdd2\n```\n\n**劣势**：\n- ❌ 需要在某个MonoBehaviour的Update中检查\n- ❌ 耦合度高\n- ❌ 不如协程管理器清晰\n\n## 推荐方案：静态协程管理器\n\n### 架构设计\n\n```mermaid\ngraph TB\n    subgraph PressCoroutineManager[\"PressCoroutineManager（静态类）\"]\n        ActiveListeners[activeListeners<br/>HashSet<UIEventListener>]\n        GlobalCoroutine[globalCoroutine<br/>Coroutine]\n        CoroutineHost[coroutineHost<br/>MonoBehaviour]\n        LockObj[lockObj<br/>线程锁]\n        NeedCoroutine[NeedCoroutine方法<br/>判断是否需要协程]\n    end\n    \n    subgraph UIEventListener[\"UIEventListener实例\"]\n        EventTypes[注册的事件类型<br/>Click/Press/Continue等]\n        OnPointerDown -->|判断是否需要协程| NeedCoroutine\n        NeedCoroutine -->|需要| Register[Register到管理器]\n        NeedCoroutine -->|不需要| Skip[跳过注册]\n        OnPointerUp -->|已注册则| Unregister[Unregister]\n        OnDisable -->|已注册则| Unregister\n        UpdatePressState[UpdatePressState方法<br/>被管理器调用]\n    end\n    \n    PressCoroutineManager -->|启动| GlobalCoroutine\n    GlobalCoroutine -->|每0.1秒遍历| ActiveListeners\n    ActiveListeners -->|调用| UpdatePressState\n    \n    style PressCoroutineManager fill:#c8e6c9\n    style GlobalCoroutine fill:#fff4e1\n    style ActiveListeners fill:#e1f5ff\n    style NeedCoroutine fill:#ffebee\n```\n\n### 数据流\n\n```mermaid\nsequenceDiagram\n    participant User as 用户操作\n    participant Listener as UIEventListener\n    participant Manager as PressCoroutineManager\n    participant Coroutine as 全局协程\n    participant Callback as 事件回调\n    \n    User->>Listener: 按下UI元素\n    Listener->>Listener: 判断是否需要协程<br/>检查是否注册了Press/Continue事件\n    alt 需要协程\n        Listener->>Manager: Register(this)\n        Manager->>Coroutine: 启动全局协程（如果未启动）\n        \n        loop 每0.1秒\n            Coroutine->>Manager: 遍历activeListeners\n            Manager->>Listener: UpdatePressState()\n            Listener->>Listener: 检查长按/持续事件\n            Listener->>Callback: 触发事件\n        end\n        \n        User->>Listener: 抬起UI元素\n        Listener->>Manager: Unregister(this)\n        Manager->>Coroutine: 如果集合为空，停止协程\n    else 不需要协程\n        Listener->>Listener: 不注册，直接处理Click事件\n        User->>Listener: 抬起UI元素\n        Listener->>Callback: 触发Click事件\n    end\n```\n\n## 优化效果对比\n\n| 指标 | 当前方案 | 优化方案（静态管理器） |\n|------|---------|---------------------|\n| **协程数量** | N个（每个实例1个） | 1个（全局唯一） |\n| **CPU消耗** | N × 20次/秒 | 1 × 10次/秒 |\n| **内存占用** | N个协程对象 | 1个协程对象 + HashSet |\n| **调度开销** | N个协程调度 | 1个协程调度 |\n| **检查频率** | 每0.05秒 | 可统一调整（建议0.1秒） |\n\n## 实现建议\n\n1. **静态管理器设计**\n   - 使用静态类，不依赖实例\n   - 使用HashSet存储活跃监听器（O(1)查找和删除）\n   - 使用锁保护线程安全\n\n2. **按需协程判断**\n   - **判断条件**：检查 Listener 是否注册了需要协程的事件（Press、Continue 等）\n   - **实现方式**：在 OnPointerDown 时调用 `NeedCoroutine()` 方法判断\n   - **优化效果**：只有需要协程事件的 Listener 才会启动协程，减少不必要的协程\n\n3. **生命周期管理**\n   - OnPointerDown 时：判断是否需要协程，需要则注册\n   - OnPointerUp 时：已注册的才需要注销\n   - OnDisable 时：已注册的才需要注销（防止内存泄漏）\n\n4. **检查频率优化**\n   - 从0.05秒增加到0.1秒（减少50%检查次数）\n   - 可以根据需要调整\n\n5. **状态更新方法**\n   - 每个UIEventListener提供UpdatePressState方法\n   - 由管理器统一调用，避免直接访问私有字段\n\n6. **事件类型判断**\n   - 需要协程的事件：Press、Continue、LongPress 等需要持续检查的事件\n   - 不需要协程的事件：Click、PointerDown、PointerUp 等一次性事件\n"
        }
    ]
}