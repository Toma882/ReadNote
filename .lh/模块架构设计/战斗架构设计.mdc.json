{
    "sourceFile": "模块架构设计/战斗架构设计.mdc",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 38,
            "patches": [
                {
                    "date": 1767016974447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767017089060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -92,8 +92,114 @@\n ```\n \n ---\n \n+## 四层循环架构设计\n+\n+### 循环层次关系\n+\n+```mermaid\n+graph TB\n+    subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n+        BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n+        BattleCheck -->|否| TurnLoop[回合循环]\n+        BattleCheck -->|是| BattleEnd[战斗结束]\n+        TurnLoop --> BattleCheck\n+    end\n+    \n+    subgraph TurnLoop[\"回合循环<br/>TurnLoop\"]\n+        TurnStart[回合开始] --> TeamLoop[阵营循环]\n+        TeamLoop --> TurnEnd[回合结束]\n+        TurnEnd --> TurnCheck{是否还有回合?}\n+        TurnCheck -->|是| TurnStart\n+        TurnCheck -->|否| TurnLoopEnd[回合循环结束]\n+    end\n+    \n+    subgraph TeamLoop[\"阵营循环<br/>TeamLoop\"]\n+        TeamStart[阵营开始] --> UnitLoop[单位循环]\n+        UnitLoop --> TeamEnd[阵营结束]\n+        TeamEnd --> TeamCheck{是否还有阵营?}\n+        TeamCheck -->|是| TeamStart\n+        TeamCheck -->|否| TeamLoopEnd[阵营循环结束]\n+    end\n+    \n+    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n+        UnitStart[单位开始] --> UnitAction[单位行动]\n+        UnitAction --> UnitEnd[单位结束]\n+        UnitEnd --> UnitCheck{是否还有单位?}\n+        UnitCheck -->|是| UnitStart\n+        UnitCheck -->|否| UnitLoopEnd[单位循环结束]\n+    end\n+    \n+    BattleLoop --> TurnLoop\n+    TurnLoop --> TeamLoop\n+    TeamLoop --> UnitLoop\n+    \n+    style BattleLoop fill:#ffebee\n+    style TurnLoop fill:#fff4e1\n+    style TeamLoop fill:#c8e6c9\n+    style UnitLoop fill:#e1f5ff\n+```\n+\n+### 循环管理器设计\n+\n+```mermaid\n+graph TB\n+    subgraph LoopManager[\"循环管理器<br/>LoopManager\"]\n+        BattleLoopManager[\"战斗循环管理器<br/>BattleLoopManager\"]\n+        TurnLoopManager[\"回合循环管理器<br/>TurnLoopManager\"]\n+        TeamLoopManager[\"阵营循环管理器<br/>TeamLoopManager\"]\n+        UnitLoopManager[\"单位循环管理器<br/>UnitLoopManager\"]\n+    end\n+    \n+    subgraph BattleContext[\"战斗上下文<br/>BattleContext\"]\n+        BattleState[\"战斗状态<br/>battleState\"]\n+        TurnState[\"回合状态<br/>turnState\"]\n+        TeamState[\"阵营状态<br/>teamState\"]\n+        UnitState[\"单位状态<br/>unitState\"]\n+    end\n+    \n+    BattleLoopManager -->|维护| BattleState\n+    TurnLoopManager -->|维护| TurnState\n+    TeamLoopManager -->|维护| TeamState\n+    UnitLoopManager -->|维护| UnitState\n+    \n+    BattleLoopManager -->|驱动| TurnLoopManager\n+    TurnLoopManager -->|驱动| TeamLoopManager\n+    TeamLoopManager -->|驱动| UnitLoopManager\n+    \n+    style LoopManager fill:#f3e5f5\n+    style BattleContext fill:#e8f5e9\n+```\n+\n+### 循环职责说明\n+\n+#### 1. 战斗循环（BattleLoop）\n+- **职责**：管理整个战斗的生命周期\n+- **状态**：BattleState（未开始/进行中/已结束）\n+- **触发**：战斗开始/结束条件检查\n+- **维护**：BattleLoopManager\n+\n+#### 2. 回合循环（TurnLoop）\n+- **职责**：管理回合的循环和切换\n+- **状态**：TurnState（回合编号/当前回合/回合数）\n+- **触发**：回合开始/结束条件检查\n+- **维护**：TurnLoopManager\n+\n+#### 3. 阵营循环（TeamLoop）\n+- **职责**：管理阵营内单位的行动顺序\n+- **状态**：TeamState（当前阵营/阵营列表/行动顺序）\n+- **触发**：阵营切换/单位行动完成\n+- **维护**：TeamLoopManager\n+\n+#### 4. 单位循环（UnitLoop）\n+- **职责**：管理单个单位的行动流程\n+- **状态**：UnitState（当前单位/行动状态/行动完成）\n+- **触发**：单位行动开始/结束\n+- **维护**：UnitLoopManager\n+\n+---\n+\n ## 分层职责说明\n \n ### 输入层（InputLayer）\n - **职责**：接收玩家输入和AI输入\n"
                },
                {
                    "date": 1767017432603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,15 +7,17 @@\n ---\n \n ## 核心设计理念\n \n-### 1. 回合驱动为核心\n+### 1. 多层循环架构为核心\n \n-**本质**：战斗系统的核心是回合流程的驱动和管理\n-- 战斗流程 = 回合循环驱动\n-- 回合管理 = 先攻计算 → 行动轮 → 回合结束\n-- 状态同步 = 回合状态在参与者间同步\n-- 流程控制 = 回合流程控制战斗节奏\n+**本质**：战斗系统的核心是四层循环的维护和管理\n+- **战斗循环**：管理整个战斗的生命周期\n+- **回合循环**：管理回合的循环和切换\n+- **阵营循环**：管理阵营内单位的行动顺序\n+- **单位循环**：管理单个单位的行动流程\n+- **循环驱动**：所有战斗逻辑都在循环框架内执行\n+- **状态维护**：每层循环维护自己的状态，驱动下层循环\n \n ### 2. 数据驱动架构\n \n **本质**：战斗特性通过配置数据实现，无需修改代码\n@@ -23,20 +25,20 @@\n - 回合流程、状态转换 → 通过配置数据调整\n - 新增战斗机制 → 扩展配置数据即可\n - 战斗平衡 → 调整配置数值即可\n \n-### 3. 分层架构 + 状态机控制\n+### 3. 分层架构（循环内的功能组织）\n \n-**本质**：分层架构实现职责分离，状态机控制实现流程管理\n-- 多层架构：输入层、决策层、执行层、表现层、管理层\n-- 状态机：战斗状态、回合状态、角色状态\n+**本质**：分层架构是循环内的功能组织方式，不是主要架构\n+- 功能组织：输入层、决策层、执行层、表现层、管理层\n+- 执行位置：所有分层功能都在单位循环内执行\n - 解耦设计：层间通过Context和CommunicationBus通信\n \n ---\n \n ## 整体架构设计\n \n-### 分层架构 + 回合驱动\n+### 多层循环架构（主要架构）\n \n ```mermaid\n graph TB\n     subgraph InputLayer[\"输入层<br/>InputLayer\"]\n"
                },
                {
                    "date": 1767017444235,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,66 +38,8 @@\n ## 整体架构设计\n \n ### 多层循环架构（主要架构）\n \n-```mermaid\n-graph TB\n-    subgraph InputLayer[\"输入层<br/>InputLayer\"]\n-        PlayerInput[\"玩家输入<br/>PlayerInput\"]\n-        AIInput[\"AI输入<br/>AIInput\"]\n-        InputValidator[\"输入验证器<br/>InputValidator\"]\n-    end\n-    \n-    subgraph DecisionLayer[\"决策层<br/>DecisionLayer\"]\n-        TurnManager[\"回合管理器<br/>TurnManager\"]\n-        ActionSelector[\"行动选择器<br/>ActionSelector\"]\n-        TargetSelector[\"目标选择器<br/>TargetSelector\"]\n-    end\n-    \n-    subgraph ExecutionLayer[\"执行层<br/>ExecutionLayer\"]\n-        ActionExecutor[\"行动执行器<br/>ActionExecutor\"]\n-        DamageCalculator[\"伤害计算器<br/>DamageCalculator\"]\n-        EffectApplier[\"效果应用器<br/>EffectApplier\"]\n-    end\n-    \n-    subgraph PresentationLayer[\"表现层<br/>PresentationLayer\"]\n-        VisualPlayer[\"视觉播放器<br/>VisualPlayer\"]\n-        AudioPlayer[\"音频播放器<br/>AudioPlayer\"]\n-        UIManager[\"UI管理器<br/>UIManager\"]\n-    end\n-    \n-    subgraph ManagementLayer[\"管理层<br/>ManagementLayer\"]\n-        BattleStateManager[\"战斗状态管理器<br/>BattleStateManager\"]\n-        ParticipantManager[\"参与者管理器<br/>ParticipantManager\"]\n-        BattleContext[\"战斗上下文<br/>BattleContext\"]\n-    end\n-    \n-    subgraph DataLayer[\"数据层<br/>DataLayer\"]\n-        BattleConfig[\"战斗配置<br/>BattleConfig\"]\n-        TurnData[\"回合数据<br/>TurnData\"]\n-        BattleData[\"战斗数据<br/>BattleData\"]\n-    end\n-    \n-    InputLayer -->|BattleContext<br/>+inputData| DecisionLayer\n-    DecisionLayer -->|BattleContext<br/>+decisionData| ExecutionLayer\n-    ExecutionLayer -->|BattleContext<br/>+executionData| PresentationLayer\n-    PresentationLayer -->|BattleContext<br/>+presentationData| ManagementLayer\n-    ManagementLayer -->|状态更新| InputLayer\n-    ManagementLayer -->|数据持久化| DataLayer\n-    DataLayer -.数据查询.-> DecisionLayer\n-    \n-    style InputLayer fill:#ffebee\n-    style DecisionLayer fill:#fff4e1\n-    style ExecutionLayer fill:#c8e6c9\n-    style PresentationLayer fill:#e1f5ff\n-    style ManagementLayer fill:#f3e5f5\n-    style DataLayer fill:#e8f5e9\n-```\n-\n----\n-\n-## 四层循环架构设计\n-\n ### 循环层次关系\n \n ```mermaid\n graph TB\n"
                },
                {
                    "date": 1767017456548,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -38,10 +38,12 @@\n ## 整体架构设计\n \n ### 多层循环架构（主要架构）\n \n-### 循环层次关系\n+**核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n \n+#### 循环层次关系\n+\n ```mermaid\n graph TB\n     subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n         BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n"
                },
                {
                    "date": 1767017477402,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,35 +144,72 @@\n - **维护**：UnitLoopManager\n \n ---\n \n-## 分层职责说明\n+### 分层架构（循环内的功能组织）\n \n-### 输入层（InputLayer）\n+**说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n+\n+#### 单位循环内的分层功能\n+\n+```mermaid\n+graph TB\n+    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n+        UnitStart[单位开始] --> InputLayer[输入层<br/>接收输入]\n+        InputLayer --> DecisionLayer[决策层<br/>选择行动/目标]\n+        DecisionLayer --> ExecutionLayer[执行层<br/>执行行动/计算伤害]\n+        ExecutionLayer --> PresentationLayer[表现层<br/>播放表现]\n+        PresentationLayer --> ManagementLayer[管理层<br/>更新状态]\n+        ManagementLayer --> UnitEnd[单位结束]\n+    end\n+    \n+    DataLayer[数据层<br/>配置数据] -.数据查询.-> DecisionLayer\n+    DataLayer -.数据查询.-> ExecutionLayer\n+    \n+    style UnitLoop fill:#e1f5ff\n+    style InputLayer fill:#ffebee\n+    style DecisionLayer fill:#fff4e1\n+    style ExecutionLayer fill:#c8e6c9\n+    style PresentationLayer fill:#e1f5ff\n+    style ManagementLayer fill:#f3e5f5\n+    style DataLayer fill:#e8f5e9\n+```\n+\n+#### 分层职责说明\n+\n+**重要**：以下所有分层功能都在**单位循环**内执行，不是独立的架构层次。\n+\n+##### 输入层（InputLayer）\n+- **执行位置**：单位循环内\n - **职责**：接收玩家输入和AI输入\n - **核心组件**：PlayerInput、AIInput、InputValidator\n - **输出**：BattleContext + inputData\n \n-### 决策层（DecisionLayer）\n-- **职责**：回合管理、行动选择、目标选择\n-- **核心组件**：TurnManager、ActionSelector、TargetSelector\n+##### 决策层（DecisionLayer）\n+- **执行位置**：单位循环内\n+- **职责**：行动选择、目标选择\n+- **核心组件**：ActionSelector、TargetSelector\n - **输出**：BattleContext + decisionData\n \n-### 执行层（ExecutionLayer）\n+##### 执行层（ExecutionLayer）\n+- **执行位置**：单位循环内\n - **职责**：行动执行、伤害计算、效果应用\n - **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n - **输出**：BattleContext + executionData\n \n-### 表现层（PresentationLayer）\n+##### 表现层（PresentationLayer）\n+- **执行位置**：单位循环内\n - **职责**：视觉表现、音频播放、UI更新\n - **核心组件**：VisualPlayer、AudioPlayer、UIManager\n - **输出**：BattleContext + presentationData\n \n-### 管理层（ManagementLayer）\n-- **职责**：战斗状态管理、参与者管理、Context管理\n-- **核心组件**：BattleStateManager、ParticipantManager、BattleContext\n-- **输出**：状态更新、数据持久化\n+##### 管理层（ManagementLayer）\n+- **执行位置**：单位循环内（状态更新）、循环间（循环管理）\n+- **职责**：战斗状态管理、参与者管理、Context管理、循环管理\n+- **核心组件**：BattleStateManager、ParticipantManager、BattleContext、LoopManager\n+- **输出**：状态更新、数据持久化、循环驱动\n \n-### 数据层（DataLayer）\n+##### 数据层（DataLayer）\n+- **执行位置**：所有循环和分层功能中\n - **职责**：战斗配置、回合数据、战斗数据\n - **核心组件**：BattleConfig、TurnData、BattleData\n - **输出**：配置数据查询\n"
                },
                {
                    "date": 1767017686371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,8 +144,113 @@\n - **维护**：UnitLoopManager\n \n ---\n \n+## 多层循环架构模式\n+\n+### 层次状态机（Hierarchical State Machine）\n+\n+**核心观点**：多层循环架构最适合使用**层次状态机（Hierarchical State Machine）**模式。\n+\n+#### 为什么是层次状态机？\n+\n+**原因**：\n+- **循环嵌套 = 状态嵌套**：每层循环都是一个状态机，可以包含子状态机\n+- **状态层次结构**：战斗状态机 → 回合状态机 → 阵营状态机 → 单位状态机\n+- **状态自动管理**：父状态机进入时自动重置子状态机，父状态机更新时自动更新子状态机\n+- **状态隔离**：每层循环的状态独立管理，互不干扰\n+\n+**适用场景**：\n+- 战斗状态机包含回合状态机（战斗进行中状态）\n+- 回合状态机包含阵营状态机（回合行动状态）\n+- 阵营状态机包含单位状态机（阵营行动状态）\n+- 单位状态机管理单位行动流程\n+\n+#### 层次状态机设计\n+\n+```mermaid\n+graph TB\n+    subgraph BattleFSM[\"战斗状态机<br/>BattleFSM<br/>HierarchicalFSM\"]\n+        BattleState1[准备中]\n+        BattleState2[进行中]\n+        BattleState3[暂停]\n+        BattleState4[结束]\n+        \n+        BattleState2 -->|包含| TurnFSM[回合状态机<br/>TurnFSM]\n+        BattleState4 -->|包含| ResultFSM[结果状态机<br/>ResultFSM]\n+    end\n+    \n+    subgraph TurnFSM[\"回合状态机<br/>TurnFSM<br/>HierarchicalFSM\"]\n+        TurnState1[回合开始]\n+        TurnState2[回合行动]\n+        TurnState3[回合结束]\n+        \n+        TurnState2 -->|包含| TeamFSM[阵营状态机<br/>TeamFSM]\n+    end\n+    \n+    subgraph TeamFSM[\"阵营状态机<br/>TeamFSM<br/>HierarchicalFSM\"]\n+        TeamState1[阵营开始]\n+        TeamState2[阵营行动]\n+        TeamState3[阵营结束]\n+        \n+        TeamState2 -->|包含| UnitFSM[单位状态机<br/>UnitFSM]\n+    end\n+    \n+    subgraph UnitFSM[\"单位状态机<br/>UnitFSM<br/>FSMBase\"]\n+        UnitState1[单位开始]\n+        UnitState2[单位行动]\n+        UnitState3[单位结束]\n+    end\n+    \n+    style BattleFSM fill:#ffebee\n+    style TurnFSM fill:#fff4e1\n+    style TeamFSM fill:#c8e6c9\n+    style UnitFSM fill:#e1f5ff\n+```\n+\n+#### 层次状态机特点\n+\n+1. **状态嵌套**：\n+   - 父状态机可以包含子状态机\n+   - 子状态机在父状态机进入时自动重置\n+   - 子状态机在父状态机更新时自动更新\n+\n+2. **状态隔离**：\n+   - 每层状态机独立管理自己的状态\n+   - 状态转换只在当前状态机内进行\n+   - 父状态机状态变化不影响子状态机状态\n+\n+3. **自动管理**：\n+   - 父状态机进入时，自动重置子状态机\n+   - 父状态机更新时，自动更新子状态机\n+   - 父状态机退出时，自动清理子状态机\n+\n+4. **循环驱动**：\n+   - 每层状态机的状态转换驱动循环推进\n+   - 状态机状态决定循环是否继续\n+   - 状态机状态决定循环行为\n+\n+#### 实现要点\n+\n+1. **层次状态机接口**：\n+   - `AddSubFSM(stateId, subFSM)`：为某个状态添加子状态机\n+   - `EnterCurrentState()`：进入当前状态时，自动重置子状态机\n+   - `UpdateCurrentState()`：更新当前状态时，自动更新子状态机\n+\n+2. **状态机层次结构**：\n+   - 战斗状态机（HierarchicalFSM）：包含回合状态机和结果状态机\n+   - 回合状态机（HierarchicalFSM）：包含阵营状态机\n+   - 阵营状态机（HierarchicalFSM）：包含单位状态机\n+   - 单位状态机（FSMBase）：最底层状态机，不包含子状态机\n+\n+3. **循环管理器 = 层次状态机**：\n+   - BattleLoopManager = 战斗状态机\n+   - TurnLoopManager = 回合状态机\n+   - TeamLoopManager = 阵营状态机\n+   - UnitLoopManager = 单位状态机\n+\n+---\n+\n ### 分层架构（循环内的功能组织）\n \n **说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n \n"
                },
                {
                    "date": 1767088777887,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -247,8 +247,74 @@\n    - TurnLoopManager = 回合状态机\n    - TeamLoopManager = 阵营状态机\n    - UnitLoopManager = 单位状态机\n \n+```mermaid\n+sequenceDiagram\n+    participant Main as 主状态机\n+    participant Round as 回合状态机\n+    participant Team as 阵营状态机\n+    participant Unit as 单位状态机\n+    \n+    Note over Main: 战斗开始\n+    Main->>Main: PREPARING → IN_PROGRESS\n+    Main->>Round: 进入IN_PROGRESS，激活回合状态机\n+    \n+    Note over Round: 第1回合开始\n+    Round->>Round: ROUND_START\n+    Round->>Round: CheckRoundActionCondition() → ROUND_ACTION\n+    Round->>Team: 进入ROUND_ACTION，激活阵营状态机\n+    \n+    Note over Team: 玩家阵营开始\n+    Team->>Team: TEAM_START\n+    Team->>Team: CheckTeamActionCondition() → TEAM_ACTION\n+    Team->>Unit: 进入TEAM_ACTION，激活单位状态机\n+    \n+    Note over Unit: 单位1行动\n+    Unit->>Unit: UNIT_START\n+    Unit->>Unit: CheckUnitActionCondition() → UNIT_ACTION\n+    Unit->>Unit: 执行行动\n+    Unit->>Unit: CheckUnitEndCondition() → UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → UNIT_START (还有单位2)\n+    \n+    Note over Unit: 单位2行动\n+    Unit->>Unit: UNIT_START\n+    Unit->>Unit: UNIT_ACTION\n+    Unit->>Unit: UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → false (没有更多单位)\n+    \n+    Note over Team: 玩家阵营结束\n+    Team->>Team: CheckTeamEndCondition() → TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → TEAM_START (还有敌人阵营)\n+    \n+    Note over Team: 敌人阵营开始\n+    Team->>Team: TEAM_START\n+    Team->>Team: TEAM_ACTION\n+    Team->>Unit: 激活单位状态机（敌人单位1）\n+    Unit->>Unit: UNIT_START → UNIT_ACTION → UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → UNIT_START (还有单位2)\n+    Unit->>Unit: UNIT_START → UNIT_ACTION → UNIT_END\n+    Unit->>Unit: CheckNextUnitCondition() → false\n+    Team->>Team: TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → false (没有更多阵营)\n+    \n+    Note over Round: 第1回合结束\n+    Round->>Round: CheckRoundEndCondition() → ROUND_END\n+    Round->>Round: CheckNextRoundCondition() → ROUND_START (还有第2回合)\n+    \n+    Note over Round: 第2回合开始\n+    Round->>Round: ROUND_START → ROUND_ACTION\n+    Round->>Team: 激活阵营状态机\n+    Team->>Team: TEAM_START → TEAM_ACTION → TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → TEAM_START (循环)\n+    Team->>Team: TEAM_START → TEAM_ACTION → TEAM_END\n+    Team->>Team: CheckNextTeamCondition() → false\n+    Round->>Round: ROUND_END\n+    Round->>Round: CheckNextRoundCondition() → false (战斗结束)\n+    \n+    Note over Main: 战斗结束\n+    Main->>Main: CheckBattleEndCondition() → ENDED\n+    Main->>Main: 激活结果状态机\n ---\n \n ### 分层架构（循环内的功能组织）\n \n"
                },
                {
                    "date": 1767088789349,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -313,8 +313,9 @@\n     \n     Note over Main: 战斗结束\n     Main->>Main: CheckBattleEndCondition() → ENDED\n     Main->>Main: 激活结果状态机\n+```\n ---\n \n ### 分层架构（循环内的功能组织）\n \n"
                },
                {
                    "date": 1767091523934,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -247,8 +247,10 @@\n    - TurnLoopManager = 回合状态机\n    - TeamLoopManager = 阵营状态机\n    - UnitLoopManager = 单位状态机\n \n+\n+### 循环机制流程图\n ```mermaid\n sequenceDiagram\n     participant Main as 主状态机\n     participant Round as 回合状态机\n"
                },
                {
                    "date": 1767091542562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -248,9 +248,9 @@\n    - TeamLoopManager = 阵营状态机\n    - UnitLoopManager = 单位状态机\n \n \n-### 循环机制流程图\n+### 循环分层状态机流程图\n ```mermaid\n sequenceDiagram\n     participant Main as 主状态机\n     participant Round as 回合状态机\n"
                },
                {
                    "date": 1767091553971,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -248,9 +248,9 @@\n    - TeamLoopManager = 阵营状态机\n    - UnitLoopManager = 单位状态机\n \n \n-### 循环分层状态机流程图\n+#### 循环分层状态机流程图\n ```mermaid\n sequenceDiagram\n     participant Main as 主状态机\n     participant Round as 回合状态机\n"
                },
                {
                    "date": 1767091586962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -241,15 +241,9 @@\n    - 回合状态机（HierarchicalFSM）：包含阵营状态机\n    - 阵营状态机（HierarchicalFSM）：包含单位状态机\n    - 单位状态机（FSMBase）：最底层状态机，不包含子状态机\n \n-3. **循环管理器 = 层次状态机**：\n-   - BattleLoopManager = 战斗状态机\n-   - TurnLoopManager = 回合状态机\n-   - TeamLoopManager = 阵营状态机\n-   - UnitLoopManager = 单位状态机\n \n-\n #### 循环分层状态机流程图\n ```mermaid\n sequenceDiagram\n     participant Main as 主状态机\n"
                },
                {
                    "date": 1767091626284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,39 +85,8 @@\n     style TeamLoop fill:#c8e6c9\n     style UnitLoop fill:#e1f5ff\n ```\n \n-### 循环管理器设计\n-\n-```mermaid\n-graph TB\n-    subgraph LoopManager[\"循环管理器<br/>LoopManager\"]\n-        BattleLoopManager[\"战斗循环管理器<br/>BattleLoopManager\"]\n-        TurnLoopManager[\"回合循环管理器<br/>TurnLoopManager\"]\n-        TeamLoopManager[\"阵营循环管理器<br/>TeamLoopManager\"]\n-        UnitLoopManager[\"单位循环管理器<br/>UnitLoopManager\"]\n-    end\n-    \n-    subgraph BattleContext[\"战斗上下文<br/>BattleContext\"]\n-        BattleState[\"战斗状态<br/>battleState\"]\n-        TurnState[\"回合状态<br/>turnState\"]\n-        TeamState[\"阵营状态<br/>teamState\"]\n-        UnitState[\"单位状态<br/>unitState\"]\n-    end\n-    \n-    BattleLoopManager -->|维护| BattleState\n-    TurnLoopManager -->|维护| TurnState\n-    TeamLoopManager -->|维护| TeamState\n-    UnitLoopManager -->|维护| UnitState\n-    \n-    BattleLoopManager -->|驱动| TurnLoopManager\n-    TurnLoopManager -->|驱动| TeamLoopManager\n-    TeamLoopManager -->|驱动| UnitLoopManager\n-    \n-    style LoopManager fill:#f3e5f5\n-    style BattleContext fill:#e8f5e9\n-```\n-\n ### 循环职责说明\n \n #### 1. 战斗循环（BattleLoop）\n - **职责**：管理整个战斗的生命周期\n"
                },
                {
                    "date": 1767091691385,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -281,72 +281,4 @@\n     Main->>Main: 激活结果状态机\n ```\n ---\n \n-### 分层架构（循环内的功能组织）\n-\n-**说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n-\n-#### 单位循环内的分层功能\n-\n-```mermaid\n-graph TB\n-    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n-        UnitStart[单位开始] --> InputLayer[输入层<br/>接收输入]\n-        InputLayer --> DecisionLayer[决策层<br/>选择行动/目标]\n-        DecisionLayer --> ExecutionLayer[执行层<br/>执行行动/计算伤害]\n-        ExecutionLayer --> PresentationLayer[表现层<br/>播放表现]\n-        PresentationLayer --> ManagementLayer[管理层<br/>更新状态]\n-        ManagementLayer --> UnitEnd[单位结束]\n-    end\n-    \n-    DataLayer[数据层<br/>配置数据] -.数据查询.-> DecisionLayer\n-    DataLayer -.数据查询.-> ExecutionLayer\n-    \n-    style UnitLoop fill:#e1f5ff\n-    style InputLayer fill:#ffebee\n-    style DecisionLayer fill:#fff4e1\n-    style ExecutionLayer fill:#c8e6c9\n-    style PresentationLayer fill:#e1f5ff\n-    style ManagementLayer fill:#f3e5f5\n-    style DataLayer fill:#e8f5e9\n-```\n-\n-#### 分层职责说明\n-\n-**重要**：以下所有分层功能都在**单位循环**内执行，不是独立的架构层次。\n-\n-##### 输入层（InputLayer）\n-- **执行位置**：单位循环内\n-- **职责**：接收玩家输入和AI输入\n-- **核心组件**：PlayerInput、AIInput、InputValidator\n-- **输出**：BattleContext + inputData\n-\n-##### 决策层（DecisionLayer）\n-- **执行位置**：单位循环内\n-- **职责**：行动选择、目标选择\n-- **核心组件**：ActionSelector、TargetSelector\n-- **输出**：BattleContext + decisionData\n-\n-##### 执行层（ExecutionLayer）\n-- **执行位置**：单位循环内\n-- **职责**：行动执行、伤害计算、效果应用\n-- **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n-- **输出**：BattleContext + executionData\n-\n-##### 表现层（PresentationLayer）\n-- **执行位置**：单位循环内\n-- **职责**：视觉表现、音频播放、UI更新\n-- **核心组件**：VisualPlayer、AudioPlayer、UIManager\n-- **输出**：BattleContext + presentationData\n-\n-##### 管理层（ManagementLayer）\n-- **执行位置**：单位循环内（状态更新）、循环间（循环管理）\n-- **职责**：战斗状态管理、参与者管理、Context管理、循环管理\n-- **核心组件**：BattleStateManager、ParticipantManager、BattleContext、LoopManager\n-- **输出**：状态更新、数据持久化、循环驱动\n-\n-##### 数据层（DataLayer）\n-- **执行位置**：所有循环和分层功能中\n-- **职责**：战斗配置、回合数据、战斗数据\n-- **核心组件**：BattleConfig、TurnData、BattleData\n-- **输出**：配置数据查询\n"
                },
                {
                    "date": 1767092932474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,50 +42,48 @@\n **核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n \n #### 循环层次关系\n \n-```mermaid\n graph TB\n-    subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n-        BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n-        BattleCheck -->|否| TurnLoop[回合循环]\n-        BattleCheck -->|是| BattleEnd[战斗结束]\n-        TurnLoop --> BattleCheck\n+    subgraph \"核心业务流程\"\n+        Start([战斗开始]) --> BattleStart[战斗循环开始]\n+        BattleStart --> RoundStart[回合循环开始]\n+        RoundStart --> TeamStart[阵营循环开始]\n+        TeamStart --> UnitStart[单位循环开始]\n+        \n+        UnitStart --> GetInput[调用 InputService]\n+        GetInput --> Execute[调用 ActionService]\n+        Execute --> UpdateData[调用 DataService]\n+        UpdateData --> PlayVisual[调用 VisualService]\n+        PlayVisual --> UnitNext{还有下一个单位?}\n+        \n+        UnitNext -->|是| UnitStart\n+        UnitNext -->|否| TeamNext{还有下一个阵营?}\n+        TeamNext -->|是| TeamStart\n+        TeamNext -->|否| RoundNext{还有下一个回合?}\n+        RoundNext -->|是| RoundStart\n+        RoundNext -->|否| BattleEnd([战斗结束])\n     end\n     \n-    subgraph TurnLoop[\"回合循环<br/>TurnLoop\"]\n-        TurnStart[回合开始] --> TeamLoop[阵营循环]\n-        TeamLoop --> TurnEnd[回合结束]\n-        TurnEnd --> TurnCheck{是否还有回合?}\n-        TurnCheck -->|是| TurnStart\n-        TurnCheck -->|否| TurnLoopEnd[回合循环结束]\n+    subgraph \"支撑服务\"\n+        InputService[InputService<br/>输入服务]\n+        ActionService[ActionService<br/>行动服务]\n+        DataService[DataService<br/>数据服务]\n+        VisualService[VisualService<br/>视觉服务]\n     end\n     \n-    subgraph TeamLoop[\"阵营循环<br/>TeamLoop\"]\n-        TeamStart[阵营开始] --> UnitLoop[单位循环]\n-        UnitLoop --> TeamEnd[阵营结束]\n-        TeamEnd --> TeamCheck{是否还有阵营?}\n-        TeamCheck -->|是| TeamStart\n-        TeamCheck -->|否| TeamLoopEnd[阵营循环结束]\n-    end\n+    GetInput -.调用.-> InputService\n+    Execute -.调用.-> ActionService\n+    UpdateData -.调用.-> DataService\n+    PlayVisual -.调用.-> VisualService\n     \n-    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n-        UnitStart[单位开始] --> UnitAction[单位行动]\n-        UnitAction --> UnitEnd[单位结束]\n-        UnitEnd --> UnitCheck{是否还有单位?}\n-        UnitCheck -->|是| UnitStart\n-        UnitCheck -->|否| UnitLoopEnd[单位循环结束]\n-    end\n-    \n-    BattleLoop --> TurnLoop\n-    TurnLoop --> TeamLoop\n-    TeamLoop --> UnitLoop\n-    \n-    style BattleLoop fill:#ffebee\n-    style TurnLoop fill:#fff4e1\n-    style TeamLoop fill:#c8e6c9\n-    style UnitLoop fill:#e1f5ff\n-```\n+    style Start fill:#90ee90\n+    style BattleEnd fill:#ffcccb\n+    style UnitStart fill:#e1f5ff\n+    style InputService fill:#fff4e1\n+    style ActionService fill:#e8f5e9\n+    style DataService fill:#ffebee\n+    style VisualService fill:#f3e5f5\n \n ### 循环职责说明\n \n #### 1. 战斗循环（BattleLoop）\n"
                },
                {
                    "date": 1767092939633,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,8 +82,9 @@\n     style InputService fill:#fff4e1\n     style ActionService fill:#e8f5e9\n     style DataService fill:#ffebee\n     style VisualService fill:#f3e5f5\n+```\n \n ### 循环职责说明\n \n #### 1. 战斗循环（BattleLoop）\n"
                },
                {
                    "date": 1767092959874,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n \n **核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n \n #### 循环层次关系\n-\n+``` mermaid\n graph TB\n     subgraph \"核心业务流程\"\n         Start([战斗开始]) --> BattleStart[战斗循环开始]\n         BattleStart --> RoundStart[回合循环开始]\n"
                },
                {
                    "date": 1767092997097,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,49 +41,50 @@\n \n **核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n \n #### 循环层次关系\n-``` mermaid\n+\n+```mermaid\n graph TB\n-    subgraph \"核心业务流程\"\n-        Start([战斗开始]) --> BattleStart[战斗循环开始]\n-        BattleStart --> RoundStart[回合循环开始]\n-        RoundStart --> TeamStart[阵营循环开始]\n-        TeamStart --> UnitStart[单位循环开始]\n-        \n-        UnitStart --> GetInput[调用 InputService]\n-        GetInput --> Execute[调用 ActionService]\n-        Execute --> UpdateData[调用 DataService]\n-        UpdateData --> PlayVisual[调用 VisualService]\n-        PlayVisual --> UnitNext{还有下一个单位?}\n-        \n-        UnitNext -->|是| UnitStart\n-        UnitNext -->|否| TeamNext{还有下一个阵营?}\n-        TeamNext -->|是| TeamStart\n-        TeamNext -->|否| RoundNext{还有下一个回合?}\n-        RoundNext -->|是| RoundStart\n-        RoundNext -->|否| BattleEnd([战斗结束])\n+    subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n+        BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n+        BattleCheck -->|否| TurnLoop[回合循环]\n+        BattleCheck -->|是| BattleEnd[战斗结束]\n+        TurnLoop --> BattleCheck\n     end\n     \n-    subgraph \"支撑服务\"\n-        InputService[InputService<br/>输入服务]\n-        ActionService[ActionService<br/>行动服务]\n-        DataService[DataService<br/>数据服务]\n-        VisualService[VisualService<br/>视觉服务]\n+    subgraph TurnLoop[\"回合循环<br/>TurnLoop\"]\n+        TurnStart[回合开始] --> TeamLoop[阵营循环]\n+        TeamLoop --> TurnEnd[回合结束]\n+        TurnEnd --> TurnCheck{是否还有回合?}\n+        TurnCheck -->|是| TurnStart\n+        TurnCheck -->|否| TurnLoopEnd[回合循环结束]\n     end\n     \n-    GetInput -.调用.-> InputService\n-    Execute -.调用.-> ActionService\n-    UpdateData -.调用.-> DataService\n-    PlayVisual -.调用.-> VisualService\n+    subgraph TeamLoop[\"阵营循环<br/>TeamLoop\"]\n+        TeamStart[阵营开始] --> UnitLoop[单位循环]\n+        UnitLoop --> TeamEnd[阵营结束]\n+        TeamEnd --> TeamCheck{是否还有阵营?}\n+        TeamCheck -->|是| TeamStart\n+        TeamCheck -->|否| TeamLoopEnd[阵营循环结束]\n+    end\n     \n-    style Start fill:#90ee90\n-    style BattleEnd fill:#ffcccb\n-    style UnitStart fill:#e1f5ff\n-    style InputService fill:#fff4e1\n-    style ActionService fill:#e8f5e9\n-    style DataService fill:#ffebee\n-    style VisualService fill:#f3e5f5\n+    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n+        UnitStart[单位开始] --> UnitAction[单位行动]\n+        UnitAction --> UnitEnd[单位结束]\n+        UnitEnd --> UnitCheck{是否还有单位?}\n+        UnitCheck -->|是| UnitStart\n+        UnitCheck -->|否| UnitLoopEnd[单位循环结束]\n+    end\n+    \n+    BattleLoop --> TurnLoop\n+    TurnLoop --> TeamLoop\n+    TeamLoop --> UnitLoop\n+    \n+    style BattleLoop fill:#ffebee\n+    style TurnLoop fill:#fff4e1\n+    style TeamLoop fill:#c8e6c9\n+    style UnitLoop fill:#e1f5ff\n ```\n \n ### 循环职责说明\n \n@@ -134,46 +135,49 @@\n - 单位状态机管理单位行动流程\n \n #### 层次状态机设计\n \n-```mermaid\n+``` mermaid\n graph TB\n-    subgraph BattleFSM[\"战斗状态机<br/>BattleFSM<br/>HierarchicalFSM\"]\n-        BattleState1[准备中]\n-        BattleState2[进行中]\n-        BattleState3[暂停]\n-        BattleState4[结束]\n+    subgraph \"核心业务流程\"\n+        Start([战斗开始]) --> BattleStart[战斗循环开始]\n+        BattleStart --> RoundStart[回合循环开始]\n+        RoundStart --> TeamStart[阵营循环开始]\n+        TeamStart --> UnitStart[单位循环开始]\n         \n-        BattleState2 -->|包含| TurnFSM[回合状态机<br/>TurnFSM]\n-        BattleState4 -->|包含| ResultFSM[结果状态机<br/>ResultFSM]\n-    end\n-    \n-    subgraph TurnFSM[\"回合状态机<br/>TurnFSM<br/>HierarchicalFSM\"]\n-        TurnState1[回合开始]\n-        TurnState2[回合行动]\n-        TurnState3[回合结束]\n+        UnitStart --> GetInput[调用 InputService]\n+        GetInput --> Execute[调用 ActionService]\n+        Execute --> UpdateData[调用 DataService]\n+        UpdateData --> PlayVisual[调用 VisualService]\n+        PlayVisual --> UnitNext{还有下一个单位?}\n         \n-        TurnState2 -->|包含| TeamFSM[阵营状态机<br/>TeamFSM]\n+        UnitNext -->|是| UnitStart\n+        UnitNext -->|否| TeamNext{还有下一个阵营?}\n+        TeamNext -->|是| TeamStart\n+        TeamNext -->|否| RoundNext{还有下一个回合?}\n+        RoundNext -->|是| RoundStart\n+        RoundNext -->|否| BattleEnd([战斗结束])\n     end\n     \n-    subgraph TeamFSM[\"阵营状态机<br/>TeamFSM<br/>HierarchicalFSM\"]\n-        TeamState1[阵营开始]\n-        TeamState2[阵营行动]\n-        TeamState3[阵营结束]\n-        \n-        TeamState2 -->|包含| UnitFSM[单位状态机<br/>UnitFSM]\n+    subgraph \"支撑服务\"\n+        InputService[InputService<br/>输入服务]\n+        ActionService[ActionService<br/>行动服务]\n+        DataService[DataService<br/>数据服务]\n+        VisualService[VisualService<br/>视觉服务]\n     end\n     \n-    subgraph UnitFSM[\"单位状态机<br/>UnitFSM<br/>FSMBase\"]\n-        UnitState1[单位开始]\n-        UnitState2[单位行动]\n-        UnitState3[单位结束]\n-    end\n+    GetInput -.调用.-> InputService\n+    Execute -.调用.-> ActionService\n+    UpdateData -.调用.-> DataService\n+    PlayVisual -.调用.-> VisualService\n     \n-    style BattleFSM fill:#ffebee\n-    style TurnFSM fill:#fff4e1\n-    style TeamFSM fill:#c8e6c9\n-    style UnitFSM fill:#e1f5ff\n+    style Start fill:#90ee90\n+    style BattleEnd fill:#ffcccb\n+    style UnitStart fill:#e1f5ff\n+    style InputService fill:#fff4e1\n+    style ActionService fill:#e8f5e9\n+    style DataService fill:#ffebee\n+    style VisualService fill:#f3e5f5\n ```\n \n #### 层次状态机特点\n \n@@ -280,4 +284,72 @@\n     Main->>Main: 激活结果状态机\n ```\n ---\n \n+### 分层架构（循环内的功能组织）\n+\n+**说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n+\n+#### 单位循环内的分层功能\n+\n+```mermaid\n+graph TB\n+    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n+        UnitStart[单位开始] --> InputLayer[输入层<br/>接收输入]\n+        InputLayer --> DecisionLayer[决策层<br/>选择行动/目标]\n+        DecisionLayer --> ExecutionLayer[执行层<br/>执行行动/计算伤害]\n+        ExecutionLayer --> PresentationLayer[表现层<br/>播放表现]\n+        PresentationLayer --> ManagementLayer[管理层<br/>更新状态]\n+        ManagementLayer --> UnitEnd[单位结束]\n+    end\n+    \n+    DataLayer[数据层<br/>配置数据] -.数据查询.-> DecisionLayer\n+    DataLayer -.数据查询.-> ExecutionLayer\n+    \n+    style UnitLoop fill:#e1f5ff\n+    style InputLayer fill:#ffebee\n+    style DecisionLayer fill:#fff4e1\n+    style ExecutionLayer fill:#c8e6c9\n+    style PresentationLayer fill:#e1f5ff\n+    style ManagementLayer fill:#f3e5f5\n+    style DataLayer fill:#e8f5e9\n+```\n+\n+#### 分层职责说明\n+\n+**重要**：以下所有分层功能都在**单位循环**内执行，不是独立的架构层次。\n+\n+##### 输入层（InputLayer）\n+- **执行位置**：单位循环内\n+- **职责**：接收玩家输入和AI输入\n+- **核心组件**：PlayerInput、AIInput、InputValidator\n+- **输出**：BattleContext + inputData\n+\n+##### 决策层（DecisionLayer）\n+- **执行位置**：单位循环内\n+- **职责**：行动选择、目标选择\n+- **核心组件**：ActionSelector、TargetSelector\n+- **输出**：BattleContext + decisionData\n+\n+##### 执行层（ExecutionLayer）\n+- **执行位置**：单位循环内\n+- **职责**：行动执行、伤害计算、效果应用\n+- **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n+- **输出**：BattleContext + executionData\n+\n+##### 表现层（PresentationLayer）\n+- **执行位置**：单位循环内\n+- **职责**：视觉表现、音频播放、UI更新\n+- **核心组件**：VisualPlayer、AudioPlayer、UIManager\n+- **输出**：BattleContext + presentationData\n+\n+##### 管理层（ManagementLayer）\n+- **执行位置**：单位循环内（状态更新）、循环间（循环管理）\n+- **职责**：战斗状态管理、参与者管理、Context管理、循环管理\n+- **核心组件**：BattleStateManager、ParticipantManager、BattleContext、LoopManager\n+- **输出**：状态更新、数据持久化、循环驱动\n+\n+##### 数据层（DataLayer）\n+- **执行位置**：所有循环和分层功能中\n+- **职责**：战斗配置、回合数据、战斗数据\n+- **核心组件**：BattleConfig、TurnData、BattleData\n+- **输出**：配置数据查询\n"
                },
                {
                    "date": 1767098704512,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,148 +36,302 @@\n ---\n \n ## 整体架构设计\n \n-### 多层循环架构（主要架构）\n+### Clean架构模式（主要架构）\n \n-**核心观点**：整个回合制战斗系统的核心是维护四层循环，所有战斗逻辑都在循环框架内执行。\n+**核心观点**：战斗系统采用Clean架构模式，将系统组织成四个同心圆层，业务规则在中心，框架和技术在外围。\n \n-#### 循环层次关系\n+#### Clean架构层次结构\n \n ```mermaid\n graph TB\n-    subgraph BattleLoop[\"战斗循环<br/>BattleLoop\"]\n-        BattleStart[战斗开始] --> BattleCheck{战斗是否结束?}\n-        BattleCheck -->|否| TurnLoop[回合循环]\n-        BattleCheck -->|是| BattleEnd[战斗结束]\n-        TurnLoop --> BattleCheck\n+    subgraph \"Clean架构同心圆\"\n+        direction TB\n+        Entities[实体层<br/>Entities<br/>核心业务规则<br/>最内层]\n+        UseCases[用例层<br/>Use Cases<br/>应用业务规则]\n+        InterfaceAdapters[接口适配器层<br/>Interface Adapters<br/>功能服务]\n+        Frameworks[框架层<br/>Frameworks & Drivers<br/>技术实现<br/>最外层]\n+        \n+        Frameworks --> InterfaceAdapters\n+        InterfaceAdapters --> UseCases\n+        UseCases --> Entities\n     end\n     \n-    subgraph TurnLoop[\"回合循环<br/>TurnLoop\"]\n-        TurnStart[回合开始] --> TeamLoop[阵营循环]\n-        TeamLoop --> TurnEnd[回合结束]\n-        TurnEnd --> TurnCheck{是否还有回合?}\n-        TurnCheck -->|是| TurnStart\n-        TurnCheck -->|否| TurnLoopEnd[回合循环结束]\n+    style Entities fill:#ffebee\n+    style UseCases fill:#fff4e1\n+    style InterfaceAdapters fill:#e8f5e9\n+    style Frameworks fill:#e1f5ff\n+```\n+\n+**依赖规则**：\n+- ✅ **允许**：外层依赖内层\n+- ❌ **禁止**：内层依赖外层\n+- ✅ **允许**：通过接口定义依赖\n+- ❌ **禁止**：直接依赖具体实现\n+\n+### 战斗系统在Clean架构中的映射\n+\n+```mermaid\n+graph TB\n+    subgraph \"实体层（Entities）- 核心业务规则\"\n+        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]\n+        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]\n+        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]\n+        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]\n+        SkillEntity[技能实体<br/>Skill Entity]\n+        EffectEntity[效果实体<br/>Effect Entity]\n     end\n     \n-    subgraph TeamLoop[\"阵营循环<br/>TeamLoop\"]\n-        TeamStart[阵营开始] --> UnitLoop[单位循环]\n-        UnitLoop --> TeamEnd[阵营结束]\n-        TeamEnd --> TeamCheck{是否还有阵营?}\n-        TeamCheck -->|是| TeamStart\n-        TeamCheck -->|否| TeamLoopEnd[阵营循环结束]\n+    subgraph \"用例层（Use Cases）- 应用业务规则\"\n+        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle UseCase]\n+        ExecuteRoundUC[执行回合用例<br/>ExecuteRound UseCase]\n+        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam UseCase]\n+        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n+        CalculateDamageUC[计算伤害用例<br/>CalculateDamage UseCase]\n+        ApplyEffectUC[应用效果用例<br/>ApplyEffect UseCase]\n     end\n     \n-    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n-        UnitStart[单位开始] --> UnitAction[单位行动]\n-        UnitAction --> UnitEnd[单位结束]\n-        UnitEnd --> UnitCheck{是否还有单位?}\n-        UnitCheck -->|是| UnitStart\n-        UnitCheck -->|否| UnitLoopEnd[单位循环结束]\n+    subgraph \"接口适配器层（Interface Adapters）- 功能服务\"\n+        InputAdapter[输入适配器<br/>Input Adapter<br/>输入服务]\n+        ActionAdapter[行动适配器<br/>Action Adapter<br/>执行服务]\n+        VisualAdapter[视觉适配器<br/>Visual Adapter<br/>表现服务]\n+        DataAdapter[数据适配器<br/>Data Adapter<br/>数据服务]\n+        CommunicationAdapter[通信适配器<br/>Communication Adapter<br/>通信服务]\n     end\n     \n-    BattleLoop --> TurnLoop\n-    TurnLoop --> TeamLoop\n-    TeamLoop --> UnitLoop\n+    subgraph \"框架层（Frameworks & Drivers）- 技术实现\"\n+        Unity[Unity引擎<br/>Unity Engine]\n+        Lua[Lua脚本引擎<br/>Lua Script Engine]\n+        Database[(数据库<br/>Database)]\n+        FSM[状态机框架<br/>FSM Framework]\n+        CommunicationBus[通信总线<br/>CommunicationBus]\n+        DataHandleQueue[数据队列<br/>DataHandleQueue]\n+    end\n     \n-    style BattleLoop fill:#ffebee\n-    style TurnLoop fill:#fff4e1\n-    style TeamLoop fill:#c8e6c9\n-    style UnitLoop fill:#e1f5ff\n+    ExecuteBattleUC --> BattleEntity\n+    ExecuteRoundUC --> RoundEntity\n+    ExecuteTeamUC --> TeamEntity\n+    ExecuteUnitUC --> UnitEntity\n+    CalculateDamageUC --> SkillEntity\n+    ApplyEffectUC --> EffectEntity\n+    \n+    InputAdapter --> ExecuteUnitUC\n+    ActionAdapter --> ExecuteUnitUC\n+    VisualAdapter --> ExecuteUnitUC\n+    DataAdapter --> ExecuteUnitUC\n+    CommunicationAdapter --> ExecuteUnitUC\n+    \n+    Unity --> VisualAdapter\n+    Lua --> ActionAdapter\n+    Database --> DataAdapter\n+    FSM --> ExecuteBattleUC\n+    CommunicationBus --> CommunicationAdapter\n+    DataHandleQueue --> DataAdapter\n+    \n+    style BattleEntity fill:#ffebee\n+    style ExecuteBattleUC fill:#fff4e1\n+    style InputAdapter fill:#e8f5e9\n+    style Unity fill:#e1f5ff\n ```\n \n-### 循环职责说明\n+### 各层职责说明\n \n-#### 1. 战斗循环（BattleLoop）\n-- **职责**：管理整个战斗的生命周期\n-- **状态**：BattleState（未开始/进行中/已结束）\n-- **触发**：战斗开始/结束条件检查\n-- **维护**：BattleLoopManager\n+#### 1. 实体层（Entities）- 核心业务规则\n \n-#### 2. 回合循环（TurnLoop）\n-- **职责**：管理回合的循环和切换\n-- **状态**：TurnState（回合编号/当前回合/回合数）\n-- **触发**：回合开始/结束条件检查\n-- **维护**：TurnLoopManager\n+**位置**：最内层，核心业务规则\n \n-#### 3. 阵营循环（TeamLoop）\n-- **职责**：管理阵营内单位的行动顺序\n-- **状态**：TeamState（当前阵营/阵营列表/行动顺序）\n-- **触发**：阵营切换/单位行动完成\n-- **维护**：TeamLoopManager\n+**职责**：\n+- 定义战斗核心实体（战斗、回合、阵营、单位）\n+- 包含企业级业务规则\n+- 定义四层循环的实体模型\n+- 不依赖任何外部框架\n \n-#### 4. 单位循环（UnitLoop）\n-- **职责**：管理单个单位的行动流程\n-- **状态**：UnitState（当前单位/行动状态/行动完成）\n-- **触发**：单位行动开始/结束\n-- **维护**：UnitLoopManager\n+**核心实体**：\n+- **战斗实体（Battle Entity）**：管理整个战斗的生命周期，包含战斗循环\n+- **回合实体（Round Entity）**：管理回合的循环和切换，包含回合循环\n+- **阵营实体（Team Entity）**：管理阵营内单位的行动顺序，包含阵营循环\n+- **单位实体（Unit Entity）**：管理单个单位的行动流程，包含单位循环\n+- **技能实体（Skill Entity）**：定义技能规则和效果\n+- **效果实体（Effect Entity）**：定义效果规则和应用逻辑\n \n+**特点**：\n+- 最稳定的一层\n+- 变化频率最低\n+- 包含核心业务概念\n+- 纯业务逻辑，无技术细节\n+\n+#### 2. 用例层（Use Cases）- 应用业务规则\n+\n+**位置**：第二层，应用业务规则\n+\n+**职责**：\n+- 实现具体的战斗用例\n+- 协调实体完成业务目标\n+- 定义应用输入输出接口\n+- 包含应用特定的业务逻辑\n+\n+**核心用例**：\n+- **执行战斗用例（ExecuteBattle）**：协调战斗实体执行战斗流程\n+- **执行回合用例（ExecuteRound）**：协调回合实体执行回合流程\n+- **执行阵营用例（ExecuteTeam）**：协调阵营实体执行阵营流程\n+- **执行单位用例（ExecuteUnit）**：协调单位实体执行单位行动\n+- **计算伤害用例（CalculateDamage）**：计算技能伤害\n+- **应用效果用例（ApplyEffect）**：应用技能效果\n+\n+**特点**：\n+- 依赖实体层\n+- 不依赖框架和UI\n+- 包含应用特定的业务逻辑\n+- 可以独立测试\n+\n+#### 3. 接口适配器层（Interface Adapters）- 功能服务\n+\n+**位置**：第三层，转换层\n+\n+**职责**：\n+- 转换数据格式\n+- 适配外部接口\n+- 实现接口定义\n+- 连接用例和框架\n+\n+**核心适配器**：\n+- **输入适配器（Input Adapter）**：处理玩家输入和AI输入，转换为用例输入\n+- **行动适配器（Action Adapter）**：执行行动逻辑，调用用例\n+- **视觉适配器（Visual Adapter）**：处理视觉表现，调用用例输出\n+- **数据适配器（Data Adapter）**：处理数据访问，调用用例\n+- **通信适配器（Communication Adapter）**：处理系统间通信，调用用例\n+\n+**特点**：\n+- 依赖用例层\n+- 实现框架层定义的接口\n+- 转换数据格式\n+- 适配外部服务\n+\n+#### 4. 框架层（Frameworks & Drivers）- 技术实现\n+\n+**位置**：最外层，技术实现\n+\n+**职责**：\n+- 实现具体的技术细节\n+- 提供框架和工具\n+- 处理外部系统交互\n+- 实现接口适配器定义的接口\n+\n+**核心框架**：\n+- **Unity引擎**：游戏引擎，提供渲染、物理等功能\n+- **Lua脚本引擎**：脚本语言，实现业务逻辑\n+- **数据库**：数据持久化\n+- **状态机框架（FSM）**：状态管理\n+- **通信总线（CommunicationBus）**：系统间通信\n+- **数据队列（DataHandleQueue）**：数据处理\n+\n+**特点**：\n+- 最外层，技术实现\n+- 可以被替换\n+- 不影响业务逻辑\n+- 提供基础设施\n+\n ---\n \n-## 多层循环架构模式\n+## 实体层详细设计（Entities Layer）\n \n-### 层次状态机（Hierarchical State Machine）\n+### 四层循环实体模型\n \n-**核心观点**：多层循环架构最适合使用**层次状态机（Hierarchical State Machine）**模式。\n+**核心观点**：战斗系统的核心是四层循环的维护和管理，这些循环在实体层中定义。\n \n-#### 为什么是层次状态机？\n+#### 循环层次关系\n \n-**原因**：\n-- **循环嵌套 = 状态嵌套**：每层循环都是一个状态机，可以包含子状态机\n-- **状态层次结构**：战斗状态机 → 回合状态机 → 阵营状态机 → 单位状态机\n-- **状态自动管理**：父状态机进入时自动重置子状态机，父状态机更新时自动更新子状态机\n-- **状态隔离**：每层循环的状态独立管理，互不干扰\n+```mermaid\n+graph TB\n+    subgraph \"实体层 - 四层循环模型\"\n+        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]\n+        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]\n+        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]\n+        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]\n+        \n+        BattleEntity --> RoundEntity\n+        RoundEntity --> TeamEntity\n+        TeamEntity --> UnitEntity\n+    end\n+    \n+    subgraph \"循环状态\"\n+        BattleState[战斗状态<br/>PREPARING/IN_PROGRESS/ENDED]\n+        RoundState[回合状态<br/>ROUND_START/ACTION/END]\n+        TeamState[阵营状态<br/>TEAM_START/ACTION/END]\n+        UnitState[单位状态<br/>UNIT_START/ACTION/END]\n+    end\n+    \n+    BattleEntity --> BattleState\n+    RoundEntity --> RoundState\n+    TeamEntity --> TeamState\n+    UnitEntity --> UnitState\n+    \n+    style BattleEntity fill:#ffebee\n+    style RoundEntity fill:#fff4e1\n+    style TeamEntity fill:#c8e6c9\n+    style UnitEntity fill:#e1f5ff\n+```\n \n-**适用场景**：\n-- 战斗状态机包含回合状态机（战斗进行中状态）\n-- 回合状态机包含阵营状态机（回合行动状态）\n-- 阵营状态机包含单位状态机（阵营行动状态）\n-- 单位状态机管理单位行动流程\n+#### 实体职责说明\n \n+##### 1. 战斗实体（Battle Entity）\n+- **职责**：管理整个战斗的生命周期\n+- **状态**：BattleState（PREPARING/IN_PROGRESS/PAUSED/ENDED）\n+- **循环**：战斗循环（BattleLoop）\n+- **业务规则**：战斗开始/结束条件、胜负判定\n+\n+##### 2. 回合实体（Round Entity）\n+- **职责**：管理回合的循环和切换\n+- **状态**：RoundState（ROUND_START/ROUND_ACTION/ROUND_END）\n+- **循环**：回合循环（RoundLoop）\n+- **业务规则**：回合开始/结束条件、回合数限制\n+\n+##### 3. 阵营实体（Team Entity）\n+- **职责**：管理阵营内单位的行动顺序\n+- **状态**：TeamState（TEAM_START/TEAM_ACTION/TEAM_END）\n+- **循环**：阵营循环（TeamLoop）\n+- **业务规则**：阵营切换规则、行动顺序规则\n+\n+##### 4. 单位实体（Unit Entity）\n+- **职责**：管理单个单位的行动流程\n+- **状态**：UnitState（UNIT_START/UNIT_ACTION/UNIT_END）\n+- **循环**：单位循环（UnitLoop）\n+- **业务规则**：单位行动规则、行动完成条件\n+\n+### 层次状态机实现（框架层）\n+\n+**说明**：层次状态机是框架层的实现，用于管理实体层的状态转换。\n+\n #### 层次状态机设计\n \n-``` mermaid\n+```mermaid\n graph TB\n-    subgraph \"核心业务流程\"\n-        Start([战斗开始]) --> BattleStart[战斗循环开始]\n-        BattleStart --> RoundStart[回合循环开始]\n-        RoundStart --> TeamStart[阵营循环开始]\n-        TeamStart --> UnitStart[单位循环开始]\n+    subgraph \"框架层 - 层次状态机\"\n+        BattleFSM[战斗状态机<br/>BattleFSM<br/>HierarchicalFSM]\n+        RoundFSM[回合状态机<br/>RoundFSM<br/>HierarchicalFSM]\n+        TeamFSM[阵营状态机<br/>TeamFSM<br/>HierarchicalFSM]\n+        UnitFSM[单位状态机<br/>UnitFSM<br/>FSMBase]\n         \n-        UnitStart --> GetInput[调用 InputService]\n-        GetInput --> Execute[调用 ActionService]\n-        Execute --> UpdateData[调用 DataService]\n-        UpdateData --> PlayVisual[调用 VisualService]\n-        PlayVisual --> UnitNext{还有下一个单位?}\n-        \n-        UnitNext -->|是| UnitStart\n-        UnitNext -->|否| TeamNext{还有下一个阵营?}\n-        TeamNext -->|是| TeamStart\n-        TeamNext -->|否| RoundNext{还有下一个回合?}\n-        RoundNext -->|是| RoundStart\n-        RoundNext -->|否| BattleEnd([战斗结束])\n+        BattleFSM -->|包含| RoundFSM\n+        RoundFSM -->|包含| TeamFSM\n+        TeamFSM -->|包含| UnitFSM\n     end\n     \n-    subgraph \"支撑服务\"\n-        InputService[InputService<br/>输入服务]\n-        ActionService[ActionService<br/>行动服务]\n-        DataService[DataService<br/>数据服务]\n-        VisualService[VisualService<br/>视觉服务]\n+    subgraph \"实体层 - 业务实体\"\n+        BattleEntity[战斗实体<br/>Battle Entity]\n+        RoundEntity[回合实体<br/>Round Entity]\n+        TeamEntity[阵营实体<br/>Team Entity]\n+        UnitEntity[单位实体<br/>Unit Entity]\n     end\n     \n-    GetInput -.调用.-> InputService\n-    Execute -.调用.-> ActionService\n-    UpdateData -.调用.-> DataService\n-    PlayVisual -.调用.-> VisualService\n+    BattleFSM -.管理.-> BattleEntity\n+    RoundFSM -.管理.-> RoundEntity\n+    TeamFSM -.管理.-> TeamEntity\n+    UnitFSM -.管理.-> UnitEntity\n     \n-    style Start fill:#90ee90\n-    style BattleEnd fill:#ffcccb\n-    style UnitStart fill:#e1f5ff\n-    style InputService fill:#fff4e1\n-    style ActionService fill:#e8f5e9\n-    style DataService fill:#ffebee\n-    style VisualService fill:#f3e5f5\n+    style BattleFSM fill:#e1f5ff\n+    style BattleEntity fill:#ffebee\n ```\n \n #### 层次状态机特点\n \n@@ -200,22 +354,8 @@\n    - 每层状态机的状态转换驱动循环推进\n    - 状态机状态决定循环是否继续\n    - 状态机状态决定循环行为\n \n-#### 实现要点\n-\n-1. **层次状态机接口**：\n-   - `AddSubFSM(stateId, subFSM)`：为某个状态添加子状态机\n-   - `EnterCurrentState()`：进入当前状态时，自动重置子状态机\n-   - `UpdateCurrentState()`：更新当前状态时，自动更新子状态机\n-\n-2. **状态机层次结构**：\n-   - 战斗状态机（HierarchicalFSM）：包含回合状态机和结果状态机\n-   - 回合状态机（HierarchicalFSM）：包含阵营状态机\n-   - 阵营状态机（HierarchicalFSM）：包含单位状态机\n-   - 单位状态机（FSMBase）：最底层状态机，不包含子状态机\n-\n-\n #### 循环分层状态机流程图\n ```mermaid\n sequenceDiagram\n     participant Main as 主状态机\n@@ -284,72 +424,317 @@\n     Main->>Main: 激活结果状态机\n ```\n ---\n \n-### 分层架构（循环内的功能组织）\n+## 用例层详细设计（Use Cases Layer）\n \n-**说明**：分层架构不是主要架构，而是循环内的功能组织方式。所有分层功能都在**单位循环**内执行。\n+### 核心用例\n \n-#### 单位循环内的分层功能\n+**说明**：用例层实现具体的战斗用例，协调实体完成业务目标。\n \n+#### 用例层次结构\n+\n ```mermaid\n graph TB\n-    subgraph UnitLoop[\"单位循环<br/>UnitLoop\"]\n-        UnitStart[单位开始] --> InputLayer[输入层<br/>接收输入]\n-        InputLayer --> DecisionLayer[决策层<br/>选择行动/目标]\n-        DecisionLayer --> ExecutionLayer[执行层<br/>执行行动/计算伤害]\n-        ExecutionLayer --> PresentationLayer[表现层<br/>播放表现]\n-        PresentationLayer --> ManagementLayer[管理层<br/>更新状态]\n-        ManagementLayer --> UnitEnd[单位结束]\n+    subgraph \"用例层 - 战斗用例\"\n+        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle UseCase]\n+        ExecuteRoundUC[执行回合用例<br/>ExecuteRound UseCase]\n+        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam UseCase]\n+        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n+        CalculateDamageUC[计算伤害用例<br/>CalculateDamage UseCase]\n+        ApplyEffectUC[应用效果用例<br/>ApplyEffect UseCase]\n     end\n     \n-    DataLayer[数据层<br/>配置数据] -.数据查询.-> DecisionLayer\n-    DataLayer -.数据查询.-> ExecutionLayer\n+    subgraph \"实体层 - 业务实体\"\n+        BattleEntity[战斗实体]\n+        RoundEntity[回合实体]\n+        TeamEntity[阵营实体]\n+        UnitEntity[单位实体]\n+        SkillEntity[技能实体]\n+        EffectEntity[效果实体]\n+    end\n     \n-    style UnitLoop fill:#e1f5ff\n-    style InputLayer fill:#ffebee\n-    style DecisionLayer fill:#fff4e1\n-    style ExecutionLayer fill:#c8e6c9\n-    style PresentationLayer fill:#e1f5ff\n-    style ManagementLayer fill:#f3e5f5\n-    style DataLayer fill:#e8f5e9\n+    ExecuteBattleUC --> BattleEntity\n+    ExecuteRoundUC --> RoundEntity\n+    ExecuteTeamUC --> TeamEntity\n+    ExecuteUnitUC --> UnitEntity\n+    CalculateDamageUC --> SkillEntity\n+    ApplyEffectUC --> EffectEntity\n+    \n+    style ExecuteBattleUC fill:#fff4e1\n+    style BattleEntity fill:#ffebee\n ```\n \n-#### 分层职责说明\n+#### 用例职责说明\n \n-**重要**：以下所有分层功能都在**单位循环**内执行，不是独立的架构层次。\n+##### 1. 执行战斗用例（ExecuteBattle UseCase）\n+- **职责**：协调战斗实体执行战斗流程\n+- **输入**：战斗配置、参与者列表\n+- **输出**：战斗结果\n+- **协调实体**：战斗实体、回合实体\n \n-##### 输入层（InputLayer）\n-- **执行位置**：单位循环内\n-- **职责**：接收玩家输入和AI输入\n-- **核心组件**：PlayerInput、AIInput、InputValidator\n-- **输出**：BattleContext + inputData\n+##### 2. 执行回合用例（ExecuteRound UseCase）\n+- **职责**：协调回合实体执行回合流程\n+- **输入**：回合编号、回合配置\n+- **输出**：回合结果\n+- **协调实体**：回合实体、阵营实体\n \n-##### 决策层（DecisionLayer）\n-- **执行位置**：单位循环内\n-- **职责**：行动选择、目标选择\n-- **核心组件**：ActionSelector、TargetSelector\n-- **输出**：BattleContext + decisionData\n+##### 3. 执行阵营用例（ExecuteTeam UseCase）\n+- **职责**：协调阵营实体执行阵营流程\n+- **输入**：阵营信息、单位列表\n+- **输出**：阵营行动结果\n+- **协调实体**：阵营实体、单位实体\n \n-##### 执行层（ExecutionLayer）\n-- **执行位置**：单位循环内\n-- **职责**：行动执行、伤害计算、效果应用\n-- **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n-- **输出**：BattleContext + executionData\n+##### 4. 执行单位用例（ExecuteUnit UseCase）\n+- **职责**：协调单位实体执行单位行动\n+- **输入**：单位信息、行动指令\n+- **输出**：行动结果\n+- **协调实体**：单位实体、技能实体\n \n-##### 表现层（PresentationLayer）\n-- **执行位置**：单位循环内\n-- **职责**：视觉表现、音频播放、UI更新\n-- **核心组件**：VisualPlayer、AudioPlayer、UIManager\n-- **输出**：BattleContext + presentationData\n+##### 5. 计算伤害用例（CalculateDamage UseCase）\n+- **职责**：计算技能伤害\n+- **输入**：技能信息、攻击者、目标\n+- **输出**：伤害数值\n+- **协调实体**：技能实体、单位实体\n \n-##### 管理层（ManagementLayer）\n-- **执行位置**：单位循环内（状态更新）、循环间（循环管理）\n-- **职责**：战斗状态管理、参与者管理、Context管理、循环管理\n-- **核心组件**：BattleStateManager、ParticipantManager、BattleContext、LoopManager\n-- **输出**：状态更新、数据持久化、循环驱动\n+##### 6. 应用效果用例（ApplyEffect UseCase）\n+- **职责**：应用技能效果\n+- **输入**：效果信息、目标\n+- **输出**：效果应用结果\n+- **协调实体**：效果实体、单位实体\n \n-##### 数据层（DataLayer）\n-- **执行位置**：所有循环和分层功能中\n-- **职责**：战斗配置、回合数据、战斗数据\n-- **核心组件**：BattleConfig、TurnData、BattleData\n-- **输出**：配置数据查询\n+## 接口适配器层详细设计（Interface Adapters Layer）\n+\n+### 功能适配器\n+\n+**说明**：接口适配器层将用例层的输出转换为框架层可以使用的格式，同时将框架层的输入转换为用例层可以使用的格式。\n+\n+#### 适配器层次结构\n+\n+```mermaid\n+graph TB\n+    subgraph \"接口适配器层 - 功能适配器\"\n+        InputAdapter[输入适配器<br/>Input Adapter]\n+        ActionAdapter[行动适配器<br/>Action Adapter]\n+        VisualAdapter[视觉适配器<br/>Visual Adapter]\n+        DataAdapter[数据适配器<br/>Data Adapter]\n+        CommunicationAdapter[通信适配器<br/>Communication Adapter]\n+    end\n+    \n+    subgraph \"用例层 - 用例\"\n+        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n+    end\n+    \n+    subgraph \"框架层 - 框架\"\n+        Unity[Unity引擎]\n+        Lua[Lua脚本]\n+        Database[(数据库)]\n+        CommunicationBus[通信总线]\n+    end\n+    \n+    InputAdapter --> ExecuteUnitUC\n+    ActionAdapter --> ExecuteUnitUC\n+    VisualAdapter --> ExecuteUnitUC\n+    DataAdapter --> ExecuteUnitUC\n+    CommunicationAdapter --> ExecuteUnitUC\n+    \n+    Unity --> VisualAdapter\n+    Lua --> ActionAdapter\n+    Database --> DataAdapter\n+    CommunicationBus --> CommunicationAdapter\n+    \n+    style InputAdapter fill:#e8f5e9\n+    style ExecuteUnitUC fill:#fff4e1\n+    style Unity fill:#e1f5ff\n+```\n+\n+#### 适配器职责说明\n+\n+##### 1. 输入适配器（Input Adapter）\n+- **职责**：处理玩家输入和AI输入，转换为用例输入\n+- **功能**：\n+  - 接收玩家输入（UI交互、键盘鼠标）\n+  - 接收AI输入（AI决策结果）\n+  - 验证输入有效性\n+  - 转换为用例输入格式（BattleContext）\n+- **框架依赖**：Unity Input Manager、AI系统\n+\n+##### 2. 行动适配器（Action Adapter）\n+- **职责**：执行行动逻辑，调用用例\n+- **功能**：\n+  - 验证行动合法性\n+  - 执行行动逻辑\n+  - 调用执行单位用例\n+  - 处理行动结果\n+- **框架依赖**：Lua脚本引擎、技能系统\n+\n+##### 3. 视觉适配器（Visual Adapter）\n+- **职责**：处理视觉表现，调用用例输出\n+- **功能**：\n+  - 播放战斗动画\n+  - 播放特效\n+  - 更新UI显示\n+  - 处理相机控制\n+- **框架依赖**：Unity引擎、Visual系统\n+\n+##### 4. 数据适配器（Data Adapter）\n+- **职责**：处理数据访问，调用用例\n+- **功能**：\n+  - 读取战斗配置\n+  - 保存战斗数据\n+  - 查询单位数据\n+  - 更新战斗状态\n+- **框架依赖**：数据库、DataHandleQueue\n+\n+##### 5. 通信适配器（Communication Adapter）\n+- **职责**：处理系统间通信，调用用例\n+- **功能**：\n+  - 发布战斗事件\n+  - 订阅系统消息\n+  - 处理跨系统通信\n+  - 管理通信上下文\n+- **框架依赖**：CommunicationBus\n+\n+### 单位循环内的功能流程\n+\n+**说明**：单位循环内的功能流程通过接口适配器层实现。\n+\n+```mermaid\n+graph TB\n+    subgraph \"单位循环 - 用例层\"\n+        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n+    end\n+    \n+    subgraph \"接口适配器层 - 功能流程\"\n+        InputAdapter[输入适配器<br/>接收输入]\n+        ActionAdapter[行动适配器<br/>执行行动]\n+        VisualAdapter[视觉适配器<br/>播放表现]\n+        DataAdapter[数据适配器<br/>更新数据]\n+    end\n+    \n+    subgraph \"框架层 - 技术实现\"\n+        Unity[Unity引擎]\n+        Lua[Lua脚本]\n+        Database[(数据库)]\n+    end\n+    \n+    InputAdapter --> ExecuteUnitUC\n+    ExecuteUnitUC --> ActionAdapter\n+    ActionAdapter --> VisualAdapter\n+    VisualAdapter --> DataAdapter\n+    \n+    Unity --> VisualAdapter\n+    Lua --> ActionAdapter\n+    Database --> DataAdapter\n+    \n+    style ExecuteUnitUC fill:#fff4e1\n+    style InputAdapter fill:#e8f5e9\n+    style Unity fill:#e1f5ff\n+```\n+\n+## 框架层详细设计（Frameworks & Drivers Layer）\n+\n+### 技术框架\n+\n+**说明**：框架层提供具体的技术实现，可以被替换而不影响业务逻辑。\n+\n+#### 框架层次结构\n+\n+```mermaid\n+graph TB\n+    subgraph \"框架层 - 技术框架\"\n+        Unity[Unity引擎<br/>Unity Engine<br/>渲染、物理、动画]\n+        Lua[Lua脚本引擎<br/>Lua Script Engine<br/>业务逻辑]\n+        Database[(数据库<br/>Database<br/>数据持久化)]\n+        FSM[状态机框架<br/>FSM Framework<br/>状态管理]\n+        CommunicationBus[通信总线<br/>CommunicationBus<br/>系统通信]\n+        DataHandleQueue[数据队列<br/>DataHandleQueue<br/>数据处理]\n+        Formula[公式引擎<br/>Formula Parser<br/>公式计算]\n+        Pool[对象池<br/>Object Pool<br/>对象管理]\n+    end\n+    \n+    subgraph \"接口适配器层 - 适配器\"\n+        VisualAdapter[视觉适配器]\n+        ActionAdapter[行动适配器]\n+        DataAdapter[数据适配器]\n+        CommunicationAdapter[通信适配器]\n+    end\n+    \n+    Unity --> VisualAdapter\n+    Lua --> ActionAdapter\n+    Database --> DataAdapter\n+    FSM --> VisualAdapter\n+    CommunicationBus --> CommunicationAdapter\n+    DataHandleQueue --> DataAdapter\n+    Formula --> ActionAdapter\n+    Pool --> VisualAdapter\n+    \n+    style Unity fill:#e1f5ff\n+    style VisualAdapter fill:#e8f5e9\n+```\n+\n+#### 框架职责说明\n+\n+##### 1. Unity引擎（Unity Engine）\n+- **职责**：提供游戏引擎功能\n+- **功能**：\n+  - 渲染系统（3D渲染、UI渲染）\n+  - 物理系统（碰撞检测、物理模拟）\n+  - 动画系统（动画播放、动画控制）\n+  - 音频系统（音效播放、背景音乐）\n+  - 资源管理（资源加载、资源释放）\n+\n+##### 2. Lua脚本引擎（Lua Script Engine）\n+- **职责**：执行业务逻辑脚本\n+- **功能**：\n+  - 脚本解析和执行\n+  - 业务逻辑实现\n+  - 配置数据读取\n+  - 热更新支持\n+\n+##### 3. 数据库（Database）\n+- **职责**：数据持久化\n+- **功能**：\n+  - 战斗配置存储\n+  - 战斗数据保存\n+  - 单位数据查询\n+  - 历史记录存储\n+\n+##### 4. 状态机框架（FSM Framework）\n+- **职责**：状态管理\n+- **功能**：\n+  - 层次状态机（HierarchicalFSM）\n+  - 基础状态机（FSMBase）\n+  - 状态转换管理\n+  - 状态生命周期管理\n+\n+##### 5. 通信总线（CommunicationBus）\n+- **职责**：系统间通信\n+- **功能**：\n+  - 事件发布订阅（Event Channel）\n+  - 消息传递（Message Channel）\n+  - 数据推送（Push Channel）\n+  - 数据查询（Query Channel）\n+\n+##### 6. 数据队列（DataHandleQueue）\n+- **职责**：数据处理\n+- **功能**：\n+  - 数据推送和处理\n+- **数据查询**（Query Delegate）\n+- **批量处理**\n+- **数据同步**\n+\n+##### 7. 公式引擎（Formula Parser）\n+- **职责**：公式计算\n+- **功能**：\n+  - 三级公式解析\n+  - 公式计算\n+  - 公式缓存\n+  - 公式验证\n+\n+##### 8. 对象池（Object Pool）\n+- **职责**：对象管理\n+- **功能**：\n+  - 对象复用\n+  - 对象预加载\n+  - 对象生命周期管理\n+  - 性能优化\n"
                },
                {
                    "date": 1767098808950,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -737,4 +737,258 @@\n   - 对象复用\n   - 对象预加载\n   - 对象生命周期管理\n   - 性能优化\n+\n+---\n+\n+## 数据驱动架构在Clean架构中的位置\n+\n+### 数据驱动架构的层次分布\n+\n+**说明**：数据驱动架构贯穿Clean架构的所有层次，但主要作用在不同层次。\n+\n+```mermaid\n+graph TB\n+    subgraph \"Clean架构 + 数据驱动\"\n+        subgraph \"实体层\"\n+            Entity[实体<br/>业务规则<br/>配置数据定义规则]\n+        end\n+        \n+        subgraph \"用例层\"\n+            UseCase[用例<br/>应用逻辑<br/>配置数据驱动流程]\n+        end\n+        \n+        subgraph \"接口适配器层\"\n+            Adapter[适配器<br/>数据转换<br/>配置数据映射]\n+        end\n+        \n+        subgraph \"框架层\"\n+            Config[配置数据<br/>Excel/JSON/Lua<br/>数据驱动源]\n+        end\n+        \n+        Config -.驱动.-> Adapter\n+        Adapter -.使用.-> UseCase\n+        UseCase -.应用.-> Entity\n+        Config -.定义.-> Entity\n+    end\n+    \n+    style Entity fill:#ffebee\n+    style UseCase fill:#fff4e1\n+    style Adapter fill:#e8f5e9\n+    style Config fill:#e1f5ff\n+```\n+\n+### 数据驱动的实现方式\n+\n+#### 1. 配置数据存储（框架层）\n+- **位置**：框架层\n+- **形式**：Excel配置表、JSON配置文件、Lua配置脚本\n+- **内容**：战斗规则、伤害计算、效果应用、回合流程、状态转换\n+\n+#### 2. 配置数据读取（接口适配器层）\n+- **位置**：接口适配器层（数据适配器）\n+- **功能**：读取配置数据，转换为用例可用的格式\n+- **组件**：DataAdapter、ConfigLoader\n+\n+#### 3. 配置数据应用（用例层）\n+- **位置**：用例层\n+- **功能**：使用配置数据驱动业务逻辑\n+- **示例**：根据配置数据执行战斗流程、计算伤害、应用效果\n+\n+#### 4. 配置数据定义规则（实体层）\n+- **位置**：实体层\n+- **功能**：配置数据定义的业务规则\n+- **示例**：战斗规则、回合规则、单位规则\n+\n+---\n+\n+## Clean架构与核心设计理念的对应关系\n+\n+### 设计理念映射\n+\n+```mermaid\n+graph TB\n+    subgraph \"核心设计理念\"\n+        Loop[多层循环架构<br/>四层循环]\n+        DataDriven[数据驱动架构<br/>配置驱动]\n+        Layered[分层架构<br/>功能组织]\n+    end\n+    \n+    subgraph \"Clean架构层次\"\n+        Entities[实体层<br/>四层循环实体]\n+        UseCases[用例层<br/>循环用例]\n+        Adapters[适配器层<br/>功能适配器]\n+        Frameworks[框架层<br/>配置数据]\n+    end\n+    \n+    Loop --> Entities\n+    Loop --> UseCases\n+    DataDriven --> Frameworks\n+    DataDriven --> Adapters\n+    Layered --> Adapters\n+    \n+    style Loop fill:#ffebee\n+    style Entities fill:#ffebee\n+```\n+\n+### 对应关系说明\n+\n+#### 1. 多层循环架构 → 实体层 + 用例层\n+\n+**实体层**：\n+- 定义四层循环的实体模型（战斗、回合、阵营、单位）\n+- 包含循环的业务规则\n+- 定义循环的状态和转换条件\n+\n+**用例层**：\n+- 实现循环的执行用例（执行战斗、执行回合、执行单位）\n+- 协调实体完成循环流程\n+- 管理循环的生命周期\n+\n+#### 2. 数据驱动架构 → 框架层 + 接口适配器层\n+\n+**框架层**：\n+- 存储配置数据（Excel、JSON、Lua）\n+- 提供配置数据访问接口\n+- 管理配置数据的加载和更新\n+\n+**接口适配器层**：\n+- 读取配置数据（数据适配器）\n+- 将配置数据转换为用例可用的格式\n+- 应用配置数据驱动业务逻辑\n+\n+#### 3. 分层架构（功能组织）→ 接口适配器层\n+\n+**接口适配器层**：\n+- 输入适配器：处理输入功能\n+- 行动适配器：处理执行功能\n+- 视觉适配器：处理表现功能\n+- 数据适配器：处理数据功能\n+- 通信适配器：处理通信功能\n+\n+---\n+\n+## Clean架构的优势\n+\n+### 对战斗系统的价值\n+\n+```mermaid\n+mindmap\n+  root((Clean架构优势))\n+    业务逻辑独立\n+      实体层独立\n+      用例层独立\n+      不依赖框架\n+    可测试性\n+      实体可独立测试\n+      用例可独立测试\n+      无需Unity/Lua\n+    技术无关性\n+      可替换Unity\n+      可替换Lua\n+      可替换数据库\n+    可维护性\n+      依赖方向清晰\n+      职责分离明确\n+      易于理解\n+    可扩展性\n+      新增用例\n+      新增适配器\n+      不影响现有代码\n+```\n+\n+### 具体优势说明\n+\n+#### 1. 业务逻辑独立\n+- **实体层**：四层循环的业务规则完全独立，不依赖Unity、Lua等技术\n+- **用例层**：战斗用例可以独立实现，不依赖框架\n+- **优势**：业务逻辑稳定，技术变化不影响业务\n+\n+#### 2. 可测试性\n+- **实体层**：可以独立测试实体和业务规则\n+- **用例层**：可以独立测试用例逻辑，无需Unity引擎\n+- **优势**：提高测试覆盖率，保证代码质量\n+\n+#### 3. 技术无关性\n+- **框架层**：Unity、Lua、数据库等技术可以被替换\n+- **接口适配器层**：通过适配器隔离技术细节\n+- **优势**：可以轻松替换技术栈，不影响业务逻辑\n+\n+#### 4. 可维护性\n+- **依赖方向清晰**：从外向内，易于理解\n+- **职责分离明确**：每层职责单一，易于维护\n+- **优势**：代码组织清晰，易于理解和修改\n+\n+#### 5. 可扩展性\n+- **新增用例**：只需在用例层添加新用例，不影响现有代码\n+- **新增适配器**：只需在适配器层添加新适配器，不影响用例\n+- **优势**：易于扩展新功能，不影响现有系统\n+\n+---\n+\n+## 实施建议\n+\n+### Clean架构实施步骤\n+\n+```mermaid\n+graph TD\n+    Start[开始实施] --> Step1[1. 设计实体层<br/>定义四层循环实体]\n+    Step1 --> Step2[2. 设计用例层<br/>定义战斗用例]\n+    Step2 --> Step3[3. 设计适配器层<br/>定义功能适配器]\n+    Step3 --> Step4[4. 集成框架层<br/>集成Unity/Lua等]\n+    Step4 --> Step5[5. 实现数据驱动<br/>配置数据读取和应用]\n+    Step5 --> End[完成]\n+    \n+    style Step1 fill:#ffebee\n+    style Step2 fill:#fff4e1\n+    style Step3 fill:#e8f5e9\n+    style Step4 fill:#e1f5ff\n+```\n+\n+### 实施优先级\n+\n+#### 第一阶段：核心实体和用例\n+1. **实体层**：定义战斗、回合、阵营、单位实体\n+2. **用例层**：实现执行战斗、执行回合、执行单位用例\n+3. **框架层**：集成状态机框架，实现层次状态机\n+\n+#### 第二阶段：功能适配器\n+1. **输入适配器**：实现玩家输入和AI输入处理\n+2. **行动适配器**：实现行动执行逻辑\n+3. **视觉适配器**：实现视觉表现处理\n+4. **数据适配器**：实现数据访问和配置读取\n+\n+#### 第三阶段：框架集成\n+1. **Unity集成**：集成Unity引擎，实现视觉表现\n+2. **Lua集成**：集成Lua脚本，实现业务逻辑\n+3. **数据库集成**：集成数据库，实现数据持久化\n+4. **通信集成**：集成CommunicationBus，实现系统通信\n+\n+---\n+\n+## 总结\n+\n+战斗系统采用Clean架构模式，将系统组织成四个同心圆层，业务规则在中心，框架和技术在外围。\n+\n+### 核心价值\n+\n+- 🎯 **业务逻辑独立**：四层循环的业务规则完全独立于框架和技术\n+- 🧪 **高度可测试**：实体和用例可以独立测试，无需Unity/Lua\n+- 🔄 **技术无关**：可以轻松替换Unity、Lua、数据库等技术栈\n+- 📐 **依赖清晰**：依赖方向从外向内，易于理解和维护\n+- 📈 **易于扩展**：新增功能只需添加用例或适配器，不影响现有代码\n+\n+### 架构映射\n+\n+- **实体层** = 四层循环实体（战斗、回合、阵营、单位）\n+- **用例层** = 战斗用例（执行战斗、执行回合、执行单位）\n+- **接口适配器层** = 功能服务（输入、执行、表现、数据、通信）\n+- **框架层** = 技术实现（Unity、Lua、数据库、FSM、CommunicationBus、DataHandleQueue）\n+\n+### 设计理念对应\n+\n+- **多层循环架构** → 实体层 + 用例层\n+- **数据驱动架构** → 框架层 + 接口适配器层\n+- **分层架构（功能组织）** → 接口适配器层\n+\n+Clean架构是构建可维护、可测试、可扩展战斗系统的优秀选择，特别适合需要长期维护和持续演进的战斗系统。\n"
                },
                {
                    "date": 1767098942212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,22 +40,99 @@\n ### Clean架构模式（主要架构）\n \n **核心观点**：战斗系统采用Clean架构模式，将系统组织成四个同心圆层，业务规则在中心，框架和技术在外围。\n \n-#### Clean架构层次结构\n+### 战斗系统整体架构图\n \n ```mermaid\n graph TB\n+    subgraph \"框架层（Frameworks & Drivers）- 技术实现\"\n+        Unity[Unity引擎<br/>渲染/物理/动画]\n+        Lua[Lua脚本引擎<br/>业务逻辑]\n+        Database[(数据库<br/>数据持久化)]\n+        FSM[状态机框架<br/>FSM Framework]\n+        CommunicationBus[通信总线<br/>CommunicationBus]\n+        DataHandleQueue[数据队列<br/>DataHandleQueue]\n+        Formula[公式引擎<br/>Formula Parser]\n+        Pool[对象池<br/>Object Pool]\n+        Config[配置数据<br/>Excel/JSON/Lua]\n+    end\n+    \n+    subgraph \"接口适配器层（Interface Adapters）- 功能服务\"\n+        InputAdapter[输入适配器<br/>Input Adapter<br/>玩家输入/AI输入]\n+        ActionAdapter[行动适配器<br/>Action Adapter<br/>行动执行/伤害计算]\n+        VisualAdapter[视觉适配器<br/>Visual Adapter<br/>动画/特效/UI]\n+        DataAdapter[数据适配器<br/>Data Adapter<br/>数据访问/配置读取]\n+        CommunicationAdapter[通信适配器<br/>Communication Adapter<br/>事件/消息/查询]\n+    end\n+    \n+    subgraph \"用例层（Use Cases）- 应用业务规则\"\n+        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n+        ExecuteRoundUC[执行回合用例<br/>ExecuteRound]\n+        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam]\n+        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit]\n+        CalculateDamageUC[计算伤害用例<br/>CalculateDamage]\n+        ApplyEffectUC[应用效果用例<br/>ApplyEffect]\n+    end\n+    \n+    subgraph \"实体层（Entities）- 核心业务规则\"\n+        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]\n+        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]\n+        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]\n+        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]\n+        SkillEntity[技能实体<br/>Skill Entity]\n+        EffectEntity[效果实体<br/>Effect Entity]\n+    end\n+    \n+    Unity --> VisualAdapter\n+    Lua --> ActionAdapter\n+    Database --> DataAdapter\n+    FSM --> ExecuteBattleUC\n+    CommunicationBus --> CommunicationAdapter\n+    DataHandleQueue --> DataAdapter\n+    Formula --> ActionAdapter\n+    Pool --> VisualAdapter\n+    Config --> DataAdapter\n+    \n+    InputAdapter --> ExecuteUnitUC\n+    ActionAdapter --> ExecuteUnitUC\n+    VisualAdapter --> ExecuteUnitUC\n+    DataAdapter --> ExecuteUnitUC\n+    CommunicationAdapter --> ExecuteUnitUC\n+    \n+    ExecuteBattleUC --> BattleEntity\n+    ExecuteRoundUC --> RoundEntity\n+    ExecuteTeamUC --> TeamEntity\n+    ExecuteUnitUC --> UnitEntity\n+    CalculateDamageUC --> SkillEntity\n+    ApplyEffectUC --> EffectEntity\n+    \n+    BattleEntity --> RoundEntity\n+    RoundEntity --> TeamEntity\n+    TeamEntity --> UnitEntity\n+    \n+    style BattleEntity fill:#ffebee\n+    style ExecuteBattleUC fill:#fff4e1\n+    style InputAdapter fill:#e8f5e9\n+    style Unity fill:#e1f5ff\n+```\n+\n+### 架构层次说明\n+\n+#### Clean架构同心圆结构\n+\n+```mermaid\n+graph TB\n     subgraph \"Clean架构同心圆\"\n         direction TB\n         Entities[实体层<br/>Entities<br/>核心业务规则<br/>最内层]\n         UseCases[用例层<br/>Use Cases<br/>应用业务规则]\n         InterfaceAdapters[接口适配器层<br/>Interface Adapters<br/>功能服务]\n         Frameworks[框架层<br/>Frameworks & Drivers<br/>技术实现<br/>最外层]\n         \n-        Frameworks --> InterfaceAdapters\n-        InterfaceAdapters --> UseCases\n-        UseCases --> Entities\n+        Frameworks -.依赖.-> InterfaceAdapters\n+        InterfaceAdapters -.依赖.-> UseCases\n+        UseCases -.依赖.-> Entities\n     end\n     \n     style Entities fill:#ffebee\n     style UseCases fill:#fff4e1\n@@ -68,75 +145,103 @@\n - ❌ **禁止**：内层依赖外层\n - ✅ **允许**：通过接口定义依赖\n - ❌ **禁止**：直接依赖具体实现\n \n-### 战斗系统在Clean架构中的映射\n+### 战斗流程在Clean架构中的执行\n \n ```mermaid\n-graph TB\n-    subgraph \"实体层（Entities）- 核心业务规则\"\n-        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]\n-        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]\n-        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]\n-        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]\n-        SkillEntity[技能实体<br/>Skill Entity]\n-        EffectEntity[效果实体<br/>Effect Entity]\n-    end\n+sequenceDiagram\n+    participant Framework as 框架层\n+    participant Adapter as 适配器层\n+    participant UseCase as 用例层\n+    participant Entity as 实体层\n     \n-    subgraph \"用例层（Use Cases）- 应用业务规则\"\n-        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle UseCase]\n-        ExecuteRoundUC[执行回合用例<br/>ExecuteRound UseCase]\n-        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam UseCase]\n-        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n-        CalculateDamageUC[计算伤害用例<br/>CalculateDamage UseCase]\n-        ApplyEffectUC[应用效果用例<br/>ApplyEffect UseCase]\n-    end\n+    Note over Framework,Entity: 战斗开始流程\n     \n-    subgraph \"接口适配器层（Interface Adapters）- 功能服务\"\n-        InputAdapter[输入适配器<br/>Input Adapter<br/>输入服务]\n-        ActionAdapter[行动适配器<br/>Action Adapter<br/>执行服务]\n-        VisualAdapter[视觉适配器<br/>Visual Adapter<br/>表现服务]\n-        DataAdapter[数据适配器<br/>Data Adapter<br/>数据服务]\n-        CommunicationAdapter[通信适配器<br/>Communication Adapter<br/>通信服务]\n-    end\n+    Framework->>Adapter: Unity触发战斗开始\n+    Adapter->>UseCase: 输入适配器转换输入\n+    UseCase->>Entity: 执行战斗用例调用战斗实体\n+    Entity->>Entity: 战斗实体启动战斗循环\n     \n-    subgraph \"框架层（Frameworks & Drivers）- 技术实现\"\n-        Unity[Unity引擎<br/>Unity Engine]\n-        Lua[Lua脚本引擎<br/>Lua Script Engine]\n-        Database[(数据库<br/>Database)]\n-        FSM[状态机框架<br/>FSM Framework]\n-        CommunicationBus[通信总线<br/>CommunicationBus]\n-        DataHandleQueue[数据队列<br/>DataHandleQueue]\n-    end\n+    Note over Entity: 战斗循环开始\n     \n-    ExecuteBattleUC --> BattleEntity\n-    ExecuteRoundUC --> RoundEntity\n-    ExecuteTeamUC --> TeamEntity\n-    ExecuteUnitUC --> UnitEntity\n-    CalculateDamageUC --> SkillEntity\n-    ApplyEffectUC --> EffectEntity\n+    Entity->>UseCase: 战斗实体调用执行回合用例\n+    UseCase->>Entity: 执行回合用例调用回合实体\n+    Entity->>Entity: 回合实体启动回合循环\n     \n-    InputAdapter --> ExecuteUnitUC\n-    ActionAdapter --> ExecuteUnitUC\n-    VisualAdapter --> ExecuteUnitUC\n-    DataAdapter --> ExecuteUnitUC\n-    CommunicationAdapter --> ExecuteUnitUC\n+    Note over Entity: 回合循环开始\n     \n-    Unity --> VisualAdapter\n-    Lua --> ActionAdapter\n-    Database --> DataAdapter\n-    FSM --> ExecuteBattleUC\n-    CommunicationBus --> CommunicationAdapter\n-    DataHandleQueue --> DataAdapter\n+    Entity->>UseCase: 回合实体调用执行阵营用例\n+    UseCase->>Entity: 执行阵营用例调用阵营实体\n+    Entity->>Entity: 阵营实体启动阵营循环\n     \n-    style BattleEntity fill:#ffebee\n-    style ExecuteBattleUC fill:#fff4e1\n-    style InputAdapter fill:#e8f5e9\n-    style Unity fill:#e1f5ff\n+    Note over Entity: 阵营循环开始\n+    \n+    Entity->>UseCase: 阵营实体调用执行单位用例\n+    UseCase->>Adapter: 执行单位用例调用输入适配器\n+    Adapter->>Framework: 输入适配器获取玩家输入/AI输入\n+    Framework->>Adapter: 返回输入数据\n+    Adapter->>UseCase: 转换输入数据\n+    \n+    UseCase->>Adapter: 执行单位用例调用行动适配器\n+    Adapter->>Framework: 行动适配器调用Lua脚本\n+    Framework->>Adapter: 返回行动结果\n+    Adapter->>UseCase: 转换行动结果\n+    \n+    UseCase->>Adapter: 执行单位用例调用视觉适配器\n+    Adapter->>Framework: 视觉适配器调用Unity引擎\n+    Framework->>Adapter: 播放动画/特效\n+    Adapter->>UseCase: 视觉播放完成\n+    \n+    UseCase->>Adapter: 执行单位用例调用数据适配器\n+    Adapter->>Framework: 数据适配器更新数据\n+    Framework->>Adapter: 数据更新完成\n+    Adapter->>UseCase: 数据更新结果\n+    \n+    UseCase->>Entity: 执行单位用例完成，更新单位实体\n+    Entity->>Entity: 单位循环继续/结束\n+    \n+    Note over Entity: 单位循环结束，返回上层循环\n ```\n \n-### 各层职责说明\n+### 数据流在Clean架构中的方向\n \n+```mermaid\n+graph LR\n+    subgraph \"数据流向\"\n+        direction TB\n+        \n+        subgraph \"请求流（从外向内）\"\n+            FrameworkReq[框架层<br/>用户输入/系统事件]\n+            AdapterReq[适配器层<br/>数据转换]\n+            UseCaseReq[用例层<br/>用例输入]\n+            EntityReq[实体层<br/>实体操作]\n+            \n+            FrameworkReq --> AdapterReq\n+            AdapterReq --> UseCaseReq\n+            UseCaseReq --> EntityReq\n+        end\n+        \n+        subgraph \"响应流（从内向外）\"\n+            EntityResp[实体层<br/>业务结果]\n+            UseCaseResp[用例层<br/>用例输出]\n+            AdapterResp[适配器层<br/>数据转换]\n+            FrameworkResp[框架层<br/>UI更新/视觉表现]\n+            \n+            EntityResp --> UseCaseResp\n+            UseCaseResp --> AdapterResp\n+            AdapterResp --> FrameworkResp\n+        end\n+    end\n+    \n+    style FrameworkReq fill:#e1f5ff\n+    style EntityReq fill:#ffebee\n+    style EntityResp fill:#ffebee\n+    style FrameworkResp fill:#e1f5ff\n+```\n+\n+### 各层职责概览\n+\n #### 1. 实体层（Entities）- 核心业务规则\n \n **位置**：最内层，核心业务规则\n \n"
                },
                {
                    "date": 1767099031196,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,230 +115,9 @@\n     style InputAdapter fill:#e8f5e9\n     style Unity fill:#e1f5ff\n ```\n \n-### 架构层次说明\n \n-#### Clean架构同心圆结构\n-\n-```mermaid\n-graph TB\n-    subgraph \"Clean架构同心圆\"\n-        direction TB\n-        Entities[实体层<br/>Entities<br/>核心业务规则<br/>最内层]\n-        UseCases[用例层<br/>Use Cases<br/>应用业务规则]\n-        InterfaceAdapters[接口适配器层<br/>Interface Adapters<br/>功能服务]\n-        Frameworks[框架层<br/>Frameworks & Drivers<br/>技术实现<br/>最外层]\n-        \n-        Frameworks -.依赖.-> InterfaceAdapters\n-        InterfaceAdapters -.依赖.-> UseCases\n-        UseCases -.依赖.-> Entities\n-    end\n-    \n-    style Entities fill:#ffebee\n-    style UseCases fill:#fff4e1\n-    style InterfaceAdapters fill:#e8f5e9\n-    style Frameworks fill:#e1f5ff\n-```\n-\n-**依赖规则**：\n-- ✅ **允许**：外层依赖内层\n-- ❌ **禁止**：内层依赖外层\n-- ✅ **允许**：通过接口定义依赖\n-- ❌ **禁止**：直接依赖具体实现\n-\n-### 战斗流程在Clean架构中的执行\n-\n-```mermaid\n-sequenceDiagram\n-    participant Framework as 框架层\n-    participant Adapter as 适配器层\n-    participant UseCase as 用例层\n-    participant Entity as 实体层\n-    \n-    Note over Framework,Entity: 战斗开始流程\n-    \n-    Framework->>Adapter: Unity触发战斗开始\n-    Adapter->>UseCase: 输入适配器转换输入\n-    UseCase->>Entity: 执行战斗用例调用战斗实体\n-    Entity->>Entity: 战斗实体启动战斗循环\n-    \n-    Note over Entity: 战斗循环开始\n-    \n-    Entity->>UseCase: 战斗实体调用执行回合用例\n-    UseCase->>Entity: 执行回合用例调用回合实体\n-    Entity->>Entity: 回合实体启动回合循环\n-    \n-    Note over Entity: 回合循环开始\n-    \n-    Entity->>UseCase: 回合实体调用执行阵营用例\n-    UseCase->>Entity: 执行阵营用例调用阵营实体\n-    Entity->>Entity: 阵营实体启动阵营循环\n-    \n-    Note over Entity: 阵营循环开始\n-    \n-    Entity->>UseCase: 阵营实体调用执行单位用例\n-    UseCase->>Adapter: 执行单位用例调用输入适配器\n-    Adapter->>Framework: 输入适配器获取玩家输入/AI输入\n-    Framework->>Adapter: 返回输入数据\n-    Adapter->>UseCase: 转换输入数据\n-    \n-    UseCase->>Adapter: 执行单位用例调用行动适配器\n-    Adapter->>Framework: 行动适配器调用Lua脚本\n-    Framework->>Adapter: 返回行动结果\n-    Adapter->>UseCase: 转换行动结果\n-    \n-    UseCase->>Adapter: 执行单位用例调用视觉适配器\n-    Adapter->>Framework: 视觉适配器调用Unity引擎\n-    Framework->>Adapter: 播放动画/特效\n-    Adapter->>UseCase: 视觉播放完成\n-    \n-    UseCase->>Adapter: 执行单位用例调用数据适配器\n-    Adapter->>Framework: 数据适配器更新数据\n-    Framework->>Adapter: 数据更新完成\n-    Adapter->>UseCase: 数据更新结果\n-    \n-    UseCase->>Entity: 执行单位用例完成，更新单位实体\n-    Entity->>Entity: 单位循环继续/结束\n-    \n-    Note over Entity: 单位循环结束，返回上层循环\n-```\n-\n-### 数据流在Clean架构中的方向\n-\n-```mermaid\n-graph LR\n-    subgraph \"数据流向\"\n-        direction TB\n-        \n-        subgraph \"请求流（从外向内）\"\n-            FrameworkReq[框架层<br/>用户输入/系统事件]\n-            AdapterReq[适配器层<br/>数据转换]\n-            UseCaseReq[用例层<br/>用例输入]\n-            EntityReq[实体层<br/>实体操作]\n-            \n-            FrameworkReq --> AdapterReq\n-            AdapterReq --> UseCaseReq\n-            UseCaseReq --> EntityReq\n-        end\n-        \n-        subgraph \"响应流（从内向外）\"\n-            EntityResp[实体层<br/>业务结果]\n-            UseCaseResp[用例层<br/>用例输出]\n-            AdapterResp[适配器层<br/>数据转换]\n-            FrameworkResp[框架层<br/>UI更新/视觉表现]\n-            \n-            EntityResp --> UseCaseResp\n-            UseCaseResp --> AdapterResp\n-            AdapterResp --> FrameworkResp\n-        end\n-    end\n-    \n-    style FrameworkReq fill:#e1f5ff\n-    style EntityReq fill:#ffebee\n-    style EntityResp fill:#ffebee\n-    style FrameworkResp fill:#e1f5ff\n-```\n-\n-### 各层职责概览\n-\n-#### 1. 实体层（Entities）- 核心业务规则\n-\n-**位置**：最内层，核心业务规则\n-\n-**职责**：\n-- 定义战斗核心实体（战斗、回合、阵营、单位）\n-- 包含企业级业务规则\n-- 定义四层循环的实体模型\n-- 不依赖任何外部框架\n-\n-**核心实体**：\n-- **战斗实体（Battle Entity）**：管理整个战斗的生命周期，包含战斗循环\n-- **回合实体（Round Entity）**：管理回合的循环和切换，包含回合循环\n-- **阵营实体（Team Entity）**：管理阵营内单位的行动顺序，包含阵营循环\n-- **单位实体（Unit Entity）**：管理单个单位的行动流程，包含单位循环\n-- **技能实体（Skill Entity）**：定义技能规则和效果\n-- **效果实体（Effect Entity）**：定义效果规则和应用逻辑\n-\n-**特点**：\n-- 最稳定的一层\n-- 变化频率最低\n-- 包含核心业务概念\n-- 纯业务逻辑，无技术细节\n-\n-#### 2. 用例层（Use Cases）- 应用业务规则\n-\n-**位置**：第二层，应用业务规则\n-\n-**职责**：\n-- 实现具体的战斗用例\n-- 协调实体完成业务目标\n-- 定义应用输入输出接口\n-- 包含应用特定的业务逻辑\n-\n-**核心用例**：\n-- **执行战斗用例（ExecuteBattle）**：协调战斗实体执行战斗流程\n-- **执行回合用例（ExecuteRound）**：协调回合实体执行回合流程\n-- **执行阵营用例（ExecuteTeam）**：协调阵营实体执行阵营流程\n-- **执行单位用例（ExecuteUnit）**：协调单位实体执行单位行动\n-- **计算伤害用例（CalculateDamage）**：计算技能伤害\n-- **应用效果用例（ApplyEffect）**：应用技能效果\n-\n-**特点**：\n-- 依赖实体层\n-- 不依赖框架和UI\n-- 包含应用特定的业务逻辑\n-- 可以独立测试\n-\n-#### 3. 接口适配器层（Interface Adapters）- 功能服务\n-\n-**位置**：第三层，转换层\n-\n-**职责**：\n-- 转换数据格式\n-- 适配外部接口\n-- 实现接口定义\n-- 连接用例和框架\n-\n-**核心适配器**：\n-- **输入适配器（Input Adapter）**：处理玩家输入和AI输入，转换为用例输入\n-- **行动适配器（Action Adapter）**：执行行动逻辑，调用用例\n-- **视觉适配器（Visual Adapter）**：处理视觉表现，调用用例输出\n-- **数据适配器（Data Adapter）**：处理数据访问，调用用例\n-- **通信适配器（Communication Adapter）**：处理系统间通信，调用用例\n-\n-**特点**：\n-- 依赖用例层\n-- 实现框架层定义的接口\n-- 转换数据格式\n-- 适配外部服务\n-\n-#### 4. 框架层（Frameworks & Drivers）- 技术实现\n-\n-**位置**：最外层，技术实现\n-\n-**职责**：\n-- 实现具体的技术细节\n-- 提供框架和工具\n-- 处理外部系统交互\n-- 实现接口适配器定义的接口\n-\n-**核心框架**：\n-- **Unity引擎**：游戏引擎，提供渲染、物理等功能\n-- **Lua脚本引擎**：脚本语言，实现业务逻辑\n-- **数据库**：数据持久化\n-- **状态机框架（FSM）**：状态管理\n-- **通信总线（CommunicationBus）**：系统间通信\n-- **数据队列（DataHandleQueue）**：数据处理\n-\n-**特点**：\n-- 最外层，技术实现\n-- 可以被替换\n-- 不影响业务逻辑\n-- 提供基础设施\n-\n----\n-\n ## 实体层详细设计（Entities Layer）\n \n ### 四层循环实体模型\n \n"
                },
                {
                    "date": 1767099086239,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,37 +5,8 @@\n 设计一套完整的回合制战斗系统架构，支持DND规则、回合管理、状态机控制、AI决策，实现战斗流程管理、伤害计算、效果应用，提供数据驱动的配置化战斗系统。\n \n ---\n \n-## 核心设计理念\n-\n-### 1. 多层循环架构为核心\n-\n-**本质**：战斗系统的核心是四层循环的维护和管理\n-- **战斗循环**：管理整个战斗的生命周期\n-- **回合循环**：管理回合的循环和切换\n-- **阵营循环**：管理阵营内单位的行动顺序\n-- **单位循环**：管理单个单位的行动流程\n-- **循环驱动**：所有战斗逻辑都在循环框架内执行\n-- **状态维护**：每层循环维护自己的状态，驱动下层循环\n-\n-### 2. 数据驱动架构\n-\n-**本质**：战斗特性通过配置数据实现，无需修改代码\n-- 战斗规则、伤害计算、效果应用 → 通过配置数据定义\n-- 回合流程、状态转换 → 通过配置数据调整\n-- 新增战斗机制 → 扩展配置数据即可\n-- 战斗平衡 → 调整配置数值即可\n-\n-### 3. 分层架构（循环内的功能组织）\n-\n-**本质**：分层架构是循环内的功能组织方式，不是主要架构\n-- 功能组织：输入层、决策层、执行层、表现层、管理层\n-- 执行位置：所有分层功能都在单位循环内执行\n-- 解耦设计：层间通过Context和CommunicationBus通信\n-\n----\n-\n ## 整体架构设计\n \n ### Clean架构模式（主要架构）\n \n"
                },
                {
                    "date": 1767100609196,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,14 +27,14 @@\n         Pool[对象池<br/>Object Pool]\n         Config[配置数据<br/>Excel/JSON/Lua]\n     end\n     \n-    subgraph \"接口适配器层（Interface Adapters）- 功能服务\"\n-        InputAdapter[输入适配器<br/>Input Adapter<br/>玩家输入/AI输入]\n-        ActionAdapter[行动适配器<br/>Action Adapter<br/>行动执行/伤害计算]\n-        VisualAdapter[视觉适配器<br/>Visual Adapter<br/>动画/特效/UI]\n-        DataAdapter[数据适配器<br/>Data Adapter<br/>数据访问/配置读取]\n-        CommunicationAdapter[通信适配器<br/>Communication Adapter<br/>事件/消息/查询]\n+    subgraph \"服务层（Services）- 功能服务\"\n+        InputService[输入服务<br/>Input Service<br/>玩家输入/AI输入]\n+        ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n+        VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n+        DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n+        CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n         ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n@@ -53,23 +53,23 @@\n         SkillEntity[技能实体<br/>Skill Entity]\n         EffectEntity[效果实体<br/>Effect Entity]\n     end\n     \n-    Unity --> VisualAdapter\n-    Lua --> ActionAdapter\n-    Database --> DataAdapter\n+    Unity --> VisualService\n+    Lua --> ActionService\n+    Database --> DataService\n     FSM --> ExecuteBattleUC\n-    CommunicationBus --> CommunicationAdapter\n-    DataHandleQueue --> DataAdapter\n-    Formula --> ActionAdapter\n-    Pool --> VisualAdapter\n-    Config --> DataAdapter\n+    CommunicationBus --> CommunicationService\n+    DataHandleQueue --> DataService\n+    Formula --> ActionService\n+    Pool --> VisualService\n+    Config --> DataService\n     \n-    InputAdapter --> ExecuteUnitUC\n-    ActionAdapter --> ExecuteUnitUC\n-    VisualAdapter --> ExecuteUnitUC\n-    DataAdapter --> ExecuteUnitUC\n-    CommunicationAdapter --> ExecuteUnitUC\n+    InputService --> ExecuteUnitUC\n+    ActionService --> ExecuteUnitUC\n+    VisualService --> ExecuteUnitUC\n+    DataService --> ExecuteUnitUC\n+    CommunicationService --> ExecuteUnitUC\n     \n     ExecuteBattleUC --> BattleEntity\n     ExecuteRoundUC --> RoundEntity\n     ExecuteTeamUC --> TeamEntity\n@@ -82,13 +82,241 @@\n     TeamEntity --> UnitEntity\n     \n     style BattleEntity fill:#ffebee\n     style ExecuteBattleUC fill:#fff4e1\n-    style InputAdapter fill:#e8f5e9\n+    style InputService fill:#e8f5e9\n     style Unity fill:#e1f5ff\n ```\n \n+### Clean架构层次结构\n \n+```mermaid\n+graph TB\n+    subgraph \"Clean架构同心圆\"\n+        direction TB\n+        Entities[实体层<br/>Entities<br/>核心业务规则<br/>最内层]\n+        UseCases[用例层<br/>Use Cases<br/>应用业务规则]\n+        Services[服务层<br/>Services<br/>功能服务]\n+        Frameworks[框架层<br/>Frameworks & Drivers<br/>技术实现<br/>最外层]\n+        \n+        Frameworks -.依赖.-> Services\n+        Services -.依赖.-> UseCases\n+        UseCases -.依赖.-> Entities\n+    end\n+    \n+    style Entities fill:#ffebee\n+    style UseCases fill:#fff4e1\n+    style Services fill:#e8f5e9\n+    style Frameworks fill:#e1f5ff\n+```\n+\n+**依赖规则**：\n+- ✅ **允许**：外层依赖内层\n+- ❌ **禁止**：内层依赖外层\n+- ✅ **允许**：通过接口定义依赖\n+- ❌ **禁止**：直接依赖具体实现\n+\n+### 战斗流程在Clean架构中的执行\n+\n+```mermaid\n+sequenceDiagram\n+    participant Framework as 框架层\n+    participant Service as 服务层\n+    participant UseCase as 用例层\n+    participant Entity as 实体层\n+    \n+    Note over Framework,Entity: 战斗开始流程\n+    \n+    Framework->>Service: Unity触发战斗开始\n+    Service->>UseCase: 输入服务转换输入\n+    UseCase->>Entity: 执行战斗用例调用战斗实体\n+    Entity->>Entity: 战斗实体启动战斗循环\n+    \n+    Note over Entity: 战斗循环开始\n+    \n+    Entity->>UseCase: 战斗实体调用执行回合用例\n+    UseCase->>Entity: 执行回合用例调用回合实体\n+    Entity->>Entity: 回合实体启动回合循环\n+    \n+    Note over Entity: 回合循环开始\n+    \n+    Entity->>UseCase: 回合实体调用执行阵营用例\n+    UseCase->>Entity: 执行阵营用例调用阵营实体\n+    Entity->>Entity: 阵营实体启动阵营循环\n+    \n+    Note over Entity: 阵营循环开始\n+    \n+    Entity->>UseCase: 阵营实体调用执行单位用例\n+    UseCase->>Service: 执行单位用例调用输入服务\n+    Service->>Framework: 输入服务获取玩家输入/AI输入\n+    Framework->>Service: 返回输入数据\n+    Service->>UseCase: 转换输入数据\n+    \n+    UseCase->>Service: 执行单位用例调用行动服务\n+    Service->>Framework: 行动服务调用Lua脚本\n+    Framework->>Service: 返回行动结果\n+    Service->>UseCase: 转换行动结果\n+    \n+    UseCase->>Service: 执行单位用例调用视觉服务\n+    Service->>Framework: 视觉服务调用Unity引擎\n+    Framework->>Service: 播放动画/特效\n+    Service->>UseCase: 视觉播放完成\n+    \n+    UseCase->>Service: 执行单位用例调用数据服务\n+    Service->>Framework: 数据服务更新数据\n+    Framework->>Service: 数据更新完成\n+    Service->>UseCase: 数据更新结果\n+    \n+    UseCase->>Entity: 执行单位用例完成，更新单位实体\n+    Entity->>Entity: 单位循环继续/结束\n+    \n+    Note over Entity: 单位循环结束，返回上层循环\n+```\n+\n+### 数据流在Clean架构中的方向\n+\n+```mermaid\n+graph LR\n+    subgraph \"数据流向\"\n+        direction TB\n+        \n+        subgraph \"请求流（从外向内）\"\n+            FrameworkReq[框架层<br/>用户输入/系统事件]\n+            ServiceReq[服务层<br/>数据转换]\n+            UseCaseReq[用例层<br/>用例输入]\n+            EntityReq[实体层<br/>实体操作]\n+            \n+            FrameworkReq --> ServiceReq\n+            ServiceReq --> UseCaseReq\n+            UseCaseReq --> EntityReq\n+        end\n+        \n+        subgraph \"响应流（从内向外）\"\n+            EntityResp[实体层<br/>业务结果]\n+            UseCaseResp[用例层<br/>用例输出]\n+            ServiceResp[服务层<br/>数据转换]\n+            FrameworkResp[框架层<br/>UI更新/视觉表现]\n+            \n+            EntityResp --> UseCaseResp\n+            UseCaseResp --> ServiceResp\n+            ServiceResp --> FrameworkResp\n+        end\n+    end\n+    \n+    style FrameworkReq fill:#e1f5ff\n+    style EntityReq fill:#ffebee\n+    style EntityResp fill:#ffebee\n+    style FrameworkResp fill:#e1f5ff\n+```\n+\n+### 各层职责概览\n+\n+#### 1. 实体层（Entities）- 核心业务规则\n+\n+**位置**：最内层，核心业务规则\n+\n+**职责**：\n+- 定义战斗核心实体（战斗、回合、阵营、单位）\n+- 包含企业级业务规则\n+- 定义四层循环的实体模型\n+- 不依赖任何外部框架\n+\n+**核心实体**：\n+- **战斗实体（Battle Entity）**：管理整个战斗的生命周期，包含战斗循环\n+- **回合实体（Round Entity）**：管理回合的循环和切换，包含回合循环\n+- **阵营实体（Team Entity）**：管理阵营内单位的行动顺序，包含阵营循环\n+- **单位实体（Unit Entity）**：管理单个单位的行动流程，包含单位循环\n+- **技能实体（Skill Entity）**：定义技能规则和效果\n+- **效果实体（Effect Entity）**：定义效果规则和应用逻辑\n+\n+**特点**：\n+- 最稳定的一层\n+- 变化频率最低\n+- 包含核心业务概念\n+- 纯业务逻辑，无技术细节\n+\n+#### 2. 用例层（Use Cases）- 应用业务规则\n+\n+**位置**：第二层，应用业务规则\n+\n+**职责**：\n+- 实现具体的战斗用例\n+- 协调实体完成业务目标\n+- 定义应用输入输出接口\n+- 包含应用特定的业务逻辑\n+\n+**核心用例**：\n+- **执行战斗用例（ExecuteBattle）**：协调战斗实体执行战斗流程\n+- **执行回合用例（ExecuteRound）**：协调回合实体执行回合流程\n+- **执行阵营用例（ExecuteTeam）**：协调阵营实体执行阵营流程\n+- **执行单位用例（ExecuteUnit）**：协调单位实体执行单位行动\n+- **计算伤害用例（CalculateDamage）**：计算技能伤害\n+- **应用效果用例（ApplyEffect）**：应用技能效果\n+\n+**特点**：\n+- 依赖实体层\n+- 不依赖框架和UI\n+- 包含应用特定的业务逻辑\n+- 可以独立测试\n+\n+#### 3. 服务层（Services）- 功能服务\n+\n+**位置**：第三层，功能服务层\n+\n+**职责**：\n+- 提供功能服务\n+- 转换数据格式\n+- 适配外部接口\n+- 连接用例和框架\n+\n+**核心服务**：\n+- **输入服务（Input Service）**：处理玩家输入和AI输入，转换为用例输入\n+- **行动服务（Action Service）**：执行行动逻辑，调用用例\n+- **视觉服务（Visual Service）**：处理视觉表现，调用用例输出\n+- **数据服务（Data Service）**：处理数据访问，调用用例\n+- **通信服务（Communication Service）**：处理系统间通信，调用用例\n+\n+**服务间交互**：\n+- 输入服务 → 行动服务（输入驱动行动）\n+- 行动服务 → 视觉服务（行动触发视觉）\n+- 行动服务 → 数据服务（行动更新数据）\n+- 数据服务 → 通信服务（数据触发通信）\n+- 通信服务 → 视觉服务（通信触发视觉）\n+\n+**特点**：\n+- 依赖用例层\n+- 实现框架层定义的接口\n+- 转换数据格式\n+- 提供功能服务\n+\n+#### 4. 框架层（Frameworks & Drivers）- 技术实现\n+\n+**位置**：最外层，技术实现\n+\n+**职责**：\n+- 实现具体的技术细节\n+- 提供框架和工具\n+- 处理外部系统交互\n+- 实现服务层定义的接口\n+\n+**核心框架**：\n+- **Unity引擎**：游戏引擎，提供渲染、物理等功能\n+- **Lua脚本引擎**：脚本语言，实现业务逻辑\n+- **数据库**：数据持久化\n+- **状态机框架（FSM）**：状态管理\n+- **通信总线（CommunicationBus）**：系统间通信\n+- **数据队列（DataHandleQueue）**：数据处理\n+- **公式引擎（Formula Parser）**：公式计算\n+- **对象池（Object Pool）**：对象管理\n+- **配置数据**：Excel/JSON/Lua配置\n+\n+**特点**：\n+- 最外层，技术实现\n+- 可以被替换\n+- 不影响业务逻辑\n+- 提供基础设施\n+\n+\n ## 实体层详细设计（Entities Layer）\n \n ### 四层循环实体模型\n \n@@ -356,24 +584,24 @@\n - **输入**：效果信息、目标\n - **输出**：效果应用结果\n - **协调实体**：效果实体、单位实体\n \n-## 接口适配器层详细设计（Interface Adapters Layer）\n+## 服务层详细设计（Services Layer）\n \n-### 功能适配器\n+### 功能服务\n \n-**说明**：接口适配器层将用例层的输出转换为框架层可以使用的格式，同时将框架层的输入转换为用例层可以使用的格式。\n+**说明**：服务层提供功能服务，将用例层的输出转换为框架层可以使用的格式，同时将框架层的输入转换为用例层可以使用的格式。\n \n-#### 适配器层次结构\n+#### 服务层次结构\n \n ```mermaid\n graph TB\n-    subgraph \"接口适配器层 - 功能适配器\"\n-        InputAdapter[输入适配器<br/>Input Adapter]\n-        ActionAdapter[行动适配器<br/>Action Adapter]\n-        VisualAdapter[视觉适配器<br/>Visual Adapter]\n-        DataAdapter[数据适配器<br/>Data Adapter]\n-        CommunicationAdapter[通信适配器<br/>Communication Adapter]\n+    subgraph \"服务层 - 功能服务\"\n+        InputService[输入服务<br/>Input Service]\n+        ActionService[行动服务<br/>Action Service]\n+        VisualService[视觉服务<br/>Visual Service]\n+        DataService[数据服务<br/>Data Service]\n+        CommunicationService[通信服务<br/>Communication Service]\n     end\n     \n     subgraph \"用例层 - 用例\"\n         ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n@@ -385,105 +613,132 @@\n         Database[(数据库)]\n         CommunicationBus[通信总线]\n     end\n     \n-    InputAdapter --> ExecuteUnitUC\n-    ActionAdapter --> ExecuteUnitUC\n-    VisualAdapter --> ExecuteUnitUC\n-    DataAdapter --> ExecuteUnitUC\n-    CommunicationAdapter --> ExecuteUnitUC\n+    InputService --> ExecuteUnitUC\n+    ActionService --> ExecuteUnitUC\n+    VisualService --> ExecuteUnitUC\n+    DataService --> ExecuteUnitUC\n+    CommunicationService --> ExecuteUnitUC\n     \n-    Unity --> VisualAdapter\n-    Lua --> ActionAdapter\n-    Database --> DataAdapter\n-    CommunicationBus --> CommunicationAdapter\n+    Unity --> VisualService\n+    Lua --> ActionService\n+    Database --> DataService\n+    CommunicationBus --> CommunicationService\n     \n-    style InputAdapter fill:#e8f5e9\n+    style InputService fill:#e8f5e9\n     style ExecuteUnitUC fill:#fff4e1\n     style Unity fill:#e1f5ff\n ```\n \n-#### 适配器职责说明\n+#### 服务职责说明\n \n-##### 1. 输入适配器（Input Adapter）\n+##### 1. 输入服务（Input Service）\n - **职责**：处理玩家输入和AI输入，转换为用例输入\n - **功能**：\n   - 接收玩家输入（UI交互、键盘鼠标）\n   - 接收AI输入（AI决策结果）\n   - 验证输入有效性\n   - 转换为用例输入格式（BattleContext）\n - **框架依赖**：Unity Input Manager、AI系统\n \n-##### 2. 行动适配器（Action Adapter）\n+##### 2. 行动服务（Action Service）\n - **职责**：执行行动逻辑，调用用例\n - **功能**：\n   - 验证行动合法性\n   - 执行行动逻辑\n   - 调用执行单位用例\n   - 处理行动结果\n - **框架依赖**：Lua脚本引擎、技能系统\n \n-##### 3. 视觉适配器（Visual Adapter）\n+##### 3. 视觉服务（Visual Service）\n - **职责**：处理视觉表现，调用用例输出\n - **功能**：\n   - 播放战斗动画\n   - 播放特效\n   - 更新UI显示\n   - 处理相机控制\n - **框架依赖**：Unity引擎、Visual系统\n \n-##### 4. 数据适配器（Data Adapter）\n+##### 4. 数据服务（Data Service）\n - **职责**：处理数据访问，调用用例\n - **功能**：\n   - 读取战斗配置\n   - 保存战斗数据\n   - 查询单位数据\n   - 更新战斗状态\n - **框架依赖**：数据库、DataHandleQueue\n \n-##### 5. 通信适配器（Communication Adapter）\n+##### 5. 通信服务（Communication Service）\n - **职责**：处理系统间通信，调用用例\n - **功能**：\n   - 发布战斗事件\n   - 订阅系统消息\n   - 处理跨系统通信\n   - 管理通信上下文\n - **框架依赖**：CommunicationBus\n \n+### 服务间交互关系\n+\n+**说明**：服务层内的服务可以相互交互，形成完整的功能流程。\n+\n+```mermaid\n+graph LR\n+    subgraph \"服务层 - 服务交互\"\n+        InputService[输入服务<br/>Input Service]\n+        ActionService[行动服务<br/>Action Service]\n+        VisualService[视觉服务<br/>Visual Service]\n+        DataService[数据服务<br/>Data Service]\n+        CommunicationService[通信服务<br/>Communication Service]\n+        \n+        InputService -->|输入驱动| ActionService\n+        ActionService -->|行动触发| VisualService\n+        ActionService -->|行动更新| DataService\n+        DataService -->|数据触发| CommunicationService\n+        CommunicationService -->|通信触发| VisualService\n+    end\n+    \n+    style InputService fill:#fff4e1\n+    style ActionService fill:#e8f5e9\n+    style VisualService fill:#e1f5ff\n+    style DataService fill:#ffebee\n+    style CommunicationService fill:#c8e6c9\n+```\n+\n ### 单位循环内的功能流程\n \n-**说明**：单位循环内的功能流程通过接口适配器层实现。\n+**说明**：单位循环内的功能流程通过服务层实现。\n \n ```mermaid\n graph TB\n     subgraph \"单位循环 - 用例层\"\n         ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n     end\n     \n-    subgraph \"接口适配器层 - 功能流程\"\n-        InputAdapter[输入适配器<br/>接收输入]\n-        ActionAdapter[行动适配器<br/>执行行动]\n-        VisualAdapter[视觉适配器<br/>播放表现]\n-        DataAdapter[数据适配器<br/>更新数据]\n+    subgraph \"服务层 - 功能流程\"\n+        InputService[输入服务<br/>接收输入]\n+        ActionService[行动服务<br/>执行行动]\n+        VisualService[视觉服务<br/>播放表现]\n+        DataService[数据服务<br/>更新数据]\n     end\n     \n     subgraph \"框架层 - 技术实现\"\n         Unity[Unity引擎]\n         Lua[Lua脚本]\n         Database[(数据库)]\n     end\n     \n-    InputAdapter --> ExecuteUnitUC\n-    ExecuteUnitUC --> ActionAdapter\n-    ActionAdapter --> VisualAdapter\n-    VisualAdapter --> DataAdapter\n+    InputService --> ExecuteUnitUC\n+    ExecuteUnitUC --> ActionService\n+    ActionService --> VisualService\n+    VisualService --> DataService\n     \n-    Unity --> VisualAdapter\n-    Lua --> ActionAdapter\n-    Database --> DataAdapter\n+    Unity --> VisualService\n+    Lua --> ActionService\n+    Database --> DataService\n     \n     style ExecuteUnitUC fill:#fff4e1\n-    style InputAdapter fill:#e8f5e9\n+    style InputService fill:#e8f5e9\n     style Unity fill:#e1f5ff\n ```\n \n ## 框架层详细设计（Frameworks & Drivers Layer）\n@@ -506,26 +761,26 @@\n         Formula[公式引擎<br/>Formula Parser<br/>公式计算]\n         Pool[对象池<br/>Object Pool<br/>对象管理]\n     end\n     \n-    subgraph \"接口适配器层 - 适配器\"\n-        VisualAdapter[视觉适配器]\n-        ActionAdapter[行动适配器]\n-        DataAdapter[数据适配器]\n-        CommunicationAdapter[通信适配器]\n+    subgraph \"服务层 - 服务\"\n+        VisualService[视觉服务]\n+        ActionService[行动服务]\n+        DataService[数据服务]\n+        CommunicationService[通信服务]\n     end\n     \n-    Unity --> VisualAdapter\n-    Lua --> ActionAdapter\n-    Database --> DataAdapter\n-    FSM --> VisualAdapter\n-    CommunicationBus --> CommunicationAdapter\n-    DataHandleQueue --> DataAdapter\n-    Formula --> ActionAdapter\n-    Pool --> VisualAdapter\n+    Unity --> VisualService\n+    Lua --> ActionService\n+    Database --> DataService\n+    FSM --> VisualService\n+    CommunicationBus --> CommunicationService\n+    DataHandleQueue --> DataService\n+    Formula --> ActionService\n+    Pool --> VisualService\n     \n     style Unity fill:#e1f5ff\n-    style VisualAdapter fill:#e8f5e9\n+    style VisualService fill:#e8f5e9\n ```\n \n #### 框架职责说明\n \n@@ -639,12 +894,12 @@\n - **位置**：框架层\n - **形式**：Excel配置表、JSON配置文件、Lua配置脚本\n - **内容**：战斗规则、伤害计算、效果应用、回合流程、状态转换\n \n-#### 2. 配置数据读取（接口适配器层）\n-- **位置**：接口适配器层（数据适配器）\n+#### 2. 配置数据读取（服务层）\n+- **位置**：服务层（数据服务）\n - **功能**：读取配置数据，转换为用例可用的格式\n-- **组件**：DataAdapter、ConfigLoader\n+- **组件**：DataService、ConfigLoader\n \n #### 3. 配置数据应用（用例层）\n - **位置**：用例层\n - **功能**：使用配置数据驱动业务逻辑\n@@ -671,17 +926,17 @@\n     \n     subgraph \"Clean架构层次\"\n         Entities[实体层<br/>四层循环实体]\n         UseCases[用例层<br/>循环用例]\n-        Adapters[适配器层<br/>功能适配器]\n+        Services[服务层<br/>功能服务]\n         Frameworks[框架层<br/>配置数据]\n     end\n     \n     Loop --> Entities\n     Loop --> UseCases\n     DataDriven --> Frameworks\n-    DataDriven --> Adapters\n-    Layered --> Adapters\n+        DataDriven --> Services\n+        Layered --> Services\n     \n     style Loop fill:#ffebee\n     style Entities fill:#ffebee\n ```\n@@ -699,28 +954,28 @@\n - 实现循环的执行用例（执行战斗、执行回合、执行单位）\n - 协调实体完成循环流程\n - 管理循环的生命周期\n \n-#### 2. 数据驱动架构 → 框架层 + 接口适配器层\n+#### 2. 数据驱动架构 → 框架层 + 服务层\n \n **框架层**：\n - 存储配置数据（Excel、JSON、Lua）\n - 提供配置数据访问接口\n - 管理配置数据的加载和更新\n \n-**接口适配器层**：\n-- 读取配置数据（数据适配器）\n+**服务层**：\n+- 读取配置数据（数据服务）\n - 将配置数据转换为用例可用的格式\n - 应用配置数据驱动业务逻辑\n \n-#### 3. 分层架构（功能组织）→ 接口适配器层\n+#### 3. 分层架构（功能组织）→ 服务层\n \n-**接口适配器层**：\n-- 输入适配器：处理输入功能\n-- 行动适配器：处理执行功能\n-- 视觉适配器：处理表现功能\n-- 数据适配器：处理数据功能\n-- 通信适配器：处理通信功能\n+**服务层**：\n+- 输入服务：处理输入功能\n+- 行动服务：处理执行功能\n+- 视觉服务：处理表现功能\n+- 数据服务：处理数据功能\n+- 通信服务：处理通信功能\n \n ---\n \n ## Clean架构的优势\n@@ -765,9 +1020,9 @@\n - **优势**：提高测试覆盖率，保证代码质量\n \n #### 3. 技术无关性\n - **框架层**：Unity、Lua、数据库等技术可以被替换\n-- **接口适配器层**：通过适配器隔离技术细节\n+- **服务层**：通过服务隔离技术细节\n - **优势**：可以轻松替换技术栈，不影响业务逻辑\n \n #### 4. 可维护性\n - **依赖方向清晰**：从外向内，易于理解\n@@ -775,9 +1030,9 @@\n - **优势**：代码组织清晰，易于理解和修改\n \n #### 5. 可扩展性\n - **新增用例**：只需在用例层添加新用例，不影响现有代码\n-- **新增适配器**：只需在适配器层添加新适配器，不影响用例\n+- **新增服务**：只需在服务层添加新服务，不影响用例\n - **优势**：易于扩展新功能，不影响现有系统\n \n ---\n \n@@ -788,9 +1043,9 @@\n ```mermaid\n graph TD\n     Start[开始实施] --> Step1[1. 设计实体层<br/>定义四层循环实体]\n     Step1 --> Step2[2. 设计用例层<br/>定义战斗用例]\n-    Step2 --> Step3[3. 设计适配器层<br/>定义功能适配器]\n+    Step2 --> Step3[3. 设计服务层<br/>定义功能服务]\n     Step3 --> Step4[4. 集成框架层<br/>集成Unity/Lua等]\n     Step4 --> Step5[5. 实现数据驱动<br/>配置数据读取和应用]\n     Step5 --> End[完成]\n     \n@@ -806,13 +1061,13 @@\n 1. **实体层**：定义战斗、回合、阵营、单位实体\n 2. **用例层**：实现执行战斗、执行回合、执行单位用例\n 3. **框架层**：集成状态机框架，实现层次状态机\n \n-#### 第二阶段：功能适配器\n-1. **输入适配器**：实现玩家输入和AI输入处理\n-2. **行动适配器**：实现行动执行逻辑\n-3. **视觉适配器**：实现视觉表现处理\n-4. **数据适配器**：实现数据访问和配置读取\n+#### 第二阶段：功能服务\n+1. **输入服务**：实现玩家输入和AI输入处理\n+2. **行动服务**：实现行动执行逻辑\n+3. **视觉服务**：实现视觉表现处理\n+4. **数据服务**：实现数据访问和配置读取\n \n #### 第三阶段：框架集成\n 1. **Unity集成**：集成Unity引擎，实现视觉表现\n 2. **Lua集成**：集成Lua脚本，实现业务逻辑\n@@ -830,20 +1085,20 @@\n - 🎯 **业务逻辑独立**：四层循环的业务规则完全独立于框架和技术\n - 🧪 **高度可测试**：实体和用例可以独立测试，无需Unity/Lua\n - 🔄 **技术无关**：可以轻松替换Unity、Lua、数据库等技术栈\n - 📐 **依赖清晰**：依赖方向从外向内，易于理解和维护\n-- 📈 **易于扩展**：新增功能只需添加用例或适配器，不影响现有代码\n+- 📈 **易于扩展**：新增功能只需添加用例或服务，不影响现有代码\n \n ### 架构映射\n \n - **实体层** = 四层循环实体（战斗、回合、阵营、单位）\n - **用例层** = 战斗用例（执行战斗、执行回合、执行单位）\n-- **接口适配器层** = 功能服务（输入、执行、表现、数据、通信）\n+- **服务层** = 功能服务（输入、执行、表现、数据、通信）\n - **框架层** = 技术实现（Unity、Lua、数据库、FSM、CommunicationBus、DataHandleQueue）\n \n ### 设计理念对应\n \n - **多层循环架构** → 实体层 + 用例层\n-- **数据驱动架构** → 框架层 + 接口适配器层\n-- **分层架构（功能组织）** → 接口适配器层\n+- **数据驱动架构** → 框架层 + 服务层\n+- **分层架构（功能组织）** → 服务层\n \n Clean架构是构建可维护、可测试、可扩展战斗系统的优秀选择，特别适合需要长期维护和持续演进的战斗系统。\n"
                },
                {
                    "date": 1767100803991,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -867,18 +867,18 @@\n         subgraph \"用例层\"\n             UseCase[用例<br/>应用逻辑<br/>配置数据驱动流程]\n         end\n         \n-        subgraph \"接口适配器层\"\n-            Adapter[适配器<br/>数据转换<br/>配置数据映射]\n+        subgraph \"服务层\"\n+            Service[服务<br/>数据转换<br/>配置数据映射]\n         end\n         \n         subgraph \"框架层\"\n             Config[配置数据<br/>Excel/JSON/Lua<br/>数据驱动源]\n         end\n         \n-        Config -.驱动.-> Adapter\n-        Adapter -.使用.-> UseCase\n+        Config -.驱动.-> Service\n+        Service -.使用.-> UseCase\n         UseCase -.应用.-> Entity\n         Config -.定义.-> Entity\n     end\n     \n@@ -1002,9 +1002,9 @@\n       职责分离明确\n       易于理解\n     可扩展性\n       新增用例\n-      新增适配器\n+      新增服务\n       不影响现有代码\n ```\n \n ### 具体优势说明\n"
                },
                {
                    "date": 1767100820227,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -883,9 +883,9 @@\n     end\n     \n     style Entity fill:#ffebee\n     style UseCase fill:#fff4e1\n-    style Adapter fill:#e8f5e9\n+    style Service fill:#e8f5e9\n     style Config fill:#e1f5ff\n ```\n \n ### 数据驱动的实现方式\n"
                },
                {
                    "date": 1767101028032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -740,365 +740,4 @@\n     style InputService fill:#e8f5e9\n     style Unity fill:#e1f5ff\n ```\n \n-## 框架层详细设计（Frameworks & Drivers Layer）\n-\n-### 技术框架\n-\n-**说明**：框架层提供具体的技术实现，可以被替换而不影响业务逻辑。\n-\n-#### 框架层次结构\n-\n-```mermaid\n-graph TB\n-    subgraph \"框架层 - 技术框架\"\n-        Unity[Unity引擎<br/>Unity Engine<br/>渲染、物理、动画]\n-        Lua[Lua脚本引擎<br/>Lua Script Engine<br/>业务逻辑]\n-        Database[(数据库<br/>Database<br/>数据持久化)]\n-        FSM[状态机框架<br/>FSM Framework<br/>状态管理]\n-        CommunicationBus[通信总线<br/>CommunicationBus<br/>系统通信]\n-        DataHandleQueue[数据队列<br/>DataHandleQueue<br/>数据处理]\n-        Formula[公式引擎<br/>Formula Parser<br/>公式计算]\n-        Pool[对象池<br/>Object Pool<br/>对象管理]\n-    end\n-    \n-    subgraph \"服务层 - 服务\"\n-        VisualService[视觉服务]\n-        ActionService[行动服务]\n-        DataService[数据服务]\n-        CommunicationService[通信服务]\n-    end\n-    \n-    Unity --> VisualService\n-    Lua --> ActionService\n-    Database --> DataService\n-    FSM --> VisualService\n-    CommunicationBus --> CommunicationService\n-    DataHandleQueue --> DataService\n-    Formula --> ActionService\n-    Pool --> VisualService\n-    \n-    style Unity fill:#e1f5ff\n-    style VisualService fill:#e8f5e9\n-```\n-\n-#### 框架职责说明\n-\n-##### 1. Unity引擎（Unity Engine）\n-- **职责**：提供游戏引擎功能\n-- **功能**：\n-  - 渲染系统（3D渲染、UI渲染）\n-  - 物理系统（碰撞检测、物理模拟）\n-  - 动画系统（动画播放、动画控制）\n-  - 音频系统（音效播放、背景音乐）\n-  - 资源管理（资源加载、资源释放）\n-\n-##### 2. Lua脚本引擎（Lua Script Engine）\n-- **职责**：执行业务逻辑脚本\n-- **功能**：\n-  - 脚本解析和执行\n-  - 业务逻辑实现\n-  - 配置数据读取\n-  - 热更新支持\n-\n-##### 3. 数据库（Database）\n-- **职责**：数据持久化\n-- **功能**：\n-  - 战斗配置存储\n-  - 战斗数据保存\n-  - 单位数据查询\n-  - 历史记录存储\n-\n-##### 4. 状态机框架（FSM Framework）\n-- **职责**：状态管理\n-- **功能**：\n-  - 层次状态机（HierarchicalFSM）\n-  - 基础状态机（FSMBase）\n-  - 状态转换管理\n-  - 状态生命周期管理\n-\n-##### 5. 通信总线（CommunicationBus）\n-- **职责**：系统间通信\n-- **功能**：\n-  - 事件发布订阅（Event Channel）\n-  - 消息传递（Message Channel）\n-  - 数据推送（Push Channel）\n-  - 数据查询（Query Channel）\n-\n-##### 6. 数据队列（DataHandleQueue）\n-- **职责**：数据处理\n-- **功能**：\n-  - 数据推送和处理\n-- **数据查询**（Query Delegate）\n-- **批量处理**\n-- **数据同步**\n-\n-##### 7. 公式引擎（Formula Parser）\n-- **职责**：公式计算\n-- **功能**：\n-  - 三级公式解析\n-  - 公式计算\n-  - 公式缓存\n-  - 公式验证\n-\n-##### 8. 对象池（Object Pool）\n-- **职责**：对象管理\n-- **功能**：\n-  - 对象复用\n-  - 对象预加载\n-  - 对象生命周期管理\n-  - 性能优化\n-\n----\n-\n-## 数据驱动架构在Clean架构中的位置\n-\n-### 数据驱动架构的层次分布\n-\n-**说明**：数据驱动架构贯穿Clean架构的所有层次，但主要作用在不同层次。\n-\n-```mermaid\n-graph TB\n-    subgraph \"Clean架构 + 数据驱动\"\n-        subgraph \"实体层\"\n-            Entity[实体<br/>业务规则<br/>配置数据定义规则]\n-        end\n-        \n-        subgraph \"用例层\"\n-            UseCase[用例<br/>应用逻辑<br/>配置数据驱动流程]\n-        end\n-        \n-        subgraph \"服务层\"\n-            Service[服务<br/>数据转换<br/>配置数据映射]\n-        end\n-        \n-        subgraph \"框架层\"\n-            Config[配置数据<br/>Excel/JSON/Lua<br/>数据驱动源]\n-        end\n-        \n-        Config -.驱动.-> Service\n-        Service -.使用.-> UseCase\n-        UseCase -.应用.-> Entity\n-        Config -.定义.-> Entity\n-    end\n-    \n-    style Entity fill:#ffebee\n-    style UseCase fill:#fff4e1\n-    style Service fill:#e8f5e9\n-    style Config fill:#e1f5ff\n-```\n-\n-### 数据驱动的实现方式\n-\n-#### 1. 配置数据存储（框架层）\n-- **位置**：框架层\n-- **形式**：Excel配置表、JSON配置文件、Lua配置脚本\n-- **内容**：战斗规则、伤害计算、效果应用、回合流程、状态转换\n-\n-#### 2. 配置数据读取（服务层）\n-- **位置**：服务层（数据服务）\n-- **功能**：读取配置数据，转换为用例可用的格式\n-- **组件**：DataService、ConfigLoader\n-\n-#### 3. 配置数据应用（用例层）\n-- **位置**：用例层\n-- **功能**：使用配置数据驱动业务逻辑\n-- **示例**：根据配置数据执行战斗流程、计算伤害、应用效果\n-\n-#### 4. 配置数据定义规则（实体层）\n-- **位置**：实体层\n-- **功能**：配置数据定义的业务规则\n-- **示例**：战斗规则、回合规则、单位规则\n-\n----\n-\n-## Clean架构与核心设计理念的对应关系\n-\n-### 设计理念映射\n-\n-```mermaid\n-graph TB\n-    subgraph \"核心设计理念\"\n-        Loop[多层循环架构<br/>四层循环]\n-        DataDriven[数据驱动架构<br/>配置驱动]\n-        Layered[分层架构<br/>功能组织]\n-    end\n-    \n-    subgraph \"Clean架构层次\"\n-        Entities[实体层<br/>四层循环实体]\n-        UseCases[用例层<br/>循环用例]\n-        Services[服务层<br/>功能服务]\n-        Frameworks[框架层<br/>配置数据]\n-    end\n-    \n-    Loop --> Entities\n-    Loop --> UseCases\n-    DataDriven --> Frameworks\n-        DataDriven --> Services\n-        Layered --> Services\n-    \n-    style Loop fill:#ffebee\n-    style Entities fill:#ffebee\n-```\n-\n-### 对应关系说明\n-\n-#### 1. 多层循环架构 → 实体层 + 用例层\n-\n-**实体层**：\n-- 定义四层循环的实体模型（战斗、回合、阵营、单位）\n-- 包含循环的业务规则\n-- 定义循环的状态和转换条件\n-\n-**用例层**：\n-- 实现循环的执行用例（执行战斗、执行回合、执行单位）\n-- 协调实体完成循环流程\n-- 管理循环的生命周期\n-\n-#### 2. 数据驱动架构 → 框架层 + 服务层\n-\n-**框架层**：\n-- 存储配置数据（Excel、JSON、Lua）\n-- 提供配置数据访问接口\n-- 管理配置数据的加载和更新\n-\n-**服务层**：\n-- 读取配置数据（数据服务）\n-- 将配置数据转换为用例可用的格式\n-- 应用配置数据驱动业务逻辑\n-\n-#### 3. 分层架构（功能组织）→ 服务层\n-\n-**服务层**：\n-- 输入服务：处理输入功能\n-- 行动服务：处理执行功能\n-- 视觉服务：处理表现功能\n-- 数据服务：处理数据功能\n-- 通信服务：处理通信功能\n-\n----\n-\n-## Clean架构的优势\n-\n-### 对战斗系统的价值\n-\n-```mermaid\n-mindmap\n-  root((Clean架构优势))\n-    业务逻辑独立\n-      实体层独立\n-      用例层独立\n-      不依赖框架\n-    可测试性\n-      实体可独立测试\n-      用例可独立测试\n-      无需Unity/Lua\n-    技术无关性\n-      可替换Unity\n-      可替换Lua\n-      可替换数据库\n-    可维护性\n-      依赖方向清晰\n-      职责分离明确\n-      易于理解\n-    可扩展性\n-      新增用例\n-      新增服务\n-      不影响现有代码\n-```\n-\n-### 具体优势说明\n-\n-#### 1. 业务逻辑独立\n-- **实体层**：四层循环的业务规则完全独立，不依赖Unity、Lua等技术\n-- **用例层**：战斗用例可以独立实现，不依赖框架\n-- **优势**：业务逻辑稳定，技术变化不影响业务\n-\n-#### 2. 可测试性\n-- **实体层**：可以独立测试实体和业务规则\n-- **用例层**：可以独立测试用例逻辑，无需Unity引擎\n-- **优势**：提高测试覆盖率，保证代码质量\n-\n-#### 3. 技术无关性\n-- **框架层**：Unity、Lua、数据库等技术可以被替换\n-- **服务层**：通过服务隔离技术细节\n-- **优势**：可以轻松替换技术栈，不影响业务逻辑\n-\n-#### 4. 可维护性\n-- **依赖方向清晰**：从外向内，易于理解\n-- **职责分离明确**：每层职责单一，易于维护\n-- **优势**：代码组织清晰，易于理解和修改\n-\n-#### 5. 可扩展性\n-- **新增用例**：只需在用例层添加新用例，不影响现有代码\n-- **新增服务**：只需在服务层添加新服务，不影响用例\n-- **优势**：易于扩展新功能，不影响现有系统\n-\n----\n-\n-## 实施建议\n-\n-### Clean架构实施步骤\n-\n-```mermaid\n-graph TD\n-    Start[开始实施] --> Step1[1. 设计实体层<br/>定义四层循环实体]\n-    Step1 --> Step2[2. 设计用例层<br/>定义战斗用例]\n-    Step2 --> Step3[3. 设计服务层<br/>定义功能服务]\n-    Step3 --> Step4[4. 集成框架层<br/>集成Unity/Lua等]\n-    Step4 --> Step5[5. 实现数据驱动<br/>配置数据读取和应用]\n-    Step5 --> End[完成]\n-    \n-    style Step1 fill:#ffebee\n-    style Step2 fill:#fff4e1\n-    style Step3 fill:#e8f5e9\n-    style Step4 fill:#e1f5ff\n-```\n-\n-### 实施优先级\n-\n-#### 第一阶段：核心实体和用例\n-1. **实体层**：定义战斗、回合、阵营、单位实体\n-2. **用例层**：实现执行战斗、执行回合、执行单位用例\n-3. **框架层**：集成状态机框架，实现层次状态机\n-\n-#### 第二阶段：功能服务\n-1. **输入服务**：实现玩家输入和AI输入处理\n-2. **行动服务**：实现行动执行逻辑\n-3. **视觉服务**：实现视觉表现处理\n-4. **数据服务**：实现数据访问和配置读取\n-\n-#### 第三阶段：框架集成\n-1. **Unity集成**：集成Unity引擎，实现视觉表现\n-2. **Lua集成**：集成Lua脚本，实现业务逻辑\n-3. **数据库集成**：集成数据库，实现数据持久化\n-4. **通信集成**：集成CommunicationBus，实现系统通信\n-\n----\n-\n-## 总结\n-\n-战斗系统采用Clean架构模式，将系统组织成四个同心圆层，业务规则在中心，框架和技术在外围。\n-\n-### 核心价值\n-\n-- 🎯 **业务逻辑独立**：四层循环的业务规则完全独立于框架和技术\n-- 🧪 **高度可测试**：实体和用例可以独立测试，无需Unity/Lua\n-- 🔄 **技术无关**：可以轻松替换Unity、Lua、数据库等技术栈\n-- 📐 **依赖清晰**：依赖方向从外向内，易于理解和维护\n-- 📈 **易于扩展**：新增功能只需添加用例或服务，不影响现有代码\n-\n-### 架构映射\n-\n-- **实体层** = 四层循环实体（战斗、回合、阵营、单位）\n-- **用例层** = 战斗用例（执行战斗、执行回合、执行单位）\n-- **服务层** = 功能服务（输入、执行、表现、数据、通信）\n-- **框架层** = 技术实现（Unity、Lua、数据库、FSM、CommunicationBus、DataHandleQueue）\n-\n-### 设计理念对应\n-\n-- **多层循环架构** → 实体层 + 用例层\n-- **数据驱动架构** → 框架层 + 服务层\n-- **分层架构（功能组织）** → 服务层\n-\n-Clean架构是构建可维护、可测试、可扩展战斗系统的优秀选择，特别适合需要长期维护和持续演进的战斗系统。\n"
                },
                {
                    "date": 1767101072320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -321,67 +321,8 @@\n ### 四层循环实体模型\n \n **核心观点**：战斗系统的核心是四层循环的维护和管理，这些循环在实体层中定义。\n \n-#### 循环层次关系\n-\n-```mermaid\n-graph TB\n-    subgraph \"实体层 - 四层循环模型\"\n-        BattleEntity[战斗实体<br/>Battle Entity<br/>战斗循环]\n-        RoundEntity[回合实体<br/>Round Entity<br/>回合循环]\n-        TeamEntity[阵营实体<br/>Team Entity<br/>阵营循环]\n-        UnitEntity[单位实体<br/>Unit Entity<br/>单位循环]\n-        \n-        BattleEntity --> RoundEntity\n-        RoundEntity --> TeamEntity\n-        TeamEntity --> UnitEntity\n-    end\n-    \n-    subgraph \"循环状态\"\n-        BattleState[战斗状态<br/>PREPARING/IN_PROGRESS/ENDED]\n-        RoundState[回合状态<br/>ROUND_START/ACTION/END]\n-        TeamState[阵营状态<br/>TEAM_START/ACTION/END]\n-        UnitState[单位状态<br/>UNIT_START/ACTION/END]\n-    end\n-    \n-    BattleEntity --> BattleState\n-    RoundEntity --> RoundState\n-    TeamEntity --> TeamState\n-    UnitEntity --> UnitState\n-    \n-    style BattleEntity fill:#ffebee\n-    style RoundEntity fill:#fff4e1\n-    style TeamEntity fill:#c8e6c9\n-    style UnitEntity fill:#e1f5ff\n-```\n-\n-#### 实体职责说明\n-\n-##### 1. 战斗实体（Battle Entity）\n-- **职责**：管理整个战斗的生命周期\n-- **状态**：BattleState（PREPARING/IN_PROGRESS/PAUSED/ENDED）\n-- **循环**：战斗循环（BattleLoop）\n-- **业务规则**：战斗开始/结束条件、胜负判定\n-\n-##### 2. 回合实体（Round Entity）\n-- **职责**：管理回合的循环和切换\n-- **状态**：RoundState（ROUND_START/ROUND_ACTION/ROUND_END）\n-- **循环**：回合循环（RoundLoop）\n-- **业务规则**：回合开始/结束条件、回合数限制\n-\n-##### 3. 阵营实体（Team Entity）\n-- **职责**：管理阵营内单位的行动顺序\n-- **状态**：TeamState（TEAM_START/TEAM_ACTION/TEAM_END）\n-- **循环**：阵营循环（TeamLoop）\n-- **业务规则**：阵营切换规则、行动顺序规则\n-\n-##### 4. 单位实体（Unit Entity）\n-- **职责**：管理单个单位的行动流程\n-- **状态**：UnitState（UNIT_START/UNIT_ACTION/UNIT_END）\n-- **循环**：单位循环（UnitLoop）\n-- **业务规则**：单位行动规则、行动完成条件\n-\n ### 层次状态机实现（框架层）\n \n **说明**：层次状态机是框架层的实现，用于管理实体层的状态转换。\n \n@@ -507,237 +448,5 @@\n     Main->>Main: 激活结果状态机\n ```\n ---\n \n-## 用例层详细设计（Use Cases Layer）\n \n-### 核心用例\n-\n-**说明**：用例层实现具体的战斗用例，协调实体完成业务目标。\n-\n-#### 用例层次结构\n-\n-```mermaid\n-graph TB\n-    subgraph \"用例层 - 战斗用例\"\n-        ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle UseCase]\n-        ExecuteRoundUC[执行回合用例<br/>ExecuteRound UseCase]\n-        ExecuteTeamUC[执行阵营用例<br/>ExecuteTeam UseCase]\n-        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n-        CalculateDamageUC[计算伤害用例<br/>CalculateDamage UseCase]\n-        ApplyEffectUC[应用效果用例<br/>ApplyEffect UseCase]\n-    end\n-    \n-    subgraph \"实体层 - 业务实体\"\n-        BattleEntity[战斗实体]\n-        RoundEntity[回合实体]\n-        TeamEntity[阵营实体]\n-        UnitEntity[单位实体]\n-        SkillEntity[技能实体]\n-        EffectEntity[效果实体]\n-    end\n-    \n-    ExecuteBattleUC --> BattleEntity\n-    ExecuteRoundUC --> RoundEntity\n-    ExecuteTeamUC --> TeamEntity\n-    ExecuteUnitUC --> UnitEntity\n-    CalculateDamageUC --> SkillEntity\n-    ApplyEffectUC --> EffectEntity\n-    \n-    style ExecuteBattleUC fill:#fff4e1\n-    style BattleEntity fill:#ffebee\n-```\n-\n-#### 用例职责说明\n-\n-##### 1. 执行战斗用例（ExecuteBattle UseCase）\n-- **职责**：协调战斗实体执行战斗流程\n-- **输入**：战斗配置、参与者列表\n-- **输出**：战斗结果\n-- **协调实体**：战斗实体、回合实体\n-\n-##### 2. 执行回合用例（ExecuteRound UseCase）\n-- **职责**：协调回合实体执行回合流程\n-- **输入**：回合编号、回合配置\n-- **输出**：回合结果\n-- **协调实体**：回合实体、阵营实体\n-\n-##### 3. 执行阵营用例（ExecuteTeam UseCase）\n-- **职责**：协调阵营实体执行阵营流程\n-- **输入**：阵营信息、单位列表\n-- **输出**：阵营行动结果\n-- **协调实体**：阵营实体、单位实体\n-\n-##### 4. 执行单位用例（ExecuteUnit UseCase）\n-- **职责**：协调单位实体执行单位行动\n-- **输入**：单位信息、行动指令\n-- **输出**：行动结果\n-- **协调实体**：单位实体、技能实体\n-\n-##### 5. 计算伤害用例（CalculateDamage UseCase）\n-- **职责**：计算技能伤害\n-- **输入**：技能信息、攻击者、目标\n-- **输出**：伤害数值\n-- **协调实体**：技能实体、单位实体\n-\n-##### 6. 应用效果用例（ApplyEffect UseCase）\n-- **职责**：应用技能效果\n-- **输入**：效果信息、目标\n-- **输出**：效果应用结果\n-- **协调实体**：效果实体、单位实体\n-\n-## 服务层详细设计（Services Layer）\n-\n-### 功能服务\n-\n-**说明**：服务层提供功能服务，将用例层的输出转换为框架层可以使用的格式，同时将框架层的输入转换为用例层可以使用的格式。\n-\n-#### 服务层次结构\n-\n-```mermaid\n-graph TB\n-    subgraph \"服务层 - 功能服务\"\n-        InputService[输入服务<br/>Input Service]\n-        ActionService[行动服务<br/>Action Service]\n-        VisualService[视觉服务<br/>Visual Service]\n-        DataService[数据服务<br/>Data Service]\n-        CommunicationService[通信服务<br/>Communication Service]\n-    end\n-    \n-    subgraph \"用例层 - 用例\"\n-        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n-    end\n-    \n-    subgraph \"框架层 - 框架\"\n-        Unity[Unity引擎]\n-        Lua[Lua脚本]\n-        Database[(数据库)]\n-        CommunicationBus[通信总线]\n-    end\n-    \n-    InputService --> ExecuteUnitUC\n-    ActionService --> ExecuteUnitUC\n-    VisualService --> ExecuteUnitUC\n-    DataService --> ExecuteUnitUC\n-    CommunicationService --> ExecuteUnitUC\n-    \n-    Unity --> VisualService\n-    Lua --> ActionService\n-    Database --> DataService\n-    CommunicationBus --> CommunicationService\n-    \n-    style InputService fill:#e8f5e9\n-    style ExecuteUnitUC fill:#fff4e1\n-    style Unity fill:#e1f5ff\n-```\n-\n-#### 服务职责说明\n-\n-##### 1. 输入服务（Input Service）\n-- **职责**：处理玩家输入和AI输入，转换为用例输入\n-- **功能**：\n-  - 接收玩家输入（UI交互、键盘鼠标）\n-  - 接收AI输入（AI决策结果）\n-  - 验证输入有效性\n-  - 转换为用例输入格式（BattleContext）\n-- **框架依赖**：Unity Input Manager、AI系统\n-\n-##### 2. 行动服务（Action Service）\n-- **职责**：执行行动逻辑，调用用例\n-- **功能**：\n-  - 验证行动合法性\n-  - 执行行动逻辑\n-  - 调用执行单位用例\n-  - 处理行动结果\n-- **框架依赖**：Lua脚本引擎、技能系统\n-\n-##### 3. 视觉服务（Visual Service）\n-- **职责**：处理视觉表现，调用用例输出\n-- **功能**：\n-  - 播放战斗动画\n-  - 播放特效\n-  - 更新UI显示\n-  - 处理相机控制\n-- **框架依赖**：Unity引擎、Visual系统\n-\n-##### 4. 数据服务（Data Service）\n-- **职责**：处理数据访问，调用用例\n-- **功能**：\n-  - 读取战斗配置\n-  - 保存战斗数据\n-  - 查询单位数据\n-  - 更新战斗状态\n-- **框架依赖**：数据库、DataHandleQueue\n-\n-##### 5. 通信服务（Communication Service）\n-- **职责**：处理系统间通信，调用用例\n-- **功能**：\n-  - 发布战斗事件\n-  - 订阅系统消息\n-  - 处理跨系统通信\n-  - 管理通信上下文\n-- **框架依赖**：CommunicationBus\n-\n-### 服务间交互关系\n-\n-**说明**：服务层内的服务可以相互交互，形成完整的功能流程。\n-\n-```mermaid\n-graph LR\n-    subgraph \"服务层 - 服务交互\"\n-        InputService[输入服务<br/>Input Service]\n-        ActionService[行动服务<br/>Action Service]\n-        VisualService[视觉服务<br/>Visual Service]\n-        DataService[数据服务<br/>Data Service]\n-        CommunicationService[通信服务<br/>Communication Service]\n-        \n-        InputService -->|输入驱动| ActionService\n-        ActionService -->|行动触发| VisualService\n-        ActionService -->|行动更新| DataService\n-        DataService -->|数据触发| CommunicationService\n-        CommunicationService -->|通信触发| VisualService\n-    end\n-    \n-    style InputService fill:#fff4e1\n-    style ActionService fill:#e8f5e9\n-    style VisualService fill:#e1f5ff\n-    style DataService fill:#ffebee\n-    style CommunicationService fill:#c8e6c9\n-```\n-\n-### 单位循环内的功能流程\n-\n-**说明**：单位循环内的功能流程通过服务层实现。\n-\n-```mermaid\n-graph TB\n-    subgraph \"单位循环 - 用例层\"\n-        ExecuteUnitUC[执行单位用例<br/>ExecuteUnit UseCase]\n-    end\n-    \n-    subgraph \"服务层 - 功能流程\"\n-        InputService[输入服务<br/>接收输入]\n-        ActionService[行动服务<br/>执行行动]\n-        VisualService[视觉服务<br/>播放表现]\n-        DataService[数据服务<br/>更新数据]\n-    end\n-    \n-    subgraph \"框架层 - 技术实现\"\n-        Unity[Unity引擎]\n-        Lua[Lua脚本]\n-        Database[(数据库)]\n-    end\n-    \n-    InputService --> ExecuteUnitUC\n-    ExecuteUnitUC --> ActionService\n-    ActionService --> VisualService\n-    VisualService --> DataService\n-    \n-    Unity --> VisualService\n-    Lua --> ActionService\n-    Database --> DataService\n-    \n-    style ExecuteUnitUC fill:#fff4e1\n-    style InputService fill:#e8f5e9\n-    style Unity fill:#e1f5ff\n-```\n-\n"
                },
                {
                    "date": 1767101143387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -86,30 +86,8 @@\n     style InputService fill:#e8f5e9\n     style Unity fill:#e1f5ff\n ```\n \n-### Clean架构层次结构\n-\n-```mermaid\n-graph TB\n-    subgraph \"Clean架构同心圆\"\n-        direction TB\n-        Entities[实体层<br/>Entities<br/>核心业务规则<br/>最内层]\n-        UseCases[用例层<br/>Use Cases<br/>应用业务规则]\n-        Services[服务层<br/>Services<br/>功能服务]\n-        Frameworks[框架层<br/>Frameworks & Drivers<br/>技术实现<br/>最外层]\n-        \n-        Frameworks -.依赖.-> Services\n-        Services -.依赖.-> UseCases\n-        UseCases -.依赖.-> Entities\n-    end\n-    \n-    style Entities fill:#ffebee\n-    style UseCases fill:#fff4e1\n-    style Services fill:#e8f5e9\n-    style Frameworks fill:#e1f5ff\n-```\n-\n **依赖规则**：\n - ✅ **允许**：外层依赖内层\n - ❌ **禁止**：内层依赖外层\n - ✅ **允许**：通过接口定义依赖\n@@ -171,152 +149,9 @@\n     \n     Note over Entity: 单位循环结束，返回上层循环\n ```\n \n-### 数据流在Clean架构中的方向\n \n-```mermaid\n-graph LR\n-    subgraph \"数据流向\"\n-        direction TB\n-        \n-        subgraph \"请求流（从外向内）\"\n-            FrameworkReq[框架层<br/>用户输入/系统事件]\n-            ServiceReq[服务层<br/>数据转换]\n-            UseCaseReq[用例层<br/>用例输入]\n-            EntityReq[实体层<br/>实体操作]\n-            \n-            FrameworkReq --> ServiceReq\n-            ServiceReq --> UseCaseReq\n-            UseCaseReq --> EntityReq\n-        end\n-        \n-        subgraph \"响应流（从内向外）\"\n-            EntityResp[实体层<br/>业务结果]\n-            UseCaseResp[用例层<br/>用例输出]\n-            ServiceResp[服务层<br/>数据转换]\n-            FrameworkResp[框架层<br/>UI更新/视觉表现]\n-            \n-            EntityResp --> UseCaseResp\n-            UseCaseResp --> ServiceResp\n-            ServiceResp --> FrameworkResp\n-        end\n-    end\n-    \n-    style FrameworkReq fill:#e1f5ff\n-    style EntityReq fill:#ffebee\n-    style EntityResp fill:#ffebee\n-    style FrameworkResp fill:#e1f5ff\n-```\n-\n-### 各层职责概览\n-\n-#### 1. 实体层（Entities）- 核心业务规则\n-\n-**位置**：最内层，核心业务规则\n-\n-**职责**：\n-- 定义战斗核心实体（战斗、回合、阵营、单位）\n-- 包含企业级业务规则\n-- 定义四层循环的实体模型\n-- 不依赖任何外部框架\n-\n-**核心实体**：\n-- **战斗实体（Battle Entity）**：管理整个战斗的生命周期，包含战斗循环\n-- **回合实体（Round Entity）**：管理回合的循环和切换，包含回合循环\n-- **阵营实体（Team Entity）**：管理阵营内单位的行动顺序，包含阵营循环\n-- **单位实体（Unit Entity）**：管理单个单位的行动流程，包含单位循环\n-- **技能实体（Skill Entity）**：定义技能规则和效果\n-- **效果实体（Effect Entity）**：定义效果规则和应用逻辑\n-\n-**特点**：\n-- 最稳定的一层\n-- 变化频率最低\n-- 包含核心业务概念\n-- 纯业务逻辑，无技术细节\n-\n-#### 2. 用例层（Use Cases）- 应用业务规则\n-\n-**位置**：第二层，应用业务规则\n-\n-**职责**：\n-- 实现具体的战斗用例\n-- 协调实体完成业务目标\n-- 定义应用输入输出接口\n-- 包含应用特定的业务逻辑\n-\n-**核心用例**：\n-- **执行战斗用例（ExecuteBattle）**：协调战斗实体执行战斗流程\n-- **执行回合用例（ExecuteRound）**：协调回合实体执行回合流程\n-- **执行阵营用例（ExecuteTeam）**：协调阵营实体执行阵营流程\n-- **执行单位用例（ExecuteUnit）**：协调单位实体执行单位行动\n-- **计算伤害用例（CalculateDamage）**：计算技能伤害\n-- **应用效果用例（ApplyEffect）**：应用技能效果\n-\n-**特点**：\n-- 依赖实体层\n-- 不依赖框架和UI\n-- 包含应用特定的业务逻辑\n-- 可以独立测试\n-\n-#### 3. 服务层（Services）- 功能服务\n-\n-**位置**：第三层，功能服务层\n-\n-**职责**：\n-- 提供功能服务\n-- 转换数据格式\n-- 适配外部接口\n-- 连接用例和框架\n-\n-**核心服务**：\n-- **输入服务（Input Service）**：处理玩家输入和AI输入，转换为用例输入\n-- **行动服务（Action Service）**：执行行动逻辑，调用用例\n-- **视觉服务（Visual Service）**：处理视觉表现，调用用例输出\n-- **数据服务（Data Service）**：处理数据访问，调用用例\n-- **通信服务（Communication Service）**：处理系统间通信，调用用例\n-\n-**服务间交互**：\n-- 输入服务 → 行动服务（输入驱动行动）\n-- 行动服务 → 视觉服务（行动触发视觉）\n-- 行动服务 → 数据服务（行动更新数据）\n-- 数据服务 → 通信服务（数据触发通信）\n-- 通信服务 → 视觉服务（通信触发视觉）\n-\n-**特点**：\n-- 依赖用例层\n-- 实现框架层定义的接口\n-- 转换数据格式\n-- 提供功能服务\n-\n-#### 4. 框架层（Frameworks & Drivers）- 技术实现\n-\n-**位置**：最外层，技术实现\n-\n-**职责**：\n-- 实现具体的技术细节\n-- 提供框架和工具\n-- 处理外部系统交互\n-- 实现服务层定义的接口\n-\n-**核心框架**：\n-- **Unity引擎**：游戏引擎，提供渲染、物理等功能\n-- **Lua脚本引擎**：脚本语言，实现业务逻辑\n-- **数据库**：数据持久化\n-- **状态机框架（FSM）**：状态管理\n-- **通信总线（CommunicationBus）**：系统间通信\n-- **数据队列（DataHandleQueue）**：数据处理\n-- **公式引擎（Formula Parser）**：公式计算\n-- **对象池（Object Pool）**：对象管理\n-- **配置数据**：Excel/JSON/Lua配置\n-\n-**特点**：\n-- 最外层，技术实现\n-- 可以被替换\n-- 不影响业务逻辑\n-- 提供基础设施\n-\n-\n ## 实体层详细设计（Entities Layer）\n \n ### 四层循环实体模型\n \n"
                },
                {
                    "date": 1767101157842,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,9 @@\n         Config[配置数据<br/>Excel/JSON/Lua]\n     end\n     \n     subgraph \"服务层（Services）- 功能服务\"\n-        InputService[输入服务<br/>Input Service<br/>玩家输入/AI输入]\n+        InputService[]\n         ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n         VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n         DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n         CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n"
                },
                {
                    "date": 1767101169058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,10 @@\n         Config[配置数据<br/>Excel/JSON/Lua]\n     end\n     \n     subgraph \"服务层（Services）- 功能服务\"\n-        InputService[]\n+        Input\n+        AI\n         ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n         VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n         DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n         CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n"
                },
                {
                    "date": 1767101180502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     subgraph \"服务层（Services）- 功能服务\"\n         Input\n         AI\n         ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n-        VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n+        VisualSystem[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n         DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n         CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n     end\n     \n"
                },
                {
                    "date": 1767101191840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,10 +31,10 @@\n     subgraph \"服务层（Services）- 功能服务\"\n         Input\n         AI\n         ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n-        VisualSystem[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n-        DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n+        VisualSystem\n+        Data\n         CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n"
                },
                {
                    "date": 1767101196871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,9 @@\n         AI\n         ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n         VisualSystem\n         Data\n-        CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n+        Communicatio\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n         ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n"
                },
                {
                    "date": 1767101213449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n     \n     subgraph \"服务层（Services）- 功能服务\"\n         Input\n         AI\n-        ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n+        Formual[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n         VisualSystem\n         Data\n         Communicatio\n     end\n"
                },
                {
                    "date": 1767101223214,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,12 +30,12 @@\n     \n     subgraph \"服务层（Services）- 功能服务\"\n         Input\n         AI\n-        Formual[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n+        FormulaSystem[公式引擎<br/>Formula Parser]\n         VisualSystem\n         Data\n-        Communicatio\n+        CommunicationSystem\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n         ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n"
                },
                {
                    "date": 1767101229438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,14 +28,14 @@\n         Config[配置数据<br/>Excel/JSON/Lua]\n     end\n     \n     subgraph \"服务层（Services）- 功能服务\"\n-        Input\n-        AI\n+        Input[输入服务<br/>Input Service<br/>玩家输入/AI输入]\n+        AI[AI服务<br/>AI Service<br/>AI决策]\n         FormulaSystem[公式引擎<br/>Formula Parser]\n-        VisualSystem\n-        Data\n-        CommunicationSystem\n+        VisualSystem[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n+        DataSystem[数据服务<br/>Data Service<br/>数据访问/配置读取]\n+        CommunicationSystem[通信服务<br/>Communication Service<br/>事件/消息/查询]\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n         ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n"
                },
                {
                    "date": 1767101246377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,14 +28,13 @@\n         Config[配置数据<br/>Excel/JSON/Lua]\n     end\n     \n     subgraph \"服务层（Services）- 功能服务\"\n-        Input[输入服务<br/>Input Service<br/>玩家输入/AI输入]\n-        AI[AI服务<br/>AI Service<br/>AI决策]\n-        FormulaSystem[公式引擎<br/>Formula Parser]\n-        VisualSystem[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n-        DataSystem[数据服务<br/>Data Service<br/>数据访问/配置读取]\n-        CommunicationSystem[通信服务<br/>Communication Service<br/>事件/消息/查询]\n+        InputService[输入服务<br/>Input Service<br/>玩家输入/AI输入]\n+        ActionService[行动服务<br/>Action Service<br/>行动执行/伤害计算]\n+        VisualService[视觉服务<br/>Visual Service<br/>动画/特效/UI]\n+        DataService[数据服务<br/>Data Service<br/>数据访问/配置读取]\n+        CommunicationService[通信服务<br/>Communication Service<br/>事件/消息/查询]\n     end\n     \n     subgraph \"用例层（Use Cases）- 应用业务规则\"\n         ExecuteBattleUC[执行战斗用例<br/>ExecuteBattle]\n"
                }
            ],
            "date": 1767016974447,
            "name": "Commit-0",
            "content": "# 战斗系统架构设计\n\n## 设计目标\n\n设计一套完整的回合制战斗系统架构，支持DND规则、回合管理、状态机控制、AI决策，实现战斗流程管理、伤害计算、效果应用，提供数据驱动的配置化战斗系统。\n\n---\n\n## 核心设计理念\n\n### 1. 回合驱动为核心\n\n**本质**：战斗系统的核心是回合流程的驱动和管理\n- 战斗流程 = 回合循环驱动\n- 回合管理 = 先攻计算 → 行动轮 → 回合结束\n- 状态同步 = 回合状态在参与者间同步\n- 流程控制 = 回合流程控制战斗节奏\n\n### 2. 数据驱动架构\n\n**本质**：战斗特性通过配置数据实现，无需修改代码\n- 战斗规则、伤害计算、效果应用 → 通过配置数据定义\n- 回合流程、状态转换 → 通过配置数据调整\n- 新增战斗机制 → 扩展配置数据即可\n- 战斗平衡 → 调整配置数值即可\n\n### 3. 分层架构 + 状态机控制\n\n**本质**：分层架构实现职责分离，状态机控制实现流程管理\n- 多层架构：输入层、决策层、执行层、表现层、管理层\n- 状态机：战斗状态、回合状态、角色状态\n- 解耦设计：层间通过Context和CommunicationBus通信\n\n---\n\n## 整体架构设计\n\n### 分层架构 + 回合驱动\n\n```mermaid\ngraph TB\n    subgraph InputLayer[\"输入层<br/>InputLayer\"]\n        PlayerInput[\"玩家输入<br/>PlayerInput\"]\n        AIInput[\"AI输入<br/>AIInput\"]\n        InputValidator[\"输入验证器<br/>InputValidator\"]\n    end\n    \n    subgraph DecisionLayer[\"决策层<br/>DecisionLayer\"]\n        TurnManager[\"回合管理器<br/>TurnManager\"]\n        ActionSelector[\"行动选择器<br/>ActionSelector\"]\n        TargetSelector[\"目标选择器<br/>TargetSelector\"]\n    end\n    \n    subgraph ExecutionLayer[\"执行层<br/>ExecutionLayer\"]\n        ActionExecutor[\"行动执行器<br/>ActionExecutor\"]\n        DamageCalculator[\"伤害计算器<br/>DamageCalculator\"]\n        EffectApplier[\"效果应用器<br/>EffectApplier\"]\n    end\n    \n    subgraph PresentationLayer[\"表现层<br/>PresentationLayer\"]\n        VisualPlayer[\"视觉播放器<br/>VisualPlayer\"]\n        AudioPlayer[\"音频播放器<br/>AudioPlayer\"]\n        UIManager[\"UI管理器<br/>UIManager\"]\n    end\n    \n    subgraph ManagementLayer[\"管理层<br/>ManagementLayer\"]\n        BattleStateManager[\"战斗状态管理器<br/>BattleStateManager\"]\n        ParticipantManager[\"参与者管理器<br/>ParticipantManager\"]\n        BattleContext[\"战斗上下文<br/>BattleContext\"]\n    end\n    \n    subgraph DataLayer[\"数据层<br/>DataLayer\"]\n        BattleConfig[\"战斗配置<br/>BattleConfig\"]\n        TurnData[\"回合数据<br/>TurnData\"]\n        BattleData[\"战斗数据<br/>BattleData\"]\n    end\n    \n    InputLayer -->|BattleContext<br/>+inputData| DecisionLayer\n    DecisionLayer -->|BattleContext<br/>+decisionData| ExecutionLayer\n    ExecutionLayer -->|BattleContext<br/>+executionData| PresentationLayer\n    PresentationLayer -->|BattleContext<br/>+presentationData| ManagementLayer\n    ManagementLayer -->|状态更新| InputLayer\n    ManagementLayer -->|数据持久化| DataLayer\n    DataLayer -.数据查询.-> DecisionLayer\n    \n    style InputLayer fill:#ffebee\n    style DecisionLayer fill:#fff4e1\n    style ExecutionLayer fill:#c8e6c9\n    style PresentationLayer fill:#e1f5ff\n    style ManagementLayer fill:#f3e5f5\n    style DataLayer fill:#e8f5e9\n```\n\n---\n\n## 分层职责说明\n\n### 输入层（InputLayer）\n- **职责**：接收玩家输入和AI输入\n- **核心组件**：PlayerInput、AIInput、InputValidator\n- **输出**：BattleContext + inputData\n\n### 决策层（DecisionLayer）\n- **职责**：回合管理、行动选择、目标选择\n- **核心组件**：TurnManager、ActionSelector、TargetSelector\n- **输出**：BattleContext + decisionData\n\n### 执行层（ExecutionLayer）\n- **职责**：行动执行、伤害计算、效果应用\n- **核心组件**：ActionExecutor、DamageCalculator、EffectApplier\n- **输出**：BattleContext + executionData\n\n### 表现层（PresentationLayer）\n- **职责**：视觉表现、音频播放、UI更新\n- **核心组件**：VisualPlayer、AudioPlayer、UIManager\n- **输出**：BattleContext + presentationData\n\n### 管理层（ManagementLayer）\n- **职责**：战斗状态管理、参与者管理、Context管理\n- **核心组件**：BattleStateManager、ParticipantManager、BattleContext\n- **输出**：状态更新、数据持久化\n\n### 数据层（DataLayer）\n- **职责**：战斗配置、回合数据、战斗数据\n- **核心组件**：BattleConfig、TurnData、BattleData\n- **输出**：配置数据查询\n"
        }
    ]
}