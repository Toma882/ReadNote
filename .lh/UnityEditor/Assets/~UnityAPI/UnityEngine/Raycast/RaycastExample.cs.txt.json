{
    "sourceFile": "UnityEditor/Assets/~UnityAPI/UnityEngine/Raycast/RaycastExample.cs.txt",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1766055924191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1766055924191,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// Unity Raycast（射线检测）完整 API 示例\r\n/// Raycast 是 Unity 中用于检测碰撞的核心系统，常用于点击检测、视线检测等\r\n/// </summary>\r\npublic class RaycastExample : MonoBehaviour\r\n{\r\n    [Header(\"射线设置\")]\r\n    [SerializeField] private float rayDistance = 100f;\r\n    [SerializeField] private LayerMask layerMask = -1;\r\n    [SerializeField] private QueryTriggerInteraction queryTriggers = QueryTriggerInteraction.UseGlobal;\r\n    \r\n    [Header(\"检测设置\")]\r\n    [SerializeField] private bool showRay = true;\r\n    [SerializeField] private Color rayColor = Color.red;\r\n    \r\n    private Camera mainCamera;\r\n    private List<RaycastHit> hitResults = new List<RaycastHit>();\r\n    private RaycastHit[] hitArray = new RaycastHit[10];\r\n    \r\n    private void Start()\r\n    {\r\n        Debug.Log(\"=== Unity Raycast（射线检测）完整 API 示例 ===\");\r\n        \r\n        mainCamera = Camera.main;\r\n        if (mainCamera == null)\r\n        {\r\n            mainCamera = FindObjectOfType<Camera>();\r\n        }\r\n        \r\n        TestAllRaycastFeatures();\r\n    }\r\n    \r\n    private void Update()\r\n    {\r\n        TestMouseRaycast();\r\n    }\r\n    \r\n    private void OnDrawGizmos()\r\n    {\r\n        if (showRay && mainCamera != null)\r\n        {\r\n            Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);\r\n            Gizmos.color = rayColor;\r\n            Gizmos.DrawRay(ray.origin, ray.direction * rayDistance);\r\n        }\r\n    }\r\n    \r\n    #region 1. 基础射线检测\r\n    \r\n    /// <summary>\r\n    /// 测试所有 Raycast 功能\r\n    /// </summary>\r\n    private void TestAllRaycastFeatures()\r\n    {\r\n        Debug.Log(\"\\n--- 1. 基础射线检测 ---\");\r\n        \r\n        // 1.1 Physics.Raycast\r\n        TestPhysicsRaycast();\r\n        \r\n        // 1.2 Physics.RaycastAll\r\n        TestPhysicsRaycastAll();\r\n        \r\n        // 1.3 Physics.RaycastNonAlloc\r\n        TestPhysicsRaycastNonAlloc();\r\n        \r\n        Debug.Log(\"\\n--- 2. 其他检测方法 ---\");\r\n        \r\n        // 2.1 Physics.Linecast\r\n        TestLinecast();\r\n        \r\n        // 2.2 Physics.OverlapSphere\r\n        TestOverlapSphere();\r\n        \r\n        // 2.3 Physics.OverlapBox\r\n        TestOverlapBox();\r\n        \r\n        Debug.Log(\"\\n--- 3. 2D 射线检测 ---\");\r\n        \r\n        // 3.1 Physics2D.Raycast\r\n        TestPhysics2DRaycast();\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 1.1 Physics.Raycast - 单次射线检测\r\n    /// 检测射线是否与碰撞体相交，返回第一个碰撞点\r\n    /// </summary>\r\n    private void TestPhysicsRaycast()\r\n    {\r\n        Debug.Log(\"1.1 Physics.Raycast - 单次射线检测\");\r\n        \r\n        // 方式1：使用 Ray 结构\r\n        Ray ray = new Ray(transform.position, transform.forward);\r\n        RaycastHit hit;\r\n        \r\n        if (Physics.Raycast(ray, out hit, rayDistance, layerMask, queryTriggers))\r\n        {\r\n            Debug.Log($\"射线命中: {hit.collider.name}\");\r\n            Debug.Log($\"命中点: {hit.point}\");\r\n            Debug.Log($\"距离: {hit.distance}\");\r\n            Debug.Log($\"法线: {hit.normal}\");\r\n        }\r\n        \r\n        // 方式2：使用起点和方向\r\n        Vector3 origin = transform.position;\r\n        Vector3 direction = transform.forward;\r\n        \r\n        if (Physics.Raycast(origin, direction, out hit, rayDistance, layerMask, queryTriggers))\r\n        {\r\n            Debug.Log($\"射线命中: {hit.collider.name}\");\r\n        }\r\n        \r\n        // 方式3：简化版本（使用默认参数）\r\n        if (Physics.Raycast(origin, direction, out hit))\r\n        {\r\n            Debug.Log($\"射线命中: {hit.collider.name}\");\r\n        }\r\n        \r\n        // 方式4：只检测是否命中（不获取详细信息）\r\n        bool hasHit = Physics.Raycast(ray, rayDistance, layerMask);\r\n        if (hasHit)\r\n        {\r\n            Debug.Log(\"射线命中某个物体\");\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 1.2 Physics.RaycastAll - 检测所有碰撞\r\n    /// 返回所有与射线相交的碰撞体\r\n    /// </summary>\r\n    private void TestPhysicsRaycastAll()\r\n    {\r\n        Debug.Log(\"1.2 Physics.RaycastAll - 检测所有碰撞\");\r\n        \r\n        Ray ray = new Ray(transform.position, transform.forward);\r\n        \r\n        // 检测所有碰撞\r\n        RaycastHit[] hits = Physics.RaycastAll(ray, rayDistance, layerMask, queryTriggers);\r\n        \r\n        Debug.Log($\"射线命中了 {hits.Length} 个物体\");\r\n        \r\n        // 按距离排序\r\n        System.Array.Sort(hits, (a, b) => a.distance.CompareTo(b.distance));\r\n        \r\n        foreach (RaycastHit hit in hits)\r\n        {\r\n            Debug.Log($\"  - {hit.collider.name}, 距离: {hit.distance}\");\r\n        }\r\n        \r\n        // 注意：RaycastAll 会分配新数组，可能产生 GC\r\n        // 推荐使用 RaycastNonAlloc\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 1.3 Physics.RaycastNonAlloc - 无 GC 分配检测\r\n    /// 使用预分配的数组，避免 GC 分配（推荐）\r\n    /// </summary>\r\n    private void TestPhysicsRaycastNonAlloc()\r\n    {\r\n        Debug.Log(\"1.3 Physics.RaycastNonAlloc - 无 GC 分配检测\");\r\n        \r\n        Ray ray = new Ray(transform.position, transform.forward);\r\n        \r\n        // 使用预分配的数组\r\n        int hitCount = Physics.RaycastNonAlloc(ray, hitArray, rayDistance, layerMask, queryTriggers);\r\n        \r\n        Debug.Log($\"射线命中了 {hitCount} 个物体（无 GC 分配）\");\r\n        \r\n        for (int i = 0; i < hitCount; i++)\r\n        {\r\n            RaycastHit hit = hitArray[i];\r\n            Debug.Log($\"  - {hit.collider.name}, 距离: {hit.distance}\");\r\n        }\r\n        \r\n        // 性能优势：避免每次调用分配新数组\r\n        // 适用场景：频繁调用的检测（如 Update 中）\r\n    }\r\n    \r\n    #endregion\r\n    \r\n    #region 2. 其他检测方法\r\n    \r\n    /// <summary>\r\n    /// 2.1 Physics.Linecast - 线段检测\r\n    /// 检测两点之间的线段是否与碰撞体相交\r\n    /// </summary>\r\n    private void TestLinecast()\r\n    {\r\n        Debug.Log(\"2.1 Physics.Linecast - 线段检测\");\r\n        \r\n        Vector3 start = transform.position;\r\n        Vector3 end = start + transform.forward * rayDistance;\r\n        \r\n        RaycastHit hit;\r\n        if (Physics.Linecast(start, end, out hit, layerMask, queryTriggers))\r\n        {\r\n            Debug.Log($\"线段命中: {hit.collider.name}\");\r\n            Debug.Log($\"命中点: {hit.point}\");\r\n        }\r\n        \r\n        // Linecast 等价于从 start 到 end 的 Raycast\r\n        // 但更简洁，不需要计算方向\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 2.2 Physics.OverlapSphere - 球形检测\r\n    /// 检测指定球形范围内的所有碰撞体\r\n    /// </summary>\r\n    private void TestOverlapSphere()\r\n    {\r\n        Debug.Log(\"2.2 Physics.OverlapSphere - 球形检测\");\r\n        \r\n        Vector3 center = transform.position;\r\n        float radius = 5f;\r\n        \r\n        // 检测所有碰撞体\r\n        Collider[] colliders = Physics.OverlapSphere(center, radius, layerMask, queryTriggers);\r\n        \r\n        Debug.Log($\"球形范围内有 {colliders.Length} 个碰撞体\");\r\n        \r\n        foreach (Collider col in colliders)\r\n        {\r\n            Debug.Log($\"  - {col.name}\");\r\n        }\r\n        \r\n        // OverlapSphereNonAlloc - 无 GC 分配版本\r\n        Collider[] colliderArray = new Collider[10];\r\n        int count = Physics.OverlapSphereNonAlloc(center, radius, colliderArray, layerMask, queryTriggers);\r\n        Debug.Log($\"无 GC 分配检测到 {count} 个碰撞体\");\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 2.3 Physics.OverlapBox - 盒形检测\r\n    /// 检测指定盒形范围内的所有碰撞体\r\n    /// </summary>\r\n    private void TestOverlapBox()\r\n    {\r\n        Debug.Log(\"2.3 Physics.OverlapBox - 盒形检测\");\r\n        \r\n        Vector3 center = transform.position;\r\n        Vector3 halfExtents = new Vector3(2f, 2f, 2f);\r\n        Quaternion orientation = transform.rotation;\r\n        \r\n        // 检测所有碰撞体\r\n        Collider[] colliders = Physics.OverlapBox(center, halfExtents, orientation, layerMask, queryTriggers);\r\n        \r\n        Debug.Log($\"盒形范围内有 {colliders.Length} 个碰撞体\");\r\n        \r\n        foreach (Collider col in colliders)\r\n        {\r\n            Debug.Log($\"  - {col.name}\");\r\n        }\r\n        \r\n        // OverlapBoxNonAlloc - 无 GC 分配版本\r\n        Collider[] colliderArray = new Collider[10];\r\n        int count = Physics.OverlapBoxNonAlloc(center, halfExtents, colliderArray, orientation, layerMask, queryTriggers);\r\n        Debug.Log($\"无 GC 分配检测到 {count} 个碰撞体\");\r\n    }\r\n    \r\n    #endregion\r\n    \r\n    #region 3. 2D 射线检测\r\n    \r\n    /// <summary>\r\n    /// 3.1 Physics2D.Raycast - 2D 射线检测\r\n    /// </summary>\r\n    private void TestPhysics2DRaycast()\r\n    {\r\n        Debug.Log(\"3.1 Physics2D.Raycast - 2D 射线检测\");\r\n        \r\n        Vector2 origin = transform.position;\r\n        Vector2 direction = transform.right;\r\n        \r\n        // 2D 射线检测\r\n        RaycastHit2D hit = Physics2D.Raycast(origin, direction, rayDistance, layerMask);\r\n        \r\n        if (hit.collider != null)\r\n        {\r\n            Debug.Log($\"2D 射线命中: {hit.collider.name}\");\r\n            Debug.Log($\"命中点: {hit.point}\");\r\n            Debug.Log($\"距离: {hit.distance}\");\r\n        }\r\n        \r\n        // 2D 检测所有碰撞\r\n        RaycastHit2D[] hits2D = Physics2D.RaycastAll(origin, direction, rayDistance, layerMask);\r\n        Debug.Log($\"2D 射线命中了 {hits2D.Length} 个物体\");\r\n        \r\n        // 2D 无 GC 分配检测\r\n        RaycastHit2D[] hitArray2D = new RaycastHit2D[10];\r\n        int count = Physics2D.RaycastNonAlloc(origin, direction, hitArray2D, rayDistance, layerMask);\r\n        Debug.Log($\"2D 无 GC 分配检测到 {count} 个碰撞\");\r\n    }\r\n    \r\n    #endregion\r\n    \r\n    #region 4. LayerMask 使用\r\n    \r\n    /// <summary>\r\n    /// 4.1 LayerMask 使用示例\r\n    /// </summary>\r\n    private void TestLayerMask()\r\n    {\r\n        Debug.Log(\"4.1 LayerMask 使用示例\");\r\n        \r\n        // 方式1：在 Inspector 中设置\r\n        // layerMask = -1; // 所有层\r\n        \r\n        // 方式2：通过代码设置\r\n        int layer = LayerMask.NameToLayer(\"Default\");\r\n        LayerMask mask = 1 << layer; // 只检测 Default 层\r\n        \r\n        // 方式3：检测多个层\r\n        int layer1 = LayerMask.NameToLayer(\"Default\");\r\n        int layer2 = LayerMask.NameToLayer(\"UI\");\r\n        LayerMask multiMask = (1 << layer1) | (1 << layer2);\r\n        \r\n        // 方式4：排除某些层\r\n        LayerMask excludeMask = ~(1 << LayerMask.NameToLayer(\"Ignore Raycast\"));\r\n        \r\n        Ray ray = new Ray(transform.position, transform.forward);\r\n        RaycastHit hit;\r\n        \r\n        if (Physics.Raycast(ray, out hit, rayDistance, mask))\r\n        {\r\n            Debug.Log($\"使用 LayerMask 检测到: {hit.collider.name}\");\r\n        }\r\n    }\r\n    \r\n    #endregion\r\n    \r\n    #region 5. 实际应用场景\r\n    \r\n    /// <summary>\r\n    /// 5.1 鼠标点击检测\r\n    /// </summary>\r\n    private void TestMouseRaycast()\r\n    {\r\n        if (Input.GetMouseButtonDown(0) && mainCamera != null)\r\n        {\r\n            // 从鼠标位置发射射线\r\n            Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);\r\n            RaycastHit hit;\r\n            \r\n            if (Physics.Raycast(ray, out hit, rayDistance, layerMask))\r\n            {\r\n                Debug.Log($\"点击了: {hit.collider.name}\");\r\n                Debug.Log($\"点击位置: {hit.point}\");\r\n                \r\n                // 可以获取点击的对象并执行操作\r\n                GameObject clickedObject = hit.collider.gameObject;\r\n                // 执行点击操作...\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 5.2 视线检测\r\n    /// </summary>\r\n    public bool CanSeeTarget(Transform target)\r\n    {\r\n        Vector3 direction = (target.position - transform.position).normalized;\r\n        Ray ray = new Ray(transform.position, direction);\r\n        RaycastHit hit;\r\n        \r\n        if (Physics.Raycast(ray, out hit, Vector3.Distance(transform.position, target.position)))\r\n        {\r\n            // 检查是否命中目标\r\n            return hit.collider.transform == target;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 5.3 地面检测\r\n    /// </summary>\r\n    public bool IsGrounded(float groundDistance = 0.1f)\r\n    {\r\n        RaycastHit hit;\r\n        Vector3 origin = transform.position;\r\n        Vector3 direction = Vector3.down;\r\n        \r\n        if (Physics.Raycast(origin, direction, out hit, groundDistance + 0.1f))\r\n        {\r\n            float distance = hit.distance;\r\n            return distance <= groundDistance;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    /// <summary>\r\n    /// 5.4 范围检测（敌人检测）\r\n    /// </summary>\r\n    public List<GameObject> FindEnemiesInRange(float range)\r\n    {\r\n        List<GameObject> enemies = new List<GameObject>();\r\n        \r\n        Collider[] colliders = Physics.OverlapSphere(transform.position, range, layerMask);\r\n        \r\n        foreach (Collider col in colliders)\r\n        {\r\n            if (col.CompareTag(\"Enemy\"))\r\n            {\r\n                enemies.Add(col.gameObject);\r\n            }\r\n        }\r\n        \r\n        return enemies;\r\n    }\r\n    \r\n    #endregion\r\n}\r\n\r\n#region 最佳实践总结\r\n\r\n/*\r\n * Unity Raycast 最佳实践：\r\n * \r\n * 1. 射线检测方法选择：\r\n *    - Raycast: 单次检测，获取第一个碰撞（最常用）\r\n *    - RaycastAll: 检测所有碰撞（会产生 GC）\r\n *    - RaycastNonAlloc: 无 GC 分配检测（推荐，频繁调用时）\r\n * \r\n * 2. 性能优化：\r\n *    - 使用 RaycastNonAlloc 代替 RaycastAll（避免 GC）\r\n *    - 使用 OverlapSphereNonAlloc 代替 OverlapSphere\r\n *    - 合理设置 LayerMask 减少检测范围\r\n *    - 避免在 Update 中频繁调用（考虑缓存或分帧）\r\n * \r\n * 3. LayerMask 使用：\r\n *    - 在 Inspector 中设置（方便调试）\r\n *    - 使用位运算组合多个层\r\n *    - 使用 ~ 排除某些层\r\n *    - 避免检测所有层（layerMask = -1）\r\n * \r\n * 4. QueryTriggerInteraction：\r\n *    - UseGlobal: 使用全局设置\r\n *    - Ignore: 忽略触发器\r\n *    - Collide: 检测触发器\r\n * \r\n * 5. RaycastHit 信息：\r\n *    - point: 碰撞点\r\n *    - distance: 距离\r\n *    - normal: 法线\r\n *    - collider: 碰撞体\r\n *    - transform: Transform 组件\r\n *    - rigidbody: Rigidbody 组件\r\n * \r\n * 6. 常见应用场景：\r\n *    - 鼠标点击检测\r\n *    - 视线检测（AI）\r\n *    - 地面检测\r\n *    - 范围检测（敌人、物品）\r\n *    - 武器瞄准\r\n * \r\n * 7. 注意事项：\r\n *    - 射线检测需要碰撞体（Collider）\r\n *    - 2D 和 3D 使用不同的 API\r\n *    - 注意射线方向（forward 是正方向）\r\n *    - 检查返回值是否为 null（2D）或有效（3D）\r\n * \r\n * 8. 性能对比：\r\n *    - Raycast: 最快，单次检测\r\n *    - RaycastAll: 较慢，产生 GC\r\n *    - RaycastNonAlloc: 快，无 GC（推荐）\r\n *    - OverlapSphere: 较慢，产生 GC\r\n *    - OverlapSphereNonAlloc: 快，无 GC（推荐）\r\n */\r\n\r\n#endregion\r\n\r\n"
        }
    ]
}