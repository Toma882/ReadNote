{
    "sourceFile": "模块架构设计/Visual系统架构设计.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1767206104203,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1767206104203,
            "name": "Commit-0",
            "content": "# Visual 系统架构设计\r\n\r\n## 设计目标\r\n\r\n设计一套完整的视觉表现框架架构，支持多种视觉类型（动画、特效、后处理、相机控制等），实现对象池管理、序列编排、工厂模式、Context 模式，提供统一接口、高性能、易扩展的视觉表现系统。\r\n\r\n---\r\n\r\n## 核心设计理念\r\n\r\n### 1. 对象池 + 零 GC 设计为核心\r\n\r\n**本质**：Visual 系统的核心是对象池管理和零 GC 压力\r\n- 对象池管理 = 所有 Visual 对象通过对象池复用，避免频繁创建销毁\r\n- 零 GC 压力 = 对象复用，不产生临时对象，减少内存分配\r\n- 自动管理 = 系统自动处理对象池生命周期，无需手动管理\r\n- 高性能 = 避免频繁的内存分配和回收，提升运行效率\r\n\r\n### 2. Context 模式统一接口\r\n\r\n**本质**：所有 Visual 创建使用统一的 Context 参数，接口稳定，参数灵活扩展\r\n- 接口稳定 = 新增字段不破坏现有接口\r\n- 参数灵活 = 支持任意扩展字段，无需修改函数签名\r\n- 语义清晰 = 自解释的参数命名，易于理解和使用\r\n- 向后兼容 = 新增字段不影响旧代码，保持兼容性\r\n\r\n### 3. 序列编排 + 时间轴控制\r\n\r\n**本质**：通过 VisualSequence 实现复杂的时间轴编排，支持顺序、并行、延迟、回调\r\n- 复杂编排 = 支持任意复杂的时间轴组合\r\n- 链式调用 = 流畅的 API 设计，易于使用\r\n- 完整控制 = 播放、暂停、恢复、停止、跳转等完整控制\r\n- 自动回收 = 序列完成后自动回收到对象池\r\n\r\n### 4. 工厂模式 + 动态注册\r\n\r\n**本质**：通过工厂模式统一创建 Visual 对象，支持动态注册新的 Visual 类型\r\n- 统一创建 = 所有 Visual 通过统一接口创建\r\n- 易于扩展 = 新增 Visual 类型只需注册，无需修改核心代码\r\n- 类型安全 = 编译时检查继承关系，运行时类型验证\r\n\r\n---\r\n\r\n## 整体架构设计\r\n\r\n### 四层架构 + 对象池管理\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph SystemLayer[\"系统管理层<br/>VisualSystem\"]\r\n        ObjectPool[\"对象池管理<br/>TypePool\"]\r\n        Factory[\"工厂管理<br/>ObjFactory\"]\r\n        SequenceManager[\"序列管理<br/>activeSequenceSet\"]\r\n    end\r\n    \r\n    subgraph BaseLayer[\"基类层<br/>VisualBase\"]\r\n        VisualBase[\"VisualBase<br/>基类\"]\r\n        Lifecycle[\"生命周期管理<br/>Check/Execute/OnComplete/EnterPool\"]\r\n    end\r\n    \r\n    subgraph ImplementationLayer[\"实现层<br/>具体Visual类型\"]\r\n        AnimationVisual[\"AnimationVisual<br/>动画控制\"]\r\n        VFXVisual[\"VFXVisual<br/>粒子特效\"]\r\n        CinemachineVisual[\"CinemachineVisual<br/>相机控制\"]\r\n        PostProcessingVisual[\"PostProcessingVisual<br/>后处理\"]\r\n        MMFeedbacksVisual[\"MMFeedbacksVisual<br/>反馈系统\"]\r\n        TimelineVisual[\"TimelineVisual<br/>时间轴\"]\r\n        VolFxVisual[\"VolFxVisual<br/>艺术后处理\"]\r\n        VolFxTransitionVisual[\"VolFxTransitionVisual<br/>场景过渡\"]\r\n    end\r\n    \r\n    subgraph SequenceLayer[\"序列编排层<br/>VisualSequence\"]\r\n        Sequence[\"VisualSequence<br/>序列编排器\"]\r\n        VisualItemQueue[\"VisualItem队列<br/>管理序列项\"]\r\n    end\r\n    \r\n    SystemLayer -->|创建和管理| BaseLayer\r\n    Factory -->|注册和创建| ImplementationLayer\r\n    ImplementationLayer -->|继承| BaseLayer\r\n    SequenceLayer -->|编排| BaseLayer\r\n    SystemLayer -->|管理| SequenceLayer\r\n    \r\n    style SystemLayer fill:#f3e5f5\r\n    style BaseLayer fill:#e1f5ff\r\n    style ImplementationLayer fill:#fff4e1\r\n    style SequenceLayer fill:#c8e6c9\r\n```\r\n\r\n### 对象池数据流\r\n\r\n```mermaid\r\ngraph LR\r\n    Start[外部请求<br/>VisualSystem:Pop] -->|1. 从对象池获取| Pool[对象池<br/>TypePool]\r\n    Pool -->|2. 对象存在| Reuse[复用对象<br/>重置状态]\r\n    Pool -->|3. 对象不存在| Create[工厂创建<br/>ObjFactory]\r\n    \r\n    Create -->|4. 创建Visual对象| Visual[Visual对象<br/>执行表现]\r\n    Reuse -->|4. 复用Visual对象| Visual\r\n    \r\n    Visual -->|5. 执行完成| Check{是否在序列中?}\r\n    Check -->|是| AutoRecycle[序列自动回收]\r\n    Check -->|否| ManualRecycle[手动回收<br/>VisualSystem:Push]\r\n    \r\n    AutoRecycle -->|6. 回收到对象池| Pool\r\n    ManualRecycle -->|6. 回收到对象池| Pool\r\n    \r\n    style Pool fill:#e1f5ff\r\n    style Visual fill:#c8e6c9\r\n    style Check fill:#fff4e1,stroke:#333,stroke-width:2px\r\n```\r\n\r\n**数据流特性**：\r\n- ✅ **对象池优先**：所有 Visual 对象从对象池获取，优先复用\r\n- ✅ **自动管理**：序列中的 Visual 自动回收，单独使用需手动回收\r\n- ✅ **零 GC 压力**：对象复用，不产生临时对象\r\n- ✅ **工厂创建**：对象池为空时，通过工厂创建新对象\r\n- ✅ **生命周期完整**：创建、执行、完成、回收全流程管理\r\n\r\n---\r\n\r\n## 详细层级设计\r\n\r\n### 系统管理层架构设计\r\n\r\n#### 核心职责\r\n对象池管理 + 工厂管理 + 序列管理\r\n\r\n#### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph VisualSystem[\"VisualSystem<br/>系统管理器\"]\r\n        TypePool[\"对象池管理<br/>TypePool\"]\r\n        VisualPool[\"Visual对象池<br/>VisualPool\"]\r\n        SequencePool[\"Sequence对象池<br/>SequencePool\"]\r\n        \r\n        ObjFactory[\"工厂管理<br/>ObjFactory\"]\r\n        VisualClassRegistry[\"Visual类型注册表<br/>visualClasses\"]\r\n        \r\n        SequenceSet[\"序列管理<br/>activeSequenceSet<br/>LuaSet\"]\r\n    end\r\n    \r\n    External[外部调用] -->|Pop/Push| TypePool\r\n    TypePool -->|获取/回收| VisualPool\r\n    TypePool -->|获取/回收| SequencePool\r\n    \r\n    External -->|Pop| ObjFactory\r\n    ObjFactory -->|查询| VisualClassRegistry\r\n    ObjFactory -->|创建| VisualBase\r\n    \r\n    External -->|PopSequence| SequencePool\r\n    External -->|管理序列| SequenceSet\r\n    \r\n    style VisualSystem fill:#f3e5f5\r\n    style TypePool fill:#e1f5ff\r\n    style ObjFactory fill:#fff4e1\r\n    style SequenceSet fill:#c8e6c9\r\n```\r\n\r\n#### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[外部请求<br/>VisualSystem:Pop] --> CheckPool{对象池是否有对象?}\r\n    \r\n    CheckPool -->|有| PopFromPool[从对象池获取<br/>重置状态]\r\n    CheckPool -->|无| CreateNew[工厂创建新对象<br/>ObjFactory:Create]\r\n    \r\n    CreateNew --> Register[注册Visual类型<br/>VisualClassRegistry]\r\n    Register --> CreateInstance[创建实例<br/>VisualBase:ctor]\r\n    \r\n    PopFromPool --> Init[初始化Context<br/>VisualBase:ctor]\r\n    CreateInstance --> Init\r\n    \r\n    Init --> Return[返回Visual对象]\r\n    \r\n    Return --> Execute[执行表现<br/>Visual:Execute]\r\n    \r\n    Execute --> CheckSequence{是否在序列中?}\r\n    CheckSequence -->|是| AutoRecycle[序列自动回收<br/>VisualSystem:Push]\r\n    CheckSequence -->|否| ManualRecycle[手动回收<br/>VisualSystem:Push]\r\n    \r\n    AutoRecycle --> End[回收到对象池]\r\n    ManualRecycle --> End\r\n    \r\n    style CheckPool fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style CheckSequence fill:#fff4e1,stroke:#333,stroke-width:2px\r\n```\r\n\r\n#### 核心组件\r\n\r\n1. **对象池管理（TypePool）**\r\n   - 管理 Visual 对象池和 Sequence 对象池\r\n   - 提供 Pop/Push 接口，自动处理对象复用\r\n   - 支持对象重置和清理\r\n\r\n2. **工厂管理（ObjFactory）**\r\n   - 维护 Visual 类型注册表\r\n   - 根据 visualType 创建对应的 Visual 对象\r\n   - 支持动态注册新的 Visual 类型\r\n\r\n3. **序列管理（activeSequenceSet）**\r\n   - 管理所有活跃的序列对象\r\n   - 跟踪序列生命周期\r\n   - 支持序列自动回收\r\n\r\n---\r\n\r\n### 基类层架构设计\r\n\r\n#### 核心职责\r\n统一接口 + 生命周期管理 + Context 模式\r\n\r\n#### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph VisualBase[\"VisualBase<br/>基类\"]\r\n        Ctor[\"构造函数<br/>ctor(context)\"]\r\n        Check[\"执行前检查<br/>Check(context)\"]\r\n        Execute[\"执行表现<br/>Execute(context)\"]\r\n        OnComplete[\"完成回调<br/>OnComplete()\"]\r\n        EnterPool[\"回收到对象池<br/>EnterPool()\"]\r\n        \r\n        Priority[\"优先级管理<br/>SetPriority\"]\r\n        Delay[\"延迟管理<br/>SetDelay\"]\r\n        Ease[\"缓动曲线<br/>SetEase\"]\r\n    end\r\n    \r\n    Context[Context参数<br/>统一接口] --> Ctor\r\n    Ctor --> Check\r\n    Check -->|通过| Execute\r\n    Check -->|失败| Error[错误处理]\r\n    Execute --> OnComplete\r\n    OnComplete --> EnterPool\r\n    \r\n    style VisualBase fill:#e1f5ff\r\n    style Context fill:#fff4e1\r\n```\r\n\r\n#### 生命周期流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[创建Visual对象<br/>VisualSystem:Pop] --> Ctor[构造函数<br/>VisualBase:ctor]\r\n    Ctor --> Init[初始化Context<br/>保存target/visualType等]\r\n    \r\n    Init --> Execute[执行表现<br/>Visual:Execute]\r\n    Execute --> Check{执行前检查<br/>Visual:Check}\r\n    \r\n    Check -->|通过| DoExecute[执行具体表现<br/>子类实现]\r\n    Check -->|失败| Error[错误处理<br/>返回失败]\r\n    \r\n    DoExecute --> Wait[等待执行完成<br/>异步/同步]\r\n    Wait --> OnComplete[完成回调<br/>Visual:OnComplete]\r\n    \r\n    OnComplete --> CheckSequence{是否在序列中?}\r\n    CheckSequence -->|是| AutoRecycle[序列自动回收]\r\n    CheckSequence -->|否| ManualRecycle[手动回收]\r\n    \r\n    AutoRecycle --> EnterPool[回收到对象池<br/>Visual:EnterPool]\r\n    ManualRecycle --> EnterPool\r\n    \r\n    EnterPool --> Reset[重置状态<br/>清理数据]\r\n    Reset --> End[回收到对象池]\r\n    \r\n    style Check fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style CheckSequence fill:#fff4e1,stroke:#333,stroke-width:2px\r\n```\r\n\r\n#### 核心组件\r\n\r\n1. **构造函数（ctor）**\r\n   - 使用 Context 模式初始化\r\n   - 保存 target、visualType 等基础参数\r\n   - 子类可重写进行自定义初始化\r\n\r\n2. **执行前检查（Check）**\r\n   - 验证 Context 参数有效性\r\n   - 检查目标对象是否存在\r\n   - 子类可重写添加自定义检查\r\n\r\n3. **执行表现（Execute）**\r\n   - 子类必须实现\r\n   - 执行具体的视觉表现逻辑\r\n   - 支持异步和同步执行\r\n\r\n4. **完成回调（OnComplete）**\r\n   - 表现完成时自动调用\r\n   - 子类可重写进行自定义处理\r\n   - 触发自动回收流程\r\n\r\n5. **回收到对象池（EnterPool）**\r\n   - 清理对象状态\r\n   - 重置所有字段\r\n   - 准备下次复用\r\n\r\n---\r\n\r\n### 实现层架构设计\r\n\r\n#### 核心职责\r\n具体视觉表现实现 + 类型特定逻辑\r\n\r\n#### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph ImplementationLayer[\"实现层\"]\r\n        AnimationVisual[\"AnimationVisual<br/>Unity动画控制\"]\r\n        VFXVisual[\"VFXVisual<br/>粒子特效系统\"]\r\n        CinemachineVisual[\"CinemachineVisual<br/>相机控制\"]\r\n        PostProcessingVisual[\"PostProcessingVisual<br/>后处理效果\"]\r\n        MMFeedbacksVisual[\"MMFeedbacksVisual<br/>MMFeedbacks反馈\"]\r\n        TimelineVisual[\"TimelineVisual<br/>Unity Timeline\"]\r\n        VolFxVisual[\"VolFxVisual<br/>VolFx艺术后处理\"]\r\n        VolFxTransitionVisual[\"VolFxTransitionVisual<br/>场景过渡\"]\r\n    end\r\n    \r\n    VisualBase[VisualBase基类] -.继承.-> ImplementationLayer\r\n    \r\n    Context[Context参数] --> ImplementationLayer\r\n    ImplementationLayer -->|执行| UnitySystem[Unity系统<br/>Animation/VFX/Camera等]\r\n    \r\n    style ImplementationLayer fill:#fff4e1\r\n    style VisualBase fill:#e1f5ff\r\n    style UnitySystem fill:#c8e6c9\r\n```\r\n\r\n#### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[创建具体Visual<br/>VisualSystem:Pop] --> ParseContext[解析Context<br/>提取类型特定参数]\r\n    \r\n    ParseContext --> CheckType{Visual类型}\r\n    \r\n    CheckType -->|Animation| Animation[AnimationVisual<br/>播放Unity动画]\r\n    CheckType -->|VFX| VFX[VFXVisual<br/>播放粒子特效]\r\n    CheckType -->|Cinemachine| Cinemachine[CinemachineVisual<br/>控制相机]\r\n    CheckType -->|PostProcess| PostProcess[PostProcessingVisual<br/>应用后处理]\r\n    CheckType -->|MMFeedbacks| MMFeedbacks[MMFeedbacksVisual<br/>触发反馈]\r\n    CheckType -->|Timeline| Timeline[TimelineVisual<br/>播放Timeline]\r\n    CheckType -->|VolFx| VolFx[VolFxVisual<br/>应用艺术后处理]\r\n    CheckType -->|VolFxTransition| VolFxTransition[VolFxTransitionVisual<br/>场景过渡]\r\n    \r\n    Animation --> Execute[执行Unity系统调用]\r\n    VFX --> Execute\r\n    Cinemachine --> Execute\r\n    PostProcess --> Execute\r\n    MMFeedbacks --> Execute\r\n    Timeline --> Execute\r\n    VolFx --> Execute\r\n    VolFxTransition --> Execute\r\n    \r\n    Execute --> Wait[等待执行完成]\r\n    Wait --> OnComplete[完成回调]\r\n    \r\n    style CheckType fill:#fff4e1,stroke:#333,stroke-width:2px\r\n```\r\n\r\n#### 支持的 Visual 类型\r\n\r\n| 类型 | 枚举值 | 说明 | 文件 |\r\n|-----|------|------|------|\r\n| **Animation** | `EVisual.Animation` | Unity 动画控制 | `Visuals/AnimationVisual.lua` |\r\n| **VFX** | `EVisual.VFX` | 粒子特效系统 | `Visuals/VFXVisual.lua` |\r\n| **Cinemachine** | `EVisual.Cinemachine` | 相机控制 | `Visuals/CinemachineVisual.lua` |\r\n| **PostProcessing** | `EVisual.PostProcess` | 后处理效果 | `Visuals/PostProcessingVisual.lua` |\r\n| **MMFeedbacks** | `EVisual.MMFeedbacks` | MMFeedbacks 反馈系统 | `MMFeedbacks/MMFeedbacksVisual.lua` |\r\n| **Timeline** | `EVisual.Timeline` | Unity Timeline 时间轴系统（模板驱动，支持动态创建） | `Timeline/TimelineVisual.lua` |\r\n| **VolFx** | `EVisual.VolFx` | VolFx 艺术后处理效果 | `VolFx/VolFxVisual.lua` |\r\n| **VolFxTransition** | `EVisual.VolFxTransition` | VolFx 场景过渡效果 | `VolFx/VolFxTransitionVisual.lua` |\r\n\r\n---\r\n\r\n### 序列编排层架构设计\r\n\r\n#### 核心职责\r\n时间轴编排 + 顺序/并行控制 + 延迟/回调管理\r\n\r\n#### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph VisualSequence[\"VisualSequence<br/>序列编排器\"]\r\n        VisualItemQueue[\"VisualItem队列<br/>管理序列项\"]\r\n        TimeTracker[\"时间追踪器<br/>currentTime/endTime\"]\r\n        PlaybackControl[\"播放控制<br/>Play/Pause/Resume/Kill\"]\r\n        LoopControl[\"循环控制<br/>SetLoops\"]\r\n        TimeScaleControl[\"时间缩放<br/>SetTimeScale\"]\r\n    end\r\n    \r\n    Append[Append<br/>顺序添加] --> VisualItemQueue\r\n    Join[Join<br/>并行添加] --> VisualItemQueue\r\n    AppendInterval[AppendInterval<br/>添加延迟] --> VisualItemQueue\r\n    AppendCallback[AppendCallback<br/>添加回调] --> VisualItemQueue\r\n    \r\n    VisualItemQueue --> TimeTracker\r\n    TimeTracker --> PlaybackControl\r\n    \r\n    style VisualSequence fill:#c8e6c9\r\n    style VisualItemQueue fill:#e1f5ff\r\n```\r\n\r\n#### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[创建序列<br/>VisualSystem:PopSequence] --> Init[初始化序列<br/>重置状态]\r\n    \r\n    Init --> Append[添加Visual项<br/>Append/Join/AppendInterval/AppendCallback]\r\n    \r\n    Append --> BuildQueue[构建VisualItem队列<br/>计算时间轴]\r\n    \r\n    BuildQueue --> Play[开始播放<br/>VisualSequence:Play]\r\n    \r\n    Play --> Update[每帧更新<br/>检查时间轴]\r\n    \r\n    Update --> CheckTime{检查当前时间<br/>是否到达项的开始时间?}\r\n    \r\n    CheckTime -->|到达| ExecuteItem[执行Visual项<br/>Visual:Execute]\r\n    CheckTime -->|未到达| Update\r\n    \r\n    ExecuteItem --> CheckComplete{项是否完成?}\r\n    \r\n    CheckComplete -->|完成| NextItem[下一个项]\r\n    CheckComplete -->|未完成| Update\r\n    \r\n    NextItem --> CheckQueue{队列是否为空?}\r\n    \r\n    CheckQueue -->|有项| Update\r\n    CheckQueue -->|无项| CheckLoop{是否循环?}\r\n    \r\n    CheckLoop -->|是| Reset[重置序列<br/>重新开始]\r\n    CheckLoop -->|否| Complete[序列完成<br/>触发完成回调]\r\n    \r\n    Reset --> Update\r\n    Complete --> AutoRecycle[自动回收<br/>VisualSystem:PushSequence]\r\n    \r\n    style CheckTime fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style CheckComplete fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style CheckQueue fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style CheckLoop fill:#fff4e1,stroke:#333,stroke-width:2px\r\n```\r\n\r\n#### 编排模式\r\n\r\n**1. 顺序执行**\r\n\r\n```mermaid\r\ngantt\r\n    title 顺序执行时间轴\r\n    dateFormat X\r\n    axisFormat %Ls\r\n    \r\n    Visual1 :0, 1000\r\n    Visual2 :1000, 1000\r\n    Visual3 :2000, 1000\r\n```\r\n\r\n**2. 并行执行**\r\n\r\n```mermaid\r\ngantt\r\n    title 并行执行时间轴\r\n    dateFormat X\r\n    axisFormat %Ls\r\n    \r\n    Visual1 :0, 1000\r\n    Visual2 :500, 1000\r\n    Visual3 :1000, 1000\r\n```\r\n\r\n**3. 混合编排**\r\n\r\n```mermaid\r\ngantt\r\n    title 混合编排时间轴\r\n    dateFormat X\r\n    axisFormat %Ls\r\n    \r\n    Visual1 :0, 1000\r\n    Visual2 :1000, 500\r\n    Visual3 :1500, 500\r\n    Visual4 :1500, 500\r\n    Delay :2000, 500\r\n    Visual5 :2500, 1000\r\n    Callback :3500, 0\r\n```\r\n\r\n#### 核心组件\r\n\r\n1. **VisualItem 队列**\r\n   - 管理序列中的所有项（Visual、延迟、回调）\r\n   - 按时间轴排序，支持顺序和并行\r\n   - 跟踪每个项的执行状态\r\n\r\n2. **时间追踪器**\r\n   - 维护当前播放时间（currentTime）\r\n   - 计算序列结束时间（endTime）\r\n   - 支持时间缩放（timeScale）\r\n\r\n3. **播放控制**\r\n   - Play：开始播放序列\r\n   - Pause：暂停播放\r\n   - Resume：恢复播放\r\n   - Kill：停止并清理序列\r\n   - SeekTo：跳转到指定时间\r\n\r\n4. **循环控制**\r\n   - 支持设置循环次数\r\n   - 支持无限循环\r\n   - 循环完成后触发完成回调\r\n\r\n---\r\n\r\n## 架构模式分析\r\n\r\n### 1. 对象池模式\r\n\r\n**应用场景**：所有 Visual 对象和 Sequence 对象\r\n\r\n**设计优势**：\r\n- ✅ **零 GC 压力**：对象复用，不产生临时对象\r\n- ✅ **高性能**：避免频繁的内存分配和回收\r\n- ✅ **自动管理**：系统自动处理对象池生命周期\r\n\r\n**实现方式**：\r\n- 使用 TypePool 管理对象池\r\n- Pop 时从对象池获取，Push 时回收到对象池\r\n- 对象重置和清理在 EnterPool 中完成\r\n\r\n### 2. Context 模式\r\n\r\n**应用场景**：所有 Visual 创建接口\r\n\r\n**设计优势**：\r\n- ✅ **接口稳定**：新增字段不破坏现有接口\r\n- ✅ **参数灵活**：支持任意扩展字段\r\n- ✅ **语义清晰**：自解释的参数命名\r\n- ✅ **向后兼容**：新增字段不影响旧代码\r\n\r\n**实现方式**：\r\n- 所有 Visual 创建使用统一的 Context 参数\r\n- Context 包含必需字段（target、visualType）和可选字段\r\n- 子类可扩展 Context 添加类型特定参数\r\n\r\n### 3. 工厂模式\r\n\r\n**应用场景**：Visual 对象创建\r\n\r\n**设计优势**：\r\n- ✅ **统一创建**：所有 Visual 通过统一接口创建\r\n- ✅ **易于扩展**：新增 Visual 类型只需注册\r\n- ✅ **类型安全**：编译时检查继承关系\r\n\r\n**实现方式**：\r\n- 使用 ObjFactory 管理 Visual 类型注册表\r\n- 根据 visualType 创建对应的 Visual 对象\r\n- 支持动态注册新的 Visual 类型\r\n\r\n### 4. 模板方法模式\r\n\r\n**应用场景**：VisualBase 生命周期管理\r\n\r\n**设计优势**：\r\n- ✅ **统一流程**：所有 Visual 遵循相同的生命周期\r\n- ✅ **灵活扩展**：子类可重写特定方法\r\n- ✅ **代码复用**：基类提供通用逻辑\r\n\r\n**实现方式**：\r\n- VisualBase 定义生命周期模板方法\r\n- 子类重写 Execute、Check 等特定方法\r\n- 基类控制整体流程\r\n\r\n### 5. 策略模式\r\n\r\n**应用场景**：不同 Visual 类型的执行策略\r\n\r\n**设计优势**：\r\n- ✅ **类型隔离**：每种 Visual 类型独立实现\r\n- ✅ **易于扩展**：新增类型不影响现有类型\r\n- ✅ **统一接口**：所有类型使用相同的接口\r\n\r\n**实现方式**：\r\n- 每种 Visual 类型实现独立的执行逻辑\r\n- 通过工厂模式创建不同类型的实例\r\n- 统一通过 VisualBase 接口调用\r\n\r\n---\r\n\r\n## 数据流设计\r\n\r\n### Context 数据流\r\n\r\n```mermaid\r\ngraph LR\r\n    External[外部调用] -->|创建Context| Context[Context参数<br/>target/visualType/...]\r\n    Context -->|Pop| System[VisualSystem<br/>对象池/工厂]\r\n    System -->|创建| Visual[Visual对象<br/>保存Context]\r\n    Visual -->|Execute| Unity[Unity系统<br/>执行表现]\r\n    Unity -->|完成| OnComplete[完成回调]\r\n    OnComplete -->|回收| System\r\n    \r\n    style Context fill:#fff4e1\r\n    style System fill:#f3e5f5\r\n    style Visual fill:#e1f5ff\r\n    style Unity fill:#c8e6c9\r\n```\r\n\r\n### 序列编排数据流\r\n\r\n```mermaid\r\ngraph TD\r\n    Start[创建序列] --> Append[添加Visual项<br/>Append/Join]\r\n    Append --> Build[构建时间轴<br/>计算开始/结束时间]\r\n    Build --> Play[开始播放<br/>Play]\r\n    Play --> Update[每帧更新<br/>检查时间轴]\r\n    Update --> Execute[执行Visual项<br/>Visual:Execute]\r\n    Execute --> Complete[项完成<br/>OnComplete]\r\n    Complete --> Next[下一个项]\r\n    Next -->|有项| Update\r\n    Next -->|无项| SequenceComplete[序列完成<br/>自动回收]\r\n    \r\n    style Start fill:#fff4e1\r\n    style Play fill:#c8e6c9\r\n    style Execute fill:#e1f5ff\r\n```\r\n\r\n### 对象池数据流\r\n\r\n```mermaid\r\ngraph LR\r\n    Pop[Pop请求] -->|1. 检查对象池| Pool{对象池有对象?}\r\n    Pool -->|有| Reuse[复用对象<br/>重置状态]\r\n    Pool -->|无| Create[工厂创建<br/>新对象]\r\n    Reuse -->|2. 返回对象| Visual[Visual对象]\r\n    Create -->|2. 返回对象| Visual\r\n    Visual -->|3. 使用完成| Push[Push请求]\r\n    Push -->|4. 回收到对象池| Pool\r\n    \r\n    style Pool fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style Visual fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 架构验证\r\n\r\n### 性能验证\r\n\r\n从架构可验证：\r\n- ✅ **零 GC 压力**：对象池管理，对象复用，不产生临时对象\r\n- ✅ **高性能**：避免频繁的内存分配和回收，提升运行效率\r\n- ✅ **自动管理**：系统自动处理对象池生命周期，无需手动管理\r\n\r\n### 扩展性验证\r\n\r\n从架构可验证：\r\n- ✅ **易于扩展**：新增 Visual 类型只需继承 VisualBase 并注册\r\n- ✅ **接口稳定**：Context 模式保证接口稳定，新增字段不影响现有代码\r\n- ✅ **类型安全**：工厂模式保证类型安全，编译时检查继承关系\r\n\r\n### 易用性验证\r\n\r\n从架构可验证：\r\n- ✅ **统一接口**：所有 Visual 使用相同的创建和执行接口\r\n- ✅ **链式调用**：序列编排支持链式调用，API 流畅易用\r\n- ✅ **自动回收**：序列中的 Visual 自动回收，简化使用流程\r\n\r\n### 完整性验证\r\n\r\n从架构可验证：\r\n- ✅ **四层架构**：系统层、基类层、实现层、序列层，覆盖全流程\r\n- ✅ **生命周期完整**：创建、执行、完成、回收全流程管理\r\n- ✅ **多类型支持**：8 种 Visual 类型，易于扩展\r\n- ✅ **序列编排**：支持顺序、并行、延迟、回调的复杂时间轴\r\n\r\n---\r\n\r\n## 开发指导原则\r\n\r\n### 1. Context 参数设计\r\n\r\n**✅ 推荐**：使用 Context 模式，参数清晰明确\r\n\r\n```lua\r\nlocal context = {\r\n    target = gameObject,\r\n    visualType = EVisual.Animation,\r\n    duration = 1.0,\r\n    delay = 0.5,\r\n    priority = EVisualPriority.High,\r\n    values = {\r\n        clipName = \"Attack\",\r\n        speed = 1.5\r\n    }\r\n}\r\n```\r\n\r\n**❌ 不推荐**：参数过多，难以维护\r\n\r\n```lua\r\n-- 不推荐：参数过多\r\nlocal visual = CreateVisual(gameObject, EVisual.Animation, 1.0, 0.5, EVisualPriority.High, \"Attack\", 1.5, ...)\r\n```\r\n\r\n### 2. 对象池使用\r\n\r\n**✅ 推荐**：让系统自动管理对象池\r\n\r\n```lua\r\n-- 序列中自动回收\r\nlocal sequence = VisualSystem:PopSequence()\r\nsequence:Append(visual1, nil, 0, 1.0)\r\nsequence:Append(visual2, nil, 1.0, 1.0)\r\nsequence:Play()  -- 完成后自动回收\r\n```\r\n\r\n**⚠️ 注意**：单独使用时需要手动回收\r\n\r\n```lua\r\nlocal visual = VisualSystem:Pop(context)\r\nvisual:Execute(context)\r\n-- 使用完毕后回收\r\nVisualSystem:Push(visual)\r\n```\r\n\r\n### 3. 序列生命周期\r\n\r\n**✅ 推荐**：使用自动回收\r\n\r\n```lua\r\nlocal sequence = VisualSystem:PopSequence()\r\nsequence:SetAutoRecycle(true)  -- 默认开启\r\nsequence:Append(...)\r\nsequence:Play()  -- 完成后自动回收\r\n```\r\n\r\n**⚠️ 注意**：需要手动控制时关闭自动回收\r\n\r\n```lua\r\nlocal sequence = VisualSystem:PopSequence()\r\nsequence:SetAutoRecycle(false)\r\nsequence:Append(...)\r\nsequence:Play()\r\n\r\n-- 稍后手动回收\r\nVisualSystem:PushSequence(sequence)\r\n```\r\n\r\n### 4. 错误处理\r\n\r\n**✅ 推荐**：检查 Visual 创建是否成功\r\n\r\n```lua\r\nlocal visual = VisualSystem:Pop(context)\r\nif not visual then\r\n    LogError(\"创建 Visual 失败\")\r\n    return\r\nend\r\n\r\nvisual:Execute(context)\r\n```\r\n\r\n### 5. 性能优化\r\n\r\n**✅ 推荐**：复用 Visual 对象\r\n\r\n```lua\r\n-- 在序列中复用同一个 Visual\r\nlocal visual = VisualSystem:Pop(context)\r\nlocal sequence = VisualSystem:PopSequence()\r\n\r\nsequence:Append(visual, nil, 0, 1.0)\r\nsequence:Append(visual, nil, 1.0, 1.0)  -- 复用\r\nsequence:Play()\r\n```\r\n\r\n**❌ 不推荐**：频繁创建销毁\r\n\r\n```lua\r\n-- 不推荐：每次都创建新的 Visual\r\nfor i = 1, 100 do\r\n    local visual = VisualSystem:Pop(context)\r\n    visual:Execute(context)\r\n    VisualSystem:Push(visual)\r\nend\r\n```\r\n\r\n---\r\n\r\n## 高级特性\r\n\r\n### Timeline 系统\r\n\r\nTimeline 系统是 Visual 框架中的**模板驱动 Timeline 系统**，支持通过模板快速创建复杂的 Unity Timeline 时间轴，并支持动态创建轨道和剪辑。\r\n\r\n**核心特性**：\r\n- ✅ **模板驱动**：通过模板快速创建复杂 Timeline\r\n- ✅ **配置化设计**：使用 Context 模式，参数灵活扩展\r\n- ✅ **分层架构**：Template → ClipTemplate → TimelineAsset\r\n- ✅ **动态创建**：运行时创建 Timeline 资源和轨道\r\n- ✅ **8种轨道类型**：Animation、Audio、Cinemachine、Signal 等\r\n- ✅ **10+ 模板类型**：BossEntry、CombatStart、Cutscene 等\r\n\r\n**架构图**：\r\n\r\n```mermaid\r\ngraph TB\r\n    TimelineVisual[TimelineVisual<br/>Visual实现] --> TimelineRule[TimelineRule<br/>规则和映射系统]\r\n    TimelineRule --> TimelineTemplate[TimelineTemplate<br/>Timeline模板]\r\n    TimelineTemplate --> TimelineClipTemplate[TimelineClipTemplate<br/>轨道剪辑模板]\r\n    TimelineClipTemplate --> TimelineAsset[TimelineAsset<br/>Unity Timeline资源]\r\n    \r\n    style TimelineVisual fill:#fff4e1\r\n    style TimelineRule fill:#e1f5ff\r\n    style TimelineTemplate fill:#c8e6c9\r\n    style TimelineClipTemplate fill:#f3e5f5\r\n```\r\n\r\n### VolFx 系统\r\n\r\nVolFx 系统是 Visual 框架中的**艺术后处理效果系统**，基于 VolFx 插件提供丰富的后处理效果，支持动态效果管理、模板化配置和场景过渡。\r\n\r\n**核心特性**：\r\n- ✅ **Volume 管理**：自动管理 Volume 组件和 Profile\r\n- ✅ **动态效果控制**：运行时激活/禁用效果\r\n- ✅ **批量操作**：支持批量激活/禁用多个效果\r\n- ✅ **模板系统**：快速应用预设效果组合\r\n- ✅ **场景过渡**：支持场景切换过渡效果\r\n- ✅ **33+ 效果类型**：Blur、Bloom、Glitch、Vhs、Watercolor 等\r\n- ✅ **URP 集成**：完全支持 URP 渲染管线\r\n\r\n**架构图**：\r\n\r\n```mermaid\r\ngraph TB\r\n    VolFxVisual[VolFxVisual<br/>核心后处理效果] --> VolumeManager[Volume管理<br/>组件和Profile]\r\n    VolFxVisual --> EffectManager[效果管理<br/>激活/禁用]\r\n    \r\n    VolFxTransitionVisual[VolFxTransitionVisual<br/>场景过渡效果] --> MovePool[Move组件对象池]\r\n    VolFxTransitionVisual --> PrefabLoader[预制体加载器]\r\n    \r\n    VolFxTemplate[VolFxTemplate<br/>模板系统] --> VolFxVisual\r\n    VolFxTemplate --> VolFxTransitionVisual\r\n    \r\n    style VolFxVisual fill:#fff4e1\r\n    style VolFxTransitionVisual fill:#e1f5ff\r\n    style VolFxTemplate fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 总结\r\n\r\n### 架构设计价值\r\n\r\n该架构设计文档的价值在于：\r\n- ✅ **思路解构**：完整解构 Visual 系统的搭建思路\r\n- ✅ **流程验证**：从架构层面验证流程合理性\r\n- ✅ **性能优化**：对象池管理实现零 GC 压力和高性能\r\n- ✅ **开发指导**：为后续详细设计和实现提供清晰指导\r\n\r\n### 设计原则\r\n\r\n- ✅ **对象池优先**：所有 Visual 对象通过对象池管理，零 GC 压力\r\n- ✅ **Context 模式**：统一接口，参数灵活扩展\r\n- ✅ **序列编排**：支持复杂时间轴，链式调用 API\r\n- ✅ **工厂模式**：统一创建接口，支持动态注册\r\n- ✅ **生命周期完整**：创建、执行、完成、回收全流程管理\r\n\r\n### 架构特点\r\n\r\n- ✅ **四层架构**：系统层、基类层、实现层、序列层，职责清晰\r\n- ✅ **对象池管理**：零 GC 压力，高性能复用\r\n- ✅ **统一接口**：Context 模式保证接口稳定和灵活扩展\r\n- ✅ **序列编排**：支持顺序、并行、延迟、回调的复杂时间轴\r\n- ✅ **易于扩展**：新增 Visual 类型只需继承并注册\r\n\r\n细节实现是后续开发阶段的工作，当前架构设计已足够指导整个 Visual 系统的开发。\r\n"
        }
    ]
}