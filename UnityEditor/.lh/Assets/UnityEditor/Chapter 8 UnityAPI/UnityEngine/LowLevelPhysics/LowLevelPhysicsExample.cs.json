{
    "sourceFile": "Assets/UnityEditor/Chapter 8 UnityAPI/UnityEngine/LowLevelPhysics/LowLevelPhysicsExample.cs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1750934925156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1750934925156,
            "name": "Commit-0",
            "content": "using UnityEngine;\r\nusing Unity.Collections;\r\nusing Unity.Jobs;\r\nusing Unity.Burst;\r\nusing Unity.Physics;\r\n\r\n/// <summary>\r\n/// UnityEngine.LowLevelPhysics 命名空间案例演示\r\n/// 展示底层物理系统、物理作业、性能优化等核心功能\r\n/// </summary>\r\npublic class LowLevelPhysicsExample : MonoBehaviour\r\n{\r\n    [Header(\"底层物理配置\")]\r\n    [SerializeField] private bool enableLowLevelPhysics = true; //启用底层物理\r\n    [SerializeField] private bool enablePhysicsJobs = true; //启用物理作业\r\n    [SerializeField] private bool enableBurstPhysics = true; //启用Burst物理\r\n    [SerializeField] private bool enablePhysicsProfiling = true; //启用物理分析\r\n    [SerializeField] private bool enableCollisionDetection = true; //启用碰撞检测\r\n    \r\n    [Header(\"物理参数\")]\r\n    [SerializeField] private int physicsObjectCount = 100; //物理对象数量\r\n    [SerializeField] private int physicsJobBatchSize = 64; //物理作业批处理大小\r\n    [SerializeField] private float physicsTimeStep = 0.02f; //物理时间步长\r\n    [SerializeField] private int physicsIterations = 6; //物理迭代次数\r\n    [SerializeField] private bool useFixedTimestep = true; //使用固定时间步长\r\n    \r\n    [Header(\"物理性能\")]\r\n    [SerializeField] private bool enablePerformanceOptimization = true; //启用性能优化\r\n    [SerializeField] private bool enableSpatialPartitioning = true; //启用空间分区\r\n    [SerializeField] private bool enableBroadPhaseOptimization = true; //启用宽相优化\r\n    [SerializeField] private bool enableNarrowPhaseOptimization = true; //启用窄相优化\r\n    \r\n    [Header(\"物理状态\")]\r\n    [SerializeField] private int activePhysicsObjects = 0; //活跃物理对象数\r\n    [SerializeField] private int activeCollisions = 0; //活跃碰撞数\r\n    [SerializeField] private int physicsJobsCompleted = 0; //物理作业完成数\r\n    [SerializeField] private float physicsUpdateTime = 0f; //物理更新时间\r\n    [SerializeField] private float collisionDetectionTime = 0f; //碰撞检测时间\r\n    [SerializeField] private float physicsMemoryUsage = 0f; //物理内存使用\r\n    \r\n    [Header(\"物理数据\")]\r\n    [SerializeField] private NativeArray<Vector3> physicsPositions; //物理位置\r\n    [SerializeField] private NativeArray<Vector3> physicsVelocities; //物理速度\r\n    [SerializeField] private NativeArray<Vector3> physicsForces; //物理力\r\n    [SerializeField] private NativeArray<float> physicsMasses; //物理质量\r\n    [SerializeField] private NativeArray<CollisionData> collisionData; //碰撞数据\r\n    \r\n    [Header(\"性能监控\")]\r\n    [SerializeField] private bool enablePhysicsMonitoring = true; //启用物理监控\r\n    [SerializeField] private float monitoringInterval = 1f; //监控间隔\r\n    [SerializeField] private bool logPhysicsData = false; //记录物理数据\r\n    [SerializeField] private int maxPhysicsSamples = 100; //最大物理样本数\r\n    \r\n    [Header(\"性能历史\")]\r\n    [SerializeField] private float[] physicsPerformanceHistory = new float[100]; //物理性能历史\r\n    [SerializeField] private int performanceIndex = 0; //性能索引\r\n    [SerializeField] private float averagePhysicsPerformance = 0f; //平均物理性能\r\n    [SerializeField] private float minPhysicsPerformance = 0f; //最低物理性能\r\n    [SerializeField] private float maxPhysicsPerformance = 0f; //最高物理性能\r\n    \r\n    private JobHandle[] physicsJobHandles;\r\n    private System.Collections.Generic.List<JobHandle> activePhysicsJobs = new System.Collections.Generic.List<JobHandle>();\r\n    private float lastPhysicsUpdateTime = 0f;\r\n    private float lastMonitoringTime = 0f;\r\n    private bool isInitialized = false;\r\n    private PhysicsWorld physicsWorld;\r\n\r\n    private void Start()\r\n    {\r\n        InitializeLowLevelPhysics();\r\n    }\r\n\r\n    /// <summary>\r\n    /// 初始化底层物理系统\r\n    /// </summary>\r\n    private void InitializeLowLevelPhysics()\r\n    {\r\n        // 初始化物理数据\r\n        InitializePhysicsData();\r\n        \r\n        // 初始化物理作业\r\n        InitializePhysicsJobs();\r\n        \r\n        // 初始化物理世界\r\n        InitializePhysicsWorld();\r\n        \r\n        // 初始化性能监控\r\n        InitializePhysicsMonitoring();\r\n        \r\n        // 配置物理系统\r\n        ConfigurePhysicsSystem();\r\n        \r\n        isInitialized = true;\r\n        Debug.Log(\"底层物理系统初始化完成\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 初始化物理数据\r\n    /// </summary>\r\n    private void InitializePhysicsData()\r\n    {\r\n        // 创建物理数据数组\r\n        physicsPositions = new NativeArray<Vector3>(physicsObjectCount, Allocator.Persistent);\r\n        physicsVelocities = new NativeArray<Vector3>(physicsObjectCount, Allocator.Persistent);\r\n        physicsForces = new NativeArray<Vector3>(physicsObjectCount, Allocator.Persistent);\r\n        physicsMasses = new NativeArray<float>(physicsObjectCount, Allocator.Persistent);\r\n        collisionData = new NativeArray<CollisionData>(physicsObjectCount * 10, Allocator.Persistent);\r\n        \r\n        // 初始化物理对象\r\n        for (int i = 0; i < physicsObjectCount; i++)\r\n        {\r\n            physicsPositions[i] = Random.insideUnitSphere * 10f;\r\n            physicsVelocities[i] = Random.insideUnitSphere * 5f;\r\n            physicsForces[i] = Vector3.zero;\r\n            physicsMasses[i] = Random.Range(0.1f, 10f);\r\n        }\r\n        \r\n        activePhysicsObjects = physicsObjectCount;\r\n        Debug.Log($\"物理数据初始化完成: 对象数量={physicsObjectCount}\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 初始化物理作业\r\n    /// </summary>\r\n    private void InitializePhysicsJobs()\r\n    {\r\n        if (enablePhysicsJobs)\r\n        {\r\n            physicsJobHandles = new JobHandle[10]; // 最多10个并发物理作业\r\n            Debug.Log(\"物理作业系统初始化完成\");\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 初始化物理世界\r\n    /// </summary>\r\n    private void InitializePhysicsWorld()\r\n    {\r\n        // 创建物理世界\r\n        physicsWorld = new PhysicsWorld();\r\n        \r\n        // 配置物理世界参数\r\n        physicsWorld.Gravity = new Unity.Mathematics.float3(0, -9.81f, 0);\r\n        \r\n        Debug.Log(\"物理世界初始化完成\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 初始化物理监控\r\n    /// </summary>\r\n    private void InitializePhysicsMonitoring()\r\n    {\r\n        if (enablePhysicsMonitoring)\r\n        {\r\n            physicsPerformanceHistory = new float[maxPhysicsSamples];\r\n            performanceIndex = 0;\r\n            averagePhysicsPerformance = 0f;\r\n            minPhysicsPerformance = 0f;\r\n            maxPhysicsPerformance = 0f;\r\n            \r\n            Debug.Log(\"物理监控初始化完成\");\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 配置物理系统\r\n    /// </summary>\r\n    private void ConfigurePhysicsSystem()\r\n    {\r\n        // 设置物理时间步长\r\n        Time.fixedDeltaTime = physicsTimeStep;\r\n        \r\n        // 设置物理迭代次数\r\n        Physics.defaultSolverIterations = physicsIterations;\r\n        \r\n        // 配置性能优化\r\n        if (enablePerformanceOptimization)\r\n        {\r\n            Physics.autoSimulation = false; // 禁用自动物理模拟\r\n            Physics.autoSyncTransforms = false; // 禁用自动同步变换\r\n        }\r\n        \r\n        Debug.Log(\"物理系统配置完成\");\r\n    }\r\n\r\n    private void Update()\r\n    {\r\n        if (!isInitialized) return;\r\n        \r\n        // 更新物理系统\r\n        UpdatePhysicsSystem();\r\n        \r\n        // 执行物理作业\r\n        ExecutePhysicsJobs();\r\n        \r\n        // 物理监控\r\n        if (enablePhysicsMonitoring && Time.time - lastMonitoringTime > monitoringInterval)\r\n        {\r\n            MonitorPhysicsPerformance();\r\n            lastMonitoringTime = Time.time;\r\n        }\r\n    }\r\n\r\n    private void FixedUpdate()\r\n    {\r\n        if (!isInitialized || !useFixedTimestep) return;\r\n        \r\n        // 固定时间步长物理更新\r\n        UpdatePhysicsFixedStep();\r\n    }\r\n\r\n    /// <summary>\r\n    /// 更新物理系统\r\n    /// </summary>\r\n    private void UpdatePhysicsSystem()\r\n    {\r\n        float startTime = Time.realtimeSinceStartup;\r\n        \r\n        // 更新物理世界\r\n        UpdatePhysicsWorld();\r\n        \r\n        // 碰撞检测\r\n        if (enableCollisionDetection)\r\n        {\r\n            PerformCollisionDetection();\r\n        }\r\n        \r\n        // 物理模拟\r\n        PerformPhysicsSimulation();\r\n        \r\n        physicsUpdateTime = Time.realtimeSinceStartup - startTime;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 更新物理世界\r\n    /// </summary>\r\n    private void UpdatePhysicsWorld()\r\n    {\r\n        // 更新物理世界状态\r\n        physicsWorld.Gravity = new Unity.Mathematics.float3(0, -9.81f, 0);\r\n        \r\n        // 更新物理对象\r\n        for (int i = 0; i < activePhysicsObjects; i++)\r\n        {\r\n            // 应用重力\r\n            physicsForces[i] += new Vector3(0, -9.81f * physicsMasses[i], 0);\r\n            \r\n            // 更新速度\r\n            physicsVelocities[i] += physicsForces[i] * Time.deltaTime / physicsMasses[i];\r\n            \r\n            // 更新位置\r\n            physicsPositions[i] += physicsVelocities[i] * Time.deltaTime;\r\n            \r\n            // 重置力\r\n            physicsForces[i] = Vector3.zero;\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 执行碰撞检测\r\n    /// </summary>\r\n    private void PerformCollisionDetection()\r\n    {\r\n        float startTime = Time.realtimeSinceStartup;\r\n        \r\n        activeCollisions = 0;\r\n        \r\n        // 简单的碰撞检测（球体碰撞）\r\n        for (int i = 0; i < activePhysicsObjects; i++)\r\n        {\r\n            for (int j = i + 1; j < activePhysicsObjects; j++)\r\n            {\r\n                float distance = Vector3.Distance(physicsPositions[i], physicsPositions[j]);\r\n                float minDistance = 1.0f; // 最小距离\r\n                \r\n                if (distance < minDistance)\r\n                {\r\n                    // 记录碰撞\r\n                    if (activeCollisions < collisionData.Length)\r\n                    {\r\n                        collisionData[activeCollisions] = new CollisionData\r\n                        {\r\n                            objectA = i,\r\n                            objectB = j,\r\n                            collisionPoint = (physicsPositions[i] + physicsPositions[j]) * 0.5f,\r\n                            collisionNormal = (physicsPositions[j] - physicsPositions[i]).normalized,\r\n                            penetrationDepth = minDistance - distance\r\n                        };\r\n                        activeCollisions++;\r\n                    }\r\n                    \r\n                    // 简单的碰撞响应\r\n                    Vector3 separation = (physicsPositions[j] - physicsPositions[i]).normalized * (minDistance - distance) * 0.5f;\r\n                    physicsPositions[i] -= separation;\r\n                    physicsPositions[j] += separation;\r\n                }\r\n            }\r\n        }\r\n        \r\n        collisionDetectionTime = Time.realtimeSinceStartup - startTime;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 执行物理模拟\r\n    /// </summary>\r\n    private void PerformPhysicsSimulation()\r\n    {\r\n        // 这里可以实现更复杂的物理模拟\r\n        // 例如：约束求解、接触力计算等\r\n        \r\n        if (logPhysicsData)\r\n        {\r\n            Debug.Log($\"物理模拟: 对象数={activePhysicsObjects}, 碰撞数={activeCollisions}\");\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 执行物理作业\r\n    /// </summary>\r\n    private void ExecutePhysicsJobs()\r\n    {\r\n        if (!enablePhysicsJobs) return;\r\n        \r\n        // 清理完成的作业\r\n        CleanupCompletedPhysicsJobs();\r\n        \r\n        // 执行新作业\r\n        if (activePhysicsJobs.Count < physicsJobHandles.Length)\r\n        {\r\n            ExecutePhysicsJob();\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 执行物理作业\r\n    /// </summary>\r\n    private void ExecutePhysicsJob()\r\n    {\r\n        if (enableBurstPhysics)\r\n        {\r\n            var job = new PhysicsBurstJob\r\n            {\r\n                positions = physicsPositions,\r\n                velocities = physicsVelocities,\r\n                forces = physicsForces,\r\n                masses = physicsMasses,\r\n                deltaTime = Time.deltaTime,\r\n                gravity = new Unity.Mathematics.float3(0, -9.81f, 0)\r\n            };\r\n            \r\n            var jobHandle = job.Schedule(activePhysicsObjects, physicsJobBatchSize);\r\n            activePhysicsJobs.Add(jobHandle);\r\n            \r\n            if (logPhysicsData)\r\n            {\r\n                Debug.Log($\"Burst物理作业已调度: 对象数={activePhysicsObjects}, 批处理={physicsJobBatchSize}\");\r\n            }\r\n        }\r\n        else\r\n        {\r\n            var job = new PhysicsJob\r\n            {\r\n                positions = physicsPositions,\r\n                velocities = physicsVelocities,\r\n                forces = physicsForces,\r\n                masses = physicsMasses,\r\n                deltaTime = Time.deltaTime,\r\n                gravity = new Unity.Mathematics.float3(0, -9.81f, 0)\r\n            };\r\n            \r\n            var jobHandle = job.Schedule(activePhysicsObjects, physicsJobBatchSize);\r\n            activePhysicsJobs.Add(jobHandle);\r\n            \r\n            if (logPhysicsData)\r\n            {\r\n                Debug.Log($\"普通物理作业已调度: 对象数={activePhysicsObjects}, 批处理={physicsJobBatchSize}\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 清理完成的物理作业\r\n    /// </summary>\r\n    private void CleanupCompletedPhysicsJobs()\r\n    {\r\n        for (int i = activePhysicsJobs.Count - 1; i >= 0; i--)\r\n        {\r\n            if (activePhysicsJobs[i].IsCompleted)\r\n            {\r\n                activePhysicsJobs[i].Complete();\r\n                activePhysicsJobs.RemoveAt(i);\r\n                physicsJobsCompleted++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 更新固定时间步长物理\r\n    /// </summary>\r\n    private void UpdatePhysicsFixedStep()\r\n    {\r\n        // 固定时间步长的物理更新\r\n        float fixedDeltaTime = Time.fixedDeltaTime;\r\n        \r\n        // 执行物理模拟\r\n        for (int i = 0; i < activePhysicsObjects; i++)\r\n        {\r\n            // 应用重力\r\n            physicsForces[i] += new Vector3(0, -9.81f * physicsMasses[i], 0);\r\n            \r\n            // 更新速度\r\n            physicsVelocities[i] += physicsForces[i] * fixedDeltaTime / physicsMasses[i];\r\n            \r\n            // 更新位置\r\n            physicsPositions[i] += physicsVelocities[i] * fixedDeltaTime;\r\n            \r\n            // 重置力\r\n            physicsForces[i] = Vector3.zero;\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 监控物理性能\r\n    /// </summary>\r\n    private void MonitorPhysicsPerformance()\r\n    {\r\n        float currentPerformance = 1f / physicsUpdateTime;\r\n        \r\n        // 更新性能历史\r\n        physicsPerformanceHistory[performanceIndex] = currentPerformance;\r\n        performanceIndex = (performanceIndex + 1) % maxPhysicsSamples;\r\n        \r\n        // 计算性能统计\r\n        CalculatePhysicsPerformanceStats();\r\n        \r\n        // 计算内存使用\r\n        physicsMemoryUsage = CalculatePhysicsMemoryUsage();\r\n        \r\n        if (logPhysicsData)\r\n        {\r\n            Debug.Log($\"物理性能监控: 性能={currentPerformance:F1}, 对象数={activePhysicsObjects}, 碰撞数={activeCollisions}\");\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 计算物理性能统计\r\n    /// </summary>\r\n    private void CalculatePhysicsPerformanceStats()\r\n    {\r\n        float sum = 0f;\r\n        minPhysicsPerformance = float.MaxValue;\r\n        maxPhysicsPerformance = 0f;\r\n        \r\n        for (int i = 0; i < maxPhysicsSamples; i++)\r\n        {\r\n            float value = physicsPerformanceHistory[i];\r\n            sum += value;\r\n            \r\n            if (value < minPhysicsPerformance) minPhysicsPerformance = value;\r\n            if (value > maxPhysicsPerformance) maxPhysicsPerformance = value;\r\n        }\r\n        \r\n        averagePhysicsPerformance = sum / maxPhysicsSamples;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 计算物理内存使用\r\n    /// </summary>\r\n    /// <returns>物理内存使用量（MB）</returns>\r\n    private float CalculatePhysicsMemoryUsage()\r\n    {\r\n        long totalMemory = 0;\r\n        \r\n        if (physicsPositions.IsCreated)\r\n            totalMemory += physicsPositions.Length * sizeof(float) * 3;\r\n        if (physicsVelocities.IsCreated)\r\n            totalMemory += physicsVelocities.Length * sizeof(float) * 3;\r\n        if (physicsForces.IsCreated)\r\n            totalMemory += physicsForces.Length * sizeof(float) * 3;\r\n        if (physicsMasses.IsCreated)\r\n            totalMemory += physicsMasses.Length * sizeof(float);\r\n        if (collisionData.IsCreated)\r\n            totalMemory += collisionData.Length * sizeof(float) * 10; // 估算碰撞数据大小\r\n        \r\n        return totalMemory / (1024f * 1024f);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 执行物理优化\r\n    /// </summary>\r\n    public void ExecutePhysicsOptimization()\r\n    {\r\n        Debug.Log(\"开始物理优化...\");\r\n        \r\n        // 空间分区优化\r\n        if (enableSpatialPartitioning)\r\n        {\r\n            OptimizeSpatialPartitioning();\r\n        }\r\n        \r\n        // 宽相优化\r\n        if (enableBroadPhaseOptimization)\r\n        {\r\n            OptimizeBroadPhase();\r\n        }\r\n        \r\n        // 窄相优化\r\n        if (enableNarrowPhaseOptimization)\r\n        {\r\n            OptimizeNarrowPhase();\r\n        }\r\n        \r\n        Debug.Log(\"物理优化完成\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 空间分区优化\r\n    /// </summary>\r\n    private void OptimizeSpatialPartitioning()\r\n    {\r\n        // 实现空间分区算法（如网格、四叉树、八叉树等）\r\n        Debug.Log(\"空间分区优化已执行\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 宽相优化\r\n    /// </summary>\r\n    private void OptimizeBroadPhase()\r\n    {\r\n        // 实现宽相碰撞检测优化\r\n        Debug.Log(\"宽相优化已执行\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 窄相优化\r\n    /// </summary>\r\n    private void OptimizeNarrowPhase()\r\n    {\r\n        // 实现窄相碰撞检测优化\r\n        Debug.Log(\"窄相优化已执行\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 生成物理报告\r\n    /// </summary>\r\n    public void GeneratePhysicsReport()\r\n    {\r\n        Debug.Log(\"=== 底层物理系统报告 ===\");\r\n        Debug.Log($\"活跃物理对象: {activePhysicsObjects}\");\r\n        Debug.Log($\"活跃碰撞数: {activeCollisions}\");\r\n        Debug.Log($\"物理作业完成数: {physicsJobsCompleted}\");\r\n        Debug.Log($\"物理更新时间: {physicsUpdateTime * 1000:F2} ms\");\r\n        Debug.Log($\"碰撞检测时间: {collisionDetectionTime * 1000:F2} ms\");\r\n        Debug.Log($\"物理内存使用: {physicsMemoryUsage:F2} MB\");\r\n        Debug.Log($\"平均物理性能: {averagePhysicsPerformance:F1}\");\r\n        Debug.Log($\"最低物理性能: {minPhysicsPerformance:F1}\");\r\n        Debug.Log($\"最高物理性能: {maxPhysicsPerformance:F1}\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 重置物理系统\r\n    /// </summary>\r\n    public void ResetPhysicsSystem()\r\n    {\r\n        Debug.Log(\"重置物理系统...\");\r\n        \r\n        // 清理物理作业\r\n        CleanupCompletedPhysicsJobs();\r\n        JobHandle.CompleteAll(activePhysicsJobs.ToArray());\r\n        activePhysicsJobs.Clear();\r\n        \r\n        // 重置物理数据\r\n        for (int i = 0; i < physicsObjectCount; i++)\r\n        {\r\n            physicsPositions[i] = Random.insideUnitSphere * 10f;\r\n            physicsVelocities[i] = Random.insideUnitSphere * 5f;\r\n            physicsForces[i] = Vector3.zero;\r\n            physicsMasses[i] = Random.Range(0.1f, 10f);\r\n        }\r\n        \r\n        activeCollisions = 0;\r\n        physicsJobsCompleted = 0;\r\n        \r\n        Debug.Log(\"物理系统重置完成\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 导出物理数据\r\n    /// </summary>\r\n    public void ExportPhysicsData()\r\n    {\r\n        var data = new PhysicsData\r\n        {\r\n            timestamp = System.DateTime.Now.ToString(),\r\n            activePhysicsObjects = activePhysicsObjects,\r\n            activeCollisions = activeCollisions,\r\n            physicsJobsCompleted = physicsJobsCompleted,\r\n            physicsUpdateTime = physicsUpdateTime,\r\n            collisionDetectionTime = collisionDetectionTime,\r\n            physicsMemoryUsage = physicsMemoryUsage,\r\n            averagePhysicsPerformance = averagePhysicsPerformance,\r\n            minPhysicsPerformance = minPhysicsPerformance,\r\n            maxPhysicsPerformance = maxPhysicsPerformance,\r\n            physicsPerformanceHistory = physicsPerformanceHistory\r\n        };\r\n        \r\n        string json = JsonUtility.ToJson(data, true);\r\n        string filename = $\"lowlevel_physics_{System.DateTime.Now:yyyyMMdd_HHmmss}.json\";\r\n        \r\n        System.IO.File.WriteAllText(filename, json);\r\n        Debug.Log($\"物理数据已导出: {filename}\");\r\n    }\r\n\r\n    private void OnGUI()\r\n    {\r\n        GUILayout.BeginArea(new Rect(10, 10, 400, 800));\r\n        GUILayout.Label(\"LowLevelPhysics 底层物理系统演示\", UnityEditor.EditorStyles.boldLabel);\r\n        \r\n        GUILayout.Space(10);\r\n        GUILayout.Label(\"物理配置:\");\r\n        enableLowLevelPhysics = GUILayout.Toggle(enableLowLevelPhysics, \"启用底层物理\");\r\n        enablePhysicsJobs = GUILayout.Toggle(enablePhysicsJobs, \"启用物理作业\");\r\n        enableBurstPhysics = GUILayout.Toggle(enableBurstPhysics, \"启用Burst物理\");\r\n        enablePhysicsProfiling = GUILayout.Toggle(enablePhysicsProfiling, \"启用物理分析\");\r\n        enableCollisionDetection = GUILayout.Toggle(enableCollisionDetection, \"启用碰撞检测\");\r\n        \r\n        GUILayout.Space(10);\r\n        GUILayout.Label(\"物理参数:\");\r\n        physicsObjectCount = int.TryParse(GUILayout.TextField(\"物理对象数量\", physicsObjectCount.ToString()), out var objectCount) ? objectCount : physicsObjectCount;\r\n        physicsJobBatchSize = int.TryParse(GUILayout.TextField(\"物理作业批处理大小\", physicsJobBatchSize.ToString()), out var batchSize) ? batchSize : physicsJobBatchSize;\r\n        physicsTimeStep = float.TryParse(GUILayout.TextField(\"物理时间步长\", physicsTimeStep.ToString()), out var timeStep) ? timeStep : physicsTimeStep;\r\n        physicsIterations = int.TryParse(GUILayout.TextField(\"物理迭代次数\", physicsIterations.ToString()), out var iterations) ? iterations : physicsIterations;\r\n        useFixedTimestep = GUILayout.Toggle(useFixedTimestep, \"使用固定时间步长\");\r\n        \r\n        GUILayout.Space(10);\r\n        GUILayout.Label(\"性能优化:\");\r\n        enablePerformanceOptimization = GUILayout.Toggle(enablePerformanceOptimization, \"启用性能优化\");\r\n        enableSpatialPartitioning = GUILayout.Toggle(enableSpatialPartitioning, \"启用空间分区\");\r\n        enableBroadPhaseOptimization = GUILayout.Toggle(enableBroadPhaseOptimization, \"启用宽相优化\");\r\n        enableNarrowPhaseOptimization = GUILayout.Toggle(enableNarrowPhaseOptimization, \"启用窄相优化\");\r\n        \r\n        GUILayout.Space(10);\r\n        GUILayout.Label(\"物理状态:\");\r\n        GUILayout.Label($\"活跃物理对象: {activePhysicsObjects}\");\r\n        GUILayout.Label($\"活跃碰撞数: {activeCollisions}\");\r\n        GUILayout.Label($\"物理作业完成数: {physicsJobsCompleted}\");\r\n        GUILayout.Label($\"物理更新时间: {physicsUpdateTime * 1000:F2} ms\");\r\n        GUILayout.Label($\"碰撞检测时间: {collisionDetectionTime * 1000:F2} ms\");\r\n        GUILayout.Label($\"物理内存使用: {physicsMemoryUsage:F2} MB\");\r\n        \r\n        GUILayout.Space(10);\r\n        GUILayout.Label(\"性能数据:\");\r\n        GUILayout.Label($\"平均物理性能: {averagePhysicsPerformance:F1}\");\r\n        GUILayout.Label($\"最低物理性能: {minPhysicsPerformance:F1}\");\r\n        GUILayout.Label($\"最高物理性能: {maxPhysicsPerformance:F1}\");\r\n        \r\n        GUILayout.Space(10);\r\n        \r\n        if (GUILayout.Button(\"执行物理优化\"))\r\n        {\r\n            ExecutePhysicsOptimization();\r\n        }\r\n        \r\n        if (GUILayout.Button(\"生成物理报告\"))\r\n        {\r\n            GeneratePhysicsReport();\r\n        }\r\n        \r\n        if (GUILayout.Button(\"重置物理系统\"))\r\n        {\r\n            ResetPhysicsSystem();\r\n        }\r\n        \r\n        if (GUILayout.Button(\"导出物理数据\"))\r\n        {\r\n            ExportPhysicsData();\r\n        }\r\n        \r\n        GUILayout.EndArea();\r\n    }\r\n\r\n    private void OnDestroy()\r\n    {\r\n        // 清理物理数据\r\n        if (physicsPositions.IsCreated)\r\n            physicsPositions.Dispose();\r\n        if (physicsVelocities.IsCreated)\r\n            physicsVelocities.Dispose();\r\n        if (physicsForces.IsCreated)\r\n            physicsForces.Dispose();\r\n        if (physicsMasses.IsCreated)\r\n            physicsMasses.Dispose();\r\n        if (collisionData.IsCreated)\r\n            collisionData.Dispose();\r\n        \r\n        // 清理物理作业\r\n        CleanupCompletedPhysicsJobs();\r\n        JobHandle.CompleteAll(activePhysicsJobs.ToArray());\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 碰撞数据\r\n/// </summary>\r\n[System.Serializable]\r\npublic struct CollisionData\r\n{\r\n    public int objectA;\r\n    public int objectB;\r\n    public Vector3 collisionPoint;\r\n    public Vector3 collisionNormal;\r\n    public float penetrationDepth;\r\n}\r\n\r\n/// <summary>\r\n/// Burst物理作业\r\n/// </summary>\r\n[BurstCompile]\r\npublic struct PhysicsBurstJob : IJobParallelFor\r\n{\r\n    [NativeDisableParallelForRestriction] public NativeArray<Vector3> positions;\r\n    [NativeDisableParallelForRestriction] public NativeArray<Vector3> velocities;\r\n    [NativeDisableParallelForRestriction] public NativeArray<Vector3> forces;\r\n    [ReadOnly] public NativeArray<float> masses;\r\n    public float deltaTime;\r\n    public Unity.Mathematics.float3 gravity;\r\n    \r\n    public void Execute(int index)\r\n    {\r\n        // 应用重力\r\n        forces[index] += new Vector3(gravity.x, gravity.y, gravity.z) * masses[index];\r\n        \r\n        // 更新速度\r\n        velocities[index] += forces[index] * deltaTime / masses[index];\r\n        \r\n        // 更新位置\r\n        positions[index] += velocities[index] * deltaTime;\r\n        \r\n        // 重置力\r\n        forces[index] = Vector3.zero;\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 普通物理作业\r\n/// </summary>\r\npublic struct PhysicsJob : IJobParallelFor\r\n{\r\n    [NativeDisableParallelForRestriction] public NativeArray<Vector3> positions;\r\n    [NativeDisableParallelForRestriction] public NativeArray<Vector3> velocities;\r\n    [NativeDisableParallelForRestriction] public NativeArray<Vector3> forces;\r\n    [ReadOnly] public NativeArray<float> masses;\r\n    public float deltaTime;\r\n    public Unity.Mathematics.float3 gravity;\r\n    \r\n    public void Execute(int index)\r\n    {\r\n        // 应用重力\r\n        forces[index] += new Vector3(gravity.x, gravity.y, gravity.z) * masses[index];\r\n        \r\n        // 更新速度\r\n        velocities[index] += forces[index] * deltaTime / masses[index];\r\n        \r\n        // 更新位置\r\n        positions[index] += velocities[index] * deltaTime;\r\n        \r\n        // 重置力\r\n        forces[index] = Vector3.zero;\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 物理数据类\r\n/// </summary>\r\n[System.Serializable]\r\npublic class PhysicsData\r\n{\r\n    public string timestamp;\r\n    public int activePhysicsObjects;\r\n    public int activeCollisions;\r\n    public int physicsJobsCompleted;\r\n    public float physicsUpdateTime;\r\n    public float collisionDetectionTime;\r\n    public float physicsMemoryUsage;\r\n    public float averagePhysicsPerformance;\r\n    public float minPhysicsPerformance;\r\n    public float maxPhysicsPerformance;\r\n    public float[] physicsPerformanceHistory;\r\n} "
        }
    ]
}