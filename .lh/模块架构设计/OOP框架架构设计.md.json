{
    "sourceFile": "模块架构设计/OOP框架架构设计.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1767203874191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1767203874191,
            "name": "Commit-0",
            "content": "# OOP框架架构设计\r\n\r\n## 设计目标\r\n\r\n设计一套完整的Lua面向对象编程框架，支持接口机制、事件系统、装饰器模式、对象工厂，提供结构化、可维护的Lua代码编写方案，特别适合在Unity游戏中使用。\r\n\r\n---\r\n\r\n## 核心设计理念\r\n\r\n### 1. 接口机制为核心\r\n\r\n**本质**：OOP框架的核心是接口机制，解决Lua单继承的限制\r\n- 接口定义 = 定义一组方法契约\r\n- 多重继承 = 通过接口混入实现多重继承效果\r\n- 接口混入 = 在类构造函数中混入接口\r\n- 契约约束 = 通过接口明确定义类必须实现的方法\r\n\r\n### 2. 设计模式组合\r\n\r\n**本质**：通过组合多种设计模式提供完整的OOP支持\r\n- 接口模式 = 解决Lua单继承限制\r\n- 观察者模式 = 事件系统实现对象间松耦合通信\r\n- 装饰器模式 = 动态扩展对象功能\r\n- 工厂模式 = 简化对象创建和管理\r\n\r\n### 3. 混入机制 + 链式调用\r\n\r\n**本质**：通过混入机制实现接口继承，通过链式调用提供流畅API\r\n- 混入机制 = ByInheritance方法实现接口混入\r\n- 链式调用 = 流畅的API设计，易于使用\r\n- 接口隔离 = 每个接口只定义相关的方法\r\n- 组合复用 = 通过接口组合实现功能复用\r\n\r\n---\r\n\r\n## 整体架构设计\r\n\r\n### 四模块架构 + 接口机制\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph InterfaceModule[\"接口模块<br/>Interface\"]\r\n        InterfaceBase[\"接口基类<br/>Interface\"]\r\n        MixinMechanism[\"混入机制<br/>ByInheritance\"]\r\n        MultipleInheritance[\"多重继承<br/>支持多个接口\"]\r\n    end\r\n    \r\n    subgraph EventModule[\"事件模块<br/>IEvent\"]\r\n        EventInterface[\"事件接口<br/>IEvent\"]\r\n        EventRegistry[\"事件注册表<br/>eventListeners\"]\r\n        EventTrigger[\"事件触发<br/>TriggerEvent\"]\r\n    end\r\n    \r\n    subgraph DecoratorModule[\"装饰器模块<br/>IDecorator\"]\r\n        DecoratorInterface[\"装饰器接口<br/>IDecorator\"]\r\n        DecoratorBehavior[\"装饰器行为<br/>IDecoratorBehavior\"]\r\n        DecoratorChain[\"装饰器链<br/>装饰器执行链\"]\r\n    end\r\n    \r\n    subgraph FactoryModule[\"工厂模块<br/>ObjFactory\"]\r\n        FactoryInterface[\"工厂接口<br/>ObjFactory\"]\r\n        TypeRegistry[\"类型注册表<br/>objClassDict\"]\r\n        ObjectPool[\"对象池<br/>对象复用\"]\r\n    end\r\n    \r\n    style InterfaceModule fill:#e1f5ff\r\n    style EventModule fill:#fff4e1\r\n    style DecoratorModule fill:#c8e6c9\r\n    style FactoryModule fill:#f3e5f5\r\n```\r\n\r\n### 接口混入数据流\r\n\r\n```mermaid\r\ngraph LR\r\n    Start[创建类实例] -->|1. 构造函数| Ctor[ctor方法<br/>初始化]\r\n    Ctor -->|2. 创建接口实例| CreateInterface[接口实例<br/>MyInterface.New()]\r\n    CreateInterface -->|3. 混入接口| Mixin[混入接口<br/>ByInheritance(self)]\r\n    Mixin -->|4. 绑定方法| Bind[绑定方法<br/>self.method = interface.method]\r\n    Bind -->|5. 完成| End[接口混入完成]\r\n    \r\n    style CreateInterface fill:#e1f5ff\r\n    style Mixin fill:#fff4e1\r\n    style Bind fill:#c8e6c9\r\n```\r\n\r\n**数据流特性**：\r\n- ✅ **多重继承**：通过接口混入实现多重继承效果\r\n- ✅ **契约约束**：通过接口明确定义类必须实现的方法\r\n- ✅ **灵活组合**：可以混入多个接口，实现功能组合\r\n- ✅ **运行时绑定**：接口方法在运行时绑定到类实例\r\n\r\n---\r\n\r\n## 接口模块架构设计\r\n\r\n### 核心职责\r\n\r\n接口定义 + 接口混入 + 多重继承支持\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph Interface[\"Interface接口基类\"]\r\n        InterfaceBase[\"接口基类<br/>Interface\"]\r\n        ByInheritance[\"混入方法<br/>ByInheritance(target)\"]\r\n        MethodBinding[\"方法绑定<br/>绑定接口方法到目标\"]\r\n    end\r\n    \r\n    subgraph ConcreteInterface[\"具体接口\"]\r\n        MyInterface[\"MyInterface<br/>自定义接口\"]\r\n        IEvent[\"IEvent<br/>事件接口\"]\r\n        IDecorator[\"IDecorator<br/>装饰器接口\"]\r\n    end\r\n    \r\n    subgraph TargetClass[\"目标类\"]\r\n        MyClass[\"MyClass<br/>使用接口的类\"]\r\n        MethodImplementation[\"方法实现<br/>实现接口方法\"]\r\n    end\r\n    \r\n    Interface -->|继承| ConcreteInterface\r\n    ConcreteInterface -->|混入| TargetClass\r\n    TargetClass -->|实现| MethodImplementation\r\n    \r\n    style Interface fill:#e1f5ff\r\n    style ConcreteInterface fill:#fff4e1\r\n    style TargetClass fill:#c8e6c9\r\n```\r\n\r\n### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[创建类实例<br/>MyClass.New()] --> Ctor[调用构造函数<br/>ctor]\r\n    Ctor --> CreateInterface[创建接口实例<br/>MyInterface.New()]\r\n    CreateInterface --> CallMixin[调用混入方法<br/>ByInheritance(self)]\r\n    CallMixin --> BindMethods[绑定接口方法<br/>遍历接口方法]\r\n    BindMethods --> CheckMethod{目标类<br/>是否已实现方法?}\r\n    CheckMethod -->|是| Skip[跳过绑定<br/>使用类实现]\r\n    CheckMethod -->|否| Bind[绑定接口方法<br/>self.method = interface.method]\r\n    Bind --> Complete[混入完成]\r\n    Skip --> Complete\r\n    \r\n    style CheckMethod fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style Bind fill:#c8e6c9\r\n    style Complete fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 事件模块架构设计\r\n\r\n### 核心职责\r\n\r\n事件注册 + 事件触发 + 事件管理\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph IEvent[\"IEvent事件接口\"]\r\n        EventRegistry[\"事件注册表<br/>eventListeners[eventName]\"]\r\n        SetEventListener[\"注册事件<br/>SetEventListener\"]\r\n        TriggerEvent[\"触发事件<br/>TriggerEvent\"]\r\n        RemoveListener[\"移除监听<br/>RemoveListener\"]\r\n    end\r\n    \r\n    subgraph EventFlow[\"事件流\"]\r\n        Register[注册事件监听<br/>SetEventListener]\r\n        Trigger[触发事件<br/>TriggerEvent]\r\n        Notify[通知所有监听者<br/>调用回调函数]\r\n    end\r\n    \r\n    IEvent -->|管理| EventRegistry\r\n    IEvent -->|执行| EventFlow\r\n    \r\n    style IEvent fill:#e1f5ff\r\n    style EventFlow fill:#fff4e1\r\n```\r\n\r\n---\r\n\r\n## 装饰器模块架构设计\r\n\r\n### 核心职责\r\n\r\n装饰器定义 + 装饰器安装 + 装饰器执行链\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph IDecorator[\"IDecorator装饰器接口\"]\r\n        DecoratorBase[\"装饰器基类<br/>IDecorator\"]\r\n        DecorateMethod[\"装饰方法<br/>覆盖或扩展原方法\"]\r\n    end\r\n    \r\n    subgraph IDecoratorBehavior[\"IDecoratorBehavior装饰器行为\"]\r\n        DecoratorList[\"装饰器列表<br/>decoratorList\"]\r\n        AddDecorator[\"添加装饰器<br/>AddExtendDecorator\"]\r\n        ExecuteChain[\"执行链<br/>按顺序执行装饰器\"]\r\n    end\r\n    \r\n    subgraph DecoratorFlow[\"装饰器流\"]\r\n        OriginalMethod[原始方法<br/>Character:Attack]\r\n        Decorator1[装饰器1<br/>FireDecorator:Attack]\r\n        Decorator2[装饰器2<br/>IceDecorator:Attack]\r\n        FinalResult[最终结果<br/>组合所有装饰器效果]\r\n    end\r\n    \r\n    IDecorator -->|实现| DecoratorBase\r\n    IDecoratorBehavior -->|管理| DecoratorList\r\n    DecoratorList -->|执行| DecoratorFlow\r\n    \r\n    style IDecorator fill:#e1f5ff\r\n    style IDecoratorBehavior fill:#fff4e1\r\n    style DecoratorFlow fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 工厂模块架构设计\r\n\r\n### 核心职责\r\n\r\n类型注册 + 对象创建 + 对象池管理\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph ObjFactory[\"ObjFactory对象工厂\"]\r\n        TypeRegistry[\"类型注册表<br/>objClassDict[typeName]\"]\r\n        CreateObject[\"创建对象<br/>CreateObject\"]\r\n        ObjectPool[\"对象池<br/>对象复用\"]\r\n    end\r\n    \r\n    subgraph FactoryFlow[\"工厂流\"]\r\n        RegisterType[注册类型<br/>AddObjClass]\r\n        CreateByType[按类型创建<br/>CreateObject]\r\n        RecycleObject[回收对象<br/>Push]\r\n    end\r\n    \r\n    ObjFactory -->|管理| TypeRegistry\r\n    ObjFactory -->|执行| FactoryFlow\r\n    \r\n    style ObjFactory fill:#e1f5ff\r\n    style FactoryFlow fill:#fff4e1\r\n```\r\n\r\n---\r\n\r\n## 架构模式分析\r\n\r\n### 接口模式（Interface Pattern）\r\n\r\n**核心思想**：通过接口定义契约，通过混入实现多重继承\r\n\r\n```mermaid\r\ngraph TB\r\n    Interface[接口<br/>Interface]\r\n    ConcreteInterface[具体接口<br/>MyInterface]\r\n    TargetClass[目标类<br/>MyClass]\r\n    \r\n    Interface -->|继承| ConcreteInterface\r\n    ConcreteInterface -->|混入| TargetClass\r\n    TargetClass -->|实现| Method[方法实现]\r\n    \r\n    style Interface fill:#f3e5f5\r\n    style ConcreteInterface fill:#e1f5ff\r\n    style TargetClass fill:#c8e6c9\r\n```\r\n\r\n**优势**：\r\n- ✅ **多重继承**：解决Lua单继承的限制\r\n- ✅ **契约约束**：通过接口明确定义类必须实现的方法\r\n- ✅ **灵活组合**：可以混入多个接口，实现功能组合\r\n\r\n### 观察者模式（Observer Pattern）\r\n\r\n**核心思想**：事件系统实现对象间松耦合通信\r\n\r\n```mermaid\r\ngraph TB\r\n    Subject[主题<br/>EventUser]\r\n    Observer1[观察者1<br/>Listener1]\r\n    Observer2[观察者2<br/>Listener2]\r\n    \r\n    Subject -->|注册| Observer1\r\n    Subject -->|注册| Observer2\r\n    Subject -->|触发事件| Observer1\r\n    Subject -->|触发事件| Observer2\r\n    \r\n    style Subject fill:#f3e5f5\r\n    style Observer1 fill:#c8e6c9\r\n    style Observer2 fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 数据流设计\r\n\r\n### 接口混入数据流\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Client as 客户端\r\n    participant MyClass as MyClass\r\n    participant Interface as MyInterface\r\n    participant Target as 目标对象\r\n    \r\n    Client->>MyClass: New() 创建实例\r\n    MyClass->>MyClass: ctor() 构造函数\r\n    MyClass->>Interface: New() 创建接口实例\r\n    Interface-->>MyClass: 返回接口实例\r\n    MyClass->>Interface: ByInheritance(self)\r\n    Interface->>Target: 绑定接口方法\r\n    Target-->>Interface: 绑定完成\r\n    Interface-->>MyClass: 混入完成\r\n    MyClass-->>Client: 返回实例\r\n```\r\n\r\n### 事件触发数据流\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Client as 客户端\r\n    participant EventUser as EventUser\r\n    participant IEvent as IEvent\r\n    participant Listener as 监听者\r\n    \r\n    Client->>EventUser: TriggerEvent(\"OnChange\", value)\r\n    EventUser->>IEvent: TriggerEvent(eventName, ...)\r\n    IEvent->>IEvent: 查找eventListeners[eventName]\r\n    IEvent->>Listener: 调用所有监听者回调\r\n    Listener-->>IEvent: 回调完成\r\n    IEvent-->>EventUser: 触发完成\r\n    EventUser-->>Client: 返回结果\r\n```\r\n\r\n---\r\n\r\n## 架构验证\r\n\r\n### 流程合理性验证\r\n\r\n从架构可验证：\r\n- ✅ **数据流完整**：接口混入 → 方法绑定 → 功能使用（完整流程）\r\n- ✅ **职责清晰**：接口模块、事件模块、装饰器模块、工厂模块职责明确\r\n- ✅ **解耦设计**：通过接口和事件系统实现模块间解耦\r\n- ✅ **灵活扩展**：可以轻松添加新的接口和装饰器\r\n\r\n### 扩展性验证\r\n\r\n从架构可验证：\r\n- ✅ **接口扩展**：新增接口只需继承Interface\r\n- ✅ **装饰器扩展**：新增装饰器只需实现IDecorator\r\n- ✅ **工厂扩展**：新增类型只需注册到工厂\r\n- ✅ **组合复用**：通过接口组合实现功能复用\r\n\r\n### 易用性验证\r\n\r\n从架构可验证：\r\n- ✅ **简单易用**：流畅的API设计，易于使用\r\n- ✅ **多重继承**：通过接口混入实现多重继承效果\r\n- ✅ **事件驱动**：事件系统实现对象间松耦合通信\r\n- ✅ **装饰器模式**：动态扩展对象功能\r\n\r\n---\r\n\r\n## 开发指导原则\r\n\r\n### 一、开发约束（什么能做，什么不能做）\r\n\r\n#### ✅ 应该做的\r\n\r\n1. **接口必须继承Interface**\r\n   ```\r\n   ✅ 正确：\r\n   local MyInterface = BaseClass(Interface)\r\n   \r\n   ❌ 错误：\r\n   不继承Interface的接口类\r\n   ```\r\n\r\n2. **接口混入必须在ctor中完成**\r\n   ```\r\n   ✅ 正确：\r\n   function MyClass:ctor()\r\n       MyInterface.New():ByInheritance(self)\r\n   end\r\n   \r\n   ❌ 错误：\r\n   在ctor外混入接口\r\n   ```\r\n\r\n3. **事件监听必须及时清理**\r\n   ```\r\n   ✅ 正确：\r\n   object:RemoveAllEventListeners()\r\n   \r\n   ❌ 错误：\r\n   不清理事件监听导致内存泄漏\r\n   ```\r\n\r\n#### ❌ 不应该做的\r\n\r\n1. **禁止在接口方法中直接访问self**\r\n   - 接口方法应该通过参数传递目标对象\r\n   - 不能直接访问self\r\n\r\n2. **禁止装饰器之间直接依赖**\r\n   - 装饰器应该独立实现\r\n   - 不能直接调用其他装饰器\r\n\r\n3. **禁止工厂直接创建未注册类型**\r\n   - 必须先在工厂中注册类型\r\n   - 不能直接创建未注册的类型\r\n\r\n### 二、开发流程（标准化开发步骤）\r\n\r\n#### 使用接口的标准流程\r\n\r\n```\r\n1. 定义接口\r\n   ↓\r\n   local MyInterface = BaseClass(Interface)\r\n   function MyInterface:Method1() end\r\n   \r\n2. 在类中使用接口\r\n   ↓\r\n   function MyClass:ctor()\r\n       MyInterface.New():ByInheritance(self)\r\n   end\r\n   \r\n3. 实现接口方法\r\n   ↓\r\n   function MyClass:Method1()\r\n       -- 实现逻辑\r\n   end\r\n```\r\n\r\n---\r\n\r\n## 总结\r\n\r\n### 架构设计价值\r\n\r\n该架构设计文档的价值在于：\r\n- ✅ **思路解构**：完整解构OOP框架系统的搭建思路\r\n- ✅ **流程验证**：从架构层面验证流程合理性\r\n- ✅ **模式分析**：分析接口模式、观察者模式、装饰器模式、工厂模式的应用\r\n- ✅ **开发指导**：为后续详细设计和实现提供清晰指导\r\n\r\n### 设计原则\r\n\r\n- ✅ **接口机制为核心**：通过接口机制解决Lua单继承的限制\r\n- ✅ **设计模式组合**：通过组合多种设计模式提供完整的OOP支持\r\n- ✅ **混入机制 + 链式调用**：通过混入机制实现接口继承，通过链式调用提供流畅API\r\n- ✅ **结构化编程**：帮助开发者以更加结构化、可维护的方式编写Lua代码\r\n\r\n### 架构特点\r\n\r\n- ✅ **多重继承**：通过接口混入实现多重继承效果\r\n- ✅ **事件驱动**：事件系统实现对象间松耦合通信\r\n- ✅ **装饰器模式**：动态扩展对象功能\r\n- ✅ **工厂模式**：简化对象创建和管理\r\n\r\n细节实现是后续开发阶段的工作，当前架构设计已足够指导整个OOP框架系统的开发。\r\n"
        }
    ]
}