{
    "sourceFile": "Collections/README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1761419763492,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1761419763492,
            "name": "Commit-0",
            "content": "# .NET Collections API 参考文档\r\n\r\n本文档基于 `CollectionsExample.cs` 文件，详细介绍了 .NET Collections 相关的所有常用 API。\r\n\r\n## 目录\r\n- [List<T> 动态数组](#listt-动态数组)\r\n- [Dictionary<TKey, TValue> 键值对集合](#dictionarytkey-tvalue-键值对集合)\r\n- [ConcurrentDictionary<TKey, TValue> 线程安全字典](#concurrentdictionarytkey-tvalue-线程安全字典)\r\n- [HashSet<T> 无序不重复集合](#hashsett-无序不重复集合)\r\n- [Queue<T> 队列（先进先出）](#queuet-队列先进先出)\r\n- [Stack<T> 栈（后进先出）](#stackt-栈后进先出)\r\n- [LinkedList<T> 双向链表](#linkedlistt-双向链表)\r\n- [LINQ查询操作](#linq查询操作)\r\n- [高级集合操作](#高级集合操作)\r\n\r\n---\r\n\r\n## List<T> 动态数组\r\n\r\n### 创建和初始化\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `new List<T>()` | 创建空List |\r\n| `new List<T>(capacity)` | 创建指定初始容量的List |\r\n| `new List<T> { item1, item2, ... }` | 创建并初始化List |\r\n\r\n### 添加元素操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `List<T>.Add(item)` | 在末尾添加单个元素 |\r\n| `List<T>.Insert(index, item)` | 在指定位置插入元素 |\r\n| `List<T>.AddRange(collection)` | 在末尾添加多个元素 |\r\n| `List<T>.InsertRange(index, collection)` | 在指定位置插入多个元素 |\r\n\r\n### 访问元素操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `List<T>[index]` | 索引访问元素 |\r\n| `List<T>[^index]` | 从末尾索引访问（C# 8.0） |\r\n| `List<T>.Count` | 获取元素数量 |\r\n| `List<T>.Capacity` | 获取当前容量 |\r\n\r\n### 查找元素操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `List<T>.IndexOf(item)` | 查找元素的第一个索引 |\r\n| `List<T>.LastIndexOf(item)` | 查找元素的最后一个索引 |\r\n| `List<T>.Contains(item)` | 检查是否包含元素 |\r\n| `List<T>.Exists(predicate)` | 使用条件查找元素 |\r\n| `List<T>.Find(predicate)` | 查找第一个满足条件的元素 |\r\n| `List<T>.FindAll(predicate)` | 查找所有满足条件的元素 |\r\n\r\n### 排序和反转操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `List<T>.Sort()` | 排序（默认升序） |\r\n| `List<T>.Sort(comparison)` | 自定义排序 |\r\n| `List<T>.Reverse()` | 反转列表 |\r\n\r\n### 移除元素操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `List<T>.Remove(item)` | 移除第一个匹配的元素 |\r\n| `List<T>.RemoveAt(index)` | 移除指定位置的元素 |\r\n| `List<T>.RemoveRange(index, count)` | 移除指定范围的元素 |\r\n| `List<T>.RemoveAll(predicate)` | 移除所有满足条件的元素 |\r\n\r\n### 转换操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `List<T>.ToArray()` | 转换为数组 |\r\n| `List<T>.ToList()` | 创建副本 |\r\n\r\n### 清空操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `List<T>.Clear()` | 清空所有元素 |\r\n| `List<T>.TrimExcess()` | 释放多余容量 |\r\n\r\n---\r\n\r\n## Dictionary<TKey, TValue> 键值对集合\r\n\r\n### 创建和初始化\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `new Dictionary<TKey, TValue>()` | 创建空字典 |\r\n| `new Dictionary<TKey, TValue>(capacity)` | 创建指定初始容量的字典 |\r\n| `new Dictionary<TKey, TValue> { { key, value }, ... }` | 创建并初始化字典 |\r\n\r\n### 添加键值对操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Dictionary[key] = value` | 使用索引器添加 |\r\n| `Dictionary.Add(key, value)` | 使用Add方法添加 |\r\n| `Dictionary.TryAdd(key, value)` | 安全添加（.NET Core 2.0+） |\r\n\r\n### 访问值操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Dictionary[key]` | 索引器访问值 |\r\n| `Dictionary.TryGetValue(key, out value)` | 安全获取值 |\r\n| `Dictionary.GetValueOrDefault(key, defaultValue)` | 获取值或默认值 |\r\n\r\n### 检查操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Dictionary.ContainsKey(key)` | 检查键是否存在 |\r\n| `Dictionary.ContainsValue(value)` | 检查值是否存在 |\r\n\r\n### 遍历操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Dictionary.Keys` | 获取所有键的集合 |\r\n| `Dictionary.Values` | 获取所有值的集合 |\r\n| `Dictionary` | 遍历键值对 |\r\n\r\n### 更新操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Dictionary[key] = newValue` | 更新现有值 |\r\n\r\n### 移除操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Dictionary.Remove(key)` | 移除键值对 |\r\n| `Dictionary.Clear()` | 清空字典 |\r\n\r\n### 高级操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Dictionary.Values.Max()` | 获取值的最大值 |\r\n| `Dictionary.Values.Min()` | 获取值的最小值 |\r\n| `Dictionary.OrderByDescending(x => x.Value)` | 按值排序 |\r\n\r\n---\r\n\r\n## ConcurrentDictionary<TKey, TValue> 线程安全字典\r\n\r\n### 创建和初始化\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `new ConcurrentDictionary<TKey, TValue>()` | 创建空并发字典 |\r\n| `new ConcurrentDictionary<TKey, TValue>(capacity)` | 创建指定初始容量的并发字典 |\r\n| `new ConcurrentDictionary<TKey, TValue> { [key] = value, ... }` | 创建并初始化并发字典 |\r\n\r\n### 线程安全的添加和更新操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `ConcurrentDictionary.TryAdd(key, value)` | 尝试添加键值对（线程安全） |\r\n| `ConcurrentDictionary.TryUpdate(key, newValue, comparisonValue)` | 尝试更新值（线程安全） |\r\n| `ConcurrentDictionary.AddOrUpdate(key, addValue, updateFactory)` | 添加或更新（线程安全） |\r\n| `ConcurrentDictionary.GetOrAdd(key, value)` | 获取或添加（线程安全） |\r\n\r\n### 线程安全的访问操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `ConcurrentDictionary.TryGetValue(key, out value)` | 尝试获取值（线程安全） |\r\n| `ConcurrentDictionary[key]` | 索引器访问（线程安全） |\r\n| `ConcurrentDictionary.ContainsKey(key)` | 检查键是否存在（线程安全） |\r\n\r\n### 线程安全的删除操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `ConcurrentDictionary.TryRemove(key, out value)` | 尝试删除键值对（线程安全） |\r\n\r\n### 批量操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `ConcurrentDictionary.ToArray()` | 转换为数组（线程安全） |\r\n| `ConcurrentDictionary.Keys` | 获取所有键的集合（线程安全） |\r\n| `ConcurrentDictionary.Values` | 获取所有值的集合（线程安全） |\r\n| `ConcurrentDictionary.Count` | 获取键值对数量（线程安全） |\r\n| `ConcurrentDictionary.IsEmpty` | 检查是否为空（线程安全） |\r\n\r\n### 高级操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `ConcurrentDictionary.GetEnumerator()` | 获取枚举器（线程安全） |\r\n| `ConcurrentDictionary.Clear()` | 清空字典（线程安全） |\r\n\r\n### 性能特点\r\n\r\n- **线程安全**: 支持多线程并发读写\r\n- **无锁设计**: 使用无锁算法，性能优异\r\n- **原子操作**: 避免竞态条件\r\n- **O(1)平均性能**: 查找、添加、删除操作\r\n\r\n### 使用场景\r\n\r\n- 多线程环境下的数据共享\r\n- 缓存系统\r\n- 计数器集合\r\n- 状态管理\r\n- 资源加载器\r\n\r\n### 注意事项\r\n\r\n- 比普通Dictionary稍慢\r\n- 某些操作不是原子性的\r\n- 迭代时可能看到不一致的状态\r\n- 适合高并发场景\r\n\r\n---\r\n\r\n## HashSet<T> 无序不重复集合\r\n\r\n### 创建和初始化\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `new HashSet<T>()` | 创建空HashSet |\r\n| `new HashSet<T>(comparer)` | 创建指定比较器的HashSet |\r\n| `new HashSet<T> { item1, item2, ... }` | 创建并初始化HashSet |\r\n\r\n### 添加元素操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `HashSet<T>.Add(item)` | 添加元素 |\r\n| `HashSet<T>.UnionWith(collection)` | 添加多个元素（并集） |\r\n\r\n### 检查操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `HashSet<T>.Contains(item)` | 检查是否包含元素 |\r\n\r\n### 集合操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `HashSet<T>.UnionWith(set)` | 并集操作 |\r\n| `HashSet<T>.IntersectWith(set)` | 交集操作 |\r\n| `HashSet<T>.ExceptWith(set)` | 差集操作 |\r\n| `HashSet<T>.SymmetricExceptWith(set)` | 对称差集操作 |\r\n\r\n### 集合关系检查\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `HashSet<T>.IsSubsetOf(set)` | 检查是否为子集 |\r\n| `HashSet<T>.IsSupersetOf(set)` | 检查是否为超集 |\r\n| `HashSet<T>.IsProperSubsetOf(set)` | 检查是否为真子集 |\r\n| `HashSet<T>.Overlaps(set)` | 检查是否有重叠 |\r\n| `HashSet<T>.SetEquals(set)` | 检查是否相等 |\r\n\r\n### 移除操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `HashSet<T>.Remove(item)` | 移除元素 |\r\n| `HashSet<T>.RemoveWhere(predicate)` | 条件移除 |\r\n| `HashSet<T>.Clear()` | 清空集合 |\r\n\r\n### 转换操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `HashSet<T>.ToArray()` | 转换为数组 |\r\n| `HashSet<T>.ToList()` | 转换为List |\r\n\r\n---\r\n\r\n## Queue<T> 队列（先进先出）\r\n\r\n### 创建队列\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `new Queue<T>()` | 创建空队列 |\r\n| `new Queue<T>(capacity)` | 创建指定初始容量的队列 |\r\n\r\n### 入队操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Queue<T>.Enqueue(item)` | 入队 |\r\n\r\n### 出队操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Queue<T>.Peek()` | 查看队首元素（不移除） |\r\n| `Queue<T>.Dequeue()` | 出队 |\r\n\r\n### 检查操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Queue<T>.Contains(item)` | 检查是否包含元素 |\r\n| `Queue<T>.Count` | 获取队列长度 |\r\n\r\n### 遍历操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Queue<T>` | 遍历队列元素 |\r\n\r\n### 清空操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Queue<T>.Clear()` | 清空队列 |\r\n\r\n---\r\n\r\n## Stack<T> 栈（后进先出）\r\n\r\n### 创建栈\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `new Stack<T>()` | 创建空栈 |\r\n| `new Stack<T>(capacity)` | 创建指定初始容量的栈 |\r\n\r\n### 压栈操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Stack<T>.Push(item)` | 压栈 |\r\n\r\n### 出栈操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Stack<T>.Peek()` | 查看栈顶元素（不移除） |\r\n| `Stack<T>.Pop()` | 出栈 |\r\n\r\n### 检查操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Stack<T>.Contains(item)` | 检查是否包含元素 |\r\n| `Stack<T>.Count` | 获取栈长度 |\r\n\r\n### 遍历操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Stack<T>` | 遍历栈元素 |\r\n\r\n### 清空操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Stack<T>.Clear()` | 清空栈 |\r\n\r\n---\r\n\r\n## LinkedList<T> 双向链表\r\n\r\n### 创建链表\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `new LinkedList<T>()` | 创建空链表 |\r\n\r\n### 添加节点操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `LinkedList<T>.AddFirst(item)` | 在开头添加节点 |\r\n| `LinkedList<T>.AddLast(item)` | 在末尾添加节点 |\r\n| `LinkedList<T>.AddAfter(node, item)` | 在指定节点后添加 |\r\n| `LinkedList<T>.AddBefore(node, item)` | 在指定节点前添加 |\r\n\r\n### 访问节点操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `LinkedList<T>.First` | 获取第一个节点 |\r\n| `LinkedList<T>.Last` | 获取最后一个节点 |\r\n| `LinkedList<T>.Count` | 获取节点数量 |\r\n\r\n### 查找操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `LinkedList<T>.Find(item)` | 查找第一个匹配的节点 |\r\n| `LinkedList<T>.FindLast(item)` | 查找最后一个匹配的节点 |\r\n| `LinkedList<T>.Contains(item)` | 检查是否包含元素 |\r\n\r\n### 移除操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `LinkedList<T>.Remove(item)` | 移除第一个匹配的元素 |\r\n| `LinkedList<T>.RemoveFirst()` | 移除第一个节点 |\r\n| `LinkedList<T>.RemoveLast()` | 移除最后一个节点 |\r\n| `LinkedList<T>.Clear()` | 清空链表 |\r\n\r\n---\r\n\r\n## LINQ查询操作\r\n\r\n### 基本查询操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `IEnumerable<T>.Where(predicate)` | 过滤元素 |\r\n| `IEnumerable<T>.Select(selector)` | 投影转换 |\r\n| `IEnumerable<T>.OrderBy(keySelector)` | 升序排序 |\r\n| `IEnumerable<T>.OrderByDescending(keySelector)` | 降序排序 |\r\n| `IEnumerable<T>.ThenBy(keySelector)` | 次要排序 |\r\n| `IEnumerable<T>.ThenByDescending(keySelector)` | 次要降序排序 |\r\n\r\n### 聚合操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `IEnumerable<T>.Count()` | 计数 |\r\n| `IEnumerable<T>.Sum(selector)` | 求和 |\r\n| `IEnumerable<T>.Average(selector)` | 平均值 |\r\n| `IEnumerable<T>.Max(selector)` | 最大值 |\r\n| `IEnumerable<T>.Min(selector)` | 最小值 |\r\n\r\n### 分组操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `IEnumerable<T>.GroupBy(keySelector)` | 分组 |\r\n| `IGrouping<TKey, TElement>.Key` | 获取分组键 |\r\n| `IGrouping<TKey, TElement>.Count()` | 获取分组数量 |\r\n\r\n### 连接操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `IEnumerable<T>.Join(inner, outerKeySelector, innerKeySelector, resultSelector)` | 内连接 |\r\n| `IEnumerable<T>.GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector)` | 分组连接 |\r\n\r\n### 集合操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `IEnumerable<T>.Distinct()` | 去重 |\r\n| `IEnumerable<T>.Union(second)` | 并集 |\r\n| `IEnumerable<T>.Intersect(second)` | 交集 |\r\n| `IEnumerable<T>.Except(second)` | 差集 |\r\n\r\n### 分页操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `IEnumerable<T>.Skip(count)` | 跳过指定数量 |\r\n| `IEnumerable<T>.Take(count)` | 获取指定数量 |\r\n\r\n### 条件操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `IEnumerable<T>.Any(predicate)` | 是否存在满足条件的元素 |\r\n| `IEnumerable<T>.All(predicate)` | 是否所有元素都满足条件 |\r\n| `IEnumerable<T>.First()` | 获取第一个元素 |\r\n| `IEnumerable<T>.FirstOrDefault(predicate)` | 获取第一个满足条件的元素或默认值 |\r\n| `IEnumerable<T>.Single(predicate)` | 获取唯一元素 |\r\n| `IEnumerable<T>.SingleOrDefault(predicate)` | 获取唯一元素或默认值 |\r\n\r\n---\r\n\r\n## 高级集合操作\r\n\r\n### 只读集合\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `IList<T>.AsReadOnly()` | 创建只读集合 |\r\n\r\n### 数组操作\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `Array.Sort(array)` | 数组排序 |\r\n| `Array.Reverse(array)` | 数组反转 |\r\n| `Array.Find(array, predicate)` | 查找元素 |\r\n| `Array.FindAll(array, predicate)` | 查找所有满足条件的元素 |\r\n\r\n### 集合初始化器\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `new List<T> { item1, item2, ... }` | List初始化器 |\r\n| `new Dictionary<TKey, TValue> { [key] = value, ... }` | Dictionary初始化器 |\r\n| `new HashSet<T> { item1, item2, ... }` | HashSet初始化器 |\r\n\r\n### 集合转换\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `IEnumerable<T>.ToList()` | 转换为List |\r\n| `IEnumerable<T>.ToArray()` | 转换为数组 |\r\n| `IEnumerable<T>.ToDictionary(keySelector, elementSelector)` | 转换为Dictionary |\r\n| `IEnumerable<T>.ToHashSet()` | 转换为HashSet |\r\n\r\n### 集合比较\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `IEnumerable<T>.SequenceEqual(second)` | 序列相等比较 |\r\n\r\n### 集合性能优化\r\n\r\n| OperationFuncName | FuncDesc |\r\n|-------------------|----------|\r\n| `new List<T>(capacity)` | 预分配容量 |\r\n| `HashSet<T>.Contains(item)` | 快速查找 |\r\n\r\n---\r\n\r\n## 使用注意事项\r\n\r\n1. **选择合适的集合类型**：根据使用场景选择最合适的集合类型\r\n2. **性能考虑**：对于频繁查找操作，优先使用HashSet或Dictionary\r\n3. **线程安全**：多线程环境下使用线程安全集合\r\n4. **内存管理**：及时清理不再使用的集合\r\n5. **LINQ性能**：避免在循环中重复执行LINQ查询\r\n6. **集合初始化**：使用集合初始化器简化代码\r\n7. **容量优化**：预知元素数量时指定初始容量\r\n8. **只读集合**：需要保护数据时使用只读集合\r\n\r\n---\r\n\r\n## 示例代码\r\n\r\n完整的示例代码请参考 `CollectionsExample.cs` 文件，其中包含了所有API的详细使用示例和中文注释。 "
        }
    ]
}