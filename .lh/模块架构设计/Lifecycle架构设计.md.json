{
    "sourceFile": "模块架构设计/Lifecycle架构设计.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1767203764102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1767203764102,
            "name": "Commit-0",
            "content": "# Lifecycle生命周期架构设计\r\n\r\n## 设计目标\r\n\r\n设计一套完整的C#-Lua生命周期桥接系统，支持Unity生命周期事件自动调用Lua函数，实现C#与Lua之间的无缝交互，提供配置化的映射机制和自动代码生成。\r\n\r\n---\r\n\r\n## 核心设计理念\r\n\r\n### 1. 桥接模式为核心\r\n\r\n**本质**：生命周期系统的核心是C#与Lua之间的桥接\r\n- C#生命周期 = Unity MonoBehaviour生命周期事件\r\n- Lua函数调用 = 自动调用对应的Lua全局函数\r\n- 映射机制 = 通过mappingName配置映射关系\r\n- 自动生成 = 编辑器工具自动生成Lua函数代码\r\n\r\n### 2. 模板方法模式 + 配置化\r\n\r\n**本质**：通过模板方法模式定义标准流程，通过配置化实现灵活映射\r\n- 模板方法 = MonoLifecycle定义标准的生命周期流程\r\n- 配置化 = mappingName配置不同的映射类型\r\n- 自动生成 = 编辑器工具根据配置自动生成Lua函数\r\n- 统一接口 = 所有生命周期组件继承自MonoLifecycle\r\n\r\n### 3. 职责分离 + 开闭原则\r\n\r\n**本质**：每个类只负责特定的生命周期管理，对扩展开放对修改封闭\r\n- 单一职责 = 每个类只负责特定的生命周期管理\r\n- 开闭原则 = 新增生命周期类型只需继承MonoLifecycle\r\n- 配置化 = 通过mappingName实现配置化的接口映射\r\n- 统一接口 = 所有生命周期组件都继承自同一个基类\r\n\r\n---\r\n\r\n## 整体架构设计\r\n\r\n### 三层架构 + 桥接模式\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph UnityLayer[\"Unity层<br/>MonoBehaviour生命周期\"]\r\n        AwakeEvent[\"Awake事件\"]\r\n        StartEvent[\"Start事件\"]\r\n        OnEnableEvent[\"OnEnable事件\"]\r\n        OnDestroyEvent[\"OnDestroy事件\"]\r\n        OtherEvents[\"其他生命周期事件\"]\r\n    end\r\n    \r\n    subgraph BridgeLayer[\"桥接层<br/>MonoLifecycle\"]\r\n        LifecycleBase[\"生命周期基类<br/>MonoLifecycle\"]\r\n        MappingManager[\"映射管理器<br/>mappingName\"]\r\n        LuaCaller[\"Lua调用器<br/>调用Lua函数\"]\r\n    end\r\n    \r\n    subgraph LuaLayer[\"Lua层<br/>生成的Lua函数\"]\r\n        UnitStart[\"Unit_Start函数\"]\r\n        ItemDestroy[\"Item_OnDestroy函数\"]\r\n        CustomLifecycle[\"自定义生命周期函数<br/>...\"]\r\n    end\r\n    \r\n    UnityLayer -->|触发| BridgeLayer\r\n    BridgeLayer -->|调用| LuaLayer\r\n    \r\n    style UnityLayer fill:#e1f5ff\r\n    style BridgeLayer fill:#fff4e1\r\n    style LuaLayer fill:#c8e6c9\r\n```\r\n\r\n### 生命周期桥接数据流\r\n\r\n```mermaid\r\ngraph LR\r\n    Start[Unity生命周期事件<br/>Start/OnDestroy等] -->|1. 触发| Bridge[桥接层<br/>MonoLifecycle]\r\n    Bridge -->|2. 获取映射名称| Mapping[mappingName<br/>Unit/Item/Custom]\r\n    Mapping -->|3. 构建函数名| FunctionName[函数名<br/>{MappingName}_{MethodName}]\r\n    FunctionName -->|4. 调用Lua函数| Lua[Lua层<br/>Unit_Start/Item_OnDestroy]\r\n    Lua -->|5. 执行Lua逻辑| End[完成]\r\n    \r\n    style Bridge fill:#fff4e1\r\n    style Mapping fill:#e1f5ff\r\n    style Lua fill:#c8e6c9\r\n```\r\n\r\n**数据流特性**：\r\n- ✅ **自动桥接**：Unity生命周期事件自动调用Lua函数\r\n- ✅ **配置化映射**：通过mappingName配置不同的映射类型\r\n- ✅ **统一接口**：所有生命周期组件使用统一的桥接机制\r\n- ✅ **自动生成**：编辑器工具自动生成Lua函数代码\r\n\r\n---\r\n\r\n## 桥接层架构设计\r\n\r\n### 核心职责\r\n\r\n生命周期事件捕获 + 映射管理 + Lua函数调用\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph MonoLifecycle[\"MonoLifecycle基类\"]\r\n        LifecycleMethods[\"生命周期方法<br/>Awake/Start/OnDestroy等\"]\r\n        MappingName[\"映射名称<br/>mappingName\"]\r\n        LuaCaller[\"Lua调用器<br/>CallLuaFunction\"]\r\n        ErrorHandler[\"错误处理器<br/>错误日志/异常处理\"]\r\n    end\r\n    \r\n    subgraph ConcreteLifecycle[\"具体生命周期类\"]\r\n        UnitLifecycle[\"UnitLifecycle<br/>单位生命周期\"]\r\n        ItemLifecycle[\"ItemLifecycle<br/>物品生命周期\"]\r\n        CustomLifecycle[\"自定义生命周期类<br/>...\"]\r\n    end\r\n    \r\n    subgraph EditorTool[\"编辑器工具<br/>CS2LuaLifecycleEditor\"]\r\n        ConfigManager[\"配置管理器<br/>mappingConfigs\"]\r\n        CodeGenerator[\"代码生成器<br/>生成Lua函数\"]\r\n        FileWriter[\"文件写入器<br/>写入Lua文件\"]\r\n    end\r\n    \r\n    MonoLifecycle -->|继承| ConcreteLifecycle\r\n    EditorTool -->|生成| LuaLayer[Lua层<br/>生成的Lua函数]\r\n    \r\n    style MonoLifecycle fill:#e1f5ff\r\n    style ConcreteLifecycle fill:#fff4e1\r\n    style EditorTool fill:#c8e6c9\r\n```\r\n\r\n### 工作流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[Unity生命周期事件<br/>Start/OnDestroy] --> Override[重写生命周期方法<br/>protected override]\r\n    Override --> GetMapping[获取映射名称<br/>mappingName]\r\n    GetMapping --> BuildFunctionName[构建函数名<br/>{MappingName}_{MethodName}]\r\n    BuildFunctionName --> CallLua[调用Lua函数<br/>CallLuaFunction]\r\n    CallLua --> CheckLua{Lua函数<br/>是否存在?}\r\n    CheckLua -->|是| ExecuteLua[执行Lua逻辑]\r\n    CheckLua -->|否| LogError[记录错误日志]\r\n    ExecuteLua --> Complete[完成]\r\n    LogError --> Complete\r\n    \r\n    Generate[编辑器生成Lua函数] --> ReadConfig[读取配置<br/>mappingConfigs]\r\n    ReadConfig --> GenerateCode[生成代码<br/>function Unit_Start(...) end]\r\n    GenerateCode --> WriteFile[写入文件<br/>MonoLifecycleGlobal.lua]\r\n    \r\n    style CheckLua fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style CallLua fill:#c8e6c9\r\n    style GenerateCode fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 编辑器工具架构设计\r\n\r\n### 核心职责\r\n\r\n配置管理 + 代码生成 + 文件写入\r\n\r\n### 架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph EditorTool[\"CS2LuaLifecycleEditor编辑器工具\"]\r\n        ConfigManager[\"配置管理器<br/>mappingConfigs\"]\r\n        MethodConfig[\"方法配置<br/>lifecycleMethods\"]\r\n        CodeGenerator[\"代码生成器<br/>GenerateLuaFunctions\"]\r\n        FileWriter[\"文件写入器<br/>WriteToFile\"]\r\n    end\r\n    \r\n    subgraph ConfigData[\"配置数据\"]\r\n        MappingConfig[\"映射配置<br/>{name: 'Unit', methods: [...]}\"]\r\n        MethodConfig[\"方法配置<br/>{name: 'Start', params: [...]}\"]\r\n    end\r\n    \r\n    subgraph GeneratedCode[\"生成的代码\"]\r\n        LuaFunctions[\"Lua函数<br/>function Unit_Start(...) end\"]\r\n        GlobalTable[\"全局表<br/>MonoLifecycleGlobal\"]\r\n    end\r\n    \r\n    EditorTool -->|读取| ConfigData\r\n    EditorTool -->|生成| GeneratedCode\r\n    \r\n    style EditorTool fill:#e1f5ff\r\n    style ConfigData fill:#fff4e1\r\n    style GeneratedCode fill:#c8e6c9\r\n```\r\n\r\n### 代码生成流程\r\n\r\n```mermaid\r\nflowchart TD\r\n    Start[用户点击生成按钮] --> ReadConfig[读取配置<br/>mappingConfigs + lifecycleMethods]\r\n    ReadConfig --> Loop[遍历映射配置]\r\n    Loop --> ForEachMapping[对每个映射配置]\r\n    ForEachMapping --> ForEachMethod[对每个生命周期方法]\r\n    ForEachMethod --> GenerateFunction[生成函数代码<br/>function {MappingName}_{MethodName}(...) end]\r\n    GenerateFunction --> AddToCode[添加到代码字符串]\r\n    AddToCode --> CheckMore{还有方法?}\r\n    CheckMore -->|是| ForEachMethod\r\n    CheckMore -->|否| CheckMoreMapping{还有映射?}\r\n    CheckMoreMapping -->|是| ForEachMapping\r\n    CheckMoreMapping -->|否| WriteFile[写入文件<br/>MonoLifecycleGlobal.lua]\r\n    WriteFile --> Complete[生成完成]\r\n    \r\n    style CheckMore fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style CheckMoreMapping fill:#fff4e1,stroke:#333,stroke-width:2px\r\n    style GenerateFunction fill:#c8e6c9\r\n    style WriteFile fill:#c8e6c9\r\n```\r\n\r\n---\r\n\r\n## 架构模式分析\r\n\r\n### 桥接模式（Bridge Pattern）\r\n\r\n**核心思想**：将C#生命周期和Lua函数调用分离，通过桥接层连接\r\n\r\n```mermaid\r\ngraph TB\r\n    Abstraction[抽象层<br/>Unity生命周期]\r\n    Implementor[实现层<br/>Lua函数]\r\n    Bridge[桥接层<br/>MonoLifecycle]\r\n    \r\n    Abstraction -->|桥接| Bridge\r\n    Bridge -->|调用| Implementor\r\n    \r\n    style Abstraction fill:#e1f5ff\r\n    style Bridge fill:#f3e5f5\r\n    style Implementor fill:#c8e6c9\r\n```\r\n\r\n**优势**：\r\n- ✅ **解耦设计**：C#生命周期和Lua实现分离\r\n- ✅ **灵活扩展**：可以轻松添加新的生命周期类型\r\n- ✅ **统一接口**：所有生命周期组件使用统一的桥接机制\r\n\r\n### 模板方法模式（Template Method Pattern）\r\n\r\n**核心思想**：MonoLifecycle定义标准的生命周期流程\r\n\r\n```mermaid\r\ngraph TB\r\n    TemplateMethod[模板方法<br/>MonoLifecycle<br/>定义标准流程]\r\n    \r\n    Step1[步骤1：获取映射名称<br/>抽象步骤]\r\n    Step2[步骤2：构建函数名<br/>具体步骤]\r\n    Step3[步骤3：调用Lua函数<br/>具体步骤]\r\n    \r\n    ConcreteStep1[具体实现1<br/>UnitLifecycle.mappingName]\r\n    ConcreteStep2[具体实现2<br/>ItemLifecycle.mappingName]\r\n    \r\n    TemplateMethod --> Step1\r\n    TemplateMethod --> Step2\r\n    TemplateMethod --> Step3\r\n    \r\n    Step1 --> ConcreteStep1\r\n    Step1 --> ConcreteStep2\r\n    \r\n    style TemplateMethod fill:#f3e5f5\r\n    style Step1 fill:#e1f5ff\r\n    style Step2 fill:#fff4e1\r\n    style Step3 fill:#fff4e1\r\n```\r\n\r\n---\r\n\r\n## 数据流设计\r\n\r\n### 生命周期事件数据流\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Unity as Unity引擎\r\n    participant MonoLifecycle as MonoLifecycle\r\n    participant Mapping as MappingManager\r\n    participant Lua as Lua环境\r\n    \r\n    Unity->>MonoLifecycle: Start() 生命周期事件\r\n    MonoLifecycle->>Mapping: 获取mappingName\r\n    Mapping-->>MonoLifecycle: 返回 \"Unit\"\r\n    MonoLifecycle->>MonoLifecycle: 构建函数名 \"Unit_Start\"\r\n    MonoLifecycle->>Lua: 调用 Unit_Start(gameObject, ...)\r\n    Lua->>Lua: 执行Lua逻辑\r\n    Lua-->>MonoLifecycle: 返回结果\r\n    MonoLifecycle-->>Unity: 生命周期处理完成\r\n```\r\n\r\n### 代码生成数据流\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant User as 用户\r\n    participant Editor as CS2LuaLifecycleEditor\r\n    participant Config as 配置数据\r\n    participant Generator as 代码生成器\r\n    participant File as Lua文件\r\n    \r\n    User->>Editor: 点击生成按钮\r\n    Editor->>Config: 读取mappingConfigs\r\n    Config-->>Editor: 返回配置数据\r\n    Editor->>Generator: 生成Lua函数代码\r\n    Generator->>Generator: 遍历配置生成代码\r\n    Generator-->>Editor: 返回生成的代码\r\n    Editor->>File: 写入MonoLifecycleGlobal.lua\r\n    File-->>Editor: 写入完成\r\n    Editor-->>User: 生成完成\r\n```\r\n\r\n---\r\n\r\n## 架构验证\r\n\r\n### 流程合理性验证\r\n\r\n从架构可验证：\r\n- ✅ **数据流完整**：Unity事件 → 桥接层 → Lua函数（完整流程）\r\n- ✅ **职责清晰**：Unity层、桥接层、Lua层职责明确，无重叠\r\n- ✅ **解耦设计**：通过桥接模式实现C#和Lua解耦\r\n- ✅ **配置化**：通过mappingName实现配置化的映射\r\n\r\n### 扩展性验证\r\n\r\n从架构可验证：\r\n- ✅ **模板方法模式**：新增生命周期类型只需继承MonoLifecycle\r\n- ✅ **配置化映射**：通过mappingName配置不同的映射类型\r\n- ✅ **自动生成**：编辑器工具自动生成Lua函数代码\r\n- ✅ **统一接口**：所有生命周期组件使用统一的桥接机制\r\n\r\n### 易用性验证\r\n\r\n从架构可验证：\r\n- ✅ **简单配置**：只需设置mappingName即可完成配置\r\n- ✅ **自动生成**：编辑器工具自动生成Lua函数代码\r\n- ✅ **统一接口**：所有生命周期组件使用统一的接口\r\n- ✅ **错误处理**：完善的错误日志和异常处理\r\n\r\n---\r\n\r\n## 开发指导原则\r\n\r\n### 一、开发约束（什么能做，什么不能做）\r\n\r\n#### ✅ 应该做的\r\n\r\n1. **生命周期类必须继承MonoLifecycle**\r\n   ```\r\n   ✅ 正确：\r\n   public class UnitLifecycle : MonoLifecycle\r\n   \r\n   ❌ 错误：\r\n   不继承MonoLifecycle的生命周期类\r\n   ```\r\n\r\n2. **必须设置mappingName**\r\n   ```\r\n   ✅ 正确：\r\n   SetMappingName(\"Unit\")\r\n   \r\n   ❌ 错误：\r\n   不设置mappingName\r\n   ```\r\n\r\n3. **必须调用基类方法**\r\n   ```\r\n   ✅ 正确：\r\n   protected override void Start()\r\n   {\r\n       base.Start();\r\n   }\r\n   \r\n   ❌ 错误：\r\n   不调用base.Start()\r\n   ```\r\n\r\n#### ❌ 不应该做的\r\n\r\n1. **禁止直接调用Lua函数**\r\n   - 必须通过MonoLifecycle的桥接机制\r\n   - 不能直接调用Lua函数\r\n\r\n2. **禁止修改生成的Lua函数**\r\n   - 生成的Lua函数应该由编辑器工具管理\r\n   - 不能手动修改生成的代码\r\n\r\n3. **禁止在生命周期方法中执行耗时操作**\r\n   - 生命周期方法应该快速执行\r\n   - 耗时操作应该异步处理\r\n\r\n### 二、开发流程（标准化开发步骤）\r\n\r\n#### 开发新生命周期类型的流程\r\n\r\n```\r\n1. 创建生命周期类\r\n   ↓\r\n   public class MyLifecycle : MonoLifecycle\r\n   \r\n2. 设置映射名称\r\n   ↓\r\n   SetMappingName(\"MyCustom\")\r\n   \r\n3. 重写生命周期方法\r\n   ↓\r\n   protected override void Start() { base.Start(); }\r\n   \r\n4. 使用编辑器工具生成Lua函数\r\n   ↓\r\n   Tools/CS2LuaLifecycle/生成Lua生命周期函数\r\n   \r\n5. 在Lua端实现函数\r\n   ↓\r\n   function MyCustom_Start(gameObject, ...) end\r\n```\r\n\r\n---\r\n\r\n## 总结\r\n\r\n### 架构设计价值\r\n\r\n该架构设计文档的价值在于：\r\n- ✅ **思路解构**：完整解构生命周期桥接系统的搭建思路\r\n- ✅ **流程验证**：从架构层面验证流程合理性\r\n- ✅ **模式分析**：分析桥接模式、模板方法模式的应用\r\n- ✅ **开发指导**：为后续详细设计和实现提供清晰指导\r\n\r\n### 设计原则\r\n\r\n- ✅ **桥接模式为核心**：C#生命周期和Lua函数调用通过桥接层连接\r\n- ✅ **模板方法模式 + 配置化**：通过模板方法定义标准流程，通过配置化实现灵活映射\r\n- ✅ **职责分离 + 开闭原则**：每个类只负责特定的生命周期管理，对扩展开放对修改封闭\r\n- ✅ **自动生成**：编辑器工具自动生成Lua函数代码\r\n\r\n### 架构特点\r\n\r\n- ✅ **自动桥接**：Unity生命周期事件自动调用Lua函数\r\n- ✅ **配置化映射**：通过mappingName配置不同的映射类型\r\n- ✅ **统一接口**：所有生命周期组件使用统一的桥接机制\r\n- ✅ **自动生成**：编辑器工具自动生成Lua函数代码\r\n\r\n细节实现是后续开发阶段的工作，当前架构设计已足够指导整个生命周期桥接系统的开发。\r\n"
        }
    ]
}