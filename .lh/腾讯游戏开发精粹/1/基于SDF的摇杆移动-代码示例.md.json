{
    "sourceFile": "è…¾è®¯æ¸¸æˆå¼€å‘ç²¾ç²¹/1/åŸºäºSDFçš„æ‘‡æ†ç§»åŠ¨-ä»£ç ç¤ºä¾‹.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1766302592821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1766302592821,
            "name": "Commit-0",
            "content": "# åŸºäºSDFçš„æ‘‡æ†ç§»åŠ¨ - ä»£ç ç¤ºä¾‹\r\n\r\n> **æ¥æº**ï¼šã€Šè…¾è®¯æ¸¸æˆå¼€å‘ç²¾ç²¹ã€‹- ç¬¬äºŒéƒ¨åˆ† æ¸¸æˆæ•°å­¦ - ç¬¬1ç«   \r\n> **ç”¨é€”**ï¼šç†è§£SDFï¼ˆæœ‰å·è·ç¦»åœºï¼‰åœ¨æ‘‡æ†ç§»åŠ¨ä¸­çš„åº”ç”¨  \r\n> **æŠ€æœ¯ç‚¹**ï¼šSDFé¢„è®¡ç®—ã€ç¢°æ’æ£€æµ‹ã€ç¢°æ’å“åº”ã€é¿å…å¾€è¿”\r\n\r\n---\r\n\r\n## ğŸ“š æ ¸å¿ƒæ¦‚å¿µ\r\n\r\n### SDFï¼ˆæœ‰å·è·ç¦»åœºï¼‰æ˜¯ä»€ä¹ˆï¼Ÿ\r\n\r\n**æœ‰å·è·ç¦»åœºï¼ˆSigned Distance Field, SDFï¼‰**ï¼š\r\n- **å®šä¹‰**ï¼šç©ºé—´ä¸­æ¯ä¸ªç‚¹åˆ°æœ€è¿‘éšœç¢ç‰©è¾¹ç•Œçš„è·ç¦»\r\n- **ç¬¦å·**ï¼š\r\n  - **æ­£å€¼**ï¼šç‚¹åœ¨éšœç¢ç‰©å¤–éƒ¨ï¼ˆå¯é€šè¡ŒåŒºåŸŸï¼‰\r\n  - **è´Ÿå€¼**ï¼šç‚¹åœ¨éšœç¢ç‰©å†…éƒ¨ï¼ˆä¸å¯é€šè¡ŒåŒºåŸŸï¼‰\r\n  - **é›¶å€¼**ï¼šç‚¹åœ¨éšœç¢ç‰©è¾¹ç•Œä¸Š\r\n- **ä¼˜åŠ¿**ï¼šå¿«é€Ÿåˆ¤æ–­ç‚¹æ˜¯å¦åœ¨éšœç¢ç‰©å†…ï¼Œå¹¶çŸ¥é“è·ç¦»è¾¹ç•Œçš„è·ç¦»\r\n\r\n---\r\n\r\n## ğŸ’» å®Œæ•´ä»£ç å®ç°\r\n\r\n### 1. SDFæ•°æ®ç»“æ„ï¼ˆåŸºäºæ …æ ¼ï¼‰\r\n\r\n```csharp\r\nusing UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\n/// <summary>\r\n/// SDFæ•°æ®ç»“æ„ - åŸºäºæ …æ ¼\r\n/// </summary>\r\npublic class SDFGrid\r\n{\r\n    public float[,] distanceField;  // è·ç¦»åœºæ•°æ®\r\n    public int width;               // æ …æ ¼å®½åº¦\r\n    public int height;              // æ …æ ¼é«˜åº¦\r\n    public float cellSize;          // æ¯ä¸ªæ …æ ¼å•å…ƒçš„å¤§å°\r\n    public Vector2 origin;          // åŸç‚¹ä½ç½®ï¼ˆä¸–ç•Œåæ ‡å·¦ä¸‹è§’ï¼‰\r\n\r\n    public SDFGrid(int width, int height, float cellSize, Vector2 origin)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.cellSize = cellSize;\r\n        this.origin = origin;\r\n        this.distanceField = new float[width, height];\r\n    }\r\n\r\n    /// <summary>\r\n    /// ä¸–ç•Œåæ ‡è½¬æ …æ ¼åæ ‡\r\n    /// </summary>\r\n    public Vector2Int WorldToGrid(Vector2 worldPos)\r\n    {\r\n        Vector2 localPos = worldPos - origin;\r\n        int x = Mathf.FloorToInt(localPos.x / cellSize);\r\n        int y = Mathf.FloorToInt(localPos.y / cellSize);\r\n        return new Vector2Int(\r\n            Mathf.Clamp(x, 0, width - 1),\r\n            Mathf.Clamp(y, 0, height - 1)\r\n        );\r\n    }\r\n\r\n    /// <summary>\r\n    /// æ …æ ¼åæ ‡è½¬ä¸–ç•Œåæ ‡\r\n    /// </summary>\r\n    public Vector2 GridToWorld(Vector2Int gridPos)\r\n    {\r\n        return origin + new Vector2(\r\n            gridPos.x * cellSize + cellSize * 0.5f,\r\n            gridPos.y * cellSize + cellSize * 0.5f\r\n        );\r\n    }\r\n\r\n    /// <summary>\r\n    /// è·å–ä¸–ç•Œåæ ‡ç‚¹çš„SDFå€¼ï¼ˆåŒçº¿æ€§æ’å€¼ï¼‰\r\n    /// </summary>\r\n    public float GetSDF(Vector2 worldPos)\r\n    {\r\n        Vector2 localPos = worldPos - origin;\r\n        float fx = localPos.x / cellSize;\r\n        float fy = localPos.y / cellSize;\r\n\r\n        int x0 = Mathf.FloorToInt(fx);\r\n        int y0 = Mathf.FloorToInt(fy);\r\n        int x1 = x0 + 1;\r\n        int y1 = y0 + 1;\r\n\r\n        // è¾¹ç•Œæ£€æŸ¥\r\n        x0 = Mathf.Clamp(x0, 0, width - 1);\r\n        y0 = Mathf.Clamp(y0, 0, height - 1);\r\n        x1 = Mathf.Clamp(x1, 0, width - 1);\r\n        y1 = Mathf.Clamp(y1, 0, height - 1);\r\n\r\n        // åŒçº¿æ€§æ’å€¼\r\n        float dx = fx - x0;\r\n        float dy = fy - y0;\r\n\r\n        float sdf00 = distanceField[x0, y0];\r\n        float sdf10 = distanceField[x1, y0];\r\n        float sdf01 = distanceField[x0, y1];\r\n        float sdf11 = distanceField[x1, y1];\r\n\r\n        float sdf0 = Mathf.Lerp(sdf00, sdf10, dx);\r\n        float sdf1 = Mathf.Lerp(sdf01, sdf11, dx);\r\n        return Mathf.Lerp(sdf0, sdf1, dy);\r\n    }\r\n\r\n    /// <summary>\r\n    /// è·å–SDFæ¢¯åº¦ï¼ˆæ³•çº¿æ–¹å‘ï¼ŒæŒ‡å‘æœ€è¿‘çš„å¯é€šè¡ŒåŒºåŸŸï¼‰\r\n    /// </summary>\r\n    public Vector2 GetGradient(Vector2 worldPos, float epsilon = 0.1f)\r\n    {\r\n        float sdfX0 = GetSDF(worldPos + new Vector2(-epsilon, 0));\r\n        float sdfX1 = GetSDF(worldPos + new Vector2(epsilon, 0));\r\n        float sdfY0 = GetSDF(worldPos + new Vector2(0, -epsilon));\r\n        float sdfY1 = GetSDF(worldPos + new Vector2(0, epsilon));\r\n\r\n        Vector2 gradient = new Vector2(\r\n            (sdfX1 - sdfX0) / (2 * epsilon),\r\n            (sdfY1 - sdfY0) / (2 * epsilon)\r\n        );\r\n\r\n        return gradient.normalized;\r\n    }\r\n}\r\n```\r\n\r\n### 2. SDFé¢„è®¡ç®—ï¼ˆåŸºäºæ …æ ¼æ•°æ®ï¼‰\r\n\r\n```csharp\r\n/// <summary>\r\n/// SDFé¢„è®¡ç®—å™¨ - ä½¿ç”¨è·ç¦»å˜æ¢ç®—æ³•\r\n/// </summary>\r\npublic class SDFCalculator\r\n{\r\n    /// <summary>\r\n    /// ä»éšœç¢ç‰©æ …æ ¼ç”ŸæˆSDF\r\n    /// true = éšœç¢ç‰©ï¼Œfalse = å¯é€šè¡Œ\r\n    /// </summary>\r\n    public static SDFGrid GenerateSDF(bool[,] obstacleGrid, float cellSize, Vector2 origin)\r\n    {\r\n        int width = obstacleGrid.GetLength(0);\r\n        int height = obstacleGrid.GetLength(1);\r\n        SDFGrid sdfGrid = new SDFGrid(width, height, cellSize, origin);\r\n\r\n        // ç¬¬ä¸€æ­¥ï¼šåˆå§‹åŒ–è·ç¦»åœº\r\n        for (int x = 0; x < width; x++)\r\n        {\r\n            for (int y = 0; y < height; y++)\r\n            {\r\n                if (obstacleGrid[x, y])\r\n                {\r\n                    // éšœç¢ç‰©å†…éƒ¨ï¼Œè®¾ä¸ºè´Ÿå€¼ï¼ˆè·ç¦»è¾¹ç•Œä¸º0ï¼‰\r\n                    sdfGrid.distanceField[x, y] = -0.5f * cellSize;\r\n                }\r\n                else\r\n                {\r\n                    // å¯é€šè¡ŒåŒºåŸŸï¼Œè®¾ä¸ºå¾ˆå¤§çš„æ­£å€¼\r\n                    sdfGrid.distanceField[x, y] = float.MaxValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        // ç¬¬äºŒæ­¥ï¼šä½¿ç”¨è·ç¦»å˜æ¢ç®—æ³•è®¡ç®—SDF\r\n        // è¿™é‡Œä½¿ç”¨ç®€åŒ–çš„8æ–¹å‘è·ç¦»å˜æ¢\r\n        CalculateDistanceTransform(sdfGrid, obstacleGrid, cellSize);\r\n\r\n        return sdfGrid;\r\n    }\r\n\r\n    /// <summary>\r\n    /// è·ç¦»å˜æ¢ç®—æ³•ï¼ˆ8æ–¹å‘ï¼‰\r\n    /// </summary>\r\n    private static void CalculateDistanceTransform(SDFGrid sdfGrid, bool[,] obstacleGrid, float cellSize)\r\n    {\r\n        int width = sdfGrid.width;\r\n        int height = sdfGrid.height;\r\n\r\n        // å‰å‘æ‰«æ\r\n        for (int x = 0; x < width; x++)\r\n        {\r\n            for (int y = 0; y < height; y++)\r\n            {\r\n                if (!obstacleGrid[x, y])\r\n                {\r\n                    float minDist = sdfGrid.distanceField[x, y];\r\n\r\n                    // æ£€æŸ¥8ä¸ªæ–¹å‘çš„é‚»å±…\r\n                    for (int dx = -1; dx <= 1; dx++)\r\n                    {\r\n                        for (int dy = -1; dy <= 1; dy++)\r\n                        {\r\n                            if (dx == 0 && dy == 0) continue;\r\n\r\n                            int nx = x + dx;\r\n                            int ny = y + dy;\r\n\r\n                            if (nx >= 0 && nx < width && ny >= 0 && ny < height)\r\n                            {\r\n                                float dist = sdfGrid.distanceField[nx, ny];\r\n                                float stepDist = new Vector2(dx, dy).magnitude * cellSize;\r\n                                minDist = Mathf.Min(minDist, dist + stepDist);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    sdfGrid.distanceField[x, y] = minDist;\r\n                }\r\n            }\r\n        }\r\n\r\n        // åå‘æ‰«æ\r\n        for (int x = width - 1; x >= 0; x--)\r\n        {\r\n            for (int y = height - 1; y >= 0; y--)\r\n            {\r\n                if (!obstacleGrid[x, y])\r\n                {\r\n                    float minDist = sdfGrid.distanceField[x, y];\r\n\r\n                    for (int dx = -1; dx <= 1; dx++)\r\n                    {\r\n                        for (int dy = -1; dy <= 1; dy++)\r\n                        {\r\n                            if (dx == 0 && dy == 0) continue;\r\n\r\n                            int nx = x + dx;\r\n                            int ny = y + dy;\r\n\r\n                            if (nx >= 0 && nx < width && ny >= 0 && ny < height)\r\n                            {\r\n                                float dist = sdfGrid.distanceField[nx, ny];\r\n                                float stepDist = new Vector2(dx, dy).magnitude * cellSize;\r\n                                minDist = Mathf.Min(minDist, dist + stepDist);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    sdfGrid.distanceField[x, y] = minDist;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3. åŸºäºSDFçš„æ‘‡æ†ç§»åŠ¨æ§åˆ¶å™¨\r\n\r\n```csharp\r\n/// <summary>\r\n/// åŸºäºSDFçš„æ‘‡æ†ç§»åŠ¨æ§åˆ¶å™¨\r\n/// </summary>\r\npublic class SDFJoystickMovement : MonoBehaviour\r\n{\r\n    [Header(\"SDFè®¾ç½®\")]\r\n    public SDFGrid sdfGrid;\r\n    public float characterRadius = 0.5f;  // è§’è‰²åŠå¾„\r\n\r\n    [Header(\"ç§»åŠ¨è®¾ç½®\")]\r\n    public float moveSpeed = 5f;\r\n    public float collisionResponseStrength = 10f;  // ç¢°æ’å“åº”å¼ºåº¦\r\n\r\n    [Header(\"é¿å…å¾€è¿”è®¾ç½®\")]\r\n    public float avoidRoundTripDistance = 0.1f;  // é¿å…å¾€è¿”çš„æœ€å°è·ç¦»\r\n    private Vector2 lastValidPosition;  // ä¸Šä¸€ä¸ªæœ‰æ•ˆä½ç½®\r\n\r\n    [Header(\"è°ƒè¯•\")]\r\n    public bool showDebugGizmos = true;\r\n\r\n    private Vector2 currentVelocity;\r\n    private Vector2 targetPosition;\r\n\r\n    void Start()\r\n    {\r\n        lastValidPosition = transform.position;\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        // è·å–æ‘‡æ†è¾“å…¥ï¼ˆè¿™é‡Œç”¨é”®ç›˜æ¨¡æ‹Ÿï¼Œå®é™…é¡¹ç›®ä¸­ç”¨æ‘‡æ†è¾“å…¥ï¼‰\r\n        Vector2 input = GetJoystickInput();\r\n\r\n        if (input.magnitude > 0.1f)\r\n        {\r\n            // è®¡ç®—ç›®æ ‡ä½ç½®\r\n            targetPosition = (Vector2)transform.position + input * moveSpeed * Time.deltaTime;\r\n\r\n            // åŸºäºSDFçš„ç§»åŠ¨å¤„ç†\r\n            Vector2 newPosition = ProcessMovementWithSDF(targetPosition);\r\n\r\n            // é¿å…å¾€è¿”æ£€æµ‹\r\n            newPosition = AvoidRoundTrip(newPosition);\r\n\r\n            // æ›´æ–°ä½ç½®\r\n            transform.position = newPosition;\r\n            lastValidPosition = newPosition;\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// è·å–æ‘‡æ†è¾“å…¥ï¼ˆç¤ºä¾‹ï¼šç”¨WASDæ¨¡æ‹Ÿï¼‰\r\n    /// </summary>\r\n    private Vector2 GetJoystickInput()\r\n    {\r\n        Vector2 input = Vector2.zero;\r\n        input.x = Input.GetAxis(\"Horizontal\");\r\n        input.y = Input.GetAxis(\"Vertical\");\r\n        return input.normalized;\r\n    }\r\n\r\n    /// <summary>\r\n    /// åŸºäºSDFå¤„ç†ç§»åŠ¨ï¼ˆç¢°æ’æ£€æµ‹ä¸å“åº”ï¼‰\r\n    /// </summary>\r\n    private Vector2 ProcessMovementWithSDF(Vector2 targetPos)\r\n    {\r\n        if (sdfGrid == null)\r\n        {\r\n            return targetPos;\r\n        }\r\n\r\n        // è·å–å½“å‰ä½ç½®å’Œç›®æ ‡ä½ç½®çš„SDFå€¼\r\n        float currentSDF = sdfGrid.GetSDF(transform.position);\r\n        float targetSDF = sdfGrid.GetSDF(targetPos);\r\n\r\n        // æƒ…å†µ1ï¼šè§’è‰²åœ¨éšœç¢ç‰©å†…éƒ¨ï¼ˆSDF < 0ï¼‰\r\n        if (currentSDF < 0)\r\n        {\r\n            return MoveOutOfObstacle();\r\n        }\r\n\r\n        // æƒ…å†µ2ï¼šç›®æ ‡ä½ç½®åœ¨éšœç¢ç‰©å†…\r\n        if (targetSDF < characterRadius)\r\n        {\r\n            // ç¢°æ’å“åº”ï¼šæ²¿ç€SDFæ¢¯åº¦æ–¹å‘æ¨å‡º\r\n            Vector2 gradient = sdfGrid.GetGradient(targetPos);\r\n            float pushDistance = characterRadius - targetSDF;\r\n            return targetPos + gradient * pushDistance;\r\n        }\r\n\r\n        // æƒ…å†µ3ï¼šæ­£å¸¸ç§»åŠ¨ï¼Œä½†éœ€è¦ç¡®ä¿è·¯å¾„å®‰å…¨\r\n        return ValidatePath(transform.position, targetPos);\r\n    }\r\n\r\n    /// <summary>\r\n    /// å°†è§’è‰²ä»éšœç¢ç‰©åŒºåŸŸç§»å‡º\r\n    /// </summary>\r\n    private Vector2 MoveOutOfObstacle()\r\n    {\r\n        Vector2 currentPos = transform.position;\r\n        Vector2 gradient = sdfGrid.GetGradient(currentPos);\r\n\r\n        // æ²¿ç€æ¢¯åº¦æ–¹å‘ï¼ˆæŒ‡å‘å¯é€šè¡ŒåŒºåŸŸï¼‰ç§»åŠ¨\r\n        float currentSDF = sdfGrid.GetSDF(currentPos);\r\n        float pushDistance = Mathf.Abs(currentSDF) + characterRadius;\r\n\r\n        return currentPos + gradient * pushDistance;\r\n    }\r\n\r\n    /// <summary>\r\n    /// éªŒè¯è·¯å¾„å®‰å…¨æ€§ï¼ˆæ£€æŸ¥è·¯å¾„ä¸Šçš„ç‚¹ï¼‰\r\n    /// </summary>\r\n    private Vector2 ValidatePath(Vector2 start, Vector2 end)\r\n    {\r\n        Vector2 direction = (end - start).normalized;\r\n        float distance = Vector2.Distance(start, end);\r\n        int steps = Mathf.CeilToInt(distance / (characterRadius * 0.5f));\r\n\r\n        Vector2 safeEnd = end;\r\n\r\n        // æ²¿ç€è·¯å¾„é‡‡æ ·æ£€æŸ¥\r\n        for (int i = 1; i <= steps; i++)\r\n        {\r\n            float t = (float)i / steps;\r\n            Vector2 samplePos = Vector2.Lerp(start, end, t);\r\n            float sdf = sdfGrid.GetSDF(samplePos);\r\n\r\n            if (sdf < characterRadius)\r\n            {\r\n                // é‡åˆ°éšœç¢ç‰©ï¼Œåœæ­¢åœ¨è¿™é‡Œ\r\n                Vector2 gradient = sdfGrid.GetGradient(samplePos);\r\n                safeEnd = samplePos - direction * (characterRadius - sdf);\r\n                break;\r\n            }\r\n        }\r\n\r\n        return safeEnd;\r\n    }\r\n\r\n    /// <summary>\r\n    /// é¿å…å¾€è¿”ï¼ˆé˜²æ­¢è§’è‰²åœ¨éšœç¢ç‰©è¾¹ç¼˜æ¥å›ç§»åŠ¨ï¼‰\r\n    /// </summary>\r\n    private Vector2 AvoidRoundTrip(Vector2 newPos)\r\n    {\r\n        float distanceToLast = Vector2.Distance(newPos, lastValidPosition);\r\n\r\n        // å¦‚æœç§»åŠ¨è·ç¦»å¤ªå°ï¼Œå¯èƒ½æ˜¯å¾€è¿”ï¼Œä¿æŒåŸä½ç½®\r\n        if (distanceToLast < avoidRoundTripDistance)\r\n        {\r\n            return lastValidPosition;\r\n        }\r\n\r\n        return newPos;\r\n    }\r\n\r\n    /// <summary>\r\n    /// è¿œè·ç¦»ç§»åŠ¨ï¼ˆä¸èƒ½è¶Šè¿‡éšœç¢ç‰©ï¼‰\r\n    /// </summary>\r\n    public bool MoveToPosition(Vector2 targetPos)\r\n    {\r\n        Vector2 startPos = transform.position;\r\n        Vector2 direction = (targetPos - startPos).normalized;\r\n        float totalDistance = Vector2.Distance(startPos, targetPos);\r\n\r\n        // æ²¿ç€è·¯å¾„é€æ­¥ç§»åŠ¨ï¼Œé‡åˆ°éšœç¢ç‰©åœæ­¢\r\n        Vector2 currentPos = startPos;\r\n        float movedDistance = 0f;\r\n        float stepSize = characterRadius * 0.5f;\r\n\r\n        while (movedDistance < totalDistance)\r\n        {\r\n            float remainingDistance = totalDistance - movedDistance;\r\n            float step = Mathf.Min(stepSize, remainingDistance);\r\n            Vector2 nextPos = currentPos + direction * step;\r\n\r\n            float sdf = sdfGrid.GetSDF(nextPos);\r\n            if (sdf < characterRadius)\r\n            {\r\n                // é‡åˆ°éšœç¢ç‰©ï¼Œåœæ­¢ç§»åŠ¨\r\n                break;\r\n            }\r\n\r\n            currentPos = nextPos;\r\n            movedDistance += step;\r\n        }\r\n\r\n        transform.position = currentPos;\r\n        return Vector2.Distance(currentPos, targetPos) < 0.1f;  // æ˜¯å¦åˆ°è¾¾ç›®æ ‡\r\n    }\r\n\r\n    void OnDrawGizmos()\r\n    {\r\n        if (!showDebugGizmos || sdfGrid == null)\r\n            return;\r\n\r\n        // ç»˜åˆ¶è§’è‰²åŠå¾„\r\n        Gizmos.color = Color.green;\r\n        Gizmos.DrawWireSphere(transform.position, characterRadius);\r\n\r\n        // ç»˜åˆ¶å½“å‰ä½ç½®çš„SDFå€¼\r\n        float sdf = sdfGrid.GetSDF(transform.position);\r\n        Vector2 gradient = sdfGrid.GetGradient(transform.position);\r\n\r\n        // ç»˜åˆ¶SDFæ¢¯åº¦æ–¹å‘\r\n        Gizmos.color = sdf < 0 ? Color.red : Color.blue;\r\n        Gizmos.DrawRay(transform.position, gradient * Mathf.Abs(sdf));\r\n    }\r\n}\r\n```\r\n\r\n### 4. SDFç®¡ç†å™¨ï¼ˆåˆå§‹åŒ–å’Œç®¡ç†ï¼‰\r\n\r\n```csharp\r\n/// <summary>\r\n/// SDFç®¡ç†å™¨ - è´Ÿè´£åˆå§‹åŒ–å’Œæ›´æ–°SDF\r\n/// </summary>\r\npublic class SDFManager : MonoBehaviour\r\n{\r\n    [Header(\"SDFç”Ÿæˆè®¾ç½®\")]\r\n    public int gridWidth = 100;\r\n    public int gridHeight = 100;\r\n    public float cellSize = 0.5f;\r\n    public Vector2 gridOrigin = Vector2.zero;\r\n\r\n    [Header(\"éšœç¢ç‰©è®¾ç½®\")]\r\n    public LayerMask obstacleLayer;\r\n    public float obstacleCheckRadius = 0.25f;\r\n\r\n    private SDFGrid sdfGrid;\r\n    private bool[,] obstacleGrid;\r\n\r\n    void Start()\r\n    {\r\n        GenerateSDF();\r\n    }\r\n\r\n    /// <summary>\r\n    /// ç”ŸæˆSDF\r\n    /// </summary>\r\n    public void GenerateSDF()\r\n    {\r\n        // ç¬¬ä¸€æ­¥ï¼šæ‰«æåœºæ™¯ï¼Œç”Ÿæˆéšœç¢ç‰©æ …æ ¼\r\n        obstacleGrid = ScanObstacles();\r\n\r\n        // ç¬¬äºŒæ­¥ï¼šä»éšœç¢ç‰©æ …æ ¼ç”ŸæˆSDF\r\n        sdfGrid = SDFCalculator.GenerateSDF(obstacleGrid, cellSize, gridOrigin);\r\n\r\n        Debug.Log($\"SDFç”Ÿæˆå®Œæˆ: {gridWidth}x{gridHeight}, å•å…ƒå¤§å°: {cellSize}\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// æ‰«æåœºæ™¯ä¸­çš„éšœç¢ç‰©ï¼Œç”Ÿæˆéšœç¢ç‰©æ …æ ¼\r\n    /// </summary>\r\n    private bool[,] ScanObstacles()\r\n    {\r\n        bool[,] grid = new bool[gridWidth, gridHeight];\r\n\r\n        for (int x = 0; x < gridWidth; x++)\r\n        {\r\n            for (int y = 0; y < gridHeight; y++)\r\n            {\r\n                Vector2 worldPos = sdfGrid != null \r\n                    ? sdfGrid.GridToWorld(new Vector2Int(x, y))\r\n                    : gridOrigin + new Vector2(x * cellSize, y * cellSize);\r\n\r\n                // æ£€æŸ¥è¯¥ä½ç½®æ˜¯å¦æœ‰éšœç¢ç‰©\r\n                Collider2D collider = Physics2D.OverlapCircle(worldPos, obstacleCheckRadius, obstacleLayer);\r\n                grid[x, y] = collider != null;\r\n            }\r\n        }\r\n\r\n        return grid;\r\n    }\r\n\r\n    /// <summary>\r\n    /// æ›´æ–°åŠ¨æ€éšœç¢ç‰©ï¼ˆè¿è¡Œæ—¶æ›´æ–°SDFï¼‰\r\n    /// </summary>\r\n    public void UpdateDynamicObstacles()\r\n    {\r\n        // é‡æ–°æ‰«æéšœç¢ç‰©\r\n        obstacleGrid = ScanObstacles();\r\n\r\n        // é‡æ–°ç”ŸæˆSDF\r\n        sdfGrid = SDFCalculator.GenerateSDF(obstacleGrid, cellSize, gridOrigin);\r\n    }\r\n\r\n    /// <summary>\r\n    /// è·å–SDFç½‘æ ¼ï¼ˆä¾›å…¶ä»–ç»„ä»¶ä½¿ç”¨ï¼‰\r\n    /// </summary>\r\n    public SDFGrid GetSDFGrid()\r\n    {\r\n        return sdfGrid;\r\n    }\r\n\r\n    void OnDrawGizmos()\r\n    {\r\n        if (sdfGrid == null)\r\n            return;\r\n\r\n        // ç»˜åˆ¶SDFå¯è§†åŒ–ï¼ˆå¯é€‰ï¼‰\r\n        // è¿™é‡Œå¯ä»¥ç»˜åˆ¶SDFçš„ç­‰å€¼çº¿ç­‰\r\n    }\r\n}\r\n```\r\n\r\n### 5. ä½¿ç”¨ç¤ºä¾‹\r\n\r\n```csharp\r\n/// <summary>\r\n/// ä½¿ç”¨ç¤ºä¾‹\r\n/// </summary>\r\npublic class SDFMovementExample : MonoBehaviour\r\n{\r\n    public SDFManager sdfManager;\r\n    public SDFJoystickMovement character;\r\n\r\n    void Start()\r\n    {\r\n        // åˆå§‹åŒ–SDFç®¡ç†å™¨\r\n        if (sdfManager == null)\r\n        {\r\n            sdfManager = FindObjectOfType<SDFManager>();\r\n        }\r\n\r\n        // è®¾ç½®è§’è‰²çš„SDFç½‘æ ¼\r\n        if (character != null && sdfManager != null)\r\n        {\r\n            character.sdfGrid = sdfManager.GetSDFGrid();\r\n        }\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        // ç¤ºä¾‹ï¼šå¤„ç†åŠ¨æ€éšœç¢ç‰©\r\n        if (Input.GetKeyDown(KeyCode.R))\r\n        {\r\n            // æŒ‰Ré”®æ›´æ–°åŠ¨æ€éšœç¢ç‰©\r\n            sdfManager.UpdateDynamicObstacles();\r\n            character.sdfGrid = sdfManager.GetSDFGrid();\r\n        }\r\n\r\n        // ç¤ºä¾‹ï¼šè¿œè·ç¦»ç§»åŠ¨\r\n        if (Input.GetMouseButtonDown(0))\r\n        {\r\n            Vector3 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);\r\n            Vector2 targetPos = new Vector2(mousePos.x, mousePos.y);\r\n            character.MoveToPosition(targetPos);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## ğŸ¯ æ ¸å¿ƒè¦ç‚¹æ€»ç»“\r\n\r\n### 1. SDFçš„ä¼˜åŠ¿\r\n\r\n- **å¿«é€Ÿç¢°æ’æ£€æµ‹**ï¼šO(1)æ—¶é—´åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨éšœç¢ç‰©å†…\r\n- **å¹³æ»‘ç§»åŠ¨**ï¼šçŸ¥é“åˆ°è¾¹ç•Œçš„è·ç¦»ï¼Œå¯ä»¥å¹³æ»‘æ¨å‡º\r\n- **é¢„è®¡ç®—**ï¼šSDFå¯ä»¥é¢„å…ˆè®¡ç®—ï¼Œè¿è¡Œæ—¶æŸ¥è¯¢å¾ˆå¿«\r\n\r\n### 2. ç¢°æ’æ£€æµ‹ä¸å“åº”\r\n\r\n- **æ£€æµ‹**ï¼šé€šè¿‡SDFå€¼åˆ¤æ–­ï¼ˆ< 0 = åœ¨éšœç¢ç‰©å†…ï¼Œ< radius = ç¢°æ’ï¼‰\r\n- **å“åº”**ï¼šæ²¿ç€SDFæ¢¯åº¦æ–¹å‘æ¨å‡ºï¼ˆæ¢¯åº¦æŒ‡å‘æœ€è¿‘çš„å¯é€šè¡ŒåŒºåŸŸï¼‰\r\n\r\n### 3. é¿å…å¾€è¿”\r\n\r\n- **é—®é¢˜**ï¼šè§’è‰²å¯èƒ½åœ¨éšœç¢ç‰©è¾¹ç¼˜æ¥å›ç§»åŠ¨\r\n- **è§£å†³**ï¼šè®°å½•ä¸Šä¸€ä¸ªæœ‰æ•ˆä½ç½®ï¼Œå¦‚æœç§»åŠ¨è·ç¦»å¤ªå°åˆ™ä¿æŒåŸä½ç½®\r\n\r\n### 4. è¿œè·ç¦»ç§»åŠ¨\r\n\r\n- **é—®é¢˜**ï¼šç›´æ¥ç§»åŠ¨åˆ°ç›®æ ‡å¯èƒ½ç©¿è¿‡éšœç¢ç‰©\r\n- **è§£å†³**ï¼šæ²¿ç€è·¯å¾„é€æ­¥æ£€æŸ¥ï¼Œé‡åˆ°éšœç¢ç‰©åœæ­¢\r\n\r\n### 5. åŠ¨æ€éšœç¢ç‰©\r\n\r\n- **æ›´æ–°**ï¼šé‡æ–°æ‰«æéšœç¢ç‰©ï¼Œé‡æ–°ç”ŸæˆSDF\r\n- **æ€§èƒ½**ï¼šSDFç”Ÿæˆæœ‰å¼€é”€ï¼Œéœ€è¦æƒè¡¡æ›´æ–°é¢‘ç‡\r\n\r\n---\r\n\r\n## ğŸ“ ä½¿ç”¨æ­¥éª¤\r\n\r\n1. **åˆ›å»ºSDFç®¡ç†å™¨**ï¼šåœ¨åœºæ™¯ä¸­æ·»åŠ `SDFManager`ç»„ä»¶\r\n2. **è®¾ç½®éšœç¢ç‰©å±‚**ï¼šé…ç½®`obstacleLayer`ï¼Œæ ‡è®°éšœç¢ç‰©\r\n3. **ç”ŸæˆSDF**ï¼šè¿è¡Œæ—¶è°ƒç”¨`GenerateSDF()`\r\n4. **æ·»åŠ è§’è‰²æ§åˆ¶å™¨**ï¼šç»™è§’è‰²æ·»åŠ `SDFJoystickMovement`ç»„ä»¶\r\n5. **è¿æ¥SDFç½‘æ ¼**ï¼šå°†SDFç®¡ç†å™¨çš„ç½‘æ ¼èµ‹å€¼ç»™è§’è‰²æ§åˆ¶å™¨\r\n\r\n---\r\n\r\n## ğŸ”§ ä¼˜åŒ–å»ºè®®\r\n\r\n1. **SDFé¢„è®¡ç®—**ï¼šåœ¨åŠ è½½æ—¶é¢„è®¡ç®—ï¼Œé¿å…è¿è¡Œæ—¶è®¡ç®—\r\n2. **åˆ†å±‚SDF**ï¼šä½¿ç”¨å¤šçº§SDFï¼ˆç²—ç²’åº¦+ç»†ç²’åº¦ï¼‰æé«˜æ€§èƒ½\r\n3. **å±€éƒ¨æ›´æ–°**ï¼šåªæ›´æ–°åŠ¨æ€éšœç¢ç‰©åŒºåŸŸçš„SDF\r\n4. **ç¼“å­˜æŸ¥è¯¢**ï¼šç¼“å­˜å¸¸ç”¨çš„SDFæŸ¥è¯¢ç»“æœ\r\n\r\n---\r\n\r\n**å‚è€ƒ**ï¼šã€Šè…¾è®¯æ¸¸æˆå¼€å‘ç²¾ç²¹ã€‹- ç¬¬äºŒéƒ¨åˆ† æ¸¸æˆæ•°å­¦ - ç¬¬1ç«  åŸºäºSDFçš„æ‘‡æ†ç§»åŠ¨\r\n\r\n"
        }
    ]
}