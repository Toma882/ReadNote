# 公式系统架构设计

## 设计目标

设计一套完整的公式解析系统，支持三级公式架构（一级基础函数、二级派生计算、三级综合效果），实现职责分离、策划友好、类型安全，提供数据驱动的配置化公式系统。

---

## 核心设计理念

### 1. 三级公式架构为核心

**本质**：公式系统的核心是三级公式的分层架构
- 一级公式 = 基础获取函数（程序员提供，不运算，只传参）
- 二级公式 = 派生计算（策划编写，基于一级公式）
- 三级公式 = 综合效果计算（策划编写，基于一级和二级公式）
- 职责分离 = 程序员提供基础设施，策划负责公式设计和测试

### 2. 字符匹配规则 + 类型安全

**本质**：通过严格的字符匹配规则实现类型安全和职责分离
- 字符匹配规则 = 三级公式以`#`开头，二级公式以`@`开头且包含下划线
- 类型安全 = 通过预定义参数类型避免运行时错误
- 策划友好 = 策划只需严格按照字符匹配规则编写公式
- 即时反馈 = 策划可以独立测试和调整公式，无需程序员参与

### 3. 数据驱动架构

**本质**：公式特性通过配置数据实现，无需修改代码
- 公式注册、公式计算 → 通过配置数据定义
- 函数注册、参数传递 → 通过配置数据调整
- 新增公式 → 扩展配置数据即可
- 公式平衡 → 调整配置数值即可

---

## 整体架构设计

### 三级公式架构 + 职责分离

```mermaid
graph TB
    subgraph ProgrammerLayer["基础设施提供层"]
        FunctionRegistry["函数注册表<br/>RegisterFunction<br/>一级公式函数"]
        ParserEngine["解析引擎<br/>FormulaParserBase<br/>公式解析和编译"]
        CacheSystem["缓存系统<br/>FormulaCache<br/>编译结果缓存"]
    end
    
    subgraph DesignerLayer["数据层<br/>公式设计"]
        Level1Formula["一级公式<br/>ATTR/EQUIPMENT_BONUS<br/>基础获取函数"]
        Level2Formula["二级公式<br/>@Category_Name<br/>派生计算"]
        Level3Formula["三级公式<br/>#FinalResult<br/>综合效果计算"]
    end
    
    subgraph RuntimeLayer["运行时层<br/>公式计算"]
        ParamContainer["参数容器<br/>Param.Create<br/>链式参数传递"]
        FormulaCalculator["公式计算器<br/>CalculateFormula<br/>执行公式计算"]
        ResultCache["结果缓存<br/>计算结果缓存"]
    end
    
    ProgrammerLayer -->|提供基础设施| DesignerLayer
    DesignerLayer -->|注册公式| RuntimeLayer
    RuntimeLayer -->|计算公式| ResultCache
    
    style ProgrammerLayer fill:#e1f5ff
    style DesignerLayer fill:#fff4e1
    style RuntimeLayer fill:#c8e6c9
```

### 三级公式数据流

```mermaid
graph LR
    Start[计算公式请求<br/>#TotalDamage] -->|1. 解析三级公式| ParseLv3[解析引擎<br/>识别#TotalDamage]
    ParseLv3 -->|2. 查找二级公式| FindLv2
    FindLv2 -->|3. 解析二级公式| ParseLv2[解析二级公式<br/>识别@Category_Name]
    ParseLv2 -->|4. 查找一级公式| FindLv1[查找一级公式<br/>ATTR/EQUIPMENT_BONUS]
    FindLv1 -->|5. 执行一级函数| ExecuteLv1[执行一级函数<br/>获取基础数据]
    ExecuteLv1 -->|6. 计算二级公式| CalcLv2[计算二级公式<br/>派生计算]
    CalcLv2 -->|7. 计算三级公式| CalcLv3[计算三级公式<br/>综合效果]
    CalcLv3 -->|8. 返回结果| End[最终结果]
    
    style ParseLv3 fill:#e1f5ff
    style FindLv2 fill:#fff4e1
    style ExecuteLv1 fill:#c8e6c9
    style CalcLv3 fill:#c8e6c9
```

**数据流特性**：
- ✅ **三级分层**：一级 → 二级 → 三级，逐层计算
- ✅ **职责分离**：程序员提供一级函数，策划编写二级和三级公式
- ✅ **字符匹配**：通过字符匹配规则识别公式级别
- ✅ **自动缓存**：编译结果自动缓存，提升性能
- ✅ **类型安全**：通过预定义参数类型避免运行时错误

---

## 三级公式架构设计

### 核心职责

一级基础函数 + 二级派生计算 + 三级综合效果

### 架构图

```mermaid
graph TB
    subgraph Level1["一级公式层<br/>基础获取函数"]
        AttrFunc["ATTR函数<br/>获取角色属性"]
        EquipFunc["EQUIPMENT_BONUS函数<br/>获取装备加成"]
        SkillFunc["SKILL_BONUS函数<br/>获取技能加成"]
        OtherFunc["其他函数<br/>..."]
    end
    
    subgraph Level2["二级公式层<br/>派生计算"]
        CombatFormula["@Combat_AttackPower<br/>战斗攻击力计算"]
        SoulFormula["@SoulAttribute_Mod<br/>灵魂属性修正"]
        WuXingFormula["@WuXing_Metal<br/>五行属性计算"]
        OtherFormula["其他二级公式<br/>..."]
    end
    
    subgraph Level3["三级公式层<br/>综合效果计算"]
        TotalDamage["#TotalDamage<br/>总伤害计算"]
        FinalHealing["#FinalHealing<br/>最终治疗量"]
        SkillEffect["#SkillEffect<br/>技能效果计算"]
        OtherFinal["其他三级公式<br/>..."]
    end
    
    Level1 -->|组成| Level2
    Level1 -->|组成| Level3
    Level2 -->|组成| Level3
    
    style Level1 fill:#e1f5ff
    style Level2 fill:#fff4e1
    style Level3 fill:#c8e6c9
```

### 字符匹配规则

**三级公式识别规则**：
```lua
-- 三级公式：以 # 开头
local lv3Pattern = "%#[%w_]+"  -- #TotalDamage
```

**二级公式识别规则**：
```lua
-- 二级公式：以 @ 开头，包含下划线
local lv2Pattern = "%@[%w_]+%_[%w_]+"  -- @Combat_AttackPower
```

**一级公式识别规则**：
```lua
-- 一级公式：三种模式
local lv1_1Pattern = "([A-Z_]+%([^%)]*%))"  -- FUNC(args)
local lv1_2Pattern = "([A-Z_]+%[[^%]]*%]"   -- FUNC[index]
local lv1_3Pattern = "\\b([A-Z_]+)\\b"      -- FUNC
```

### 公式依赖关系

```mermaid
graph TD
    L3[三级公式<br/>#TotalDamage] -->|依赖| L2A[二级公式<br/>@Combat_AttackPower]
    L3 -->|依赖| L2B[二级公式<br/>@Combat_CriticalMultiplier]
    
    L2A -->|依赖| L1A[一级公式<br/>ATTR]
    L2A -->|依赖| L1B[一级公式<br/>EQUIPMENT_BONUS]
    L2B -->|依赖| L1C[一级公式<br/>SKILL_BONUS]
    
    style L3 fill:#c8e6c9
    style L2A fill:#fff4e1
    style L2B fill:#fff4e1
    style L1A fill:#e1f5ff
    style L1B fill:#e1f5ff
    style L1C fill:#e1f5ff
```

---

## 解析引擎架构设计

### 核心职责

公式解析 + 公式编译 + 结果缓存

### 架构图

```mermaid
graph TB
    subgraph ParserEngine["解析引擎<br/>FormulaParserBase"]
        FormulaParser["公式解析器<br/>ParseFormula<br/>识别公式级别"]
        FormulaCompiler["公式编译器<br/>CompileFormula<br/>编译为Lua函数"]
        FormulaCache["公式缓存<br/>FormulaCache<br/>缓存编译结果"]
    end
    
    subgraph PatternMatcher["模式匹配器"]
        Lv3Matcher["三级公式匹配器<br/>#Pattern"]
        Lv2Matcher["二级公式匹配器<br/>@Pattern"]
        Lv1Matcher["一级公式匹配器<br/>FUNCPattern"]
    end
    
    subgraph FunctionResolver["函数解析器"]
        Lv3Resolver["三级公式解析器<br/>解析#Formula"]
        Lv2Resolver["二级公式解析器<br/>解析@Formula"]
        Lv1Resolver["一级公式解析器<br/>解析FUNC调用"]
    end
    
    FormulaParser --> PatternMatcher
    PatternMatcher --> FunctionResolver
    FunctionResolver --> FormulaCompiler
    FormulaCompiler --> FormulaCache
    
    style ParserEngine fill:#e1f5ff
    style PatternMatcher fill:#fff4e1
    style FunctionResolver fill:#c8e6c9
```

### 工作流程

```mermaid
flowchart TD
    Start[计算公式请求<br/>CalculateFormula] --> CheckCache{检查缓存<br/>FormulaCache}
    CheckCache -->|缓存命中| ReturnCache[返回缓存结果]
    CheckCache -->|缓存未命中| ParseFormula[解析公式<br/>识别公式级别]
    
    ParseFormula --> IdentifyLevel{识别公式级别<br/>#/@/FUNC}
    IdentifyLevel -->|三级公式| ParseLv3[解析三级公式<br/>查找依赖的二级公式]
    IdentifyLevel -->|二级公式| ParseLv2[解析二级公式<br/>查找依赖的一级公式]
    IdentifyLevel -->|一级公式| ParseLv1[解析一级公式<br/>查找函数定义]
    
    ParseLv3 --> ResolveDeps[解析依赖<br/>递归解析二级和一级公式]
    ParseLv2 --> ResolveDeps
    ParseLv1 --> ResolveDeps
    
    ResolveDeps --> Compile[编译公式<br/>生成Lua函数]
    Compile --> CacheResult[缓存编译结果<br/>FormulaCache]
    CacheResult --> Execute[执行函数<br/>传入参数]
    Execute --> ReturnResult[返回计算结果]
    
    style CheckCache fill:#fff4e1,stroke:#333,stroke-width:2px
    style IdentifyLevel fill:#fff4e1,stroke:#333,stroke-width:2px
    style Compile fill:#c8e6c9
    style ReturnResult fill:#c8e6c9
```

---

## 参数传递系统架构设计

### 核心职责

链式参数传递 + 类型安全 + 参数验证

### 架构图

```mermaid
graph TB
    subgraph ParamContainer["参数容器<br/>Param.Create"]
        ParamBuilder["参数构建器<br/>链式调用"]
        ParamValidator["参数验证器<br/>类型检查"]
        ParamStorage["参数存储<br/>paramDict"]
    end
    
    subgraph ParamTypes["参数类型定义"]
        ActorType["Actor类型<br/>角色对象"]
        TargetType["Target类型<br/>目标对象"]
        SkillType["Skill类型<br/>技能数据"]
        ItemType["Item类型<br/>道具数据"]
    end
    
    subgraph FunctionCall["函数调用"]
        GetParam["获取参数<br/>GetParam(type)"]
        TypeCheck["类型检查<br/>验证参数类型"]
        PassParam["传递参数<br/>传递给函数"]
    end
    
    ParamContainer -->|定义参数类型| ParamTypes
    ParamTypes -->|验证参数| ParamValidator
    ParamValidator -->|存储参数| ParamStorage
    FunctionCall -->|读取参数| ParamStorage
    FunctionCall -->|类型检查| TypeCheck
    TypeCheck -->|传递参数| PassParam
    
    style ParamContainer fill:#e1f5ff
    style ParamTypes fill:#fff4e1
    style FunctionCall fill:#c8e6c9
```

### 链式调用设计

```mermaid
graph LR
    Create[Param.Create] -->|:Actor| Actor[设置Actor参数]
    Actor -->|:Target| Target[设置Target参数]
    Target -->|:Skill| Skill[设置Skill参数]
    Skill -->|:Item| Item[设置Item参数]
    Item -->|完成| End[参数容器就绪]
    
    style Create fill:#e1f5ff
    style End fill:#c8e6c9
```

**设计优势**：
- ✅ **链式调用**：流畅的API设计，易于使用
- ✅ **类型安全**：参数类型预定义，避免运行时错误
- ✅ **参数验证**：自动验证参数类型和完整性
- ✅ **灵活扩展**：可以轻松添加新的参数类型

---

## 架构模式分析

### 职责分离模式（Separation of Concerns）

**核心思想**：程序员和策划职责分离

```mermaid
graph TB
    Programmer[程序员<br/>提供基础设施]
    Designer[策划<br/>设计公式]
    
    Programmer -->|提供| Infrastructure[基础设施<br/>函数注册/解析引擎]
    Designer -->|使用| Infrastructure
    Designer -->|编写| Formulas[公式<br/>二级/三级公式]
    
    style Programmer fill:#e1f5ff
    style Designer fill:#fff4e1
    style Infrastructure fill:#c8e6c9
```

**优势**：
- ✅ **职责清晰**：程序员负责基础设施，策划负责公式设计
- ✅ **独立工作**：策划可以独立测试和调整公式
- ✅ **减少沟通**：减少程序员和策划之间的沟通成本

### 模板方法模式（Template Method Pattern）

**核心思想**：定义公式解析的标准流程

```mermaid
graph TB
    TemplateMethod[模板方法<br/>CalculateFormula<br/>定义标准流程]
    
    Step1[步骤1：检查缓存<br/>抽象步骤]
    Step2[步骤2：解析公式<br/>抽象步骤]
    Step3[步骤3：编译公式<br/>具体步骤]
    Step4[步骤4：执行计算<br/>具体步骤]
    
    ConcreteStep1[具体实现1<br/>FormulaCache查找]
    ConcreteStep2[具体实现2<br/>ParseFormula解析]
    
    TemplateMethod --> Step1
    TemplateMethod --> Step2
    TemplateMethod --> Step3
    TemplateMethod --> Step4
    
    Step1 --> ConcreteStep1
    Step2 --> ConcreteStep2
    
    style TemplateMethod fill:#f3e5f5
    style Step1 fill:#e1f5ff
    style Step2 fill:#e1f5ff
    style Step3 fill:#fff4e1
    style Step4 fill:#fff4e1
```

---

## 数据流设计

### 公式计算数据流

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Parser as FormulaParserBase
    participant Cache as FormulaCache
    participant Compiler as FormulaCompiler
    participant Func as 一级函数
    
    Client->>Parser: CalculateFormula("#TotalDamage", params)
    Parser->>Cache: 检查缓存
    Cache-->>Parser: 缓存未命中
    Parser->>Parser: 解析三级公式
    Parser->>Parser: 查找二级公式 @Combat_AttackPower
    Parser->>Parser: 解析二级公式
    Parser->>Parser: 查找一级公式 ATTR
    Parser->>Func: 调用 ATTR('strength', Actor)
    Func-->>Parser: 返回属性值
    Parser->>Compiler: 编译公式为函数
    Compiler-->>Parser: 返回编译后的函数
    Parser->>Cache: 缓存编译结果
    Parser->>Parser: 执行编译后的函数
    Parser-->>Client: 返回计算结果
```

---

## 架构验证

### 流程合理性验证

从架构可验证：
- ✅ **数据流完整**：公式请求 → 解析 → 编译 → 执行 → 返回（完整流程）
- ✅ **职责清晰**：程序员层、策划层、运行时层职责明确，无重叠
- ✅ **解耦设计**：通过三级公式架构实现职责分离
- ✅ **类型安全**：通过字符匹配规则和参数类型定义实现类型安全

### 扩展性验证

从架构可验证：
- ✅ **三级架构**：新增公式只需在对应级别注册
- ✅ **函数扩展**：新增一级函数只需注册到FunctionRegistry
- ✅ **参数扩展**：新增参数类型只需扩展ParamTypes
- ✅ **配置驱动**：公式通过配置数据扩展，无需修改代码

### 易用性验证

从架构可验证：
- ✅ **策划友好**：策划只需按照字符匹配规则编写公式
- ✅ **即时反馈**：策划可以独立测试和调整公式
- ✅ **类型安全**：通过预定义参数类型避免运行时错误
- ✅ **自动缓存**：编译结果自动缓存，提升性能

---

## 开发指导原则

### 一、开发约束（什么能做，什么不能做）

#### ✅ 应该做的

1. **一级函数必须注册**
   ```
   ✅ 正确：
   formulaParser:RegisterFunction("ATTR", function(...) end, ...)
   
   ❌ 错误：
   直接调用未注册的函数
   ```

2. **公式必须遵循字符匹配规则**
   ```
   ✅ 正确：
   三级公式：#TotalDamage
   二级公式：@Combat_AttackPower
   一级公式：ATTR('strength', Actor)
   
   ❌ 错误：
   不遵循字符匹配规则（如：TotalDamage、@CombatPower）
   ```

3. **参数必须使用Param容器**
   ```
   ✅ 正确：
   local params = Param.Create():Actor(player):Target(enemy)
   
   ❌ 错误：
   直接传递复杂对象
   ```

#### ❌ 不应该做的

1. **禁止绕过字符匹配规则**
   - 公式必须严格按照字符匹配规则编写
   - 不能使用不符合规则的公式格式

2. **禁止直接调用未注册函数**
   - 所有一级函数必须注册
   - 不能直接调用未注册的函数

3. **禁止硬编码公式逻辑**
   - 公式逻辑应该在配置中定义
   - 不能硬编码公式计算逻辑

### 二、开发流程（标准化开发步骤）

#### 程序员开发一级函数的流程

```
1. 定义函数签名
   ↓
   确定函数名、参数类型、返回值类型
   
2. 实现函数逻辑
   ↓
   实现函数的具体计算逻辑
   
3. 注册函数
   ↓
   formulaParser:RegisterFunction("FUNC_NAME", func, ...)
   
4. 测试函数
   ↓
   使用TestNestedFormula测试函数
```

#### 策划编写公式的流程

```
1. 确定公式级别
   ↓
   一级/二级/三级公式
   
2. 遵循字符匹配规则
   ↓
   三级：#开头，二级：@开头+下划线，一级：FUNC格式
   
3. 编写公式
   ↓
   使用已注册的一级函数和二级公式
   
4. 测试公式
   ↓
   使用CalculateFormula测试公式
```

---

## 总结

### 架构设计价值

该架构设计文档的价值在于：
- ✅ **思路解构**：完整解构公式系统的搭建思路
- ✅ **流程验证**：从架构层面验证流程合理性
- ✅ **模式分析**：分析职责分离、模板方法模式的应用
- ✅ **开发指导**：为后续详细设计和实现提供清晰指导

### 设计原则

- ✅ **三级公式架构为核心**：一级基础函数、二级派生计算、三级综合效果
- ✅ **字符匹配规则 + 类型安全**：通过严格的字符匹配规则实现类型安全
- ✅ **数据驱动架构**：公式特性通过配置数据实现
- ✅ **职责分离**：程序员提供基础设施，策划负责公式设计

### 架构特点

- ✅ **策划友好**：策划只需按照字符匹配规则编写公式
- ✅ **类型安全**：通过预定义参数类型避免运行时错误
- ✅ **自动缓存**：编译结果自动缓存，提升性能
- ✅ **灵活扩展**：新增公式只需在对应级别注册

细节实现是后续开发阶段的工作，当前架构设计已足够指导整个公式系统的开发。
