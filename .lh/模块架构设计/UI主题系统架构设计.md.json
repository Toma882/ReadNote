{
    "sourceFile": "模块架构设计/UI主题系统架构设计.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1767360301254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1767361406324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,741 +0,0 @@\n-# UI 主题系统架构设计\r\n-\r\n-## 设计目标\r\n-\r\n-设计一套基于 Unity 预制体 + 预制体变体 + 模板驱动的 UI 主题系统，支持动态创建 UI 元素、模板化配置、多主题类型（暗色、亮色、高对比度等），提供统一接口、高性能、易扩展的主题管理框架。\r\n-\r\n----\r\n-\r\n-## 核心设计理念\r\n-\r\n-### 1. 模板驱动架构为核心\r\n-\r\n-**本质**：UI 主题系统的核心是模板驱动的动态创建机制\r\n-- 模板配置 = 所有 UI 主题配置通过模板类预定义\r\n-- 动态创建 = 运行时根据模板动态创建 UI 预制体实例\r\n-- 模板复用 = 同一模板可创建多个 UI 实例，支持参数覆盖\r\n-- 配置分离 = 模板配置与运行时数据分离，易于维护\r\n-\r\n-### 2. 双层模板系统：UI 模板 + 组件模板\r\n-\r\n-**本质**：系统采用双层模板设计，分别管理 UI 整体和单个组件\r\n-- UI 模板 = 管理整个 UI 的配置（如 ButtonTemplate、PanelTemplate）\r\n-- 组件模板 = 管理单个 UI 组件的创建（如 TextComponentTemplate、ImageComponentTemplate）\r\n-- 模板组合 = UI 模板通过组合多个组件模板构建完整 UI\r\n-- 独立扩展 = 两种模板可独立扩展，互不干扰\r\n-\r\n-### 3. 多主题类型统一管理\r\n-\r\n-**本质**：系统统一管理多种主题类型，提供一致的创建接口\r\n-- 主题类型 = Dark、Light、HighContrast、Custom 等\r\n-- 统一接口 = 所有主题类型使用相同的模板基类\r\n-- 类型映射 = 通过枚举和映射表管理主题类型\r\n-- 易于扩展 = 新增主题类型只需创建新的模板变体\r\n-\r\n-### 4. Context 模式统一参数\r\n-\r\n-**本质**：所有模板使用统一的 Context 参数，接口稳定，参数灵活扩展\r\n-- 统一接口 = UI 模板和组件模板都使用 Context 参数\r\n-- 参数扩展 = 支持任意扩展字段，无需修改函数签名\r\n-- 默认配置 = 支持默认配置和覆盖配置合并\r\n-- 向后兼容 = 新增字段不影响旧代码\r\n-\r\n----\r\n-\r\n-## 整体架构设计\r\n-\r\n-### 三层架构 + 双层模板系统\r\n-\r\n-```mermaid\r\n-graph TB\r\n-    subgraph VisualLayer[\"Visual 层<br/>UIVisualLayer\"]\r\n-        UIVisual[\"UIVisual<br/>UI 执行器\"]\r\n-    end\r\n-    \r\n-    subgraph TemplateLayer[\"模板层<br/>TemplateLayer\"]\r\n-        UITemplate[\"UI 模板<br/>UITemplateBase\"]\r\n-        ComponentTemplate[\"组件模板<br/>UIComponentTemplateBase\"]\r\n-        TemplateMapping[\"模板映射表<br/>EUITemplateMapping\"]\r\n-        ThemeMapping[\"主题映射表<br/>EThemeMapping\"]\r\n-    end\r\n-    \r\n-    subgraph UnityLayer[\"Unity Prefab 层<br/>UnityLayer\"]\r\n-        PrefabBase[\"基础预制体<br/>BasePrefab\"]\r\n-        PrefabVariant[\"预制体变体<br/>PrefabVariant\"]\r\n-        UIComponent[\"UI 组件<br/>Text/Image/Button等\"]\r\n-    end\r\n-    \r\n-    VisualLayer -->|使用模板| TemplateLayer\r\n-    TemplateLayer -->|创建| UnityLayer\r\n-    UnityLayer -->|渲染| Output[最终 UI]\r\n-    \r\n-    style VisualLayer fill:#ffebee\r\n-    style TemplateLayer fill:#e1f5ff\r\n-    style UnityLayer fill:#c8e6c9\r\n-    style Output fill:#fff4e1\r\n-```\r\n-\r\n-### 双层模板数据流\r\n-\r\n-```mermaid\r\n-graph LR\r\n-    subgraph UITemplateFlow[\"UI 模板流程\"]\r\n-        T1[Context<br/>uiTemplateType/themeType] --> T2[获取 UI 模板]\r\n-        T2 --> T3[InitTemplate<br/>初始化 UI]\r\n-        T3 --> T4[创建多个组件<br/>调用组件模板]\r\n-        T4 --> T5[UI 预制体完成]\r\n-    end\r\n-    \r\n-    subgraph ComponentTemplateFlow[\"组件模板流程\"]\r\n-        C1[ComponentContext<br/>componentType/themeType] --> C2[获取组件模板]\r\n-        C2 --> C3[CreateComponent<br/>创建 UI 组件]\r\n-        C3 --> C4[设置组件属性<br/>color/font/size等]\r\n-        C4 --> C5[应用主题变体<br/>PrefabVariant]\r\n-        C5 --> C6[组件完成]\r\n-    end\r\n-    \r\n-    UITemplateFlow --> ComponentTemplateFlow\r\n-    \r\n-    style UITemplateFlow fill:#ffebee\r\n-    style ComponentTemplateFlow fill:#e1f5ff\r\n-```\r\n-\r\n----\r\n-\r\n-## 详细层级设计\r\n-\r\n-### 1. Visual 层：UIVisual\r\n-\r\n-#### 1.1 UIVisual 架构\r\n-\r\n-**架构图**：\r\n-\r\n-```mermaid\r\n-graph TB\r\n-    subgraph UIVisual[\"UIVisual\"]\r\n-        LeavePool[\"LeavePool<br/>初始化 UI\"]\r\n-        LoadPrefab[\"LoadUIPrefab<br/>加载 UI 预制体\"]\r\n-        ApplyTheme[\"ApplyTheme<br/>应用主题\"]\r\n-        Execute[\"Execute<br/>显示 UI\"]\r\n-    end\r\n-    \r\n-    subgraph UIInit[\"UI 初始化\"]\r\n-        GetTemplate[\"获取 UI 模板<br/>EUITemplateMapping\"]\r\n-        GetTheme[\"获取主题模板<br/>EThemeMapping\"]\r\n-        InitTemplate[\"InitTemplate<br/>初始化模板\"]\r\n-        CreateComponents[\"创建组件\"]\r\n-    end\r\n-    \r\n-    LeavePool --> LoadPrefab\r\n-    LoadPrefab --> GetTemplate\r\n-    GetTemplate --> GetTheme\r\n-    GetTheme --> InitTemplate\r\n-    InitTemplate --> CreateComponents\r\n-    Execute --> UIInit\r\n-    \r\n-    style UIVisual fill:#ffebee\r\n-    style UIInit fill:#e1f5ff\r\n-```\r\n-\r\n-**工作流程**：\r\n-\r\n-1. **初始化阶段**（LeavePool）：\r\n-   - 从 Context 获取 `uiTemplateType` 和 `themeType`\r\n-   - 如果 `uiPrefab` 未提供，调用 `LoadUIPrefab()` 加载\r\n-   - 从映射表获取对应的 UI 模板和主题模板\r\n-   - 调用模板的 `InitTemplate()` 初始化 UI\r\n-\r\n-2. **资源加载阶段**（LoadUIPrefab）：\r\n-   - 根据 `uiTemplateType` 和 `themeType` 获取资源路径\r\n-   - 加载 UI 预制体（基础预制体或变体）\r\n-   - 获取 UI 组件引用\r\n-\r\n-3. **主题应用阶段**（ApplyTheme）：\r\n-   - 根据 `themeType` 获取对应的预制体变体\r\n-   - 替换基础预制体为变体\r\n-   - 应用主题配置到所有组件\r\n-\r\n-4. **执行阶段**（Execute）：\r\n-   - 显示 UI\r\n-   - 触发 UI 事件\r\n-\r\n-**核心组件**：\r\n-\r\n-- `UIVisual:LeavePool()` - 初始化 UI 和模板\r\n-- `UIVisual:LoadUIPrefab()` - 加载 UI 资源\r\n-- `UIVisual:ApplyTheme()` - 应用主题\r\n-- `UIVisual:Execute()` - 显示 UI\r\n-\r\n-### 2. 模板层：双层模板系统\r\n-\r\n-#### 2.1 UI 模板系统\r\n-\r\n-**架构图**：\r\n-\r\n-```mermaid\r\n-graph TB\r\n-    subgraph UITemplateSystem[\"UI 模板系统\"]\r\n-        TemplateBase[\"UITemplateBase<br/>模板基类\"]\r\n-        ButtonTemplate[\"ButtonTemplate<br/>按钮模板\"]\r\n-        PanelTemplate[\"PanelTemplate<br/>面板模板\"]\r\n-        TemplateMapping2[\"模板映射表<br/>EUITemplateMapping\"]\r\n-    end\r\n-    \r\n-    subgraph TemplateMethods[\"模板方法\"]\r\n-        InitTemplate[\"InitTemplate<br/>初始化模板\"]\r\n-        CreateTextComponent[\"CreateTextComponent<br/>创建文本组件\"]\r\n-        MergeDefaultConfig[\"MergeDefaultConfig<br/>合并默认配置\"]\r\n-    end\r\n-    \r\n-    TemplateBase --> ButtonTemplate\r\n-    TemplateBase --> PanelTemplate\r\n-    TemplateBase --> TemplateMethods\r\n-    ButtonTemplate --> TemplateMapping2\r\n-    \r\n-    style UITemplateSystem fill:#e1f5ff\r\n-    style TemplateMethods fill:#c8e6c9\r\n-```\r\n-\r\n-**工作流程**：\r\n-\r\n-1. **模板定义**（编辑器/代码）：\r\n-   - 继承 `UITemplateBase` 创建模板类\r\n-   - 定义默认配置（如 `DefaultButtonContext`）\r\n-   - 实现 `InitTemplate()` 方法，创建所需的组件\r\n-\r\n-2. **模板注册**（运行时）：\r\n-   - 在 `UIRule.cs` 中注册模板到映射表\r\n-   - 通过 `EUITemplate` 枚举管理模板类型\r\n-\r\n-3. **模板使用**（运行时）：\r\n-   - 通过 `uiTemplateType` 获取模板\r\n-   - 调用 `InitTemplate()` 初始化 UI\r\n-   - 模板内部调用组件模板创建各个组件\r\n-\r\n-**核心组件**：\r\n-\r\n-- `UITemplateBase` - UI 模板基类\r\n-- `UITemplateBase:InitTemplate()` - 初始化模板\r\n-- `UITemplateBase:CreateTextComponent()` - 创建文本组件（通用方法）\r\n-- `UITemplateBase.MergeDefaultConfig()` - 合并默认配置（静态方法）\r\n-\r\n-**示例：ButtonTemplate**\r\n-\r\n-```csharp\r\n-// 按钮 UI 模板\r\n-// 包含：文本组件 + 背景图片组件 + 按钮交互组件\r\n-public class ButtonTemplate : UITemplateBase {\r\n-    public override void InitTemplate(UIContext context) {\r\n-        // 1. 创建文本组件\r\n-        if (context.text != null) {\r\n-            CreateTextComponent(context, context.text, DefaultTextContext, \"Text\");\r\n-        }\r\n-        \r\n-        // 2. 创建背景图片组件\r\n-        if (context.backgroundSprite != null) {\r\n-            CreateImageComponent(context, context.backgroundSprite, DefaultImageContext, \"Background\");\r\n-        }\r\n-        \r\n-        // 3. 创建按钮交互组件\r\n-        var buttonComponentContext = new ComponentContext {\r\n-            componentType = EComponentType.Button,\r\n-            themeType = context.themeType,\r\n-            // ... 其他参数\r\n-        };\r\n-        var buttonComponentTemplate = EComponentTemplateMapping[EComponentTemplate.Button];\r\n-        buttonComponentTemplate.CreateComponent(buttonComponentContext);\r\n-    }\r\n-}\r\n-```\r\n-\r\n-#### 2.2 组件模板系统\r\n-\r\n-**架构图**：\r\n-\r\n-```mermaid\r\n-graph TB\r\n-    subgraph ComponentTemplateSystem[\"组件模板系统\"]\r\n-        ComponentTemplateBase[\"UIComponentTemplateBase<br/>组件模板基类\"]\r\n-        TextComponentTemplate[\"TextComponentTemplate<br/>文本组件模板\"]\r\n-        ImageComponentTemplate[\"ImageComponentTemplate<br/>图片组件模板\"]\r\n-        ButtonComponentTemplate[\"ButtonComponentTemplate<br/>按钮组件模板\"]\r\n-        ComponentMapping[\"组件模板映射表<br/>EComponentTemplateMapping\"]\r\n-    end\r\n-    \r\n-    subgraph ComponentMethods[\"组件方法\"]\r\n-        CreateComponent[\"CreateComponent<br/>创建 UI 组件\"]\r\n-        Check[\"Check<br/>验证 Context\"]\r\n-        SetDefaultContext[\"SetDefaultContext<br/>设置默认值\"]\r\n-        ApplyThemeVariant[\"ApplyThemeVariant<br/>应用主题变体\"]\r\n-    end\r\n-    \r\n-    ComponentTemplateBase --> TextComponentTemplate\r\n-    ComponentTemplateBase --> ImageComponentTemplate\r\n-    ComponentTemplateBase --> ButtonComponentTemplate\r\n-    ComponentTemplateBase --> ComponentMethods\r\n-    TextComponentTemplate --> ComponentMapping\r\n-    \r\n-    style ComponentTemplateSystem fill:#e1f5ff\r\n-    style ComponentMethods fill:#c8e6c9\r\n-```\r\n-\r\n-**工作流程**：\r\n-\r\n-1. **组件创建流程**：\r\n-   - 从 Context 获取组件类型、主题类型等参数\r\n-   - 调用 `UIController.CreateUIComponent()` 创建组件\r\n-   - 设置组件的基础属性（color、font、size 等）\r\n-   - 根据主题类型应用对应的预制体变体\r\n-   - 绑定目标对象（如 Text、Image 等）\r\n-\r\n-2. **组件类型支持**：\r\n-   - **Text Component**：文本显示，支持字体、颜色、大小\r\n-   - **Image Component**：图片显示，支持 Sprite、颜色、填充方式\r\n-   - **Button Component**：按钮交互，支持状态切换、事件绑定\r\n-   - **Panel Component**：面板容器，支持布局、背景\r\n-   - **Input Component**：输入框，支持文本输入、验证\r\n-\r\n-**核心组件**：\r\n-\r\n-- `UIComponentTemplateBase` - 组件模板基类\r\n-- `UIComponentTemplateBase:CreateComponent()` - 创建 UI 组件\r\n-- `UIComponentTemplateBase:Check()` - 验证 Context 参数\r\n-- `UIComponentTemplateBase:SetDefaultContext()` - 设置默认值\r\n-- `UIComponentTemplateBase:ApplyThemeVariant()` - 应用主题变体\r\n-\r\n-**示例：TextComponentTemplate**\r\n-\r\n-```csharp\r\n-public class TextComponentTemplate : UIComponentTemplateBase {\r\n-    public override GameObject CreateComponent(ComponentContext context) {\r\n-        // 设置组件类型\r\n-        context.componentType = EComponentType.Text;\r\n-        \r\n-        // 调用基类创建组件\r\n-        var component = base.CreateComponent(context);\r\n-        \r\n-        // 获取 Text 组件\r\n-        var textComponent = component.GetComponent<Text>();\r\n-        if (textComponent == null) {\r\n-            textComponent = component.AddComponent<Text>();\r\n-        }\r\n-        \r\n-        // 应用主题变体\r\n-        ApplyThemeVariant(component, context.themeType);\r\n-        \r\n-        // 设置文本属性\r\n-        if (context.text != null) {\r\n-            textComponent.text = context.text;\r\n-        }\r\n-        if (context.font != null) {\r\n-            textComponent.font = context.font;\r\n-        }\r\n-        if (context.fontSize > 0) {\r\n-            textComponent.fontSize = context.fontSize;\r\n-        }\r\n-        if (context.color != Color.clear) {\r\n-            textComponent.color = context.color;\r\n-        }\r\n-        \r\n-        return component;\r\n-    }\r\n-    \r\n-    protected override void ApplyThemeVariant(GameObject component, EThemeType themeType) {\r\n-        // 根据主题类型获取对应的预制体变体\r\n-        var variantPath = GetThemeVariantPath(component.name, themeType);\r\n-        var variantPrefab = Resources.Load<GameObject>(variantPath);\r\n-        \r\n-        if (variantPrefab != null) {\r\n-            // 应用变体的属性覆盖\r\n-            PrefabUtility.ApplyPrefabVariant(component, variantPrefab);\r\n-        }\r\n-    }\r\n-}\r\n-```\r\n-\r\n-### 3. Unity Prefab 层：预制体 + 预制体变体\r\n-\r\n-**架构图**：\r\n-\r\n-```mermaid\r\n-graph TB\r\n-    subgraph UnityPrefab[\"Unity Prefab 系统\"]\r\n-        PrefabBase2[\"BasePrefab<br/>基础预制体\"]\r\n-        PrefabVariant2[\"PrefabVariant<br/>预制体变体\"]\r\n-        UIComponent2[\"UI 组件系统\"]\r\n-    end\r\n-    \r\n-    subgraph VariantTypes[\"变体类型\"]\r\n-        DarkVariant[\"Dark Variant<br/>暗色主题变体\"]\r\n-        LightVariant[\"Light Variant<br/>亮色主题变体\"]\r\n-        HighContrastVariant[\"HighContrast Variant<br/>高对比度变体\"]\r\n-        CustomVariant[\"Custom Variant<br/>自定义变体\"]\r\n-    end\r\n-    \r\n-    PrefabBase2 --> PrefabVariant2\r\n-    PrefabVariant2 --> DarkVariant\r\n-    PrefabVariant2 --> LightVariant\r\n-    PrefabVariant2 --> HighContrastVariant\r\n-    PrefabVariant2 --> CustomVariant\r\n-    PrefabVariant2 --> UIComponent2\r\n-    \r\n-    style UnityPrefab fill:#c8e6c9\r\n-    style VariantTypes fill:#fff4e1\r\n-```\r\n-\r\n-**工作流程**：\r\n-\r\n-1. **基础预制体创建**：\r\n-   - 创建基础 UI 预制体（如 ButtonBase）\r\n-   - 设置默认组件和结构\r\n-   - 作为所有变体的父级\r\n-\r\n-2. **预制体变体创建**：\r\n-   - 基于基础预制体创建变体（如 ButtonDark、ButtonLight）\r\n-   - 覆盖需要改变的主题属性（颜色、字体、样式等）\r\n-   - 保持结构不变，只改变视觉表现\r\n-\r\n-3. **运行时应用变体**：\r\n-   - 根据主题类型选择对应的变体\r\n-   - 动态替换或应用变体属性\r\n-   - 支持运行时切换主题\r\n-\r\n-**核心组件**：\r\n-\r\n-- `UnityEngine.GameObject` - UI 预制体\r\n-- `UnityEngine.PrefabUtility` - 预制体工具\r\n-- `UIController` - UI 控制器（C# 封装）\r\n-- `UIComponent` - UI 组件基类\r\n-\r\n----\r\n-\r\n-## 架构模式分析\r\n-\r\n-### 1. 模板方法模式（Template Method）\r\n-\r\n-**应用场景**：UI 模板和组件模板的创建流程\r\n-\r\n-**实现方式**：\r\n-- `UITemplateBase` 定义模板创建流程\r\n-- 子类重写 `InitTemplate()` 实现具体配置\r\n-- `UIComponentTemplateBase` 定义组件创建流程\r\n-- 子类重写 `CreateComponent()` 实现特定组件类型\r\n-\r\n-**优势**：\r\n-- 统一创建流程，易于维护\r\n-- 子类只需关注具体配置\r\n-- 支持模板复用和扩展\r\n-\r\n-### 2. 工厂模式（Factory）\r\n-\r\n-**应用场景**：UI 模板和组件模板的创建\r\n-\r\n-**实现方式**：\r\n-- `EUITemplateMapping` 管理 UI 模板映射\r\n-- `EComponentTemplateMapping` 管理组件模板映射\r\n-- `EThemeMapping` 管理主题映射\r\n-- 通过枚举类型获取对应的模板实例\r\n-- 统一的创建接口，隐藏创建细节\r\n-\r\n-**优势**：\r\n-- 统一创建逻辑\r\n-- 易于扩展新的模板类型\r\n-- 支持延迟加载和动态注册\r\n-\r\n-### 3. 策略模式（Strategy）\r\n-\r\n-**应用场景**：多种组件类型的统一管理\r\n-\r\n-**实现方式**：\r\n-- 每种组件类型实现独立的组件模板\r\n-- 都继承 `UIComponentTemplateBase`，使用统一的接口\r\n-- 通过 `componentType` 选择使用哪种策略\r\n-\r\n-**优势**：\r\n-- 组件类型独立，互不干扰\r\n-- 易于扩展新的组件类型\r\n-- 统一接口，降低使用复杂度\r\n-\r\n-### 4. 建造者模式（Builder）\r\n-\r\n-**应用场景**：UI 的复杂构建过程\r\n-\r\n-**实现方式**：\r\n-- UI 模板通过组合多个组件模板构建完整 UI\r\n-- 支持链式调用和分步构建\r\n-- Context 参数逐步填充\r\n-\r\n-**优势**：\r\n-- 支持复杂 UI 的构建\r\n-- 构建过程清晰，易于理解\r\n-- 支持参数覆盖和默认配置\r\n-\r\n-### 5. Context 模式\r\n-\r\n-**应用场景**：统一参数传递\r\n-\r\n-**实现方式**：\r\n-- UI 模板和组件模板都使用 Context 参数\r\n-- 支持默认配置和覆盖配置合并\r\n-- 参数可灵活扩展，不影响接口\r\n-\r\n-**优势**：\r\n-- 接口稳定，参数灵活\r\n-- 支持向后兼容\r\n-- 易于扩展新参数\r\n-\r\n----\r\n-\r\n-## 数据流设计\r\n-\r\n-### 1. UI 创建数据流\r\n-\r\n-```mermaid\r\n-sequenceDiagram\r\n-    participant Client as 客户端\r\n-    participant Visual as UIVisual\r\n-    participant Template as UITemplate\r\n-    participant ComponentTemplate as ComponentTemplate\r\n-    participant Controller as UIController\r\n-    participant Prefab as PrefabVariant\r\n-    \r\n-    Client->>Visual: Create(context)<br/>uiTemplateType/themeType\r\n-    Visual->>Template: 获取模板<br/>EUITemplateMapping\r\n-    Visual->>Template: InitTemplate(context)\r\n-    Template->>ComponentTemplate: CreateComponent(textContext)\r\n-    ComponentTemplate->>Controller: CreateUIComponent(...)\r\n-    Controller->>Prefab: 应用预制体变体\r\n-    Prefab-->>ComponentTemplate: UI 组件\r\n-    ComponentTemplate-->>Template: 组件创建完成\r\n-    Template-->>Visual: UI 初始化完成\r\n-    Visual-->>Client: UI 准备就绪\r\n-```\r\n-\r\n-### 2. 组件创建数据流\r\n-\r\n-```mermaid\r\n-sequenceDiagram\r\n-    participant Template as UITemplate\r\n-    participant ComponentTemplate as ComponentTemplate\r\n-    participant Controller as UIController\r\n-    participant Prefab as PrefabVariant\r\n-    participant Component as UIComponent\r\n-    \r\n-    Template->>ComponentTemplate: CreateComponent(context)\r\n-    ComponentTemplate->>ComponentTemplate: Check(context)\r\n-    ComponentTemplate->>Controller: CreateUIComponent(componentType, themeType)\r\n-    Controller->>Prefab: 加载预制体变体\r\n-    Prefab-->>Controller: PrefabVariant\r\n-    ComponentTemplate->>ComponentTemplate: 设置组件属性<br/>color/font/size\r\n-    ComponentTemplate->>Component: 应用主题变体\r\n-    Component-->>ComponentTemplate: 组件创建完成\r\n-```\r\n-\r\n-### 3. Context 数据流\r\n-\r\n-```mermaid\r\n-graph LR\r\n-    subgraph UIContext[\"UITemplateContext\"]\r\n-        TemplateType[\"uiTemplateType<br/>模板类型\"]\r\n-        ThemeType[\"themeType<br/>主题类型\"]\r\n-        UIPrefab[\"uiPrefab<br/>UI 预制体\"]\r\n-        Parent[\"parent<br/>父对象\"]\r\n-        CustomParams[\"自定义参数<br/>text/backgroundSprite等\"]\r\n-    end\r\n-    \r\n-    subgraph ComponentContext[\"ComponentContext\"]\r\n-        ComponentType[\"componentType<br/>组件类型\"]\r\n-        ThemeType2[\"themeType<br/>主题类型\"]\r\n-        Text[\"text<br/>文本内容\"]\r\n-        Font[\"font<br/>字体\"]\r\n-        Color[\"color<br/>颜色\"]\r\n-        Size[\"size<br/>大小\"]\r\n-        ComponentParams[\"组件特定参数<br/>sprite/buttonState等\"]\r\n-    end\r\n-    \r\n-    UIContext --> ComponentContext\r\n-    TemplateType --> ComponentType\r\n-    ThemeType --> ThemeType2\r\n-    UIPrefab --> ComponentContext\r\n-    CustomParams --> ComponentParams\r\n-    \r\n-    style UIContext fill:#ffebee\r\n-    style ComponentContext fill:#e1f5ff\r\n-```\r\n-\r\n----\r\n-\r\n-## 与 Godot Theme 的对比\r\n-\r\n-### 功能对比\r\n-\r\n-| 功能 | Unity 模板驱动系统 | Godot Theme |\r\n-|------|------------------|------------|\r\n-| 模板化配置 | ✅ 双层模板系统 | ❌ 单一主题资源 |\r\n-| 动态创建 | ✅ 运行时动态创建 | ⚠️ 静态配置 |\r\n-| 预制体变体 | ✅ 原生支持 | ❌ 不支持 |\r\n-| 组件化设计 | ✅ 组件模板独立 | ⚠️ 扁平化主题 |\r\n-| 嵌套结构 | ✅ 支持多层嵌套 | ❌ 不支持 |\r\n-| 运行时切换 | ✅ 灵活切换 | ✅ 简单切换 |\r\n-| 参数扩展 | ✅ Context 模式 | ⚠️ 受限于主题结构 |\r\n-| 代码控制 | ✅ 完全可控 | ⚠️ 受限于引擎 |\r\n-\r\n-### 自由度对比\r\n-\r\n-| 维度 | Unity 模板驱动系统 | Godot Theme |\r\n-|------|------------------|------------|\r\n-| 结构控制 | ✅ 完全自由 | ❌ 固定结构 |\r\n-| 组件组合 | ✅ 灵活组合 | ⚠️ 主题统一 |\r\n-| 自定义扩展 | ✅ 无限制 | ⚠️ 受限于主题系统 |\r\n-| 模板复用 | ✅ 多层复用 | ⚠️ 单一复用 |\r\n-| 参数控制 | ✅ Context 灵活扩展 | ⚠️ 固定参数 |\r\n-\r\n----\r\n-\r\n-## 架构验证\r\n-\r\n-### 1. 性能验证\r\n-\r\n-**验证点**：\r\n-- ✅ UI 预制体预加载，避免运行时加载延迟\r\n-- ✅ 模板系统延迟加载，减少初始化开销\r\n-- ✅ 组件创建使用 Unity API，性能稳定\r\n-- ✅ 支持批量创建组件，减少多次调用开销\r\n-\r\n-**性能指标**：\r\n-- UI 模板初始化：< 30ms（包含多个组件创建）\r\n-- 组件创建：< 3ms（单个组件）\r\n-- 主题切换：< 10ms（单个 UI 元素）\r\n-\r\n-### 2. 扩展性验证\r\n-\r\n-**验证点**：\r\n-- ✅ 新增 UI 模板只需创建新类并注册\r\n-- ✅ 新增组件模板只需创建新类并注册\r\n-- ✅ 支持自定义主题类型\r\n-- ✅ Context 模式支持参数扩展，向后兼容\r\n-\r\n-**扩展场景**：\r\n-- 新增 UI 模板：创建模板类，注册到映射表\r\n-- 新增组件模板：创建组件模板类，注册到映射表\r\n-- 新增主题类型：创建预制体变体，注册到主题映射表\r\n-\r\n-### 3. 易用性验证\r\n-\r\n-**验证点**：\r\n-- ✅ 统一的 Context 接口，参数清晰\r\n-- ✅ 模板化配置，减少代码编写\r\n-- ✅ 支持默认配置和覆盖配置\r\n-- ✅ 完整的错误检查和日志输出\r\n-\r\n-**使用示例**：\r\n-\r\n-```csharp\r\n-// 创建按钮 UI\r\n-var context = new UIContext {\r\n-    uiTemplateType = EUITemplate.Button,\r\n-    themeType = EThemeType.Dark,\r\n-    text = \"点击按钮\",\r\n-    backgroundSprite = buttonBackgroundSprite,\r\n-    // 可选：覆盖默认配置\r\n-    textConfig = new TextConfig {\r\n-        fontSize = 24,\r\n-        color = Color.white\r\n-    }\r\n-};\r\n-var visual = VisualFactory.Create(EVisual.UI, context);\r\n-visual.Execute();\r\n-```\r\n-\r\n-### 4. 完整性验证\r\n-\r\n-**验证点**：\r\n-- ✅ 支持多种组件类型（Text、Image、Button、Panel 等）\r\n-- ✅ 支持 UI 模板和组件模板双层设计\r\n-- ✅ 支持默认配置和覆盖配置合并\r\n-- ✅ 完整的生命周期管理（创建、显示、回收）\r\n-- ✅ 支持主题切换和动态更新\r\n-\r\n----\r\n-\r\n-## 开发指导原则\r\n-\r\n-### 1. 模板设计原则\r\n-\r\n-**原则**：UI 模板关注整体结构，组件模板关注单个组件\r\n-\r\n-**实践**：\r\n-- UI 模板：定义 UI 的整体结构（如按钮包含哪些组件）\r\n-- 组件模板：定义单个组件的创建逻辑（如如何创建文本组件）\r\n-- 模板职责分离，避免相互依赖\r\n-\r\n-### 2. 配置合并原则\r\n-\r\n-**原则**：支持默认配置和覆盖配置合并，提供灵活的参数控制\r\n-\r\n-**实践**：\r\n-- 在模板中定义默认配置（如 `DefaultButtonContext`）\r\n-- 支持通过 Context 传入覆盖配置\r\n-- 使用 `MergeDefaultConfig()` 合并配置\r\n-- 覆盖配置优先，默认配置作为后备\r\n-\r\n-### 3. 主题类型扩展原则\r\n-\r\n-**原则**：新增主题类型时，创建对应的预制体变体并注册\r\n-\r\n-**实践**：\r\n-- 基于基础预制体创建变体\r\n-- 覆盖需要改变的主题属性\r\n-- 在 `UIRule.cs` 中注册到主题映射表\r\n-- 扩展 `EThemeType` 枚举\r\n-\r\n-### 4. Context 设计原则\r\n-\r\n-**原则**：Context 参数清晰，支持扩展，保持向后兼容\r\n-\r\n-**实践**：\r\n-- 必需参数明确标注，提供清晰的错误提示\r\n-- 可选参数提供默认值\r\n-- 新增参数不影响旧代码\r\n-- 使用有意义的参数名称\r\n-\r\n-### 5. 错误处理原则\r\n-\r\n-**原则**：完整的错误检查和日志输出，便于调试\r\n-\r\n-**实践**：\r\n-- 在 `Check()` 方法中验证必需参数\r\n-- 创建失败时输出详细的错误信息\r\n-- 使用 `LogError` 和 `LogWarning` 区分错误级别\r\n-- 提供有意义的错误消息，包含上下文信息\r\n-\r\n----\r\n-\r\n-## 总结\r\n-\r\n-### 架构设计价值\r\n-\r\n-UI 主题系统通过模板驱动架构、双层模板设计、多主题类型统一管理，实现了统一接口、高性能、易扩展的主题管理框架。系统核心是模板驱动的动态创建机制，通过预定义模板减少运行时配置，通过双层设计实现灵活的组合和扩展。\r\n-\r\n-### 设计原则总结\r\n-\r\n-1. **模板驱动**：所有 UI 配置通过模板预定义，运行时动态创建\r\n-2. **双层设计**：UI 模板和组件模板分离，职责清晰\r\n-3. **统一管理**：多种主题类型使用统一的接口和管理方式\r\n-4. **Context 模式**：统一参数传递，支持扩展和向后兼容\r\n-5. **配置合并**：支持默认配置和覆盖配置，提供灵活控制\r\n-\r\n-### 与 Godot Theme 的对比优势\r\n-\r\n-1. **更高的自由度**：完全可控的模板化设计，不受引擎限制\r\n-2. **更强的扩展性**：双层模板系统，支持灵活组合和扩展\r\n-3. **更好的结构控制**：支持预制体嵌套和变体，结构更灵活\r\n-4. **更专业的实现**：适合大型游戏开发，支持复杂的 UI 系统\r\n-\r\n-### 未来扩展方向\r\n-\r\n-1. **可视化编辑器**：UI 模板的可视化配置工具\r\n-2. **模板预设系统**：预定义常用 UI 组合，一键应用\r\n-3. **性能优化**：UI 预制体的预加载和缓存机制\r\n-4. **事件系统**：UI 交互过程中的事件回调\r\n-5. **动画系统**：UI 主题切换的动画过渡效果\r\n\\ No newline at end of file\n"
                }
            ],
            "date": 1767360301254,
            "name": "Commit-0",
            "content": "# UI 主题系统架构设计\r\n\r\n## 设计目标\r\n\r\n设计一套基于 Unity 预制体 + 预制体变体 + 模板驱动的 UI 主题系统，支持动态创建 UI 元素、模板化配置、多主题类型（暗色、亮色、高对比度等），提供统一接口、高性能、易扩展的主题管理框架。\r\n\r\n---\r\n\r\n## 核心设计理念\r\n\r\n### 1. 模板驱动架构为核心\r\n\r\n**本质**：UI 主题系统的核心是模板驱动的动态创建机制\r\n- 模板配置 = 所有 UI 主题配置通过模板类预定义\r\n- 动态创建 = 运行时根据模板动态创建 UI 预制体实例\r\n- 模板复用 = 同一模板可创建多个 UI 实例，支持参数覆盖\r\n- 配置分离 = 模板配置与运行时数据分离，易于维护\r\n\r\n### 2. 双层模板系统：UI 模板 + 组件模板\r\n\r\n**本质**：系统采用双层模板设计，分别管理 UI 整体和单个组件\r\n- UI 模板 = 管理整个 UI 的配置（如 ButtonTemplate、PanelTemplate）\r\n- 组件模板 = 管理单个 UI 组件的创建（如 TextComponentTemplate、ImageComponentTemplate）\r\n- 模板组合 = UI 模板通过组合多个组件模板构建完整 UI\r\n- 独立扩展 = 两种模板可独立扩展，互不干扰\r\n\r\n### 3. 多主题类型统一管理\r\n\r\n**本质**：系统统一管理多种主题类型，提供一致的创建接口\r\n- 主题类型 = Dark、Light、HighContrast、Custom 等\r\n- 统一接口 = 所有主题类型使用相同的模板基类\r\n- 类型映射 = 通过枚举和映射表管理主题类型\r\n- 易于扩展 = 新增主题类型只需创建新的模板变体\r\n\r\n### 4. Context 模式统一参数\r\n\r\n**本质**：所有模板使用统一的 Context 参数，接口稳定，参数灵活扩展\r\n- 统一接口 = UI 模板和组件模板都使用 Context 参数\r\n- 参数扩展 = 支持任意扩展字段，无需修改函数签名\r\n- 默认配置 = 支持默认配置和覆盖配置合并\r\n- 向后兼容 = 新增字段不影响旧代码\r\n\r\n---\r\n\r\n## 整体架构设计\r\n\r\n### 三层架构 + 双层模板系统\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph VisualLayer[\"Visual 层<br/>UIVisualLayer\"]\r\n        UIVisual[\"UIVisual<br/>UI 执行器\"]\r\n    end\r\n    \r\n    subgraph TemplateLayer[\"模板层<br/>TemplateLayer\"]\r\n        UITemplate[\"UI 模板<br/>UITemplateBase\"]\r\n        ComponentTemplate[\"组件模板<br/>UIComponentTemplateBase\"]\r\n        TemplateMapping[\"模板映射表<br/>EUITemplateMapping\"]\r\n        ThemeMapping[\"主题映射表<br/>EThemeMapping\"]\r\n    end\r\n    \r\n    subgraph UnityLayer[\"Unity Prefab 层<br/>UnityLayer\"]\r\n        PrefabBase[\"基础预制体<br/>BasePrefab\"]\r\n        PrefabVariant[\"预制体变体<br/>PrefabVariant\"]\r\n        UIComponent[\"UI 组件<br/>Text/Image/Button等\"]\r\n    end\r\n    \r\n    VisualLayer -->|使用模板| TemplateLayer\r\n    TemplateLayer -->|创建| UnityLayer\r\n    UnityLayer -->|渲染| Output[最终 UI]\r\n    \r\n    style VisualLayer fill:#ffebee\r\n    style TemplateLayer fill:#e1f5ff\r\n    style UnityLayer fill:#c8e6c9\r\n    style Output fill:#fff4e1\r\n```\r\n\r\n### 双层模板数据流\r\n\r\n```mermaid\r\ngraph LR\r\n    subgraph UITemplateFlow[\"UI 模板流程\"]\r\n        T1[Context<br/>uiTemplateType/themeType] --> T2[获取 UI 模板]\r\n        T2 --> T3[InitTemplate<br/>初始化 UI]\r\n        T3 --> T4[创建多个组件<br/>调用组件模板]\r\n        T4 --> T5[UI 预制体完成]\r\n    end\r\n    \r\n    subgraph ComponentTemplateFlow[\"组件模板流程\"]\r\n        C1[ComponentContext<br/>componentType/themeType] --> C2[获取组件模板]\r\n        C2 --> C3[CreateComponent<br/>创建 UI 组件]\r\n        C3 --> C4[设置组件属性<br/>color/font/size等]\r\n        C4 --> C5[应用主题变体<br/>PrefabVariant]\r\n        C5 --> C6[组件完成]\r\n    end\r\n    \r\n    UITemplateFlow --> ComponentTemplateFlow\r\n    \r\n    style UITemplateFlow fill:#ffebee\r\n    style ComponentTemplateFlow fill:#e1f5ff\r\n```\r\n\r\n---\r\n\r\n## 详细层级设计\r\n\r\n### 1. Visual 层：UIVisual\r\n\r\n#### 1.1 UIVisual 架构\r\n\r\n**架构图**：\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph UIVisual[\"UIVisual\"]\r\n        LeavePool[\"LeavePool<br/>初始化 UI\"]\r\n        LoadPrefab[\"LoadUIPrefab<br/>加载 UI 预制体\"]\r\n        ApplyTheme[\"ApplyTheme<br/>应用主题\"]\r\n        Execute[\"Execute<br/>显示 UI\"]\r\n    end\r\n    \r\n    subgraph UIInit[\"UI 初始化\"]\r\n        GetTemplate[\"获取 UI 模板<br/>EUITemplateMapping\"]\r\n        GetTheme[\"获取主题模板<br/>EThemeMapping\"]\r\n        InitTemplate[\"InitTemplate<br/>初始化模板\"]\r\n        CreateComponents[\"创建组件\"]\r\n    end\r\n    \r\n    LeavePool --> LoadPrefab\r\n    LoadPrefab --> GetTemplate\r\n    GetTemplate --> GetTheme\r\n    GetTheme --> InitTemplate\r\n    InitTemplate --> CreateComponents\r\n    Execute --> UIInit\r\n    \r\n    style UIVisual fill:#ffebee\r\n    style UIInit fill:#e1f5ff\r\n```\r\n\r\n**工作流程**：\r\n\r\n1. **初始化阶段**（LeavePool）：\r\n   - 从 Context 获取 `uiTemplateType` 和 `themeType`\r\n   - 如果 `uiPrefab` 未提供，调用 `LoadUIPrefab()` 加载\r\n   - 从映射表获取对应的 UI 模板和主题模板\r\n   - 调用模板的 `InitTemplate()` 初始化 UI\r\n\r\n2. **资源加载阶段**（LoadUIPrefab）：\r\n   - 根据 `uiTemplateType` 和 `themeType` 获取资源路径\r\n   - 加载 UI 预制体（基础预制体或变体）\r\n   - 获取 UI 组件引用\r\n\r\n3. **主题应用阶段**（ApplyTheme）：\r\n   - 根据 `themeType` 获取对应的预制体变体\r\n   - 替换基础预制体为变体\r\n   - 应用主题配置到所有组件\r\n\r\n4. **执行阶段**（Execute）：\r\n   - 显示 UI\r\n   - 触发 UI 事件\r\n\r\n**核心组件**：\r\n\r\n- `UIVisual:LeavePool()` - 初始化 UI 和模板\r\n- `UIVisual:LoadUIPrefab()` - 加载 UI 资源\r\n- `UIVisual:ApplyTheme()` - 应用主题\r\n- `UIVisual:Execute()` - 显示 UI\r\n\r\n### 2. 模板层：双层模板系统\r\n\r\n#### 2.1 UI 模板系统\r\n\r\n**架构图**：\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph UITemplateSystem[\"UI 模板系统\"]\r\n        TemplateBase[\"UITemplateBase<br/>模板基类\"]\r\n        ButtonTemplate[\"ButtonTemplate<br/>按钮模板\"]\r\n        PanelTemplate[\"PanelTemplate<br/>面板模板\"]\r\n        TemplateMapping2[\"模板映射表<br/>EUITemplateMapping\"]\r\n    end\r\n    \r\n    subgraph TemplateMethods[\"模板方法\"]\r\n        InitTemplate[\"InitTemplate<br/>初始化模板\"]\r\n        CreateTextComponent[\"CreateTextComponent<br/>创建文本组件\"]\r\n        MergeDefaultConfig[\"MergeDefaultConfig<br/>合并默认配置\"]\r\n    end\r\n    \r\n    TemplateBase --> ButtonTemplate\r\n    TemplateBase --> PanelTemplate\r\n    TemplateBase --> TemplateMethods\r\n    ButtonTemplate --> TemplateMapping2\r\n    \r\n    style UITemplateSystem fill:#e1f5ff\r\n    style TemplateMethods fill:#c8e6c9\r\n```\r\n\r\n**工作流程**：\r\n\r\n1. **模板定义**（编辑器/代码）：\r\n   - 继承 `UITemplateBase` 创建模板类\r\n   - 定义默认配置（如 `DefaultButtonContext`）\r\n   - 实现 `InitTemplate()` 方法，创建所需的组件\r\n\r\n2. **模板注册**（运行时）：\r\n   - 在 `UIRule.cs` 中注册模板到映射表\r\n   - 通过 `EUITemplate` 枚举管理模板类型\r\n\r\n3. **模板使用**（运行时）：\r\n   - 通过 `uiTemplateType` 获取模板\r\n   - 调用 `InitTemplate()` 初始化 UI\r\n   - 模板内部调用组件模板创建各个组件\r\n\r\n**核心组件**：\r\n\r\n- `UITemplateBase` - UI 模板基类\r\n- `UITemplateBase:InitTemplate()` - 初始化模板\r\n- `UITemplateBase:CreateTextComponent()` - 创建文本组件（通用方法）\r\n- `UITemplateBase.MergeDefaultConfig()` - 合并默认配置（静态方法）\r\n\r\n**示例：ButtonTemplate**\r\n\r\n```csharp\r\n// 按钮 UI 模板\r\n// 包含：文本组件 + 背景图片组件 + 按钮交互组件\r\npublic class ButtonTemplate : UITemplateBase {\r\n    public override void InitTemplate(UIContext context) {\r\n        // 1. 创建文本组件\r\n        if (context.text != null) {\r\n            CreateTextComponent(context, context.text, DefaultTextContext, \"Text\");\r\n        }\r\n        \r\n        // 2. 创建背景图片组件\r\n        if (context.backgroundSprite != null) {\r\n            CreateImageComponent(context, context.backgroundSprite, DefaultImageContext, \"Background\");\r\n        }\r\n        \r\n        // 3. 创建按钮交互组件\r\n        var buttonComponentContext = new ComponentContext {\r\n            componentType = EComponentType.Button,\r\n            themeType = context.themeType,\r\n            // ... 其他参数\r\n        };\r\n        var buttonComponentTemplate = EComponentTemplateMapping[EComponentTemplate.Button];\r\n        buttonComponentTemplate.CreateComponent(buttonComponentContext);\r\n    }\r\n}\r\n```\r\n\r\n#### 2.2 组件模板系统\r\n\r\n**架构图**：\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph ComponentTemplateSystem[\"组件模板系统\"]\r\n        ComponentTemplateBase[\"UIComponentTemplateBase<br/>组件模板基类\"]\r\n        TextComponentTemplate[\"TextComponentTemplate<br/>文本组件模板\"]\r\n        ImageComponentTemplate[\"ImageComponentTemplate<br/>图片组件模板\"]\r\n        ButtonComponentTemplate[\"ButtonComponentTemplate<br/>按钮组件模板\"]\r\n        ComponentMapping[\"组件模板映射表<br/>EComponentTemplateMapping\"]\r\n    end\r\n    \r\n    subgraph ComponentMethods[\"组件方法\"]\r\n        CreateComponent[\"CreateComponent<br/>创建 UI 组件\"]\r\n        Check[\"Check<br/>验证 Context\"]\r\n        SetDefaultContext[\"SetDefaultContext<br/>设置默认值\"]\r\n        ApplyThemeVariant[\"ApplyThemeVariant<br/>应用主题变体\"]\r\n    end\r\n    \r\n    ComponentTemplateBase --> TextComponentTemplate\r\n    ComponentTemplateBase --> ImageComponentTemplate\r\n    ComponentTemplateBase --> ButtonComponentTemplate\r\n    ComponentTemplateBase --> ComponentMethods\r\n    TextComponentTemplate --> ComponentMapping\r\n    \r\n    style ComponentTemplateSystem fill:#e1f5ff\r\n    style ComponentMethods fill:#c8e6c9\r\n```\r\n\r\n**工作流程**：\r\n\r\n1. **组件创建流程**：\r\n   - 从 Context 获取组件类型、主题类型等参数\r\n   - 调用 `UIController.CreateUIComponent()` 创建组件\r\n   - 设置组件的基础属性（color、font、size 等）\r\n   - 根据主题类型应用对应的预制体变体\r\n   - 绑定目标对象（如 Text、Image 等）\r\n\r\n2. **组件类型支持**：\r\n   - **Text Component**：文本显示，支持字体、颜色、大小\r\n   - **Image Component**：图片显示，支持 Sprite、颜色、填充方式\r\n   - **Button Component**：按钮交互，支持状态切换、事件绑定\r\n   - **Panel Component**：面板容器，支持布局、背景\r\n   - **Input Component**：输入框，支持文本输入、验证\r\n\r\n**核心组件**：\r\n\r\n- `UIComponentTemplateBase` - 组件模板基类\r\n- `UIComponentTemplateBase:CreateComponent()` - 创建 UI 组件\r\n- `UIComponentTemplateBase:Check()` - 验证 Context 参数\r\n- `UIComponentTemplateBase:SetDefaultContext()` - 设置默认值\r\n- `UIComponentTemplateBase:ApplyThemeVariant()` - 应用主题变体\r\n\r\n**示例：TextComponentTemplate**\r\n\r\n```csharp\r\npublic class TextComponentTemplate : UIComponentTemplateBase {\r\n    public override GameObject CreateComponent(ComponentContext context) {\r\n        // 设置组件类型\r\n        context.componentType = EComponentType.Text;\r\n        \r\n        // 调用基类创建组件\r\n        var component = base.CreateComponent(context);\r\n        \r\n        // 获取 Text 组件\r\n        var textComponent = component.GetComponent<Text>();\r\n        if (textComponent == null) {\r\n            textComponent = component.AddComponent<Text>();\r\n        }\r\n        \r\n        // 应用主题变体\r\n        ApplyThemeVariant(component, context.themeType);\r\n        \r\n        // 设置文本属性\r\n        if (context.text != null) {\r\n            textComponent.text = context.text;\r\n        }\r\n        if (context.font != null) {\r\n            textComponent.font = context.font;\r\n        }\r\n        if (context.fontSize > 0) {\r\n            textComponent.fontSize = context.fontSize;\r\n        }\r\n        if (context.color != Color.clear) {\r\n            textComponent.color = context.color;\r\n        }\r\n        \r\n        return component;\r\n    }\r\n    \r\n    protected override void ApplyThemeVariant(GameObject component, EThemeType themeType) {\r\n        // 根据主题类型获取对应的预制体变体\r\n        var variantPath = GetThemeVariantPath(component.name, themeType);\r\n        var variantPrefab = Resources.Load<GameObject>(variantPath);\r\n        \r\n        if (variantPrefab != null) {\r\n            // 应用变体的属性覆盖\r\n            PrefabUtility.ApplyPrefabVariant(component, variantPrefab);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 3. Unity Prefab 层：预制体 + 预制体变体\r\n\r\n**架构图**：\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph UnityPrefab[\"Unity Prefab 系统\"]\r\n        PrefabBase2[\"BasePrefab<br/>基础预制体\"]\r\n        PrefabVariant2[\"PrefabVariant<br/>预制体变体\"]\r\n        UIComponent2[\"UI 组件系统\"]\r\n    end\r\n    \r\n    subgraph VariantTypes[\"变体类型\"]\r\n        DarkVariant[\"Dark Variant<br/>暗色主题变体\"]\r\n        LightVariant[\"Light Variant<br/>亮色主题变体\"]\r\n        HighContrastVariant[\"HighContrast Variant<br/>高对比度变体\"]\r\n        CustomVariant[\"Custom Variant<br/>自定义变体\"]\r\n    end\r\n    \r\n    PrefabBase2 --> PrefabVariant2\r\n    PrefabVariant2 --> DarkVariant\r\n    PrefabVariant2 --> LightVariant\r\n    PrefabVariant2 --> HighContrastVariant\r\n    PrefabVariant2 --> CustomVariant\r\n    PrefabVariant2 --> UIComponent2\r\n    \r\n    style UnityPrefab fill:#c8e6c9\r\n    style VariantTypes fill:#fff4e1\r\n```\r\n\r\n**工作流程**：\r\n\r\n1. **基础预制体创建**：\r\n   - 创建基础 UI 预制体（如 ButtonBase）\r\n   - 设置默认组件和结构\r\n   - 作为所有变体的父级\r\n\r\n2. **预制体变体创建**：\r\n   - 基于基础预制体创建变体（如 ButtonDark、ButtonLight）\r\n   - 覆盖需要改变的主题属性（颜色、字体、样式等）\r\n   - 保持结构不变，只改变视觉表现\r\n\r\n3. **运行时应用变体**：\r\n   - 根据主题类型选择对应的变体\r\n   - 动态替换或应用变体属性\r\n   - 支持运行时切换主题\r\n\r\n**核心组件**：\r\n\r\n- `UnityEngine.GameObject` - UI 预制体\r\n- `UnityEngine.PrefabUtility` - 预制体工具\r\n- `UIController` - UI 控制器（C# 封装）\r\n- `UIComponent` - UI 组件基类\r\n\r\n---\r\n\r\n## 架构模式分析\r\n\r\n### 1. 模板方法模式（Template Method）\r\n\r\n**应用场景**：UI 模板和组件模板的创建流程\r\n\r\n**实现方式**：\r\n- `UITemplateBase` 定义模板创建流程\r\n- 子类重写 `InitTemplate()` 实现具体配置\r\n- `UIComponentTemplateBase` 定义组件创建流程\r\n- 子类重写 `CreateComponent()` 实现特定组件类型\r\n\r\n**优势**：\r\n- 统一创建流程，易于维护\r\n- 子类只需关注具体配置\r\n- 支持模板复用和扩展\r\n\r\n### 2. 工厂模式（Factory）\r\n\r\n**应用场景**：UI 模板和组件模板的创建\r\n\r\n**实现方式**：\r\n- `EUITemplateMapping` 管理 UI 模板映射\r\n- `EComponentTemplateMapping` 管理组件模板映射\r\n- `EThemeMapping` 管理主题映射\r\n- 通过枚举类型获取对应的模板实例\r\n- 统一的创建接口，隐藏创建细节\r\n\r\n**优势**：\r\n- 统一创建逻辑\r\n- 易于扩展新的模板类型\r\n- 支持延迟加载和动态注册\r\n\r\n### 3. 策略模式（Strategy）\r\n\r\n**应用场景**：多种组件类型的统一管理\r\n\r\n**实现方式**：\r\n- 每种组件类型实现独立的组件模板\r\n- 都继承 `UIComponentTemplateBase`，使用统一的接口\r\n- 通过 `componentType` 选择使用哪种策略\r\n\r\n**优势**：\r\n- 组件类型独立，互不干扰\r\n- 易于扩展新的组件类型\r\n- 统一接口，降低使用复杂度\r\n\r\n### 4. 建造者模式（Builder）\r\n\r\n**应用场景**：UI 的复杂构建过程\r\n\r\n**实现方式**：\r\n- UI 模板通过组合多个组件模板构建完整 UI\r\n- 支持链式调用和分步构建\r\n- Context 参数逐步填充\r\n\r\n**优势**：\r\n- 支持复杂 UI 的构建\r\n- 构建过程清晰，易于理解\r\n- 支持参数覆盖和默认配置\r\n\r\n### 5. Context 模式\r\n\r\n**应用场景**：统一参数传递\r\n\r\n**实现方式**：\r\n- UI 模板和组件模板都使用 Context 参数\r\n- 支持默认配置和覆盖配置合并\r\n- 参数可灵活扩展，不影响接口\r\n\r\n**优势**：\r\n- 接口稳定，参数灵活\r\n- 支持向后兼容\r\n- 易于扩展新参数\r\n\r\n---\r\n\r\n## 数据流设计\r\n\r\n### 1. UI 创建数据流\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Client as 客户端\r\n    participant Visual as UIVisual\r\n    participant Template as UITemplate\r\n    participant ComponentTemplate as ComponentTemplate\r\n    participant Controller as UIController\r\n    participant Prefab as PrefabVariant\r\n    \r\n    Client->>Visual: Create(context)<br/>uiTemplateType/themeType\r\n    Visual->>Template: 获取模板<br/>EUITemplateMapping\r\n    Visual->>Template: InitTemplate(context)\r\n    Template->>ComponentTemplate: CreateComponent(textContext)\r\n    ComponentTemplate->>Controller: CreateUIComponent(...)\r\n    Controller->>Prefab: 应用预制体变体\r\n    Prefab-->>ComponentTemplate: UI 组件\r\n    ComponentTemplate-->>Template: 组件创建完成\r\n    Template-->>Visual: UI 初始化完成\r\n    Visual-->>Client: UI 准备就绪\r\n```\r\n\r\n### 2. 组件创建数据流\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Template as UITemplate\r\n    participant ComponentTemplate as ComponentTemplate\r\n    participant Controller as UIController\r\n    participant Prefab as PrefabVariant\r\n    participant Component as UIComponent\r\n    \r\n    Template->>ComponentTemplate: CreateComponent(context)\r\n    ComponentTemplate->>ComponentTemplate: Check(context)\r\n    ComponentTemplate->>Controller: CreateUIComponent(componentType, themeType)\r\n    Controller->>Prefab: 加载预制体变体\r\n    Prefab-->>Controller: PrefabVariant\r\n    ComponentTemplate->>ComponentTemplate: 设置组件属性<br/>color/font/size\r\n    ComponentTemplate->>Component: 应用主题变体\r\n    Component-->>ComponentTemplate: 组件创建完成\r\n```\r\n\r\n### 3. Context 数据流\r\n\r\n```mermaid\r\ngraph LR\r\n    subgraph UIContext[\"UITemplateContext\"]\r\n        TemplateType[\"uiTemplateType<br/>模板类型\"]\r\n        ThemeType[\"themeType<br/>主题类型\"]\r\n        UIPrefab[\"uiPrefab<br/>UI 预制体\"]\r\n        Parent[\"parent<br/>父对象\"]\r\n        CustomParams[\"自定义参数<br/>text/backgroundSprite等\"]\r\n    end\r\n    \r\n    subgraph ComponentContext[\"ComponentContext\"]\r\n        ComponentType[\"componentType<br/>组件类型\"]\r\n        ThemeType2[\"themeType<br/>主题类型\"]\r\n        Text[\"text<br/>文本内容\"]\r\n        Font[\"font<br/>字体\"]\r\n        Color[\"color<br/>颜色\"]\r\n        Size[\"size<br/>大小\"]\r\n        ComponentParams[\"组件特定参数<br/>sprite/buttonState等\"]\r\n    end\r\n    \r\n    UIContext --> ComponentContext\r\n    TemplateType --> ComponentType\r\n    ThemeType --> ThemeType2\r\n    UIPrefab --> ComponentContext\r\n    CustomParams --> ComponentParams\r\n    \r\n    style UIContext fill:#ffebee\r\n    style ComponentContext fill:#e1f5ff\r\n```\r\n\r\n---\r\n\r\n## 与 Godot Theme 的对比\r\n\r\n### 功能对比\r\n\r\n| 功能 | Unity 模板驱动系统 | Godot Theme |\r\n|------|------------------|------------|\r\n| 模板化配置 | ✅ 双层模板系统 | ❌ 单一主题资源 |\r\n| 动态创建 | ✅ 运行时动态创建 | ⚠️ 静态配置 |\r\n| 预制体变体 | ✅ 原生支持 | ❌ 不支持 |\r\n| 组件化设计 | ✅ 组件模板独立 | ⚠️ 扁平化主题 |\r\n| 嵌套结构 | ✅ 支持多层嵌套 | ❌ 不支持 |\r\n| 运行时切换 | ✅ 灵活切换 | ✅ 简单切换 |\r\n| 参数扩展 | ✅ Context 模式 | ⚠️ 受限于主题结构 |\r\n| 代码控制 | ✅ 完全可控 | ⚠️ 受限于引擎 |\r\n\r\n### 自由度对比\r\n\r\n| 维度 | Unity 模板驱动系统 | Godot Theme |\r\n|------|------------------|------------|\r\n| 结构控制 | ✅ 完全自由 | ❌ 固定结构 |\r\n| 组件组合 | ✅ 灵活组合 | ⚠️ 主题统一 |\r\n| 自定义扩展 | ✅ 无限制 | ⚠️ 受限于主题系统 |\r\n| 模板复用 | ✅ 多层复用 | ⚠️ 单一复用 |\r\n| 参数控制 | ✅ Context 灵活扩展 | ⚠️ 固定参数 |\r\n\r\n---\r\n\r\n## 架构验证\r\n\r\n### 1. 性能验证\r\n\r\n**验证点**：\r\n- ✅ UI 预制体预加载，避免运行时加载延迟\r\n- ✅ 模板系统延迟加载，减少初始化开销\r\n- ✅ 组件创建使用 Unity API，性能稳定\r\n- ✅ 支持批量创建组件，减少多次调用开销\r\n\r\n**性能指标**：\r\n- UI 模板初始化：< 30ms（包含多个组件创建）\r\n- 组件创建：< 3ms（单个组件）\r\n- 主题切换：< 10ms（单个 UI 元素）\r\n\r\n### 2. 扩展性验证\r\n\r\n**验证点**：\r\n- ✅ 新增 UI 模板只需创建新类并注册\r\n- ✅ 新增组件模板只需创建新类并注册\r\n- ✅ 支持自定义主题类型\r\n- ✅ Context 模式支持参数扩展，向后兼容\r\n\r\n**扩展场景**：\r\n- 新增 UI 模板：创建模板类，注册到映射表\r\n- 新增组件模板：创建组件模板类，注册到映射表\r\n- 新增主题类型：创建预制体变体，注册到主题映射表\r\n\r\n### 3. 易用性验证\r\n\r\n**验证点**：\r\n- ✅ 统一的 Context 接口，参数清晰\r\n- ✅ 模板化配置，减少代码编写\r\n- ✅ 支持默认配置和覆盖配置\r\n- ✅ 完整的错误检查和日志输出\r\n\r\n**使用示例**：\r\n\r\n```csharp\r\n// 创建按钮 UI\r\nvar context = new UIContext {\r\n    uiTemplateType = EUITemplate.Button,\r\n    themeType = EThemeType.Dark,\r\n    text = \"点击按钮\",\r\n    backgroundSprite = buttonBackgroundSprite,\r\n    // 可选：覆盖默认配置\r\n    textConfig = new TextConfig {\r\n        fontSize = 24,\r\n        color = Color.white\r\n    }\r\n};\r\nvar visual = VisualFactory.Create(EVisual.UI, context);\r\nvisual.Execute();\r\n```\r\n\r\n### 4. 完整性验证\r\n\r\n**验证点**：\r\n- ✅ 支持多种组件类型（Text、Image、Button、Panel 等）\r\n- ✅ 支持 UI 模板和组件模板双层设计\r\n- ✅ 支持默认配置和覆盖配置合并\r\n- ✅ 完整的生命周期管理（创建、显示、回收）\r\n- ✅ 支持主题切换和动态更新\r\n\r\n---\r\n\r\n## 开发指导原则\r\n\r\n### 1. 模板设计原则\r\n\r\n**原则**：UI 模板关注整体结构，组件模板关注单个组件\r\n\r\n**实践**：\r\n- UI 模板：定义 UI 的整体结构（如按钮包含哪些组件）\r\n- 组件模板：定义单个组件的创建逻辑（如如何创建文本组件）\r\n- 模板职责分离，避免相互依赖\r\n\r\n### 2. 配置合并原则\r\n\r\n**原则**：支持默认配置和覆盖配置合并，提供灵活的参数控制\r\n\r\n**实践**：\r\n- 在模板中定义默认配置（如 `DefaultButtonContext`）\r\n- 支持通过 Context 传入覆盖配置\r\n- 使用 `MergeDefaultConfig()` 合并配置\r\n- 覆盖配置优先，默认配置作为后备\r\n\r\n### 3. 主题类型扩展原则\r\n\r\n**原则**：新增主题类型时，创建对应的预制体变体并注册\r\n\r\n**实践**：\r\n- 基于基础预制体创建变体\r\n- 覆盖需要改变的主题属性\r\n- 在 `UIRule.cs` 中注册到主题映射表\r\n- 扩展 `EThemeType` 枚举\r\n\r\n### 4. Context 设计原则\r\n\r\n**原则**：Context 参数清晰，支持扩展，保持向后兼容\r\n\r\n**实践**：\r\n- 必需参数明确标注，提供清晰的错误提示\r\n- 可选参数提供默认值\r\n- 新增参数不影响旧代码\r\n- 使用有意义的参数名称\r\n\r\n### 5. 错误处理原则\r\n\r\n**原则**：完整的错误检查和日志输出，便于调试\r\n\r\n**实践**：\r\n- 在 `Check()` 方法中验证必需参数\r\n- 创建失败时输出详细的错误信息\r\n- 使用 `LogError` 和 `LogWarning` 区分错误级别\r\n- 提供有意义的错误消息，包含上下文信息\r\n\r\n---\r\n\r\n## 总结\r\n\r\n### 架构设计价值\r\n\r\nUI 主题系统通过模板驱动架构、双层模板设计、多主题类型统一管理，实现了统一接口、高性能、易扩展的主题管理框架。系统核心是模板驱动的动态创建机制，通过预定义模板减少运行时配置，通过双层设计实现灵活的组合和扩展。\r\n\r\n### 设计原则总结\r\n\r\n1. **模板驱动**：所有 UI 配置通过模板预定义，运行时动态创建\r\n2. **双层设计**：UI 模板和组件模板分离，职责清晰\r\n3. **统一管理**：多种主题类型使用统一的接口和管理方式\r\n4. **Context 模式**：统一参数传递，支持扩展和向后兼容\r\n5. **配置合并**：支持默认配置和覆盖配置，提供灵活控制\r\n\r\n### 与 Godot Theme 的对比优势\r\n\r\n1. **更高的自由度**：完全可控的模板化设计，不受引擎限制\r\n2. **更强的扩展性**：双层模板系统，支持灵活组合和扩展\r\n3. **更好的结构控制**：支持预制体嵌套和变体，结构更灵活\r\n4. **更专业的实现**：适合大型游戏开发，支持复杂的 UI 系统\r\n\r\n### 未来扩展方向\r\n\r\n1. **可视化编辑器**：UI 模板的可视化配置工具\r\n2. **模板预设系统**：预定义常用 UI 组合，一键应用\r\n3. **性能优化**：UI 预制体的预加载和缓存机制\r\n4. **事件系统**：UI 交互过程中的事件回调\r\n5. **动画系统**：UI 主题切换的动画过渡效果\r\n"
        }
    ]
}